<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les variables et la mutabilitÃ© - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html" class="active"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Variables and Mutability
-->
<h2><a class="header" href="#les-variables-et-la-mutabilitÃ©" id="les-variables-et-la-mutabilitÃ©">Les variables et la mutabilitÃ©</a></h2>
<!--
As mentioned in Chapter 2, by default variables are immutable. This is one of
many nudges Rust gives you to write your code in a way that takes advantage of
the safety and easy concurrency that Rust offers. However, you still have the
option to make your variables mutable. Letâ€™s explore how and why Rust
encourages you to favor immutability and why sometimes you might want to opt
out.
-->
<p>Tel qu'abordÃ© au chapitre 2, par dÃ©faut, les variables sont <em>immuables</em>. C'est
un des nombreux coups de pouce de Rust pour Ã©crire votre code de faÃ§on Ã 
garantir la sÃ©curitÃ© et la concurrence sans problÃ¨me. Cependant, vous avez quand
mÃªme la possibilitÃ© de rendre vos variables mutables <em>(modifiables)</em>. Explorons
comment et pourquoi Rust vous encourage Ã  favoriser l'immuabilitÃ©, et pourquoi
parfois vous pourriez choisir d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you canâ€™t change
that value. To illustrate this, letâ€™s generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
liÃ©e Ã  un nom, vous ne pouvez pas changer cette valeur. Ã€ titre d'illustration,
gÃ©nÃ©rons un nouveau projet appelÃ© <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code that wonâ€™t compile just yet:
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant qui ne compile pas pour le momentÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ciÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!(&quot;La valeur de x estÂ : {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables`

To learn more, run the command again with --verbose.
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Even though compiler errors can be frustrating, they only mean your program
isnâ€™t safely doing what you want it to do yet; they do *not* mean that youâ€™re
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide Ã  trouver les erreurs dans
vos programmes. MÃªme si les erreurs de compilation peuvent s'avÃ©rer frustrantes,
elles signifient uniquement que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute sÃ©curitÃ©Â ; elles ne
signifient <em>pas</em> que vous Ãªtes un mauvais dÃ©veloppeurÂ ! MÃªme les RustacÃ©s
expÃ©rimentÃ©s continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `cannot
assign twice to immutable variable x`, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du problÃ¨me est qu'il est <em>impossible
d'assigner Ã  deux reprises la variable immuable <code>x</code></em> (<code>cannot assign twice to immutable variable x</code>).</p>
<!--
Itâ€™s important that we get compile-time errors when we attempt to change a
value that we previously designated as immutable because this very situation
can lead to bugs. If one part of our code operates on the assumption that a
value will never change and another part of our code changes that value, itâ€™s
possible that the first part of the code wonâ€™t do what it was designed to do.
The cause of this kind of bug can be difficult to track down after the fact,
especially when the second piece of code changes the value only *sometimes*.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a prÃ©cÃ©demment Ã©tÃ© dÃ©clarÃ©e
comme immuable, car cette situation particuliÃ¨re peut donner lieu Ã  des bogues.
Si une partie de notre code part du principe qu'une valeur ne changera jamais et
qu'une autre partie de notre code modifie cette valeur, il est possible que la
premiÃ¨re partie du code ne fasse pas ce pour quoi elle a Ã©tÃ© conÃ§ue. La cause de
ce genre de bogue peut Ãªtre difficile Ã  localiser aprÃ¨s coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur.</p>
<!--
In Rust, the compiler guarantees that when you state that a value wonâ€™t change,
it really wonâ€™t change. That means that when youâ€™re reading and writing code,
you donâ€™t have to keep track of how and where a value might change. Your code
is thus easier to reason through.
-->
<p>Avec Rust, le compilateur garantit que lorsque nous dÃ©clarons qu'une variable ne
changera pas, elle ne changera vraiment pas. Cela signifie que lorsque vous
lisez et Ã©crivez du code, vous n'avez pas Ã  vous soucier d'oÃ¹ et comment la
valeur pourrait changer. Votre code est ainsi plus facile Ã  comprendre.</p>
<!--
But mutability can be very useful. Variables are immutable only by default; as
you did in Chapter 2, you can make them mutable by adding `mut` in front of the
variable name. In addition to allowing this value to change, `mut` conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variableâ€™s value.
-->
<p>Mais la mutabilitÃ© peut s'avÃ©rer trÃ¨s utile. Les variables sont immuables par
dÃ©fautÂ ; mais comme vous l'avez fait au chapitre 2, vous pouvez les rendre
mutables en ajoutant <code>mut</code> devant le nom de la variable. En plus de permettre Ã 
cette valeur de changer, <code>mut</code> va signaler l'intention aux futurs lecteurs de ce
code que d'autres parties du code vont modifier la valeur de cette variable.</p>
<!--
For example, letâ€™s change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsiÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous exÃ©cutons le programme, nous obtenonsÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
La valeur de x estÂ : 5
La valeur de x estÂ : 6
</code></pre>
<!--
Weâ€™re allowed to change the value that `x` binds to from `5` to `6` when `mut`
is used. In some cases, youâ€™ll want to make a variable mutable because it makes
the code more convenient to write than if it had only immutable variables.
-->
<p>En utilisant <code>mut</code>, nous avons permis Ã  la valeur de <code>x</code> de passer de <code>5</code> Ã  <code>6</code>.
Dans certains cas, on voudra rendre une variable mutable car cela
rendra le code plus pratique Ã  Ã©crire que s'il n'utilisait que des variables
immuables.</p>
<!--
There are multiple trade-offs to consider in addition to the prevention of
bugs. For example, in cases where youâ€™re using large data structures, mutating
an instance in place may be faster than copying and returning newly allocated
instances. With smaller data structures, creating new instances and writing in
a more functional programming style may be easier to think through, so lower
performance might be a worthwhile penalty for gaining that clarity.
-->
<p>Il y a d'autres compromis Ã  envisager, en plus de la prÃ©vention des bogues. Par
exemple, dans le cas oÃ¹ vous utiliseriez des grosses structures de donnÃ©es,
muter une instance dÃ©jÃ  existante peut Ãªtre plus rapide que copier et retourner
une instance nouvellement allouÃ©e. Avec des structures de donnÃ©es plus petites,
crÃ©er de nouvelles instances avec un style de programmation fonctionnelle peut
rendre le code plus facile Ã  comprendre, donc il peut valoir le coup de
sacrifier un peu de performance pour que le code gagne en clartÃ©.</p>
<!--
### Differences Between Variables and Constants
-->
<h3><a class="header" href="#diffÃ©rences-entre-les-variables-et-les-constantes" id="diffÃ©rences-entre-les-variables-et-les-constantes">DiffÃ©rences entre les variables et les constantes</a></h3>
<!--
Being unable to change the value of a variable might have reminded you of
another programming concept that most other languages have: *constants*. Like
immutable variables, constants are values that are bound to a name and are not
allowed to change, but there are a few differences between constants and
variables.
-->
<p>Rendre impossible de changer la valeur d'une variable peut vous avoir rappelÃ© un
autre concept de programmation que de nombreux autres langages possÃ¨dentÂ : les
<em>constantes</em>. Comme les variables immuables, les constantes sont des valeurs qui
sont liÃ©es Ã  un nom et qui ne peuvent Ãªtre modifiÃ©es, mais il y a quelques
diffÃ©rences entre les constantes et les variables.</p>
<!--
First, you arenâ€™t allowed to use `mut` with constants. Constants arenâ€™t just
immutable by defaultâ€”theyâ€™re always immutable.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par dÃ©faut âˆ’ elles sont toujours immuables.</p>
<!--
You declare constants using the `const` keyword instead of the `let` keyword,
and the type of the value *must* be annotated. Weâ€™re about to cover types and
type annotations in the next section, [â€œData Types,â€][data-types]<!-- ignore
-- > so donâ€™t worry about the details right now. Just know that you must always
annotate the type.
-->
<p>On dÃ©clare les constantes en utilisant le mot-clÃ© <code>const</code> Ã  la place du
mot-clÃ© <code>let</code>, et le type de la valeur <em>doit</em> Ãªtre indiquÃ©. Nous allons aborder
les types et les annotations de types dans la prochaine section,
<a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">â€œLes types de donnÃ©esâ€</a><!-- ignore -->, donc ne vous souciez pas
des dÃ©tails pour le moment. Sachez seulement que vous devez toujours indiquer le
type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent Ãªtre dÃ©clarÃ©es Ã  n'importe quel endroit du code, y
compris la portÃ©e globale, ce qui les rend trÃ¨s utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de connaÃ®tre.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a function call or any other value that could only be
computed at runtime.
-->
<p>La derniÃ¨re diffÃ©rence est que les constantes ne peuvent Ãªtre dÃ©finies que par
une expression constante, et non pas le rÃ©sultat d'un appel de fonction ou toute
autre valeur qui ne pourrait Ãªtre calculÃ©e qu'Ã  l'exÃ©cution.</p>
<!--
Hereâ€™s an example of a constant declaration where the constantâ€™s name is
`MAX_POINTS` and its value is set to 100,000. (Rustâ€™s naming convention for
constants is to use all uppercase with underscores between words, and
underscores can be inserted in numeric literals to improve readability):
-->
<p>Voici un exemple d'une dÃ©claration de constante oÃ¹ le nom de la constante est
<code>MAX_POINTS</code> et oÃ¹ sa valeur est dÃ©finie Ã  100Â 000. (En Rust, la convention de
nommage des constantes est de les Ã©crire tout en majuscule avec des tirets bas
entre les mots, et des tirets bas peuvent Ãªtre ajoutÃ©s entre les nombres pour
amÃ©liorer la lisibilitÃ©)Â :</p>
<!--
```rust
const MAX_POINTS: u32 = 100_000;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in, making them a useful choice for values in your application
domain that multiple parts of the program might need to know about, such as the
maximum number of points any player of a game is allowed to earn or the speed
of light.
-->
<p>Les constantes sont valables pendant toute la durÃ©e d'exÃ©cution du programme
au sein de la portÃ©e dans laquelle elles sont dÃ©clarÃ©es, ce qui en fait de
trÃ¨s bons choix lorsque plusieurs parties du programme doivent connaÃ®tre
certaines valeurs, comme par exemple le nombre maximum de points qu'un joueur
est autorisÃ© Ã  gagner ou encore la vitesse de la lumiÃ¨re.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>DÃ©clarer des valeurs codÃ©es en dur et utilisÃ©es tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs dÃ©veloppeurs. Cela permet Ã©galement de
n'avoir qu'un seul endroit de votre code Ã  modifier si cette valeur codÃ©e en dur
doit Ãªtre mise Ã  jour Ã  l'avenir.</p>
<!--
### Shadowing
-->
<h3><a class="header" href="#le-masquage" id="le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in the [â€œComparing the Guess to the
Secret Numberâ€][comparing-the-guess-to-the-secret-number]<!-- ignore -- >
section in Chapter 2, you can declare a new variable with the same name as a
previous variable, and the new variable shadows the previous variable.
Rustaceans say that the first variable is *shadowed* by the second, which means
that the second variableâ€™s value is what appears when the variable is used. We
can shadow a variable by using the same variableâ€™s name and repeating the use
of the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">â€œComparer le nombre saisi au nombre
secretâ€</a><!-- ignore -->
du jeu de devinettes au chapitre 2, on peut dÃ©clarer une nouvelle variable
avec le mÃªme nom qu'une variable prÃ©cÃ©dente, et la nouvelle variable
masquera la premiÃ¨re. Les RustacÃ©s disent que la premiÃ¨re variable est <em>masquÃ©e</em>
par la seconde, ce qui signifie que la valeur de la seconde variable sera ce que
nous obtiendrons lorsque nous utiliserons cette variable. Nous pouvons crÃ©er un
masque d'une variable en utilisant le mÃªme nom de variable et en rÃ©utilisant le
mot-clÃ© <code>let</code> comme ci-dessousÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. The third `let` statement also shadows `x`, multiplying the
previous value by `2` to give `x` a final value of `12`. When we run this
program, it will output the following:
-->
<p>Au dÃ©but, ce programme lie <code>x</code> Ã  la valeur <code>5</code>. Puis il crÃ©e un masque de <code>x</code>
en rÃ©pÃ©tant <code>let x =</code>, en rÃ©cupÃ©rant la valeur d'origine et lui ajoutant <code>1</code>Â :
la valeur de <code>x</code> est dÃ©sormais <code>6</code>. La troisiÃ¨me instruction <code>let</code> crÃ©e un autre
masque de <code>x</code>, en rÃ©cupÃ©rant la prÃ©cÃ©dente valeur et en la multipliant par <code>2</code>
pour donner Ã  <code>x</code> la valeur finale de <code>12</code>. Lorsque nous exÃ©cutons ce programme,
nous obtenons ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x is: 12
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
La valeur de x estÂ : 12
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because weâ€™ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>CrÃ©er un masque est diffÃ©rent que de marquer une variable comme Ã©tant <code>mut</code>,
car Ã  moins d'utiliser une nouvelle fois le mot-clÃ© <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de rÃ©assigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable aprÃ¨s que ces
transformations ont Ã©tÃ© appliquÃ©es.</p>
<!--
The other difference between `mut` and shadowing is that because weâ€™re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:
-->
<p>Comme nous crÃ©ons une nouvelle variable lorsque nous utilisons le mot-clÃ© <code>let</code>
une nouvelle fois, l'autre diffÃ©rence entre le <code>mut</code> et la crÃ©ation d'un masque
est que cela nous permet de changer le type de la valeur, mais en rÃ©utilisant
le mÃªme nom. Par exemple, imaginons un programme qui demande Ã  l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, mais que nous voulons plutÃ´t stocker cela sous forme de nombreÂ :</p>
<!--
```rust
# fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let espaces = &quot;   &quot;;
    let espaces = espaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
This construct is allowed because the first `spaces` variable is a string type
and the second `spaces` variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, such as `spaces_str` and
`spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we
try to use `mut` for this, as shown here, weâ€™ll get a compile-time error:
-->
<p>Cette solution est autorisÃ©e car la premiÃ¨re variable <code>espaces</code> est du type
chaÃ®ne de caractÃ¨res <em>(string)</em>, alors que la seconde variable <code>espaces</code>, qui
est une toute nouvelle variable qui se trouve avoir le mÃªme nom que la premiÃ¨re,
est du type nombre. L'utilisation du masquage nous Ã©vite ainsi d'avoir Ã  trouver
des noms diffÃ©rents, comme <code>espaces_str</code> et <code>espaces_num</code>Â ; nous pouvons plutÃ´t
simplement rÃ©utiliser le nom <code>espaces</code>. Cependant, si nous essayons d'utiliser
<code>mut</code> pour faire ceci, comme ci-dessous, nous avons une erreur de compilationÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut espaces = &quot;   &quot;;
    espaces = espaces.len();
<span class="boring">}
</span></code></pre>
<!--
The error says weâ€™re not allowed to mutate a variableâ€™s type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variableÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`

To learn more, run the command again with --verbose.
</code></pre>
<!--
Now that weâ€™ve explored how variables work, letâ€™s look at more data types they
can have.
-->
<p>Maintenant que nous avons dÃ©couvert comment fonctionnent les variables, Ã©tudions
les types de donnÃ©es qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-02-data-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch03-00-common-programming-concepts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch03-02-data-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
