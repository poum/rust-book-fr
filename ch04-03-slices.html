<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le type slice - Le langage de programmation Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer un jeu de devinettes</a></li><li class="expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li class="expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li><li class="expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrôle</a></li></ol></li><li class="expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les références et l'emprunt</a></li><li class="expanded "><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li><li><ol class="section"><li class="expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Définir et instancier des structures</a></li><li class="expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des méthodes</a></li></ol></li><li class="expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les énumérations et le filtrage par motif</a></li><li><ol class="section"><li class="expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Définir une énumération</a></li><li class="expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrôle match</a></li><li class="expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrôle concise : if let</a></li></ol></li><li class="expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Gérer des projets grandissants avec les paquets, crates et modules</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Le langage de programmation Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## The Slice Type
-->
<h2><a class="header" href="#le-type-slice" id="le-type-slice">Le type slice</a></h2>
<!--
Another data type that does not have ownership is the *slice*. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.
-->
<p>Un autre type de donnée qui ne prend pas possession est la <em>slice</em>. Une slice
vous permet d'obtenir une référence vers une séquence continue d'éléments d'une
collection plutôt que toute la collection.</p>
<!--
Here’s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesn’t find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>Voici un petit problème de programmation : écrire une fonction qui prend une
chaîne de caractères et retourne le premier mot qu'elle trouve dans cette
chaîne. Si la fonction ne trouve pas d'espace dans la chaîne, cela veut dire
que la chaîne est en un seul mot, donc la chaîne en entier doit être retournée.</p>
<!--
Let’s think about the signature of this function:
-->
<p>Imaginons la signature de cette fonction :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> ?
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; ?
</code></pre>
<!--
This function, `first_word`, has a `&String` as a parameter. We don’t want
ownership, so this is fine. But what should we return? We don’t really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word. Let’s try that, as shown in Listing 4-7.
-->
<p>Cette fonction, <code>premier_mot</code>, prend un <code>&amp;String</code> comme paramètre. Nous ne
voulons pas en prendre possession, donc c'est ce qu'il nous faut. Mais que
devons-nous retourner ? Nous n'avons aucun moyen de désigner une <em>partie</em>
d'une chaîne de caractères. Cependant, nous pouvons retourner l'indice de la
fin du mot. Essayons cela, dans l'encart 4-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn premier_mot(s: &amp;String) -&gt; usize {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">Encart 4-7 : La fonction <code>premier_mot</code> qui retourne
l'indice d'un octet provenant du paramètre <code>String</code></span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, we’ll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p>Comme nous avons besoin de parcourir la <code>String</code> élément par élément et de
vérifier si la valeur est une espace, nous convertissons notre <code>String</code> en un
tableau d'octets en utilisant la méthode <code>as_bytes</code> :</p>
<!--
```rust,ignore
let bytes = s.as_bytes();
```
-->
<pre><code class="language-rust ignore">let octets = s.as_bytes();
</code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>Ensuite, nous créons un itérateur sur le tableau d'octets en utilisant la
méthode <code>iter</code> :</p>
<!--
```rust,ignore
for (i, &item) in bytes.iter().enumerate() {
```
-->
<pre><code class="language-rust ignore">for (i, &amp;element) in octets.iter().enumerate() {
</code></pre>
<!--
We’ll discuss iterators in more detail in Chapter 13. For now, know that `iter`
is a method that returns each element in a collection and that `enumerate`
wraps the result of `iter` and returns each element as part of a tuple instead.
The first element of the tuple returned from `enumerate` is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.
-->
<p>Nous aborderons plus en détail les itérateurs dans le chapitre 13. Pour le
moment, sachez que <code>iter</code> est une méthode qui retourne chaque élément d'une
collection, et que <code>enumerate</code> transforme le résultat de <code>iter</code> pour retourner
plutôt chaque élément comme un tuple. Le premier élément du tuple retourné par
<code>enumerate</code> est l'indice, et le second élément est une référence vers l'élément.
C'est un peu plus pratique que de calculer les indices par nous-mêmes.</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple, just like everywhere else in Rust. So in the `for`
loop, we specify a pattern that has `i` for the index in the tuple and `&item`
for the single byte in the tuple. Because we get a reference to the element
from `.iter().enumerate()`, we use `&` in the pattern.
-->
<p>Comme la méthode <code>enumerate</code> retourne un tuple, nous pouvons utiliser des motifs
pour déstructurer ce tuple, comme nous pourrions le faire n'importe où avec
Rust. Donc dans la boucle <code>for</code>, nous précisons un motif qui indique que nous
définissons <code>i</code> pour l'indice au sein du tuple et <code>&amp;element</code> pour l'octet dans
le tuple. Comme nous obtenons une référence vers l'élément avec
<code>.iter().enumerate()</code>, nous utilisons <code>&amp;</code> dans le motif.</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p>Au sein de la boucle <code>for</code>, nous recherchons l'octet qui représente l'espace en
utilisant la syntaxe de littéral d'octet. Si nous trouvons une espace, nous
retournons sa position. Sinon, nous retournons la taille de la chaîne en
utilisant <code>s.len()</code> :</p>
<!--
```rust,ignore
    if item == b' ' {
        return i;
    }
}

s.len()
```
-->
<pre><code class="language-rust ignore">    if element == b' ' {
        return i;
    }
}

s.len()
</code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a `usize` on its own, but it’s
only a meaningful number in the context of the `&String`. In other words,
because it’s a separate value from the `String`, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>Nous avons maintenant une façon de trouver l'indice de la fin du premier mot
dans la chaîne de caractères, mais il y a un problème. Nous retournons un
<code>usize</code> tout seul, mais il n'a du sens que lorsqu'il est lié au <code>&amp;String</code>.
Autrement dit, comme il a une valeur séparée de la <code>String</code>, il n'y a pas de
garantie qu'il restera toujours valide dans le futur. Imaginons le programme
dans l'encart 4-8 qui utilise la fonction <code>premier_mot</code> de l'encart 4-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s); // la variable mot aura 5 comme valeur.

    s.clear(); // ceci vide la String, elle vaut maintenant &quot;&quot;.

    // mot a toujours la valeur 5 ici, mais il n'y a plus de chaîne qui donne
    // du sens à la valeur 5. mot est maintenant complètement invalide !
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">Encart 4-8 : On stocke le résultat de l'appel à la
fonction <code>premier_mot</code> et ensuite on change le contenu de la <code>String</code></span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isn’t connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>Ce programme se compile sans aucune erreur et le ferait toujours si nous
utilisions <code>mot</code> après avoir appelé <code>s.clear()</code>. Comme <code>mot</code> n'est pas du tout
lié à <code>s</code>, <code>mot</code> contient toujours la valeur <code>5</code>. Nous pourrions utiliser cette
valeur <code>5</code> avec la variable <code>s</code> pour essayer d'en extraire le premier mot, mais
cela serait un bogue, car le contenu de <code>s</code> a changé depuis que nous avons
enregistré <code>5</code> dans <code>mot</code>.</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p>Se préoccuper en permanence que l'indice présent dans <code>mot</code> ne soit plus
synchronisé avec les données présentes dans <code>s</code> est fastidieux et source
d'erreur ! La gestion de ces indices est encore plus risquée si nous écrivons
une fonction <code>second_mot</code>. Sa signature ressemblerait à ceci :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now we’re tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.
-->
<p>Maintenant, nous avons un indice de début <em>et</em> un indice de fin, donc nous avons
encore plus de valeurs qui sont calculées à partir d'une donnée dans un état
donné, mais qui ne sont pas liées du tout à l'état de cette donnée. Nous avons
maintenant trois variables isolées qui ont besoin d'être maintenues à jour.</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>Heureusement, Rust a une solution pour ce problème : les <em>slices</em> de chaînes de
caractères.</p>
<!--
### String Slices
-->
<h3><a class="header" href="#les-slices-de-chaînes-de-caractères" id="les-slices-de-chaînes-de-caractères">Les slices de chaînes de caractères</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p>Une <em>slice de chaîne de caractères</em> (ou <em>slice de chaîne</em>) est une référence à
une partie d'une <code>String</code>, et ressemble à ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
This is similar to taking a reference to the whole `String` but with the extra
`[0..5]` bit. Rather than a reference to the entire `String`, it’s a reference
to a portion of the `String`.
-->
<p>Cela ressemble à une référence pour toute la <code>String</code>, mais avec la partie
<code>[0..5]</code> en plus. Plutôt que d'être une référence vers toute la <code>String</code>, c'est
une référence vers une partie de la <code>String</code>.</p>
<!-- markdownlint-disable -->
<!--
We can create slices using a range within brackets by specifying
`[starting_index..ending_index]`, where `starting_index` is the first position
in the slice and `ending_index` is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to `ending_index` minus
`starting_index`. So in the case of `let world = &s[6..11];`, `world` would be
a slice that contains a pointer to the 7th byte (counting from 1) of `s` with a length value of 5.
-->
<!-- markdownlint-enable -->
<p>Nous pouvons créer des slices en utilisant un intervalle entre crochets en
spécifiant <code>[indice_debut..indice_fin]</code>, où <code>indice_debut</code> est la position du
premier octet de la slice et <code>indice_fin</code> est la position juste après le dernier
octet de la slice. En interne, la structure de données de la slice stocke la
position de départ et la longueur de la slice, ce qui correspond à <code>indice_fin</code>
moins <code>indice_debut</code>. Donc dans le cas de <code>let world = &amp;s[6..11];</code>, <code>world</code> est
une slice qui contient un pointeur vers le septième octet (en comptant à partir
de 1) de <code>s</code> et une longueur de 5.</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>L'illustration 4-6 montre ceci dans un schéma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="world contient un pointeur vers l'octet d'indice 6 de la String s et
une longueur de 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">Illustration 4-6 : Une slice de chaîne qui pointe vers
une partie d'une <code>String</code></span></p>
<!--
With Rust’s `..` range syntax, if you want to start at the first index (zero),
you can drop the value before the two periods. In other words, these are equal:
-->
<p>Avec la syntaxe d'intervalle <code>..</code> de Rust, si vous voulez commencer au premier
indice (zéro), vous pouvez ne rien mettre avant les deux points. Autrement dit,
ces deux cas sont identiques :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>De la même manière, si votre slice contient le dernier octet de la <code>String</code>,
vous pouvez ne rien mettre à la fin. Cela veut dire que ces deux cas sont
identiques :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[3..taille];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>Vous pouvez aussi ne mettre aucune limite pour créer une slice de toute la
chaîne de caractères. Ces deux cas sont donc identiques :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[0..taille];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [“Storing UTF-8 Encoded
> Text with Strings”][strings]<!-- ignore -- > section of Chapter 8.
-->
<blockquote>
<p>Remarque : Les indices de l'intervalle d'une slice de chaîne doivent toujours
se trouver dans les zones acceptables de séparation des caractères encodés en
UTF-8. Si vous essayez de créer une slice de chaîne qui s'arrête au milieu
d'un caractère encodé sur plusieurs octets, votre programme va se fermer avec
une erreur. Afin de simplifier l'explication des slices de chaînes, nous
utiliserons uniquement l'ASCII dans cette section ; nous verrons la gestion
d'UTF-8 dans la section <a href="ch08-02-strings.html">“Stocker du texte encodé en UTF-8 avec les chaînes de
caractères”</a><!-- ignore --> du chapitre 8.</p>
</blockquote>
<!--
With all this information in mind, let’s rewrite `first_word` to return a
slice. The type that signifies “string slice” is written as `&str`:
-->
<p>Maintenant que nous savons tout cela, essayons de réécrire <code>premier_mot</code> pour
qu'il retourne une slice. Le type pour les slices de chaînes de caractères
s'écrit <code>&amp;str</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn premier_mot(s: &amp;String) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>Nous récupérons l'indice de la fin du mot de la même façon que nous l'avions
fait dans l'encart 4-7, en cherchant la première occurrence d'une espace.
Lorsque nous trouvons une espace, nous retournons une slice de chaîne en
utilisant le début de la chaîne de caractères et l'indice de l'espace comme
indices de début et de fin respectivement.</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>Désormais, quand nous appelons <code>premier_mot</code>, nous récupérons une unique valeur
qui est liée à la donnée de base. La valeur se compose d'une référence vers le
point de départ de la slice et du nombre d'éléments dans la slice.</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p>Retourner une slice fonctionnerait aussi pour une fonction <code>second_mot</code> :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API that’s much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>Nous avons maintenant une API simple qui est bien plus difficile à mal utiliser,
puisque le compilateur va s'assurer que les références dans la <code>String</code> seront
toujours en vigueur. Vous souvenez-vous du bogue du programme de l'encart 4-8,
lorsque nous avions un indice vers la fin du premier mot mais qu'ensuite nous
avions vidé la chaîne de caractères et que notre indice n'était plus valide ? Ce
code était logiquement incorrect, mais ne montrait pas immédiatement une erreur.
Les problèmes apparaîtront plus tard si nous essayons d'utiliser l'indice du
premier mot avec une chaîne de caractères qui a été vidée. Les slices rendent ce
bogue impossible et nous signalent bien plus tôt que nous avons un problème avec
notre code. Utiliser la version avec la slice de <code>premier_mot</code> va causer une
erreur de compilation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s);

    s.clear(); // Erreur !

    println!(&quot;Le premier mot est : {}&quot;, mot);
}
</code></pre>
<!--
Here’s the compiler error:
-->
<p>Voici l'erreur du compilateur :</p>
<!--
```text
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  -- > src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here
```
-->
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let mot = premier_mot(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // Erreur !
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;Le premier mot est : {}&quot;, mot);
   |                                         --- immutable borrow later used here
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. Rust disallows
this, and compilation fails. Not only has Rust made our API easier to use, but
it has also eliminated an entire class of errors at compile time!
-->
<p>Rappelons-nous que d'après les règles d'emprunt, si nous avons une référence
immuable vers quelque chose, nous ne pouvons pas avoir une référence mutable
en même temps. Étant donné que <code>clear</code> a besoin de modifier la <code>String</code>, il a
besoin d'une référence mutable. Rust interdit cette situation, et la compilation
échoue. Non seulement Rust a simplifié l'utilisation de notre API, mais il a
aussi éliminé une catégorie entière d'erreurs au moment de la compilation !</p>
<!--
#### String Literals Are Slices
-->
<h4><a class="header" href="#les-littéraux-de-chaîne-de-caractères-sont-aussi-des-slices" id="les-littéraux-de-chaîne-de-caractères-sont-aussi-des-slices">Les littéraux de chaîne de caractères sont aussi des slices</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>Rappelez-vous lorsque nous avons appris que les littéraux de chaîne de
caractères étaient enregistrés dans le binaire. Maintenant que nous connaissons
les slices, nous pouvons désormais comprendre les littéraux de chaîne.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>Ici, le type de <code>s</code> est un <code>&amp;str</code> : c'est une slice qui pointe vers un endroit
précis du binaire. C'est aussi la raison pour laquelle les littéraux de chaîne
sont immuables ; <code>&amp;str</code> est une référence immuable.</p>
<!--
#### String Slices as Parameters
-->
<h4><a class="header" href="#les-slices-de-chaînes-de-caractères-en-paramètres" id="les-slices-de-chaînes-de-caractères-en-paramètres">Les slices de chaînes de caractères en paramètres</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and that’s its signature:
-->
<p>Savoir que l'on peut utiliser des slices de littéraux et de <code>String</code> nous incite
à apporter une petite amélioration à <code>premier_mot</code>, dont voici la signature :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>Un Rustacé plus expérimenté écrirait plutôt la signature de l'encart 4-9, car
cela nous permet d'utiliser la même fonction sur les <code>&amp;String</code> et aussi les
<code>&amp;str</code> :</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">Encart 4-9 : Amélioration de la fonction <code>premier_mot</code> en
utilisant une slice de chaîne de caractères comme type du paramètre <code>s</code></span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the entire `String`. Defining a function to take a string
slice instead of a reference to a `String` makes our API more general and useful
without losing any functionality:
-->
<p>Si nous avons une slice de chaîne, nous pouvons la passer en argument
directement. Si nous avons une <code>String</code>, nous pouvons envoyer une slice de toute
la <code>String</code>. Définir une fonction qui prend une slice de chaîne plutôt qu'une
référence à une <code>String</code> rend notre API plus générique et plus utile sans perdre
aucune fonctionnalité :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
#
#     &s[..]
# }
fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span>fn main() {
    let ma_string = String::from(&quot;hello world&quot;);

    // premier_mot fonctionne avec les slices de `String`
    let mot = premier_mot(&amp;ma_string[..]);

    let mon_litteral_de_chaine = &quot;hello world&quot;;

    // premier_mot fonctionne avec les slices de littéraux de chaîne
    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);

    // Comme les littéraux de chaîne *sont* déjà des slices de chaînes,
    // cela fonctionne aussi, sans la syntaxe de slice !
    let mot = premier_mot(mon_litteral_de_chaine);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3><a class="header" href="#les-autres-slices" id="les-autres-slices">Les autres slices</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But there’s a
more general slice type, too. Consider this array:
-->
<p>Les slices de chaînes de caractères, comme vous pouvez l'imaginer, sont
spécifiques aux chaînes de caractères. Mais il existe aussi un type de slice
plus générique. Imaginons ce tableau de données :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. We’d do so like this:
-->
<p>Tout comme nous pouvons nous référer à une partie d'une chaîne de caractères,
nous pouvons nous référer à une partie d'un tableau. Nous pouvons le faire comme
ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>Cette slice est de type <code>&amp;[i32]</code>. Elle fonctionne de la même manière que les
slices de chaînes de caractères, en enregistrant une référence vers le premier
élément et une longueur. Vous utiliserez ce type de slice pour tous les autres
types de collections. Nous aborderons ces collections en détail quand nous
verrons les vecteurs au chapitre 8.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé" id="résumé">Résumé</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.
-->
<p>Les concepts de possession, d'emprunt et de slices garantissent la sécurité de
la mémoire dans les programmes Rust au moment de la compilation. Le langage Rust
vous donne le contrôle sur l'utilisation de la mémoire comme tous les autres
langages de programmation système, mais le fait que celui qui possède des
données nettoie automatiquement ces données quand il sort de la portée vous
permet de ne pas avoir à écrire et déboguer du code en plus pour avoir cette
fonctionnalité.</p>
<!--
Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>La possession influe sur de nombreuses autres fonctionnalités de Rust, c'est
pourquoi nous allons encore parler de ces concepts plus loin dans le livre.
Passons maintenant au chapitre 5 et découvrons comment regrouper des données
ensemble dans une <code>struct</code>.</p>
<!--
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        

        

    </body>
</html>
