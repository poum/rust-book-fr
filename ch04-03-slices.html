<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le type slice - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## The Slice Type
-->
<h2 id="le-type-slice"><a class="header" href="#le-type-slice">Le type slice</a></h2>
<!--
Another data type that does not have ownership is the *slice*. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.
-->
<p>Un autre type de donnÃ©e qui ne prend pas possession est la <em>slice</em>. Une slice
vous permet d'obtenir une rÃ©fÃ©rence vers une sÃ©quence continue d'Ã©lÃ©ments d'une
collection plutÃ´t que toute la collection.</p>
<!--
Hereâ€™s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesnâ€™t find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>Voici un petit problÃ¨me de programmationÂ : Ã©crire une fonction qui prend une
chaÃ®ne de caractÃ¨res et retourne le premier mot qu'elle trouve dans cette
chaÃ®ne. Si la fonction ne trouve pas d'espace dans la chaÃ®ne, cela veut dire
que la chaÃ®ne est en un seul mot, donc la chaÃ®ne en entier doit Ãªtre retournÃ©e.</p>
<!--
Letâ€™s think about the signature of this function:
-->
<p>Imaginons la signature de cette fonctionÂ :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> ?
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; ?
</code></pre>
<!--
This function, `first_word`, has a `&String` as a parameter. We donâ€™t want
ownership, so this is fine. But what should we return? We donâ€™t really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word. Letâ€™s try that, as shown in Listing 4-7.
-->
<p>Cette fonction, <code>premier_mot</code>, prend un <code>&amp;String</code> comme paramÃ¨tre. Nous ne
voulons pas en prendre possession, donc c'est ce qu'il nous faut. Mais que
devons-nous retournerÂ ? Nous n'avons aucun moyen de dÃ©signer une <em>partie</em>
d'une chaÃ®ne de caractÃ¨res. Cependant, nous pouvons retourner l'indice de la
fin du mot. Essayons cela, dans l'encart 4-7Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; usize {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">Encart 4-7Â : La fonction <code>premier_mot</code> qui retourne
l'indice d'un octet provenant du paramÃ¨tre <code>String</code></span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, weâ€™ll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p>Comme nous avons besoin de parcourir la <code>String</code> Ã©lÃ©ment par Ã©lÃ©ment et de
vÃ©rifier si la valeur est une espace, nous convertissons notre <code>String</code> en un
tableau d'octets en utilisant la mÃ©thode <code>as_bytes</code>Â :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span>    let octets = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>Ensuite, nous crÃ©ons un itÃ©rateur sur le tableau d'octets en utilisant la
mÃ©thode <code>iter</code>Â :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
    for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;element) in octets.iter().enumerate() {
<span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Weâ€™ll discuss iterators in more detail in Chapter 13. For now, know that `iter`
is a method that returns each element in a collection and that `enumerate`
wraps the result of `iter` and returns each element as part of a tuple instead.
The first element of the tuple returned from `enumerate` is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.
-->
<p>Nous aborderons plus en dÃ©tail les itÃ©rateurs dans le chapitre 13. Pour le
moment, sachez que <code>iter</code> est une mÃ©thode qui retourne chaque Ã©lÃ©ment d'une
collection, et que <code>enumerate</code> transforme le rÃ©sultat de <code>iter</code> pour retourner
plutÃ´t chaque Ã©lÃ©ment comme un tuple. Le premier Ã©lÃ©ment du tuple retournÃ© par
<code>enumerate</code> est l'indice, et le second Ã©lÃ©ment est une rÃ©fÃ©rence vers l'Ã©lÃ©ment.
C'est un peu plus pratique que de calculer les indices par nous-mÃªmes.</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple. Weâ€™ll be discussing patterns more in Chapter 6. So in
the `for` loop, we specify a pattern that has `i` for the index in the tuple
and `&item` for the single byte in the tuple. Because we get a reference to the
element from `.iter().enumerate()`, we use `&` in the pattern.
-->
<p>Comme la mÃ©thode <code>enumerate</code> retourne un tuple, nous pouvons utiliser des
motifs pour dÃ©structurer ce tuple. Nous verrons les motifs au chapitre 6. Donc
dans la boucle <code>for</code>, nous prÃ©cisons un motif qui indique que nous dÃ©finissons
<code>i</code> pour l'indice au sein du tuple et <code>&amp;element</code> pour l'octet dans le tuple.
Comme nous obtenons une rÃ©fÃ©rence vers l'Ã©lÃ©ment avec <code>.iter().enumerate()</code>,
nous utilisons <code>&amp;</code> dans le motif.</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p>Au sein de la boucle <code>for</code>, nous recherchons l'octet qui reprÃ©sente l'espace en
utilisant la syntaxe de littÃ©ral d'octet. Si nous trouvons une espace, nous
retournons sa position. Sinon, nous retournons la taille de la chaÃ®ne en
utilisant <code>s.len()</code>Â :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span>        if element == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but thereâ€™s a problem. Weâ€™re returning a `usize` on its own, but itâ€™s
only a meaningful number in the context of the `&String`. In other words,
because itâ€™s a separate value from the `String`, thereâ€™s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>Nous avons maintenant une faÃ§on de trouver l'indice de la fin du premier mot
dans la chaÃ®ne de caractÃ¨res, mais il y a un problÃ¨me. Nous retournons un
<code>usize</code> tout seul, mais il n'a du sens que lorsqu'il est liÃ© au <code>&amp;String</code>.
Autrement dit, comme il a une valeur sÃ©parÃ©e de la <code>String</code>, il n'y a pas de
garantie qu'il restera toujours valide dans le futur. Imaginons le programme
dans l'encart 4-8 qui utilise la fonction <code>premier_mot</code> de l'encart 4-7Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s); // la variable mot aura 5 comme valeur.

    s.clear(); // ceci vide la String, elle vaut maintenant &quot;&quot;.

    // mot a toujours la valeur 5 ici, mais il n'y a plus de chaÃ®ne qui donne
    // du sens Ã  la valeur 5. mot est maintenant complÃ¨tement invalideÂ !
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">Encart 4-8Â : On stocke le rÃ©sultat de l'appel Ã  la
fonction <code>premier_mot</code> et ensuite on change le contenu de la <code>String</code></span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isnâ€™t connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>Ce programme se compile sans aucune erreur et le ferait toujours si nous
utilisions <code>mot</code> aprÃ¨s avoir appelÃ© <code>s.clear()</code>. Comme <code>mot</code> n'est pas du tout
liÃ© Ã  <code>s</code>, <code>mot</code> contient toujours la valeur <code>5</code>. Nous pourrions utiliser cette
valeur <code>5</code> avec la variable <code>s</code> pour essayer d'en extraire le premier mot, mais
cela serait un bogue, car le contenu de <code>s</code> a changÃ© depuis que nous avons
enregistrÃ© <code>5</code> dans <code>mot</code>.</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p>Se prÃ©occuper en permanence que l'indice prÃ©sent dans <code>mot</code> ne soit plus
synchronisÃ© avec les donnÃ©es prÃ©sentes dans <code>s</code> est fastidieux et source
d'erreurÂ ! La gestion de ces indices est encore plus risquÃ©e si nous Ã©crivons
une fonction <code>second_mot</code>. Sa signature ressemblerait Ã  ceciÂ :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now weâ€™re tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but arenâ€™t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.
-->
<p>Maintenant, nous avons un indice de dÃ©but <em>et</em> un indice de fin, donc nous avons
encore plus de valeurs qui sont calculÃ©es Ã  partir d'une donnÃ©e dans un Ã©tat
donnÃ©, mais qui ne sont pas liÃ©es du tout Ã  l'Ã©tat de cette donnÃ©e. Nous avons
maintenant trois variables isolÃ©es qui ont besoin d'Ãªtre maintenues Ã  jour.</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>Heureusement, Rust a une solution pour ce problÃ¨meÂ : les <em>slices</em> de chaÃ®nes de
caractÃ¨res.</p>
<!--
### String Slices
-->
<h3 id="les-slices-de-chaÃ®nes-de-caractÃ¨res"><a class="header" href="#les-slices-de-chaÃ®nes-de-caractÃ¨res">Les slices de chaÃ®nes de caractÃ¨res</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p>Une <em>slice de chaÃ®ne de caractÃ¨res</em> (ou <em>slice de chaÃ®ne</em>) est une rÃ©fÃ©rence Ã 
une partie d'une <code>String</code>, et ressemble Ã  ceciÂ :</p>
<!--
```rust
# fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
This is similar to taking a reference to the whole `String` but with the extra
`[0..5]` bit. Rather than a reference to the entire `String`, itâ€™s a reference
to a portion of the `String`.
-->
<p>Cela ressemble Ã  une rÃ©fÃ©rence pour toute la <code>String</code>, mais avec la partie
<code>[0..5]</code> en plus. PlutÃ´t que d'Ãªtre une rÃ©fÃ©rence vers toute la <code>String</code>, c'est
une rÃ©fÃ©rence vers une partie de la <code>String</code>.</p>
<!--
We can create slices using a range within brackets by specifying
`[starting_index..ending_index]`, where `starting_index` is the first position
in the slice and `ending_index` is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to `ending_index` minus
`starting_index`. So in the case of `let world = &s[6..11];`, `world` would be
a slice that contains a pointer to the byte at index 6 of `s` with a length
value of 5.
-->
<p>Nous pouvons crÃ©er des slices en utilisant un intervalle entre crochets en
spÃ©cifiant <code>[indice_debut..indice_fin]</code>, oÃ¹ <code>indice_debut</code> est la position du
premier octet de la slice et <code>indice_fin</code> est la position juste aprÃ¨s le dernier
octet de la slice. En interne, la structure de donnÃ©es de la slice stocke la
position de dÃ©part et la longueur de la slice, ce qui correspond Ã  <code>indice_fin</code>
moins <code>indice_debut</code>. Donc dans le cas de <code>let world = &amp;s[6..11];</code>, <code>world</code> est
une slice qui contient un pointeur vers le sixiÃ¨me octet de <code>s</code> et une longueur
de 5.</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>L'illustration 4-6 montre ceci dans un schÃ©ma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="world containing a pointer to the byte at index 6 of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="world contient un pointeur vers l'octet d'indice 6 de la String s et
une longueur de 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">Illustration 4-6Â : Une slice de chaÃ®ne qui pointe vers
une partie d'une <code>String</code></span></p>
<!--
With Rustâ€™s `..` range syntax, if you want to start at index zero, you can drop
the value before the two periods. In other words, these are equal:
-->
<p>Avec la syntaxe d'intervalle <code>..</code> de Rust, si vous voulez commencer Ã  l'indice
zÃ©ro, vous pouvez ne rien mettre avant les deux points. Autrement dit, ces deux
cas sont identiquesÂ :</p>
<!--
```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>De la mÃªme maniÃ¨re, si votre slice contient le dernier octet de la <code>String</code>,
vous pouvez ne rien mettre Ã  la fin. Cela veut dire que ces deux cas sont
identiquesÂ :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[3..taille];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>Vous pouvez aussi ne mettre aucune limite pour crÃ©er une slice de toute la
chaÃ®ne de caractÃ¨res. Ces deux cas sont donc identiquesÂ :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[0..taille];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [â€œStoring UTF-8 Encoded
> Text with Stringsâ€][strings]<!-- ignore -- > section of Chapter 8.
-->
<blockquote>
<p>RemarqueÂ : Les indices de l'intervalle d'une slice de chaÃ®ne doivent toujours
se trouver dans les zones acceptables de sÃ©paration des caractÃ¨res encodÃ©s en
UTF-8. Si vous essayez de crÃ©er une slice de chaÃ®ne qui s'arrÃªte au milieu
d'un caractÃ¨re encodÃ© sur plusieurs octets, votre programme va se fermer avec
une erreur. Afin de simplifier l'explication des slices de chaÃ®nes, nous
utiliserons uniquement l'ASCII dans cette sectionÂ ; nous verrons la gestion
d'UTF-8 dans la section <a href="ch08-02-strings.html">â€œStocker du texte encodÃ© en UTF-8 avec les chaÃ®nes de
caractÃ¨resâ€</a><!-- ignore --> du chapitre 8.</p>
</blockquote>
<!--
With all this information in mind, letâ€™s rewrite `first_word` to return a
slice. The type that signifies â€œstring sliceâ€ is written as `&str`:
-->
<p>Maintenant que nous savons tout cela, essayons de rÃ©Ã©crire <code>premier_mot</code> pour
qu'il retourne une slice. Le type pour les slices de chaÃ®nes de caractÃ¨res
s'Ã©crit <code>&amp;str</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>Nous rÃ©cupÃ©rons l'indice de la fin du mot de la mÃªme faÃ§on que nous l'avions
fait dans l'encart 4-7, en cherchant la premiÃ¨re occurrence d'une espace.
Lorsque nous trouvons une espace, nous retournons une slice de chaÃ®ne en
utilisant le dÃ©but de la chaÃ®ne de caractÃ¨res et l'indice de l'espace comme
indices de dÃ©but et de fin respectivement.</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>DÃ©sormais, quand nous appelons <code>premier_mot</code>, nous rÃ©cupÃ©rons une unique valeur
qui est liÃ©e Ã  la donnÃ©e de base. La valeur se compose d'une rÃ©fÃ©rence vers le
point de dÃ©part de la slice et du nombre d'Ã©lÃ©ments dans la slice.</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p>Retourner une slice fonctionnerait aussi pour une fonction <code>second_mot</code>Â :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API thatâ€™s much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didnâ€™t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>Nous avons maintenant une API simple qui est bien plus difficile Ã  mal utiliser,
puisque le compilateur va s'assurer que les rÃ©fÃ©rences dans la <code>String</code> seront
toujours en vigueur. Vous souvenez-vous du bogue du programme de l'encart 4-8,
lorsque nous avions un indice vers la fin du premier mot mais qu'ensuite nous
avions vidÃ© la chaÃ®ne de caractÃ¨res et que notre indice n'Ã©tait plus valideÂ ? Ce
code Ã©tait logiquement incorrect, mais ne montrait pas immÃ©diatement une erreur.
Les problÃ¨mes apparaÃ®tront plus tard si nous essayons d'utiliser l'indice du
premier mot avec une chaÃ®ne de caractÃ¨res qui a Ã©tÃ© vidÃ©e. Les slices rendent ce
bogue impossible et nous signalent bien plus tÃ´t que nous avons un problÃ¨me avec
notre code. Utiliser la version avec la slice de <code>premier_mot</code> va causer une
erreur de compilationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn first_word(s: &String) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s);

    s.clear(); // ErreurÂ !

    println!(&quot;Le premier mot estÂ : {}&quot;, mot);
}
</code></pre>
<!--
Hereâ€™s the compiler error:
-->
<p>Voici l'erreur du compilateurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  -- > src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let mot = premier_mot(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // ErreurÂ !
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Le premier mot estÂ : {}&quot;, mot);
   |                                         --- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. The `println!`
after the call to `clear` uses the reference in `word`, so the immutable
reference must still be active at that point. Rust disallows the mutable
reference in `clear` and the immutable reference in `word` from existing at the
same time, and compilation fails. Not only has Rust made our API easier to use,
but it has also eliminated an entire class of errors at compile time!
-->
<p>Rappelons-nous que d'aprÃ¨s les rÃ¨gles d'emprunt, si nous avons une rÃ©fÃ©rence
immuable vers quelque chose, nous ne pouvons pas avoir une rÃ©fÃ©rence mutable
en mÃªme temps. Ã‰tant donnÃ© que <code>clear</code> a besoin de modifier la <code>String</code>, il a
besoin d'une rÃ©fÃ©rence mutable. Le <code>println!</code> qui a lieu aprÃ¨s l'appel Ã  <code>clear</code>
utilise la rÃ©fÃ©rence Ã  <code>mot</code>, donc la rÃ©fÃ©rence immuable sera toujours en
vigueur Ã  cet endroit. Rust interdit la rÃ©fÃ©rence mutable dans <code>clear</code> et la
rÃ©fÃ©rence immuable pour <code>mot</code> au mÃªme moment, et la compilation Ã©choue. Non
seulement Rust a simplifiÃ© l'utilisation de notre API, mais il a
aussi Ã©liminÃ© une catÃ©gorie entiÃ¨re d'erreurs au moment de la compilationÂ !</p>
<!--
#### String Literals Are Slices
-->
<h4 id="les-littÃ©raux-de-chaÃ®ne-de-caractÃ¨res-sont-aussi-des-slices"><a class="header" href="#les-littÃ©raux-de-chaÃ®ne-de-caractÃ¨res-sont-aussi-des-slices">Les littÃ©raux de chaÃ®ne de caractÃ¨res sont aussi des slices</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>Rappelez-vous lorsque nous avons appris que les littÃ©raux de chaÃ®ne de
caractÃ¨res Ã©taient enregistrÃ©s dans le binaire. Maintenant que nous connaissons
les slices, nous pouvons dÃ©sormais comprendre les littÃ©raux de chaÃ®ne.</p>
<!--
```rust
let s = "Hello, world!";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: itâ€™s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>Ici, le type de <code>s</code> est un <code>&amp;str</code>Â : c'est une slice qui pointe vers un endroit
prÃ©cis du binaire. C'est aussi la raison pour laquelle les littÃ©raux de chaÃ®ne
sont immuablesÂ ; <code>&amp;str</code> est une rÃ©fÃ©rence immuable.</p>
<!--
#### String Slices as Parameters
-->
<h4 id="les-slices-de-chaÃ®nes-de-caractÃ¨res-en-paramÃ¨tres"><a class="header" href="#les-slices-de-chaÃ®nes-de-caractÃ¨res-en-paramÃ¨tres">Les slices de chaÃ®nes de caractÃ¨res en paramÃ¨tres</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and thatâ€™s its signature:
-->
<p>Savoir que l'on peut utiliser des slices de littÃ©raux et de <code>String</code> nous incite
Ã  apporter une petite amÃ©lioration Ã  <code>premier_mot</code>, dont voici la signatureÂ :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>Un RustacÃ© plus expÃ©rimentÃ© Ã©crirait plutÃ´t la signature de l'encart 4-9, car
cela nous permet d'utiliser la mÃªme fonction sur les <code>&amp;String</code> et aussi les
<code>&amp;str</code>Â :</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // `first_word` works on slices of `String`s, whether partial or whole
#     let word = first_word(&my_string[0..6]);
#     let word = first_word(&my_string[..]);
#     // `first_word` also works on references to `String`s, which are equivalent
#     // to whole slices of `String`s
#     let word = first_word(&my_string);
# 
#     let my_string_literal = "hello world";
# 
#     // `first_word` works on slices of string literals, whether partial or whole
#     let word = first_word(&my_string_literal[0..6]);
#     let word = first_word(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = first_word(my_string_literal);
# }
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ma_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne avec les slices de `String`, que ce soit sur
</span><span class="boring">    // une partie ou sur sur son intÃ©gralitÃ©
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[0..6]);
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[..]);
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne Ã©galement sur des rÃ©fÃ©rences vers des `String`,
</span><span class="boring">    // qui sont Ã©quivalentes Ã  des slices de toute la `String`
</span><span class="boring">    let mot = premier_mot(&amp;ma_string);
</span><span class="boring">
</span><span class="boring">    let mon_litteral_de_chaine = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne avec les slices de littÃ©raux de chaÃ®ne, qu'elles
</span><span class="boring">    // soient partielles ou intÃ©grales
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[0..6]);
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);
</span><span class="boring">
</span><span class="boring">    // Comme les littÃ©raux de chaÃ®ne *sont* dÃ©jÃ  des slices de chaÃ®nes,
</span><span class="boring">    // cela fonctionne aussi, sans la syntaxe de sliceÂ !
</span><span class="boring">    let mot = premier_mot(mon_litteral_de_chaine);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">Encart 4-9Â : AmÃ©lioration de la fonction <code>premier_mot</code> en
utilisant une slice de chaÃ®ne de caractÃ¨res comme type du paramÃ¨tre <code>s</code></span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the `String` or a reference to the `String`. This
flexibility takes advantage of *deref coercions*, a feature we will cover in
the [â€œImplicit Deref Coercions with Functions and
Methodsâ€][deref-coercions]<!--ignore-- > section of Chapter 15. Defining a
function to take a string slice instead of a reference to a `String` makes our
API more general and useful without losing any functionality:
-->
<p>Si nous avons une slice de chaÃ®ne, nous pouvons la passer en argument
directement. Si nous avons une <code>String</code>, nous pouvons envoyer une rÃ©fÃ©rence ou
une slice de la <code>String</code>. Cette flexibilitÃ© nous est offerte par
l'<em>extrapolation de dÃ©rÃ©ferencement</em>, une fonctionnalitÃ© que nous allons
dÃ©couvrir dans <a href="ch15-02-deref.html">une section du Chapitre 15</a><!--ignore-->.
DÃ©finir une fonction qui prend une slice de chaÃ®ne plutÃ´t qu'une rÃ©fÃ©rence Ã 
une <code>String</code> rend notre API plus gÃ©nÃ©rique et plus utile sans perdre aucune
fonctionnalitÃ©Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let ma_string = String::from(&quot;hello world&quot;);

    // `premier_mot` fonctionne avec les slices de `String`, que ce soit sur
    // une partie ou sur sur son intÃ©gralitÃ©
    let mot = premier_mot(&amp;ma_string[0..6]);
    let mot = premier_mot(&amp;ma_string[..]);

    // `premier_mot` fonctionne Ã©galement sur des rÃ©fÃ©rences vers des `String`,
    // qui sont Ã©quivalentes Ã  des slices de toute la `String`
    let mot = premier_mot(&amp;ma_string);

    let mon_litteral_de_chaine = &quot;hello world&quot;;

    // `premier_mot` fonctionne avec les slices de littÃ©raux de chaÃ®ne, qu'elles
    // soient partielles ou intÃ©grales
    let mot = premier_mot(&amp;mon_litteral_de_chaine[0..6]);
    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);

    // Comme les littÃ©raux de chaÃ®ne *sont* dÃ©jÃ  des slices de chaÃ®nes,
    // cela fonctionne aussi, sans la syntaxe de sliceÂ !
    let mot = premier_mot(mon_litteral_de_chaine);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3 id="les-autres-slices"><a class="header" href="#les-autres-slices">Les autres slices</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But thereâ€™s a
more general slice type, too. Consider this array:
-->
<p>Les slices de chaÃ®nes de caractÃ¨res, comme vous pouvez l'imaginer, sont
spÃ©cifiques aux chaÃ®nes de caractÃ¨res. Mais il existe aussi un type de slice
plus gÃ©nÃ©rique. Imaginons ce tableau de donnÃ©esÂ :</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. Weâ€™d do so like this:
-->
<p>Tout comme nous pouvons nous rÃ©fÃ©rer Ã  une partie d'une chaÃ®ne de caractÃ¨res,
nous pouvons nous rÃ©fÃ©rer Ã  une partie d'un tableau. Nous pouvons le faire comme
ceciÂ :</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. Youâ€™ll use this kind of
slice for all sorts of other collections. Weâ€™ll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>Cette slice est de type <code>&amp;[i32]</code>. Elle fonctionne de la mÃªme maniÃ¨re que les
slices de chaÃ®nes de caractÃ¨res, en enregistrant une rÃ©fÃ©rence vers le premier
Ã©lÃ©ment et une longueur. Vous utiliserez ce type de slice pour tous les autres
types de collections. Nous aborderons ces collections en dÃ©tail quand nous
verrons les vecteurs au chapitre 8.</p>
<!--
## Summary
-->
<h2 id="rÃ©sumÃ©"><a class="header" href="#rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you donâ€™t have to write and debug extra code to get this control.
-->
<p>Les concepts de possession, d'emprunt et de slices garantissent la sÃ©curitÃ© de
la mÃ©moire dans les programmes Rust au moment de la compilation. Le langage Rust
vous donne le contrÃ´le sur l'utilisation de la mÃ©moire comme tous les autres
langages de programmation systÃ¨me, mais le fait que celui qui possÃ¨de des
donnÃ©es nettoie automatiquement ces donnÃ©es quand il sort de la portÃ©e vous
permet de ne pas avoir Ã  Ã©crire et dÃ©boguer du code en plus pour avoir cette
fonctionnalitÃ©.</p>
<!--
Ownership affects how lots of other parts of Rust work, so weâ€™ll talk about
these concepts further throughout the rest of the book. Letâ€™s move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>La possession influe sur de nombreuses autres fonctionnalitÃ©s de Rust, c'est
pourquoi nous allons encore parler de ces concepts plus loin dans le livre.
Passons maintenant au chapitre 5 et dÃ©couvrons comment regrouper des donnÃ©es
ensemble dans une <code>struct</code>.</p>
<!--
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[deref-coercions]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
