<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comment Ã©crire des tests - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html" class="active"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## How to Write Tests
-->
<h2 id="comment-Ã©crire-des-tests"><a class="header" href="#comment-Ã©crire-des-tests">Comment Ã©crire des tests</a></h2>
<!--
Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:
-->
<p>Les tests sont des fonctions Rust qui vÃ©rifient que le code qui n'est pas un
test se comporte bien de la maniÃ¨re attendue. Les corps des fonctions de test
effectuent gÃ©nÃ©ralement ces trois actionsÂ :</p>
<!--
1. Set up any needed data or state.
2. Run the code you want to test.
3. Assert the results are what you expect.
-->
<ol>
<li>Initialiser toutes les donnÃ©es ou les Ã©tats,</li>
<li>Lancer le code que vous voulez tester,</li>
<li>VÃ©rifier que les rÃ©sultats correspondent bien Ã  ce que vous souhaitez.</li>
</ol>
<!--
Letâ€™s look at the features Rust provides specifically for writing tests that
take these actions, which include the `test` attribute, a few macros, and the
`should_panic` attribute.
-->
<p>DÃ©couvrons les fonctionnalitÃ©s spÃ©cifiques qu'offre Rust pour Ã©crire des tests
qui font ces actions, dans lesquelles on retrouve l'attribut <code>test</code>, quelques
macros, et l'attribut <code>should_panic</code>.</p>
<!--
### The Anatomy of a Test Function
-->
<h3 id="lanatomie-dune-fonction-de-test"><a class="header" href="#lanatomie-dune-fonction-de-test">L'anatomie d'une fonction de test</a></h3>
<!--
At its simplest, a test in Rust is a function thatâ€™s annotated with the `test`
attribute. Attributes are metadata about pieces of Rust code; one example is
the `derive` attribute we used with structs in Chapter 5. To change a function
into a test function, add `#[test]` on the line before `fn`. When you run your
tests with the `cargo test` command, Rust builds a test runner binary that runs
the functions annotated with the `test` attribute and reports on whether each
test function passes or fails.
-->
<p>Dans la forme la plus simple, un test en Rust est une fonction qui est marquÃ©e
avec l'attribut <code>test</code>. Les attributs sont des mÃ©tadonnÃ©es sur des parties de
code RustÂ ; un exemple est l'attribut <code>derive</code> que nous avons utilisÃ© sur les
structures au chapitre 5. Pour transformer une fonction en une fonction de test,
il faut ajouter <code>#[test]</code> dans la ligne avant le <code>fn</code>. Lorsque vous lancez vos
tests avec la commande <code>cargo test</code>, Rust construit un binaire d'exÃ©cution de tests
qui exÃ©cute les fonctions marquÃ©es avec l'attribut <code>test</code> et fait un rapport sur
quelles fonctions ont rÃ©ussi ou Ã©chouÃ©.</p>
<!--
When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you donâ€™t have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!
-->
<p>Lorsque nous crÃ©ons une nouvelle bibliothÃ¨que avec Cargo, un module de tests
qui contient une fonction de test est automatiquement crÃ©Ã© pour nous. Ce module
vous aide Ã  dÃ©marrer l'Ã©criture de vos tests afin que vous n'ayez pas Ã  chercher
la structure et la syntaxe exacte d'une fonction de test Ã  chaque fois que vous
dÃ©butez un nouveau projet. Vous pouvez ajouter autant de fonctions de test et
autant de modules de test que vous le souhaitezÂ !</p>
<!--
Weâ€™ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then weâ€™ll write some
real-world tests that call some code that weâ€™ve written and assert that its
behavior is correct.
-->
<p>Nous allons dÃ©couvrir quelques aspects du fonctionnement des tests en
expÃ©rimentant avec le modÃ¨le de test gÃ©nÃ©rÃ© pour nous, mais qui ne teste aucun
code pour le moment. Ensuite, nous Ã©crirons quelques tests plus proches de la
rÃ©alitÃ©, qui utilisera du code que nous avons Ã©crit et qui validera son bon
comportement.</p>
<!--
Letâ€™s create a new library project called `adder`:
-->
<p>CommenÃ§ons par crÃ©er un nouveau projet de bibliothÃ¨que que nous appellerons
<code>addition</code>Â :</p>
<!--
```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```
-->
<pre><code class="language-console">$ cargo new addition --lib
     Created library `addition` project
$ cd addition
</code></pre>
<!--
The contents of the *src/lib.rs* file in your `adder` library should look like
Listing 11-1.
-->
<p>Le contenu de votre fichier <em>src/lib.rs</em> dans votre bibliothÃ¨que <code>addition</code>
devrait ressembler Ã  l'encart 11-1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-1: The test module and function generated
automatically by `cargo new`</span>
-->
<p><span class="caption">Encart 11-1Â : le module de test et la fonction gÃ©nÃ©rÃ©es
automatiquement par <code>cargo new</code></span></p>
<!--
For now, letâ€™s ignore the top two lines and focus on the function to see how it
works. Note the `#[test]` annotation before the `fn` line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the `tests` module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the `#[test]` attribute.
-->
<p>Pour l'instant, ignorons les deux premiÃ¨res lignes et concentrons-nous sur la
fonction pour voir comment elle fonctionne. Remarquez l'annotation <code>#[test]</code>
avant la ligne <code>fn</code>Â : cet attribut indique que c'est une fonction de test, donc
l'exÃ©cuteur de tests sait qu'il doit considÃ©rer cette fonction comme Ã©tant un
test. Nous pouvons aussi avoir des fonctions qui ne font pas de tests dans le
module <code>tests</code> afin de rÃ©gler des scÃ©narios en commun ou pour procÃ©der Ã  des
opÃ©rations en commun, c'est pourquoi nous devons indiquer quelles fonctions sont
des tests en utilisant l'attribut <code>#[test]</code>.</p>
<!--
The function body uses the `assert_eq!` macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Letâ€™s run
it to see that this test passes.
-->
<p>Le corps de la fonction utilise la macro <code>assert_eq!</code> pour vÃ©rifier que 2 + 2
vaut bien 4. Cette vÃ©rification sert d'exemple pour expliquer le format d'un
test classique. LanÃ§ons-le pour vÃ©rifier si ce test est validÃ©.</p>
<!--
The `cargo test` command runs all tests in our project, as shown in Listing
11-2.
-->
<p>La commande <code>cargo test</code> lance tous les tests prÃ©sents dans votre projet, comme
le montre l'encart 11-2.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
<span class="caption">Listing 11-2: The output from running the automatically
generated test</span>
-->
<p><span class="caption">Encart 11-2Â : le rÃ©sultat du lancement des tests sur le
test gÃ©nÃ©rÃ© automatiquement</span></p>
<!--
Cargo compiled and ran the test. After the `Compiling`, `Finished`, and
`Running` lines is the line `running 1 test`. The next line shows the name
of the generated test function, called `it_works`, and the result of running
that test, `ok`. The overall summary of running the tests appears next. The
text `test result: ok.` means that all the tests passed, and the portion that
reads `1 passed; 0 failed` totals the number of tests that passed or failed.
-->
<p>Cargo a compilÃ© et lancÃ© le test. AprÃ¨s les lignes <code>Compiling</code>, <code>Finished</code>, et
<code>Running</code>, on trouve la ligne <code>running 1 test</code>. La ligne suivante montre le nom
de la fonction de test <code>it_works</code>, qui a Ã©tÃ© gÃ©nÃ©rÃ© prÃ©cÃ©demment, et le rÃ©sultat de
l'exÃ©cution de ce test, <code>ok</code>. Le rÃ©sumÃ© gÃ©nÃ©ral de l'exÃ©cution des tests
s'affiche ensuite. Le texte <code>test result: ok.</code> signifie que tous les tests ont
rÃ©ussi, et la partie <code>1 passed; 0 failed</code> compte le nombre total de tests qui
ont rÃ©ussi ou Ã©chouÃ©.</p>
<!--
Because we donâ€™t have any tests weâ€™ve marked as ignored, the summary shows `0
ignored`. We also havenâ€™t filtered the tests being run, so the end of the
summary shows `0 filtered out`. Weâ€™ll talk about ignoring and filtering out
tests in the next section, [â€œControlling How Tests Are
Run.â€][controlling-how-tests-are-run]<!-- ignore -- >
-->
<p>Comme nous n'avons aucun test que nous avons marquÃ© comme ignorÃ©, le rÃ©sumÃ©
affiche <code>0 ignored</code>. Nous n'avons pas non plus filtrÃ© les tests qui ont Ã©tÃ©
exÃ©cutÃ©s, donc la fin du rÃ©sumÃ© affiche <code>0 filtered out</code>. Nous verrons comment
ignorer et filtrer les tests dans la prochaine section, <a href="ch11-02-running-tests.html">â€œContrÃ´ler comment les
tests sont exÃ©cutÃ©sâ€</a><!-- ignore -->.</p>
<!--
The `0 measured` statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
[the documentation about benchmark tests][bench] to learn more.
-->
<p>La statistique <code>0 measured</code> sert pour des tests de benchmark qui mesurent les
performances. Les tests de benchmark ne sont disponibles pour le moment que dans
la version expÃ©rimentale de Rust (nighly), au moment de cette Ã©criture.
Rendez-vous sur <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">la documentation sur les tests de benchmark</a> pour en
savoir plus.</p>
<!--
[bench]: ../unstable-book/library-features/test.html
-->
<!--
The next part of the test output, which starts with `Doc-tests adder`, is for
the results of any documentation tests. We donâ€™t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! Weâ€™ll
discuss how to write documentation tests in the [â€œDocumentation Comments as
Testsâ€][doc-comments]<!-- ignore -- > section of Chapter 14. For now, weâ€™ll
ignore the `Doc-tests` output.
-->
<p>La partie suivante du rÃ©sultat du test, qui commence par <code>Doc-tests addition</code>,
concerne les rÃ©sultats de tous les tests prÃ©sents dans la documentation. Nous
n'avons pas de tests dans la documentation pour le moment, mais Rust peut
compiler tous les exemples de code qui sont prÃ©sents dans la documentation de
notre API. Cette fonctionnalitÃ© nous aide Ã  garder synchronisÃ© notre
documentation et notre codeÂ ! Nous verrons comment Ã©crire nos tests dans la
documentation dans une section du chapitre 14. Pour le moment, nous allons
ignorer la partie <code>Doc-tests</code> du rÃ©sultat.</p>
<!--
Letâ€™s change the name of our test to see how that changes the test output.
Change the `it_works` function to a different name, such as `exploration`, like
so:
-->
<p>Changeons le nom de notre test pour voir comment cela change le rÃ©sultat du
test. Changeons le nom de la fonction <code>it_works</code> pour un nom diffÃ©rent, comme
<code>exploration</code> ci-dessousÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!--
Then run `cargo test` again. The output now shows `exploration` instead of
`it_works`:
-->
<p>Lancez ensuite Ã  nouveau <code>cargo test</code>. Le rÃ©sultat affiche dÃ©sormais
<code>exploration</code> plutÃ´t que <code>it_works</code>Â :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Letâ€™s add another test, but this time weâ€™ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the `panic!` macro. Enter the new test, `another`, so your
*src/lib.rs* file looks like Listing 11-3.
-->
<p>Ajoutons un autre test, mais cette fois nous allons construire un test qui
Ã©choueÂ ! Les tests Ã©chouent lorsque quelque chose dans la fonction de test
panique. Chaque test est lancÃ© dans une nouvelle tÃ¢che, et lorsque la tÃ¢che
principale voit qu'une tÃ¢che de test est mort, le test est considÃ©rÃ©
comme Ã©chouÃ©. Nous avons vu la faÃ§on la plus simple de faire paniquer au
chapitre 9, qui consiste Ã  appeler la macro <code>panic!</code>. Ecrivez ce nouveau test,
<code>un_autre</code>, de sorte que votre fichier <code>src/lib.rs</code> ressemble Ã  ceciÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,panics,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!("Fait Ã©chouer ce test");
    }
}
```
-->
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!(&quot;Fait Ã©chouer ce test&quot;);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-3: Adding a second test that will fail because
we call the `panic!` macro</span>
-->
<p><span class="caption">Encart 11-3Â : ajout d'un second test qui va Ã©chouer car
nous appelons la macro <code>panic!</code></span></p>
<!--
Run the tests again using `cargo test`. The output should look like Listing
11-4, which shows that our `exploration` test passed and `another` failed.
-->
<p>Lancez Ã  nouveau les tests en utilisant <code>cargo test</code>. Le rÃ©sultat devrait
ressembler Ã  l'encart 11-4, qui va afficher que notre test <code>exploration</code> a
rÃ©ussi et que <code>un_autre</code> va Ã©chouer.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait Ã©chouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait Ã©chouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
<span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span>
-->
<p><span class="caption">Encart 11-4Â : les rÃ©sultats de tests lorsque un test
rÃ©ussit et un autre test Ã©choue</span></p>
<!--
Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
`another` failed because it `panicked at 'Make this test fail'`, which happened
on line 10 in the *src/lib.rs* file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; weâ€™ll talk more about ways to run tests in
the [â€œControlling How Tests Are Runâ€][controlling-how-tests-are-run]<!-- ignore
-- > section.
-->
<p>A la place du <code>ok</code>, la ligne <code>test tests:un_autre</code> affiche <code>FAILED</code>. Deux
nouvelles sections apparaissent entre la liste des tests et le rÃ©sumÃ©Â : la
premiÃ¨re section affiche les raisons dÃ©taillÃ©es de chaque Ã©chec de test. Dans
notre cas, <code>un_autre</code> a Ã©chouÃ© car il a paniquÃ© Ã  'Fait Ã©chouer ce test', qui
est placÃ© Ã  la ligne 10 du fichier <em>src/lib.rs</em>. La partie suivante liste
simplement les noms de tous les tests qui ont Ã©chouÃ©, ce qui est utile lorsqu'il
y a de nombreux tests et beaucoup de dÃ©tails provenant des tests qui Ã©chouent.
Nous pouvons utiliser le nom d'un test qui Ã©choue pour lancer uniquement ce test
afin de dÃ©boguer plus facilementÂ ; nous allons voir plus de faÃ§ons de lancer
des tests dans la <a href="ch11-02-running-tests.html">section suivante</a><!-- ignore
-->.</p>
<!--
The summary line displays at the end: overall, our test result is `FAILED`.
We had one test pass and one test fail.
-->
<p>La ligne de rÃ©sumÃ© s'affiche Ã  la finÂ : au final, le rÃ©sultat de nos tests est
au statut <code>FAILED</code> (Ã©chouÃ©). Nous avons un test rÃ©ussi et un test Ã©chouÃ©.</p>
<!--
Now that youâ€™ve seen what the test results look like in different scenarios,
letâ€™s look at some macros other than `panic!` that are useful in tests.
-->
<p>Maintenant que vous avez vu Ã  quoi ressemblent les rÃ©sultats de tests dans
diffÃ©rents scÃ©narios, voyons d'autres macros que <code>panic!</code> qui nous serons utiles
pour les tests.</p>
<!--
### Checking Results with the `assert!` Macro
-->
<h3 id="vÃ©rifier-les-rÃ©sultats-avec-la-macro-assert"><a class="header" href="#vÃ©rifier-les-rÃ©sultats-avec-la-macro-assert">VÃ©rifier les rÃ©sultats avec la macro <code>assert!</code></a></h3>
<!--
The `assert!` macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to `true`. We give the
`assert!` macro an argument that evaluates to a Boolean. If the value is
`true`, `assert!` does nothing and the test passes. If the value is `false`,
the `assert!` macro calls the `panic!` macro, which causes the test to fail.
Using the `assert!` macro helps us check that our code is functioning in the
way we intend.
-->
<p>La macro <code>assert!</code>, fournie par la bibliothÃ¨que standard, est utile lorsque vous
voulez vous assurer qu'une condition dans un test vaut <code>true</code>. Nous fournissons
Ã  la macro <code>assert!</code> un argument qui donne un BoolÃ©en une fois interprÃ©tÃ©. Si la
valeur est <code>true</code>, <code>assert!</code> ne fait rien et le test est rÃ©ussi. Si la valeur
est <code>false</code>, la macro <code>assert!</code> appelle la macro <code>panic!</code>, qui fait Ã©chouer le
test. L'utilisation de la macro <code>assert!</code> nous aide Ã  vÃ©rifier que notre code
fonctionne bien comme nous le souhaitions.</p>
<!--
In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`
method, which are repeated here in Listing 11-5. Letâ€™s put this code in the
*src/lib.rs* file and write some tests for it using the `assert!` macro.
-->
<p>Dans le chapitre 5, dans l'encart 5-15, nous avons utilisÃ© une structure
<code>Rectangle</code> et une mÃ©thode <code>peut_contenir</code>, qui sont recopiÃ©s dans l'encart 11-5
ci-dessous. Ajoutons ce code dans le fichier <em>src/lib.rs</em> et Ã©crivons quelques
tests en utilisant la macro <code>assert!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur > other.largeur && self.hauteur > other.hauteur
    }
}
```
-->
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-5: Using the `Rectangle` struct and its
`can_hold` method from Chapter 5</span>
-->
<p><span class="caption">Encart 11-5Â : utilisation de la structure <code>Rectangle</code> et
sa mÃ©thode <code>peut_contenir</code> du chapitre 5</span></p>
<!--
The `can_hold` method returns a Boolean, which means itâ€™s a perfect use case
for the `assert!` macro. In Listing 11-6, we write a test that exercises the
`can_hold` method by creating a `Rectangle` instance that has a width of 8 and
a height of 7 and asserting that it can hold another `Rectangle` instance that
has a width of 5 and a height of 1.
-->
<p>La mÃ©thode <code>peut_contenir</code> retourne un BoolÃ©en, ce qui veut dire que c'est un
cas parfait pour tester la macro <code>assert!</code>. Dans l'encart 11-6, nous Ã©crivons un
test qui s'applique sur la mÃ©thode <code>peut_contenir</code> en crÃ©ant une instance de
<code>Rectangle</code> qui a une largeur de 8 et une hauteur de 7, et qui vÃ©rifie qu'il
peut contenir une autre instance de <code>Rectangle</code> qui a une largeur de 6 et une
hauteur de 1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&le_petit));
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&amp;le_petit));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-6: A test for `can_hold` that checks whether a
larger rectangle can indeed hold a smaller rectangle</span>
-->
<p><span class="caption">Encart 11-6Â : un test pour <code>peut_contenir</code> qui vÃ©rifie le
cas oÃ¹ un grand rectangle peut contenir un plus petit rectangle</span></p>
<!--
Note that weâ€™ve added a new line inside the `tests` module: `use super::*;`.
The `tests` module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the [â€œPaths for Referring to an Item in the Module
Treeâ€][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -- >
section. Because the `tests` module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
`tests` module.
-->
<p>Remarquez que nous avons ajoutÃ© une nouvelle ligne Ã  l'intÃ©rieur du module
<code>test</code>Â : <code>use super::*;</code>. Le module <code>tests</code> est un module classique qui suit les
rÃ¨gles de visibilitÃ© que nous avons vu au chapitre 7 dans la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">â€œLes
chemins pour dÃ©signer un Ã©lÃ©ment dans l'arborescence de
moduleâ€</a><!-- ignore -->.
Comme le module <code>tests</code> est un module interne, nous avons besoin de ramener le
code Ã  tester qui se trouve dans son module parent dans la portÃ©e du module Ã 
l'intÃ©rieur. Nous utilisons ici un opÃ©rateur global afin que tout ce que nous
avons dÃ©fini dans le module parent soit disponible dans le module <code>tests</code>.</p>
<!--
Weâ€™ve named our test `larger_can_hold_smaller`, and weâ€™ve created the two
`Rectangle` instances that we need. Then we called the `assert!` macro and
passed it the result of calling `larger.can_hold(&smaller)`. This expression
is supposed to return `true`, so our test should pass. Letâ€™s find out!
-->
<p>Nous avons nommÃ© notre test <code>un_grand_peut_contenir_un_petit</code>, et nous avons
crÃ©Ã© les deux instances <code>Rectangle</code> que nous avions besoin. Ensuite, nous avons
appelÃ© la macro <code>assert!</code> et nous lui avons passÃ© le rÃ©sultat de l'appel Ã 
<code>le_grand.peut_contenir(&amp;le_petit)</code>. Cette expression est censÃ©e retourner
<code>true</code>, donc notre test devrait rÃ©ussir. VÃ©rifions celaÂ !</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
It does pass! Letâ€™s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:
-->
<p>Il a rÃ©ussiÂ ! Ajoutons maintenant un autre test, qui vÃ©rifie cette fois qu'un
petit rectangle ne peut contenir un rectangle plus grandÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&le_grand));
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
<span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span>    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&amp;le_grand));
    }
}
</code></pre>
<!--
Because the correct result of the `can_hold` function in this case is `false`,
we need to negate that result before we pass it to the `assert!` macro. As a
result, our test will pass if `can_hold` returns `false`:
-->
<p>Comme le rÃ©sultat correct de la fonction <code>peut_contenir</code> dans ce cas doit Ãªtre
<code>false</code>, nous devons faire un nÃ©gatif de cette fonction avant de l'envoyer Ã  la
macro <code>assert!</code>. Cela aura pour effet de faire rÃ©ussir notre test si
<code>peut_contenir</code> retourne <code>false</code>Â :</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Two tests that pass! Now letâ€™s see what happens to our test results when we
introduce a bug in our code. Letâ€™s change the implementation of the `can_hold`
method by replacing the greater than sign with a less than sign when it
compares the widths:
-->
<p>VoilÃ  deux tests qui rÃ©ussissentÂ ! Maintenant, voyons ce qu'il se passe dans les
rÃ©sultats de nos tests lorsque nous introduisons un bogue dans notre code.
Changeons l'implÃ©mentation de la mÃ©thode <code>peut_contenir</code> en remplaÃ§ant
l'opÃ©rateur <em>plus grand que</em> par un <em>plus petit que</em> au moment de la comparaison
des largeursÂ :</p>
<!--
```rust,not_desired_behavior,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
// -- partie masquÃ©e ici --
impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur < other.largeur && self.hauteur > other.hauteur
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_grand_peut_contenir_un_petit() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
#     }
# 
#     #[test]
#     fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(!le_petit.peut_contenir(&le_grand));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --
impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &lt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_grand_peut_contenir_un_petit() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!le_petit.peut_contenir(&amp;le_grand));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Running the tests now produces the following:
-->
<p>Le lancement des tests donne maintenant le rÃ©sultat suivantÂ :</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&amp;le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our tests caught the bug! Because `larger.width` is 8 and `smaller.width` is
5, the comparison of the widths in `can_hold` now returns `false`: 8 is not
less than 5.
-->
<p>Nos tests ont repÃ©rÃ© le bogueÂ ! Comme <code>le_grand.largeur</code> est 8 et
<code>le_petit.largeur</code> est 5, la comparaison des largeurs dans <code>peut_contenir</code>
retourne maintenant <code>false</code>Â : 8 n'est pas plus petit que 5.</p>
<!--
### Testing Equality with the `assert_eq!` and `assert_ne!` Macros
-->
<h3 id="tester-lÃ©galitÃ©-avec-les-macros-assert_eq-et-assert_ne"><a class="header" href="#tester-lÃ©galitÃ©-avec-les-macros-assert_eq-et-assert_ne">Tester l'Ã©galitÃ© avec les macros <code>assert_eq!</code> et <code>assert_ne!</code></a></h3>
<!--
A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure theyâ€™re equal. You
could do this using the `assert!` macro and passing it an expression using the
`==` operator. However, this is such a common test that the standard library
provides a pair of macrosâ€”`assert_eq!` and `assert_ne!`â€”to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. Theyâ€™ll also print the two values if the assertion
fails, which makes it easier to see *why* the test failed; conversely, the
`assert!` macro only indicates that it got a `false` value for the `==`
expression, not the values that led to the `false` value.
-->
<p>Une faÃ§on courante de tester des fonctionnalitÃ©s est de comparer le rÃ©sultat du
code Ã  tester par rapport Ã  une valeur que vous souhaitez que le code retourne,
afin de vous assurer qu'elles soient bien Ã©gales. Vous pouvez faire cela avec la
macro <code>assert!</code> et en lui passant une expression qui utilise l'opÃ©rateur <code>==</code>.
Cependant, c'est un test si courant que la bibliothÃ¨que standard fournit une
paire de macros (<code>assert_eq!</code> et <code>assert_ne!</code>) pour procÃ©der Ã  ce test plus
facilement. Les macros comparent respectivement l'Ã©galitÃ© ou la non Ã©galitÃ© de
deux arguments. Elles vont aussi afficher les deux valeurs si la vÃ©rification
Ã©choue, ce qui va nous aider Ã  comprendre <em>pourquoi</em> le test a Ã©chouÃ©Â ;
paradoxalement, la macro <code>assert!</code> indique seulement qu'elle a obtenu une valeur
<code>false</code> de l'expression avec le <code>==</code>, mais n'affiche pas les valeurs qui l'ont
menÃ© Ã  la valeur <code>false</code>.</p>
<!--
In Listing 11-7, we write a function named `add_two` that adds `2` to its
parameter and returns the result. Then we test this function using the
`assert_eq!` macro.
-->
<p>Dans l'encart 11-7, nous Ã©crivons une fonction <code>ajouter_deux</code> qui ajoute <code>2</code> Ã 
son paramÃ¨tre et retourne le rÃ©sultat. Ensuite, nous testons cette fonction en
utilisant la macro <code>assert_eq!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-7: Testing the function `add_two` using the
`assert_eq!` macro</span>
-->
<p><span class="caption">Encart 11-7Â : test de la fonction <code>ajouter_deux</code> en
utilisant la macro <code>assert_eq!</code>.</span></p>
<!--
Letâ€™s check that it passes!
-->
<p>VÃ©rifions si cela fonctionneÂ !</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The first argument we gave to the `assert_eq!` macro, `4`, is equal to the
result of calling `add_two(2)`. The line for this test is `test
tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed!
-->
<p>Le premier argument que nous avons donnÃ© Ã  la macro <code>assert_eq!</code>, <code>4</code>, est bien
Ã©gal au rÃ©sultat de l'appel Ã  <code>ajouter_deux</code>. La ligne correspondant Ã  ce test
est <code>test tests::cela_ajoute_deux ... ok</code>, et le texte <code>ok</code> indique que notre
test a rÃ©ussiÂ !</p>
<!--
Letâ€™s introduce a bug into our code to see what it looks like when a test that
uses `assert_eq!` fails. Change the implementation of the `add_two` function to
instead add `3`:
-->
<p>Ajoutons un bogue dans notre code pour voir ce qu'il se passe lorsque un test
qui utilise <code>assert_eq!</code> Ã©choue. Changez l'implÃ©mentation de la fonction
<code>ajouter_deux</code> pour ajouter plutÃ´t <code>3</code>Â :</p>
<!--
```rust,not_desired_behavior,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 3
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn cela_ajoute_deux() {
#         assert_eq!(4, ajouter_deux(2));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn cela_ajoute_deux() {
</span><span class="boring">        assert_eq!(4, ajouter_deux(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the tests again:
-->
<p>Lancez Ã  nouveau les testsÂ :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our test caught the bug! The `it_adds_two` test failed, displaying the message
`` assertion failed: `(left == right)` `` and showing that `left` was `4` and
`right` was `5`. This message is useful and helps us start debugging: it means
the `left` argument to `assert_eq!` was `4` but the `right` argument, where we
had `add_two(2)`, was `5`.
-->
<p>Notre test a dÃ©tectÃ© le bogueÂ ! Le test <code>cela_ajoute_deux</code> a Ã©chouÃ©, ce qui a
affichÃ© le message <code>assertion failed: `(left == right)`</code> qui nous explique
qu'Ã  gauche nous avions <code>4</code> et qu'Ã  droite nous avions <code>5</code>. Ce message utile
nous aide au dÃ©boguageÂ : cela veut dire que l'argument de gauche de <code>assert_eq!</code>
valait <code>4</code> mais que l'argument de droite, oÃ¹ nous avions <code>ajouter_deux(2)</code>,
valait <code>5</code>.</p>
<!--
Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called `expected` and `actual`,
and the order in which we specify the arguments matters. However, in Rust,
theyâ€™re called `left` and `right`, and the order in which we specify the value
we expect and the value that the code under test produces doesnâ€™t matter. We
could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which
would result in a failure message that displays `` assertion failed: `(left ==
right)` `` and that `left` was `5` and `right` was `4`.
-->
<p>Notez que dans certains langages et environnements de test, les paramÃ¨tres des
fonctions qui vÃ©rifient que deux valeurs soient Ã©gales sont appelÃ©s <code>attendu</code> et
<code>effectif</code>, et l'ordre dans lesquels nous renseignons les arguments est
important. Cependant, dans Rust, on les appelle <code>gauche</code> et <code>droite</code>, et l'ordre
dans lesquels nous renseignons la valeur que nous attendons et la valeur que
produit le code Ã  tester n'est pas important. Nous pouvons Ã©crire la
vÃ©rification de ce test dans la forme <code>assert_eq!(ajouter_deux(2), 4)</code>, ce qui
donnera un message d'Ã©chec qui affichera <code>assertion failed: `(left == right)`</code> et que gauche vaudra <code>5</code> et droit vaudra <code>4</code>.</p>
<!--
The `assert_ne!` macro will pass if the two values we give it are not equal and
fail if theyâ€™re equal. This macro is most useful for cases when weâ€™re not sure
what a value *will* be, but we know what the value definitely *wonâ€™t* be if our
code is functioning as we intend. For example, if weâ€™re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.
-->
<p>La macro <code>assert_ne!</code> va rÃ©ussir si les deux valeurs que nous lui donnons ne
sont pas Ã©gales et va Ã©chouer si elles sont Ã©gales. Cette macro est utile dans
les cas oÃ¹ nous ne sommes pas sÃ»r de ce que <em>devrait</em> valoir une valeur, mais
que nous savons ce que la valeur ne devrait surtout <em>pas</em> Ãªtre si notre code
fonctionne comme nous le souhaitons. Par exemple, si nous testons une fonction
qui doit transformer sa valeur d'entrÃ©e de maniÃ¨re Ã  ce qu'elle dÃ©pend du jour
de la semaine oÃ¹ nous lanÃ§ons nos tests, la meilleure faÃ§on de vÃ©rifier serait
que la sortie de la fonction ne soit pas Ã©gale Ã  son entrÃ©e.</p>
<!--
Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators
`==` and `!=`, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the `PartialEq` and `Debug` traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, youâ€™ll need to implement `PartialEq` to assert that values of
those types are equal or not equal. Youâ€™ll need to implement `Debug` to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum
definition. See Appendix C, [â€œDerivable Traits,â€][derivable-traits]<!-- ignore
-- > for more details about these and other derivable traits.
-->
<p>Sous la surface, les macros <code>assert_eq!</code> et <code>assert_ne!</code> utilisent
respectivement les opÃ©rateurs <code>==</code> et <code>!=</code>. Lorsque les vÃ©rifications Ã©chouent,
ces macros affichent leurs arguments en utilisant le formatage de dÃ©boguage, ce
qui veut dire que les valeurs comparÃ©es doivent implÃ©menter les traits
<code>PartialEq</code> et <code>Debug</code>. Tous les types primitifs et la plupart des types de
la bibliothÃ¨que standard implÃ©mentent ces traits. Concernant les structures et
les Ã©numÃ©rations que vous dÃ©finissez, vous allez avoir besoin de leur
implÃ©menter <code>Debug</code> pour afficher les valeurs lorsque les vÃ©rifications
Ã©chouent. Comme ces traits sont des traits dÃ©rivables, comme nous l'avons Ã©voquÃ©
dans l'encart 5-12 du chapitre 5, il suffit gÃ©nÃ©ralement de simplement ajouter
l'annotation <code>#[derive(PartialEq, Debug)]</code> sur les dÃ©finitions de vos structures
ou Ã©numÃ©rations. Rendez-vous Ã  <a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore -->
pour en savoir plus sur ces derniers et les autres traits dÃ©rivables.</p>
<!--
### Adding Custom Failure Messages
-->
<h3 id="ajouter-des-messages-dÃ©chec-personnalisÃ©s"><a class="header" href="#ajouter-des-messages-dÃ©chec-personnalisÃ©s">Ajouter des messages d'Ã©chec personnalisÃ©s</a></h3>
<!--
You can also add a custom message to be printed with the failure message as
optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any
arguments specified after the one required argument to `assert!` or the two
required arguments to `assert_eq!` and `assert_ne!` are passed along to the
`format!` macro (discussed in Chapter 8 in the [â€œConcatenation with the `+`
Operator or the `format!`
Macroâ€][concatenation-with-the--operator-or-the-format-macro]<!-- ignore -- >
section), so you can pass a format string that contains `{}` placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, youâ€™ll have a better idea of what
the problem is with the code.
-->
<p>Vous pouvez aussi ajouter un message personnalisÃ© qui peut Ãªtre affichÃ© avec le
message d'Ã©chec comme un argument optionnel aux macros <code>assert!</code>, <code>assert_eq!</code>,
et <code>assert_ne!</code>. Tous les arguments renseignÃ©s aprÃ¨s celui qui est obligatoire
dans <code>assert!</code> ou les deux arguments obligatoires de <code>assert_eq!</code> et
<code>assert_ne!</code> sont envoyÃ©s Ã  la macro <code>format!</code> (que nous avons vu dans une
section du
<a href="ch08-02-strings.html">chapitre
8</a><!-- ignore -->), ainsi
vous pouvez passer une chaine de caractÃ¨res de formatage qui contient des espaces
rÃ©servÃ©s <code>{}</code> et les valeurs iront dans ces espaces rÃ©servÃ©s. Les messages
personnalisÃ©s sont utiles pour documenter ce que fait une vÃ©rificationÂ ;
lorsqu'un test Ã©choue, vous aurez une idÃ©e plus prÃ©cise du problÃ¨me avec ce
code.</p>
<!--
For example, letâ€™s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:
-->
<p>Par exemple, disons que nous avons une fonction qui accueille les gens par leur
nom et que nous voulons tester que le nom que nous envoyons Ã  la fonction
apparaÃ®t dans le rÃ©sultatÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn accueil(nom: &str) -> String {
    format!("Salut, {}Â !", nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(resultat.contains("Carole"));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn accueil(nom: &amp;str) -&gt; String {
    format!(&quot;Salut, {}Â !&quot;, nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(resultat.contains(&quot;Carole&quot;));
    }
}
</code></pre>
<!--
The requirements for this program havenâ€™t been agreed upon yet, and weâ€™re
pretty sure the `Hello` text at the beginning of the greeting will change. We
decided we donâ€™t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
`greeting` function, weâ€™ll just assert that the output contains the text of the
input parameter.
-->
<p>Les spÃ©cifications de ce programme n'ont pas Ã©tÃ© validÃ©es entiÃ¨rement pour le
moment, et on est quasiment sÃ»r que le texte <code>Salut</code> au dÃ©but va changer. Nous
avons dÃ©cidÃ© que nous ne devrions pas Ã  avoir Ã  changer le test si les
spÃ©cifications changent, donc plutÃ´t que de vÃ©rifier l'Ã©galitÃ© exacte de la
valeur retournÃ©e par la fonction <code>accueil</code>, nous allons uniquement vÃ©rifier que
le rÃ©sultat contient le texte correspondant au paramÃ¨tre d'entrÃ©e de la
fonction.</p>
<!--
Letâ€™s introduce a bug into this code by changing `greeting` to not include
`name` to see what this test failure looks like:
-->
<p>Introduisons un bogue dans ce code en changeant <code>accueil</code> pour ne pas
ajouter <code>nom</code> afin de voir ce que donne l'Ã©chec de ce test :</p>
<!--
```rust,not_desired_behavior,noplayground
pub fn accueil(name: &str) -> String {
    String::from("SalutÂ !")
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn accueil_contient_le_nom() {
#         let resultat = accueil("Carole");
#         assert!(resultat.contains("Carole"));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground">pub fn accueil(name: &amp;str) -&gt; String {
    String::from(&quot;SalutÂ !&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn accueil_contient_le_nom() {
</span><span class="boring">        let resultat = accueil(&quot;Carole&quot;);
</span><span class="boring">        assert!(resultat.contains(&quot;Carole&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Running this test produces the following:
-->
<p>L'exÃ©cution du test va donner ceci :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(\"Carole\")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(\&quot;Carole\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the `greeting` function. Letâ€™s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the `greeting` function:
-->
<p>Ce rÃ©sultat indique simplement que la vÃ©rification a Ã©chouÃ©, et Ã  quel endroit.
Le message d'Ã©chec serait plus utile dans notre cas s'il affichait la valeur
que nous obtenons de la fonction <code>accueil</code>. Changeons la fonction de test, pour
lui donner un message d'erreur personnalisÃ©, qui est une chaÃ®ne de caractÃ¨res
de formatage avec un espace rÃ©servÃ© qui contiendra la valeur que
nous avons obtenue de la fonction <code>accueil</code> :</p>
<!--
```rust,ignore
# pub fn accueil(nom: &str) -> String {
#     String::from("SalutÂ !")
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(
            resultat.contains("Carole"),
            "Le message d'accueil ne contient pas le nom, il vautÂ `{}`",
            resultat
        );
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub fn accueil(nom: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;SalutÂ !&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(
            resultat.contains(&quot;Carole&quot;),
            &quot;Le message d'accueil ne contient pas le nom, il vautÂ `{}`&quot;,
            resultat
        );
    }
<span class="boring">}
</span></code></pre>
<!--
Now when we run the test, weâ€™ll get a more informative error message:
-->
<p>Maintenant, lorsque nous lanÃ§ons Ã  nouveau le test, nous obtenons un message
d'Ã©chec plus explicite :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vautÂ `SalutÂ !`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vautÂ `SalutÂ !`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.
-->
<p>Nous pouvons voir la valeur que nous avons obtenue lors de la lecture du
rÃ©sultat du test, ce qui va nous aider Ã  dÃ©boguer ce qui s'est passÃ© Ã  la
place de ce que nous voulions qu'il se passe.</p>
<!--
### Checking for Panics with `should_panic`
-->
<h3 id="vÃ©rifier-le-fonctionnement-des-paniques-avec-should_panic"><a class="header" href="#vÃ©rifier-le-fonctionnement-des-paniques-avec-should_panic">VÃ©rifier le fonctionnement des paniques avec <code>should_panic</code></a></h3>
<!--
In addition to checking that our code returns the correct values we expect,
itâ€™s also important to check that our code handles error conditions as we
expect. For example, consider the `Guess` type that we created in Chapter 9,
Listing 9-13. Other code that uses `Guess` depends on the guarantee that `Guess`
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a `Guess` instance with a value outside that
range panics.
-->
<p>En plus de vÃ©rifier que notre code retourne bien les valeurs que nous
souhaitons, il est aussi important de vÃ©rifier que notre code gÃ¨re bien les cas
d'erreurs comme nous le souhaitons. Par exemple, utilisons le type <code>Supposition</code>
que nous avons crÃ©Ã© au chapitre 9, dans l'encart 9-13. Les autres codes qui
utilisent <code>Supposition</code> reposent sur la garantie que les instances de
<code>Supposition</code> contiennent uniquement des valeurs entre 1 et 100. Nous pouvons
Ã©crire un test qui s'assure que la crÃ©ation d'une instance de <code>Supposition</code>
avec une valeur en dehors de cette intervalle va faire paniquer le programme.</p>
<!--
We do this by adding another attribute, `should_panic`, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesnâ€™t panic.
-->
<p>Nous allons vÃ©rifier cela en ajoutant un autre attribut, <code>should_panic</code>, Ã  notre
fonction de test. Cet attribut fait rÃ©ussir le test si le code Ã  l'intÃ©rieur
de la fonction fait paniquer ; le test va Ã©chouer si le code Ã  l'intÃ©rieur de
la fonction ne panique pas.</p>
<!--
Listing 11-8 shows a test that checks that the error conditions of `Guess::new`
happen when we expect them to.
-->
<p>L'encart 11-8 nous montre un test qui vÃ©rifie que les conditions d'erreur de
<code>Supposition::new</code> fonctionne bien comme nous l'avons prÃ©vu.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
```
-->
<pre><code class="language-rust noplayground">pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-8: Testing that a condition will cause a
`panic!`</span>
-->
<p><span class="caption">Encart 11-8 : tester qu'une condition va faire un <code>panic</code>
</span></p>
<!--
We place the `#[should_panic]` attribute after the `#[test]` attribute and
before the test function it applies to. Letâ€™s look at the result when this test
passes:
-->
<p>Nous plaÃ§ons l'attribut <code>#[should_panic]</code> aprÃ¨s l'attribut <code>#[test]</code> et avant
la fonction de test sur laquelle il s'applique. Voyons le rÃ©sultat lorsque ce
test rÃ©ussit :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Looks good! Now letâ€™s introduce a bug in our code by removing the condition
that the `new` function will panic if the value is greater than 100:
-->
<p>Ca fonctionne ! Maintenant, ajoutons un bogue dans notre code en enlevant
la condition dans laquelle la fonction <code>new</code> panique lorsque la valeur est
plus grande que 100 :</p>
<!--
```rust,not_desired_behavior,noplayground
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
When we run the test in Listing 11-8, it will fail:
-->
<p>Lorsque nous lanÃ§ons le test de l'encart 11-8, il va Ã©chouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We donâ€™t get a very helpful message in this case, but when we look at the test
function, we see that itâ€™s annotated with `#[should_panic]`. The failure we got
means that the code in the test function did not cause a panic.
-->
<p>Dans ce cas, nous n'obtenons pas de message trÃ¨s utile, mais lorsque nous
regardons la fonction de test, nous constatons qu'elle est marquÃ©e avec
<code>#[should_panic]</code>. L'Ã©chec que nous obtenons signifie que le code dans la
fonction de test n'a pas fait paniquer.</p>
<!--
Tests that use `should_panic` can be imprecise because they only indicate that
the code has caused some panic. A `should_panic` test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make `should_panic` tests more precise, we can add an optional `expected`
parameter to the `should_panic` attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for `Guess` in Listing 11-9 where the `new` function panics with
different messages depending on whether the value is too small or too large.
-->
<p>Les tests qui utilisent <code>should_panic</code> ne sont parfois pas assez explicites car
ils indiquent seulement que le code a paniquÃ©. Un test <code>should_panic</code> peut
rÃ©ussir, mÃªme si le test panique pour une raison diffÃ©rente Ã  celle que nous
attendions. Pour rendre les tests <code>should_panic</code> plus prÃ©cis, nous pouvons
ajouter un paramÃ¨tre optionnel <code>expected</code> Ã  l'attribut <code>should_panic</code>. Le
systÃ¨me de test va s'assurer que le message d'Ã©chec contient bien le texte
renseignÃ©. Par exemple, imaginons le code modifiÃ© de <code>Supposition</code> dans
l'encart 11-9 oÃ¹ la fonction <code>new</code> panique avec des messages diffÃ©rents si la
valeur est trop petite ou trop grande.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.",
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100")]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.&quot;,
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100&quot;)]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-9: Testing that a condition will cause a
`panic!` with a particular panic message</span>
-->
<p><span class="caption">Encart 11-9 : on vÃ©rifie qu'une situation va provoquer un
<code>panic!</code> avec un message de panique bien prÃ©cis</span></p>
<!--
This test will pass because the value we put in the `should_panic` attributeâ€™s
`expected` parameter is a substring of the message that the `Guess::new`
function panics with. We could have specified the entire panic message that we
expect, which in this case would be `Guess value must be less than or equal to
100, got 200.` What you choose to specify in the expected parameter for
`should_panic` depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the `else if value > 100` case.
-->
<p>Ce test va rÃ©ussir car la valeur que nous insÃ©rons dans l'attribut <code>expected</code>
de <code>should_panic</code> est une partie du message de panique de la fonction
<code>Supposition::new</code>. Nous aurions pu renseigner le message de panique en entier
que nous attendions, qui dans ce cas est <code>La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons 200.</code>. Ce que vous choisissez de renseigner dans
le paramÃ¨tre <code>expected</code> de <code>should_panic</code> dÃ©pend de la mesure dans laquelle le
message de panique est unique ou dynamique et de la prÃ©cision de votre test que
vous souhaitez appliquer. Dans ce cas, un extrait du message de panique est
suffisant pour s'assurer que le code de la fonction de test s'exÃ©cute dans le
cas du <code>else if valeur &gt; 100</code>.</p>
<!--
To see what happens when a `should_panic` test with an `expected` message
fails, letâ€™s again introduce a bug into our code by swapping the bodies of the
`if value < 1` and the `else if value > 100` blocks:
-->
<p>Pour voir ce qui se passe lorsqu'un test <code>should_panic</code> qui a un message
<code>expected</code> qui Ã©choue, essayons Ã  nouveau d'introduire un bogue dans notre code
en permutant les corps des blocs de <code>if valeur &lt; 1</code> et de
<code>else if valeur &gt; 100</code> :</p>
<!--
```rust,ignore,not_desired_behavior
# pub struct Supposition {
#     valeur: i32,
# }
# 
# impl Supposition {
#     pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.",
                valeur
            );
        }
# 
#         Supposition { valeur }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic(expected = "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100")]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Supposition {
</span><span class="boring">    pub fn new(valeur: i32) -&gt; Supposition {
</span>        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.&quot;,
                valeur
            );
        }
<span class="boring">
</span><span class="boring">        Supposition { valeur }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100&quot;)]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This time when we run the `should_panic` test, it will fail:
-->
<p>Cette fois, lorsque nous lanÃ§ons le test avec <code>should_panic</code>, il devrait
Ã©chouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200."`,
 expected substring: `"La supposition doit Ãªtre plus petite ou Ã©gale Ã  100"`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.&quot;`,
 expected substring: `&quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100&quot;`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string `'Guess value must be
less than or equal to 100'`. The panic message that we did get in this case was
`Guess value must be greater than or equal to 1, got 200.` Now we can start
figuring out where our bug is!
-->
<p>Le message d'Ã©chec nous informe que ce test a paniquÃ© comme prÃ©vu, mais que le
message de panique n'inclus pas la chaÃ®ne de caractÃ¨res prÃ©vue <code>'La supposition doit Ãªtre plus petite ou Ã©gale Ã  100'</code>. Le message de panique que nous avons
obtenu dans ce cas Ã©tait <code>La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.</code>. Maintenant, on comprend mieux oÃ¹ est le bogue !</p>
<!--
### Using `Result<T, E>` in Tests
-->
<h3 id="utiliser-resultt-e-dans-les-tests"><a class="header" href="#utiliser-resultt-e-dans-les-tests">Utiliser <code>Result&lt;T, E&gt;</code> dans les tests</a></h3>
<!--
So far, weâ€™ve written tests that panic when they fail. We can also write tests
that use `Result<T, E>`! Hereâ€™s the test from Listing 11-1, rewritten to use
`Result<T, E>` and return an `Err` instead of panicking:
-->
<p>PrÃ©cÃ©demment, nous avons Ã©crit des tests qui paniquent lorsqu'ils Ã©chouent.
Nous pouvons Ã©galement Ã©crire des tests qui utilisent <code>Result&lt;T, E&gt;</code> ! Voici
le test de l'encart 11-1, rÃ©Ã©cris pour utiliser <code>Result&lt;T, E&gt;</code> et retourner
une <code>Err</code> au lieu de paniquer :</p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("deux plus deux ne vaut pas quatre"))
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;deux plus deux ne vaut pas quatre&quot;))
        }
    }
}
</code></pre>
<!--
The `it_works` function now has a return type, `Result<(), String>`. In the
body of the function, rather than calling the `assert_eq!` macro, we return
`Ok(())` when the test passes and an `Err` with a `String` inside when the test
fails.
-->
<p>La fonction <code>it_works</code> a maintenant un type de retour, <code>Result&lt;(), String&gt;</code>.
Dans le corps de la fonction, plutÃ´t que d'appeler la macro <code>assert_eq!</code>, nous
retournons <code>Ok(())</code> lorsque le test rÃ©ussit et une <code>Err</code> avec une <code>String</code> Ã 
l'intÃ©rieur lorsque le test Ã©choue.</p>
<!--
Writing tests so they return a `Result<T, E>` enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an `Err` variant.
-->
<p>Ecrire vos tests afin qu'ils retournent un <code>Result&lt;T, E&gt;</code> vous permet
d'utiliser l'opÃ©rateur <em>point d'interrogation</em> dans le corps des tests, ce
qui est un outil facile Ã  utiliser pour Ã©crire des tests qui peuvent Ã©chouer
si n'importe quelle opÃ©ration en son sein retourne une variante de <code>Err</code>.</p>
<!--
You canâ€™t use the `#[should_panic]` annotation on tests that use `Result<T,
E>`. Instead, you should return an `Err` value directly when the test should
fail.
-->
<p>Vous ne pouvez pas utiliser l'annotation <code>#[should_panic]</code> sur les tests qui
utilisent <code>Result&lt;T, E&gt;</code>. Mais Ã  la place, vous devez retourner directement
une valeur <code>Err</code> lorsque le test Ã©choue.</p>
<!--
Now that you know several ways to write tests, letâ€™s look at what is happening
when we run our tests and explore the different options we can use with `cargo
test`.
-->
<p>Maintenant que vous avez appris diffÃ©rentes maniÃ¨res d'Ã©crire des tests, voyons
ce qui se passe lorsque nous lanÃ§ons nos tests et explorons les diffÃ©rentes
options que nous pouvons utiliser avec <code>cargo test</code>.</p>
<!--
[concatenation-with-the--operator-or-the-format-macro]:
ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro
[controlling-how-tests-are-run]:
ch11-02-running-tests.html#controlling-how-tests-are-run
[derivable-traits]: appendix-03-derivable-traits.html
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
