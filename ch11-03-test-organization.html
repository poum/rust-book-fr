<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ L&#x27;organisation des tests - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html" class="active"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/128">Pull Request</a>.</p>
</blockquote>
<!--
## Test Organization
-->
<h2 id="lorganisation-des-tests"><a class="header" href="#lorganisation-des-tests">L'organisation des tests</a></h2>
<!--
As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: *unit tests* and
*integration tests*. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.
-->
<p>Comme nous l'avons Ã©voquÃ© au dÃ©but du chapitre, le test est une discipline
complexe, et diffÃ©rentes personnes utilisent des terminologies et organisations
diffÃ©rentes. La communautÃ© Rust a conÃ§u les tests dans deux catÃ©gories
principalesÂ : <em>les tests unitaires</em> et <em>les tests d'intÃ©gration</em>. Les tests
unitaires sont petits et plus prÃ©cis, et tester un module isolÃ© Ã  la fois, et
peuvent tester les interfaces privÃ©es. Les tests d'intÃ©gration sont uniquement
externes Ã  notre bibliothÃ¨que et consomme notre code exactement de la mÃªme
maniÃ¨re que tout autre code externe le ferait, en utilisant uniquement
l'interface publique et Ã©ventuellement en utilisant plusieurs modules dans un
test.</p>
<!--
Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.
-->
<p>L'Ã©criture de ces deux types de tests est importante pour s'assurer que chaque
Ã©lÃ©ment de notre bibliothÃ¨que fait bien ce que vous attendiez d'eux, de
maniÃ¨re isolÃ©e et conjuguÃ©e avec d'autres.</p>
<!--
### Unit Tests
-->
<h3 id="les-tests-unitaires"><a class="header" href="#les-tests-unitaires">Les tests unitaires</a></h3>
<!--
The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isnâ€™t working as
expected. Youâ€™ll put unit tests in the *src* directory in each file with the
code that theyâ€™re testing. The convention is to create a module named `tests`
in each file to contain the test functions and to annotate the module with
`cfg(test)`.
-->
<p>Le but des tests unitaires est de tester chaque Ã©lÃ©ment du code de maniÃ¨re
sÃ©parÃ©e du reste du code pour identifier rapidement oÃ¹ le code fonctionne
fonctionne ou non comme prÃ©vu. Vous devriez insÃ©rer les tests unitaires dans le
dossier <em>src</em> de chaque fichier, Ã  cÃ´tÃ© du code qu'ils testent. La convention
est de crÃ©er un module <code>tests</code> dans chaque fichier qui contient les fonctions
de test et de marquer le module avec <code>cfg(test)</code>.</p>
<!--
#### The Tests Module and `#[cfg(test)]`
-->
<h4 id="les-modules-de-tests-et-cfgtest"><a class="header" href="#les-modules-de-tests-et-cfgtest">Les modules de tests et <code>#[cfg(test)]</code></a></h4>
<!--
The `#[cfg(test)]` annotation on the tests module tells Rust to compile and run
the test code only when you run `cargo test`, not when you run `cargo build`.
This saves compile time when you only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. Youâ€™ll
see that because integration tests go in a different directory, they donâ€™t need
the `#[cfg(test)]` annotation. However, because unit tests go in the same files
as the code, youâ€™ll use `#[cfg(test)]` to specify that they shouldnâ€™t be
included in the compiled result.
-->
<p>L'annotation <code>#[cfg(test)]</code> sur les modules de tests indiquent Ã  Rust de
compiler et d'exÃ©cuter le code de test seulement lorsque vous lancez
<code>cargo test</code>, et non pas lorsque vous lancez <code>cargo build</code>. Cela diminue la
durÃ©e de compilation lorsque vous souhaitez uniquement compiler la bibliothÃ¨que
et cela rÃ©duit la taille dans l'artefact compilÃ© qui en rÃ©sulte car les tests
n'y sont pas intÃ©grÃ©s. Vous verrez plus tard que comme les tests d'intÃ©gration
se placent dans un rÃ©pertoire diffÃ©rent, ils n'ont pas besoin de l'annotation
<code>#[cfg(test)]</code>. Cependant, comme les tests unitaires vont dans les mÃªmes
fichiers que le code, vous devriez utiliser <code>#[cfg(test)]</code> pour marquer qu'ils
ne devraient pas Ãªtre inclus dans les rÃ©sultats de compilation.</p>
<!--
Recall that when we generated the new `adder` project in the first section of
this chapter, Cargo generated this code for us:
-->
<p>Souvenez-vous, lorsque nous avons gÃ©nÃ©rÃ© le nouveau projet <code>addition</code> dans la
premiÃ¨re section de ce chapitre, Cargo a gÃ©nÃ©rÃ© ce code pour nousÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
This code is the automatically generated test module. The attribute `cfg`
stands for *configuration* and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is `test`, which is provided by Rust for compiling and
running tests. By using the `cfg` attribute, Cargo compiles our test code only
if we actively run the tests with `cargo test`. This includes any helper
functions that might be within this module, in addition to the functions
annotated with `#[test]`.
-->
<p>Ce code est le module de test gÃ©nÃ©rÃ© automatiquement. L'attribut <code>cfg</code> est
l'abrÃ©viation de <em>configuration</em> et indique Ã  rust que l'Ã©lÃ©ment suivant ne
doit Ãªtre intÃ©grÃ© que dans une certaine option de configuration donnÃ©e. Dans
ce cas, l'option de configuration est <code>test</code>, qui est fourni par Rust pour la
compilation et l'exÃ©cution des tests. En utilisant l'attribut <code>cfg</code>, Cargo
compile notre code de tests uniquement si nous avons exÃ©cutÃ© les tests avec
<code>cargo test</code>. Cela inclut toutes les fonctions auxiliaires qui pourraient se
trouver dans ce module, en plus des fonctions marquÃ©es d'un <code>#[test]</code>.</p>
<!--
#### Testing Private Functions
-->
<h4 id="tester-des-fonctions-privÃ©es"><a class="header" href="#tester-des-fonctions-privÃ©es">Tester des fonctions privÃ©es</a></h4>
<!--
Thereâ€™s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rustâ€™s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function `internal_adder`.
-->
<p>Il existe un dÃ©bat dans communautÃ© des testeurs au sujet de la nÃ©cessitÃ© ou non
de tester directement les fonctions privÃ©es, et d'autres langages rendent
difficile, voir impossible, de tester les fonctions privÃ©es. Quelle que soit
votre approche des tests, les rÃ¨gles de protection de Rust vous permettent de
tester des fonctions privÃ©es. Imaginons le code de l'encart 11-12 qui contient
la fonction privÃ©e <code>addition_interne</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub fn ajouter_deux(a: i32) -> i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub fn ajouter_deux(a: i32) -&gt; i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-12: Testing a private function</span>
-->
<p><span class="caption">Encart 11-12Â : test d'une fonction privÃ©e</span></p>
<!--
Note that the `internal_adder` function is not marked as `pub`, but because
tests are just Rust code and the `tests` module is just another module, you can
bring `internal_adder` into a testâ€™s scope and call it. If you donâ€™t think
private functions should be tested, thereâ€™s nothing in Rust that will compel
you to do so.
-->
<p>Remarquez que la fonction <code>addition_interne</code> n'est pas marquÃ©e comme <code>pub</code>, car
comme les tests sont uniquement du code Rust et que le module <code>test</code> est
simplement un autre module, vous pouvez importer <code>addition_interne</code> dans la
portÃ©e des tests et l'utiliser. Si vous pensez qu'une fonction privÃ©e ne doit
pas Ãªtre testÃ©e, il n'y a rien qui vous y force avec Rust.</p>
<!--
### Integration Tests
-->
<h3 id="les-tests-dintÃ©gration"><a class="header" href="#les-tests-dintÃ©gration">Les tests d'intÃ©gration</a></h3>
<!--
In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your libraryâ€™s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a *tests* directory.
-->
<p>En Rust, les tests d'intÃ©gration sont exclusivement externes Ã  votre
bibliothÃ¨que. Ils consomment votre bibliothÃ¨que de la mÃªme maniÃ¨re que n'importe
quel autre code, ce qui signifie qu'ils ne peuvent appeler uniquement les
fonctions qui font partie de l'interface de programmation applicative (API)
publique de votre bibliothÃ¨que. Leur but est de tester si les multiples parties
de votre bibliothÃ¨que fonctionnent correctement ensemble. Les portions de code
qui fonctionnent bien toutes seules pourraient rencontrer des problÃ¨mes une fois
imbriquÃ©es avec d'autres, donc les tests qui couvrent l'intÃ©gration du code est
aussi important. Pour crÃ©er des tests d'intÃ©gration, vous avez d'abord besoin
d'un dossier <em>tests</em>.</p>
<!--
#### The *tests* Directory
-->
<h4 id="le-dossier-tests"><a class="header" href="#le-dossier-tests">Le dossier <em>tests</em></a></h4>
<!--
We create a *tests* directory at the top level of our project directory, next
to *src*. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.
-->
<p>Nous crÃ©ons un dossier <em>tests</em> au niveau le plus haut de notre dossier de
projet, juste Ã  cÃ´tÃ© de <em>src</em>. Cargo sait qu'il doit rechercher les fichiers de
test d'intÃ©gration dans ce dossier. Nous pouvons ensuite construire autant de
fichiers de test que nous souhaitons dans ce dossier, et Cargo va compiler
chacun des fichiers comme une crate individuelle.</p>
<!--
Letâ€™s create an integration test. With the code in Listing 11-12 still in the
*src/lib.rs* file, make a *tests* directory, create a new file named
*tests/integration_test.rs*, and enter the code in Listing 11-13.
-->
<p>CommenÃ§ons Ã  crÃ©er un test d'intÃ©gration. Avec le code de l'encart 11-12
toujours prÃ©sent dans le fichier <em>src/lib.rs</em>, crÃ©ons un dossier <em>tests</em>, puis
un nouveau fichier <em>tests/test_integration.rs</em>, et insÃ©rez-y le code de l'encart
11-13.</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">FichierÂ : tests/test_integration.rs</span></p>
<!--
```rust,ignore
use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
<span class="caption">Listing 11-13: An integration test of a function in the
`adder` crate</span>
-->
<p><span class="caption">Encart 11-13Â : un test d'intÃ©gration d'une fonction
prÃ©sente dans la crate <code>addition</code></span></p>
<!--
Weâ€™ve added `use adder` at the top of the code, which we didnâ€™t need in the
unit tests. The reason is that each file in the `tests` directory is a separate
crate, so we need to bring our library into each test crateâ€™s scope.
-->
<p>Nous avons ajoutÃ© <code>use addition</code> en haut du code, ce que nous n'avions pas
besoin de faire dans les tests unitaires. La raison Ã  cela est que chaque
fichier dans le dossier <code>tests</code> est une crate sÃ©parÃ©e, donc nous devons importer
notre bibliothÃ¨que dans la portÃ©e de chaque crate de test.</p>
<!--
We donâ€™t need to annotate any code in *tests/integration_test.rs* with
`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files
in this directory only when we run `cargo test`. Run `cargo test` now:
-->
<p>Nous n'avons pas besoin de marquer du code avec <code>#[cfg(test)]</code> dans
<em>tests/test_integration.rs</em>. Cargo traite le dossier <code>tests</code> de maniÃ¨re
particuliÃ¨re et compile les fichiers prÃ©sents dans ce dossier uniquement si nous
lanÃ§ons <code>cargo test</code>. Lancez dÃ¨s maintenant <code>cargo test</code>Â :</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as weâ€™ve been
seeing: one line for each unit test (one named `internal` that we added in
Listing 11-12) and then a summary line for the unit tests.
-->
<p>Les trois sections de la sortie concernent les tests unitaires, les tests
d'intÃ©gration, et les tests de documentation. La premiÃ¨re section Ã  propos des
tests unitaires est la mÃªme que nous avons dÃ©jÃ  vuÂ : une ligne pour chaque test
unitaire (celui qui s'appelle <code>interne</code> que nous avons insÃ©rÃ© dans l'encart
11-12) et ensuite une ligne de rÃ©sumÃ© des tests unitaires.</p>
<!--
The integration tests section starts with the line `Running
target/debug/deps/integration_test-ce99bcc2479f4607` (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the `Doc-tests adder` section starts.
-->
<p>La section des tests d'intÃ©gration commence avec la ligne <code>Running target/debug/deps/test_integration-ce99bcc2479f4607</code> (le hachage Ã  la fin de
votre sortie pourrait Ãªtre diffÃ©rent). Ensuite, il y a une ligne pour chaque
fonction de test prÃ©sente dans ce test d'intÃ©gration et une ligne de rÃ©sumÃ© pour
les rÃ©sultats des tests d'intÃ©gration, juste avant que la section
<code>Doc-tests addition</code> commence.</p>
<!--
Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test fileâ€™s section. Each
integration test file has its own section, so if we add more files in the
*tests* directory, there will be more integration test sections.
-->
<p>De la mÃªme faÃ§on que plus vous ajoutez de fonctions de tests unitaires et plus
vous avez des lignes de rÃ©sultats dans la section des tests unitaires, plus
vous ajoutez des fonctions de tests aux fichiers de tests d'intÃ©gration et plus
vous aurez des lignes de rÃ©sultat Ã  cette section correspondante aux fichiers
de test d'intÃ©gration. Chaque fichier de test d'intÃ©gration a sa propre section,
donc si nous ajoutons plus de fichiers dans le dossier <em>tests</em>, il y aura plus
de sections de tests d'intÃ©gration.</p>
<!--
We can still run a particular integration test function by specifying the test
functionâ€™s name as an argument to `cargo test`. To run all the tests in a
particular integration test file, use the `--test` argument of `cargo test`
followed by the name of the file:
-->
<p>Nous pouvons aussi exÃ©cuter une fonction de test d'intÃ©gration prÃ©cise en
utilisant le nom de la fonction de test comme argument Ã  <code>cargo test</code>. Pour
exÃ©cuter tous les tests d'un fichier de tests d'intÃ©gration prÃ©cis, utilisez
l'argument <code>--test</code> de <code>cargo test</code> suivi du nom du fichierÂ :</p>
<!--
```console
$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
This command runs only the tests in the *tests/integration_test.rs* file.
-->
<p>Cette commande exÃ©cute seulement les tests dans le fichier
<em>tests/test_integration.rs</em>.</p>
<!--
#### Submodules in Integration Tests
-->
<h4 id="les-sous-modules-des-tests-dintÃ©gration"><a class="header" href="#les-sous-modules-des-tests-dintÃ©gration">Les sous-modules des tests d'intÃ©gration</a></h4>
<!--
As you add more integration tests, you might want to make more than one file in
the *tests* directory to help organize them; for example, you can group the
test functions by the functionality theyâ€™re testing. As mentioned earlier, each
file in the *tests* directory is compiled as its own separate crate.
-->
<p>Au fur et Ã  mesure que vous ajouterez des tests d'intÃ©gration, vous pourriez
avoir besoin de les diviser en plusieurs fichiers dans le dossier <em>tests</em> pour
vous aider Ã  les organiserÂ ; par exemple, vous pouvez regrouper les fonctions
de test par fonctionnalitÃ©s qu'elles testent. Comme mentionnÃ© prÃ©cÃ©demment,
chaque fichier dans le dossier <em>tests</em> est compilÃ© comme Ã©tant sa propre crate
sÃ©parÃ©e de tous les autres.</p>
<!--
Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the *tests* directory donâ€™t share the same
behavior as files in *src* do, as you learned in Chapter 7 regarding how to
separate code into modules and files.
-->
<p>Le fait que chaque fichier de test d'intÃ©gration soit sa propre crate est utile
pour crÃ©er des portÃ©es sÃ©parÃ©es qui ressemblent Ã  la maniÃ¨re dont les
dÃ©veloppeurs vont consommer votre crate. Cependant, cela veut aussi dire que
les fichiers dans le dossier <em>tests</em> n'ont pas le mÃªme comportement que le
ferraient les fichiers dans <em>src</em>, comme vous l'avez appris au chapitre 7 Ã 
propos de la maniÃ¨re de sÃ©parer le code dans des modules et des fichiers.</p>
<!--
The different behavior of files in the *tests* directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the [â€œSeparating
Modules into Different Filesâ€][separating-modules-into-files]<!-- ignore -- >
section of Chapter 7 to extract them into a common module. For example, if we
create *tests/common.rs* and place a function named `setup` in it, we can add
some code to `setup` that we want to call from multiple test functions in
multiple test files:
-->
<p>Ce comportement diffÃ©rent des fichiers dans le dossier <em>tests</em> est encore plus
remarquable lorsque vous avez un jeu de fonctions d'aide qui s'avÃ¨rent utiles
pour plusieurs fichiers de test d'intÃ©gration et que vous essayez de suivre les
Ã©tapes de la section <a href="ch07-05-separating-modules-into-different-files.html">â€œSÃ©parer les modules dans diffÃ©rents
fichiersâ€</a><!-- ignore --> du chapitre 7 afin de
les extraire dans un module en commun. Par exemple, si nous crÃ©ons
<em>tests/commun.rs</em> et que nous y plaÃ§ons une fonction <code>parametrage</code> Ã 
l'intÃ©rieur, nous pourrions ajouter du code Ã  <code>parametrage</code> que nous voudrions
appeler Ã  partir de diffÃ©rentes fonctions de test dans diffÃ©rents fichiers de
testÂ :</p>
<!--
<span class="filename">Filename: tests/common.rs</span>
-->
<p><span class="filename">FichierÂ : tests/commun.rs</span></p>
<!--
```rust
pub fn parametrage() {
    // code de paramÃ©trage spÃ©cifique Ã  vos tests de votre bibliothÃ¨que ici
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parametrage() {
    // code de paramÃ©trage spÃ©cifique Ã  vos tests de votre bibliothÃ¨que ici
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parametrage() {
    // code de paramÃ©trage spÃ©cifique Ã  vos tests de votre bibliothÃ¨que ici
}
<span class="boring">}
</span></code></pre></pre>
<!--
When we run the tests again, weâ€™ll see a new section in the test output for the
*common.rs* file, even though this file doesnâ€™t contain any test functions nor
did we call the `setup` function from anywhere:
-->
<p>Lorsque nous lanÃ§ons les tests Ã  nouveau, nous allons voir une nouvelle section
dans la sortie des tests, correspondant au fichier <em>commun.rs</em>, mÃªme si ce
fichier ne contient aucune fonction de test et que nous n'avons utilisÃ© nulle
part la fonction <code>parametrage</code>Â :</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Having `common` appear in the test results with `running 0 tests` displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.
-->
<p>Nous ne voulons pas que <code>commun</code> apparaisse dans les rÃ©sultats, ni que cela
affiche <code>running 0 tests</code>. Nous voulons juste partager du code avec les autres
fichiers de test d'intÃ©gration.</p>
<!--
To avoid having `common` appear in the test output, instead of creating
*tests/common.rs*, weâ€™ll create *tests/common/mod.rs*. This is an alternate
naming convention that Rust also understands. Naming the file this way tells
Rust not to treat the `common` module as an integration test file. When we move
the `setup` function code into *tests/common/mod.rs* and delete the
*tests/common.rs* file, the section in the test output will no longer appear.
Files in subdirectories of the *tests* directory donâ€™t get compiled as separate
crates or have sections in the test output.
-->
<p>Pour Ã©viter que <code>commun</code> s'affiche sur la sortie de test, au lieu de crÃ©er le
fichier <em>tests/commun.rs</em>, nous allons crÃ©er <em>tests/commun/mod.rs</em>. Cela est
une convention de nommage alternative que Rust comprends aussi. Nommer le
fichier ainsi indique Ã  Rust de ne pas traiter le module <code>commun</code> comme un
fichier de test d'intÃ©gration. Lorsque nous dÃ©plaÃ§ons le code de la fonction
<code>parametrage</code> dans <em>tests/commun/mod.rs</em> et que nous supprimons le fichier
<em>tests/commun.rs</em>, la section dans la sortie des tests ne va plus s'afficher.
Les fichiers dans les sous-rÃ©pertoires du dossier <em>tests</em> ne seront pas
compilÃ©s comme Ã©tant une crate sÃ©parÃ©e et n'auront pas de sections dans la
sortie des tests.</p>
<!--
After weâ€™ve created *tests/common/mod.rs*, we can use it from any of the
integration test files as a module. Hereâ€™s an example of calling the `setup`
function from the `it_adds_two` test in *tests/integration_test.rs*:
-->
<p>AprÃ¨s avoir crÃ©Ã© <em>tests/commun/mod.rs</em>, nous pouvons l'utiliser Ã  partir de
n'importe quel fichier de test d'intÃ©gration comme un module. Voici un
exemple d'appel Ã  la fonction <code>parametrage</code> Ã  partir du test
<code>cela_ajoute_deux</code> dans <em>tests/test_integration.rs</em>Â :</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">FichierÂ : tests/integration_test.rs</span></p>
<!--
```rust,ignore
use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
Note that the `mod common;` declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then in the test function, we can call the
`common::setup()` function.
-->
<p>Remarquez que la dÃ©claration <code>mod commun;</code> est la mÃªme que la dÃ©claration d'un
module que nous avons dÃ©montrÃ© dans l'encart 7-21. Ensuite, dans la fonction
de tests, nous pouvons appeler la fonction <code>commun::parametrage</code>.</p>
<!--
#### Integration Tests for Binary Crates
-->
<h4 id="tests-dintÃ©gration-pour-les-crates-binaires"><a class="header" href="#tests-dintÃ©gration-pour-les-crates-binaires">Tests d'intÃ©gration pour les crates binaires</a></h4>
<!--
If our project is a binary crate that only contains a *src/main.rs* file and
doesnâ€™t have a *src/lib.rs* file, we canâ€™t create integration tests in the
*tests* directory and bring functions defined in the *src/main.rs* file into
scope with a `use` statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.
-->
<p>Si notre projet est une crate binaire qui contient uniquement un fichier
<em>src/main.rs</em> et n'a pas de fichier <em>src/lib.rs</em>, nous ne pouvons pas crÃ©er
de tests d'intÃ©gration dans le dossier <em>tests</em> et importer les fonctions
dÃ©finies dans le fichier <em>src/main.rs</em> dans notre portÃ©e avec une instruction
<code>use</code>. Seules les crates de bibliothÃ¨que exposent des fonctions que les autres
crates peuvent utiliserÂ ; les crates binaires sont conÃ§ues pour Ãªtre exÃ©cutÃ©es
de maniÃ¨re isolÃ©e.</p>
<!--
This is one of the reasons Rust projects that provide a binary have a
straightforward *src/main.rs* file that calls logic that lives in the
*src/lib.rs* file. Using that structure, integration tests *can* test the
library crate with `use` to make the important functionality available.
If the important functionality works, the small amount of code in the
*src/main.rs* file will work as well, and that small amount of code doesnâ€™t
need to be tested.
-->
<p>C'est une des raisons pour lesquelles les projets Rust qui fournissent un
binaire ont un simple fichier <em>src/main.rs</em> qui fait appel Ã  la logique
prÃ©sente dans le fichier <em>src/lib.rs</em>. En utilisant cette structure, les tests
d'intÃ©gration <em>peuvent</em> tester la crate de bibliothÃ¨que avec le <code>use</code> pour
importer les importantes fonctionnalitÃ©s disponibles. Si les fonctionnalitÃ©s
importantes fonctionnent, la petite portion de code dans le fichier
<em>src/main.rs</em> va fonctionner, et cette petite partie de code n'a pas besoin
d'Ãªtre testÃ©e.</p>
<!--
## Summary
-->
<h2 id="rÃ©sumÃ©"><a class="header" href="#rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
Rustâ€™s testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the libraryâ€™s public API to test the code
in the same way external code will use it. Even though Rustâ€™s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.
-->
<p>Les fonctionnalitÃ©s de test de Rust permettent de spÃ©cifier comment le code
doit fonctionner pour garantir qu'il va continuer Ã  fonctionner comme vous le
souhaitez, mÃªme si vous faites des changements. Les tests unitaires permettent
de tester sÃ©parÃ©ment diffÃ©rentes parties d'une bibliothÃ¨que et peuvent tester
l'implÃ©mentation des Ã©lÃ©ments privÃ©s. Les tests d'intÃ©gration vÃ©rifient que de
nombreuses parties de la bibliothÃ¨que fonctionnent correctement ensemble, et
ils utilisent l'API publique de la bibliothÃ¨que pour tester le code, de la mÃªme
maniÃ¨re  que le ferait du code externe qui l'utiliserait. MÃªme si le systÃ¨me de
type de Rust et les rÃ¨gles de possession aident Ã  prÃ©venir certains types de
bogues, les tests restent toujours importants pour rÃ©duire les bogues de
logique concernant le comportement attendu de votre code.</p>
<!--
Letâ€™s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!
-->
<p>Et maintenant, combinons le savoir que vous avez accumulÃ© dans ce chapitre et
dans les chapitres prÃ©cÃ©dents en travaillant sur un nouveau projetÂ !</p>
<!--
[separating-modules-into-files]:
ch07-05-separating-modules-into-different-files.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch11-02-running-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch12-00-an-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch11-02-running-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch12-00-an-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
