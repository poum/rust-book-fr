<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html" class="active"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/137">Pull Request</a>.</p>
</blockquote>
<!--
## Refactoring to Improve Modularity and Error Handling
-->
<h2 id="remanier-le-code-pour-amÃ©liorer-sa-modularitÃ©-et-la-gestion-des-erreurs"><a class="header" href="#remanier-le-code-pour-amÃ©liorer-sa-modularitÃ©-et-la-gestion-des-erreurs">Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></h2>
<!--
To improve our program, weâ€™ll fix four problems that have to do with the
programâ€™s structure and how itâ€™s handling potential errors.
-->
<p>Pour amÃ©liorer notre programme, nous allons rÃ©soudre quatre problÃ¨mes liÃ©s
Ã  la structure du programme et comment il gÃ¨re de potentielles erreurs.</p>
<!--
First, our `main` function now performs two tasks: it parses arguments and
reads files. For such a small function, this isnâ€™t a major problem. However, if
we continue to grow our program inside `main`, the number of separate tasks the
`main` function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. Itâ€™s best to separate functionality so each
function is responsible for one task.
-->
<p>PremiÃ¨rement, notre fonction <code>main</code> assure deux tÃ¢chesÂ : elle interprÃ¨te les
arguments et elle lit des fichiers. Pour une fonction aussi petite, ce n'est
pas un problÃ¨me majeur. Cependant, si nous continuons Ã  faire grossir notre
programme dans le <code>main</code>, le nombre des diffÃ©rentes tÃ¢ches qu'assure la
fonction <code>main</code> va continuer Ã  s'agrandir. Plus une fonction assure des
tÃ¢ches diffÃ©rentes, plus cela devient difficile de la comprendre, de la tester,
et d'y faire des changements sans casser ses autres constituants. Cela est
mieux de sÃ©parer les fonctionnalitÃ©s afin que chaque fonction n'assure qu'une
seule tÃ¢che.</p>
<!--
This issue also ties into the second problem: although `query` and `filename`
are configuration variables to our program, variables like `contents` are used
to perform the programâ€™s logic. The longer `main` becomes, the more variables
weâ€™ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. Itâ€™s best to group the
configuration variables into one structure to make their purpose clear.
-->
<p>Cette problÃ©matique est aussi liÃ©e au second problÃ¨meÂ : bien que <code>recherche</code> et
<code>nom_fichier</code> soient des variables de configuration de notre programme, les
variables telles que <code>contenu</code> sont utilisÃ©es pour appuyer la logique du
programme. Plus <code>main</code> est grand, plus nous aurons des variables Ã  importer
dans la portÃ©eÂ ; plus nous avons des variables dans notre portÃ©e, plus il sera
difficile de se souvenir Ã  quoi elles servent. Il est prÃ©fÃ©rable de regrouper
les variables de configuration dans une structure pour clarifier leur usage.</p>
<!--
The third problem is that weâ€™ve used `expect` to print an error message when
reading the file fails, but the error message just prints `Something went wrong
reading the file`. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, weâ€™d print the `Something went wrong reading
the file` error message, which wouldnâ€™t give the user any information!
-->
<p>Le troisiÃ¨me problÃ¨me est que nous avons utilisÃ© <code>expect</code> pour afficher un
message d'erreur lorsque la lecture du fichier Ã©choue, mais le message affiche
uniquement <code>Quelque chose s'est mal passÃ© lors de la lecture du fichier</code>. Lire
un fichier peut Ã©chouer pour de nombreuses raisonsÂ : par exemple, le fichier
peut ne pas exister, ou nous n'avons pas le droit de l'ouvrir. Pour le moment,
quelle que soit la raison, nous affichons le message d'erreur <code>Quelque chose s'est mal passÃ© lors de la lecture du fichier</code>, ce qui ne donne aucune
information Ã  l'utilisateurÂ !</p>
<!--
Fourth, we use `expect` repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, theyâ€™ll get an `index out
of bounds` error from Rust that doesnâ€™t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
weâ€™re printing messages that will be meaningful to our end users.
-->
<p>QuatriÃ¨mement, nous utilisons <code>expect</code> Ã  rÃ©pÃ©tition pour gÃ©rer les diffÃ©rentes
erreurs, et si l'utilisateur lance notre programme sans renseigner d'arguments,
il va avoir une erreur <code>index out of bounds</code> provenant de Rust, qui n'explique
pas clairement le problÃ¨me. Il serait plus judicieux que tout le code de gestion
des erreurs se trouve au mÃªme endroit afin que les futurs mainteneurs n'aient
qu'un seul endroit Ã  consulter dans le code si la logique de gestion des
erreurs doit Ãªtre modifiÃ©e. Avoir tout le code de gestion des erreurs dans un
seul endroit va aussi garantir que nous affichons des messages qui ont du sens
pour les utilisateurs.</p>
<!--
Letâ€™s address these four problems by refactoring our project.
-->
<p>Corrigeons ces quatre problÃ¨mes en remaniant notre projet.</p>
<!--
### Separation of Concerns for Binary Projects
-->
<h3 id="sÃ©paration-des-tÃ¢ches-des-projets-de-binaires"><a class="header" href="#sÃ©paration-des-tÃ¢ches-des-projets-de-binaires">SÃ©paration des tÃ¢ches des projets de binaires</a></h3>
<!--
The organizational problem of allocating responsibility for multiple tasks to
the `main` function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when `main` starts getting large. The
process has the following steps:
-->
<p>Le problÃ¨me de l'organisation de la rÃ©partition des tÃ¢ches multiples dans la
fonction <code>main</code> est commun Ã  de nombreux projets binaires. En consÃ©quence, la
communautÃ© Rust a dÃ©veloppÃ© une procÃ©dure Ã  utiliser comme ligne conductrice
pour partager les tÃ¢ches d'un programme binaire lorsque <code>main</code> commence Ã 
grossir. Le processus se dÃ©compose selon les Ã©tapes suivantesÂ :</p>
<!--
* Split your program into a *main.rs* and a *lib.rs* and move your programâ€™s
  logic to *lib.rs*.
* As long as your command line parsing logic is small, it can remain in
  *main.rs*.
* When the command line parsing logic starts getting complicated, extract it
  from *main.rs* and move it to *lib.rs*.
-->
<ul>
<li>Diviser votre programme dans un <em>main.rs</em> et un <em>lib.rs</em> et dÃ©placer la
logique de votre programme dans <em>lib.rs</em>.</li>
<li>Tant que votre logique d'interprÃ©tation de la ligne de commande est peu
volumineuse, elle peut rester dans le <em>main.rs</em></li>
<li>Lorsque la logique d'interprÃ©tation de la ligne de commande commence Ã  devenir
compliquÃ©e, il faut la dÃ©placer du <em>main.rs</em> vers le <em>lib.rs</em>.</li>
</ul>
<!--
The responsibilities that remain in the `main` function after this process
should be limited to the following:
-->
<p>Les fonctionnalitÃ©s qui restent dans la fonction <code>main</code> aprÃ¨s cette procÃ©dure
seront les suivantesÂ :</p>
<!--
* Calling the command line parsing logic with the argument values
* Setting up any other configuration
* Calling a `run` function in *lib.rs*
* Handling the error if `run` returns an error
-->
<ul>
<li>Appeler la logique d'interprÃ©tation de ligne de commande avec les valeurs des
arguments</li>
<li>RÃ©gler toutes les autres configurations</li>
<li>Appeler une fonction <code>run</code> de <em>lib.rs</em></li>
<li>GÃ©rer l'erreur si <code>run</code> retourne une erreur</li>
</ul>
<!--
This pattern is about separating concerns: *main.rs* handles running the
program, and *lib.rs* handles all the logic of the task at hand. Because you
canâ€™t test the `main` function directly, this structure lets you test all of
your programâ€™s logic by moving it into functions in *lib.rs*. The only code
that remains in *main.rs* will be small enough to verify its correctness by
reading it. Letâ€™s rework our program by following this process.
-->
<p>Cette structure permet de sÃ©parer les responsabilitÃ©sÂ : <em>main.rs</em> se charge de
lancer le programme, et <em>lib.rs</em> renferme toute la logique des tÃ¢ches Ã 
accomplir. Comme vous ne pouvez pas directement tester la fonction <code>main</code>, cette
structure vous permet de tester toute la logique de votre programme en les
dÃ©plaÃ§ant dans des fonctions dans <em>lib.rs</em>. Le seul code qui restera dans le
<em>main.rs</em> sera suffisamment petit pour s'assurer qu'il soit correcte en le
lisant. LanÃ§ons-nous dans le remaniement de notre programme en suivant cette
procÃ©dure.</p>
<!--
#### Extracting the Argument Parser
-->
<h4 id="extraction-de-linterprÃ©teur-des-arguments"><a class="header" href="#extraction-de-linterprÃ©teur-des-arguments">Extraction de l'interprÃ©teur des arguments</a></h4>
<!--
Weâ€™ll extract the functionality for parsing arguments into a function that
`main` will call to prepare for moving the command line parsing logic to
*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new
function `parse_config`, which weâ€™ll define in *src/main.rs* for the moment.
-->
<p>Nous allons dÃ©placer la fonctionnalitÃ© de l'interprÃ©tation des arguments dans
une fonction que <code>main</code> va appeler afin de prÃ©parer le dÃ©placement de la logique
de l'interprÃ©teur dans <em>src/lib.rs</em>. L'encart 12-5 montre le nouveau dÃ©but du
<code>main</code> qui appelle une nouvelle fonction <code>interpreter_config</code>, que nous allons
dÃ©finir dans <em>src/main.rs</em> pour le moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
# 
#     println!("Searching for {}", query);
#     println!("In file {}", filename);
# 
#     let contents = fs::read_to_string(filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (recherche, nom_fichier) = interpreter_config(&amp;args);

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

fn interpreter_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    (recherche, nom_fichier)
}
</code></pre>
<!--
<span class="caption">Listing 12-5: Extracting a `parse_config` function from
`main`</span>
-->
<p><span class="caption">Encart 12-5Â : Extraction d'une fonction
<code>interpreter_config</code> Ã  partir de <code>main</code></span></p>
<!--
Weâ€™re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable `query` and the
argument value at index 2 to the variable `filename` within the `main`
function, we pass the whole vector to the `parse_config` function. The
`parse_config` function then holds the logic that determines which argument
goes in which variable and passes the values back to `main`. We still create
the `query` and `filename` variables in `main`, but `main` no longer has the
responsibility of determining how the command line arguments and variables
correspond.
-->
<p>Nous continuons Ã  rÃ©cupÃ©rer les arguments de la ligne de commande dans un
vecteur, mais au lieu d'assigner la valeur de l'argument d'indice 1 Ã  la
variable <code>recherche</code> et la valeur de l'argument d'indice 2 Ã  la variable
<code>nom_fichier</code> dans la fonction <code>main</code>, nous passons le vecteur entier Ã  la
fonction <code>interpreter_config</code>. La fonction <code>interpreter_config</code> renferme la
logique qui dÃ©termine quel argument va dans quelle variable et renvoie les
valeurs au <code>main</code>. Nous continuons Ã  crÃ©er les variables <code>recherche</code> et
<code>nom_fichier</code> dans le <code>main</code>, mais <code>main</code> n'a plus la responsabilitÃ© de
dÃ©terminer quelles sont les variables qui correspondent aux arguments de la
ligne de commande.</p>
<!--
This rework may seem like overkill for our small program, but weâ€™re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. Itâ€™s good to check your progress
often, to help identify the cause of problems when they occur.
-->
<p>Ce remaniement peut sembler excessif pour notre petit programme, mais nous
remanions avec de maniÃ¨re incrÃ©mentale par de petites Ã©tapes. AprÃ¨s avoir fait
ces changements, lancez Ã  nouveau le programme pour vÃ©rifier que l'envoi des
arguments fonctionne toujours. C'est une bonne chose de vÃ©rifier souvent lorsque
vous avancez, pour vous aider Ã  mieux identifier les causes de problÃ¨mes
lorsqu'ils apparaissent.</p>
<!--
#### Grouping Configuration Values
-->
<h4 id="grouper-les-valeurs-de-configuration"><a class="header" href="#grouper-les-valeurs-de-configuration">Grouper les valeurs de configuration</a></h4>
<!--
We can take another small step to improve the `parse_config` function further.
At the moment, weâ€™re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we donâ€™t have
the right abstraction yet.
-->
<p>Nous pouvons appliquer une nouvelle petite Ã©tape pour amÃ©liorer la fonction
<code>interpreter_config</code>. Pour le moment, nous retournons un tuple, mais ensuite
nous divisons immÃ©diatement ce tuple Ã  nouveau en plusieurs Ã©lÃ©ments. C'est un
signe que nous n'avons peut-Ãªtre la bonne approche.</p>
<!--
Another indicator that shows thereâ€™s room for improvement is the `config` part
of `parse_config`, which implies that the two values we return are related and
are both part of one configuration value. Weâ€™re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.
-->
<p>Un autre signe qui indique qu'il y a encore de la place pour de l'amÃ©lioration
est que la partie <code>config</code> de <code>interpreter_config</code>, ce qui sous-entend que les
deux valeurs que nous retournons sont liÃ©es et font partie d'une mÃªme valeur de
configuration. Actuellement, nous ne donnons pas de signification Ã  cela dans la
structure des donnÃ©es autrement qu'en regroupant les deux valeurs dans un
tupleÂ ; nous pourrions mettre les deux valeurs dans une seule structure et
donner un nom significatif Ã  chacun des champs de la structure. Faire ainsi
permet de faciliter la comprÃ©hension du code par les futurs dÃ©veloppeurs de ce
code pour comprendre le lien entre les deux et quels sont leurs rÃ´les.</p>
<!--
> Note: Using primitive values when a complex type would be more appropriate is
> an anti-pattern known as *primitive obsession*.
-->
<blockquote>
<p>RemarqueÂ : l'utilisation de valeurs primitives Ã  la place d'un type
sophistiquÃ© lorsque c'est nÃ©cessaire est un anti-patron connu sous le nom
<em>d'obsession primitive</em>.</p>
</blockquote>
<!--
Listing 12-6 shows the improvements to the `parse_config` function.
-->
<p>L'encart 12-6 montre les amÃ©liorations apportÃ©es Ã  la fonction
<code>interpreter_config</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
# 
#     println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = interpreter_config(&amp;args);

    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);

    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

struct Config {
    recherche: String,
    nom_fichier: String,
}

fn interpreter_config(args: &amp;[String]) -&gt; Config {
    let recherche = args[1].clone();
    let nom_fichier = args[2].clone();

    Config { recherche, nom_fichier }
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-6: Refactoring `parse_config` to return an
instance of a `Config` struct</span>
-->
<p><span class="caption">Encart 12-6Â : Remaniement de <code>interpreter_config</code> pour
retourner une instance de la structure <code>Config</code></span></p>
<!--
Weâ€™ve added a struct named `Config` defined to have fields named `query` and
`filename`. The signature of `parse_config` now indicates that it returns a
`Config` value. In the body of `parse_config`, where we used to return string
slices that reference `String` values in `args`, we now define `Config` to
contain owned `String` values. The `args` variable in `main` is the owner of
the argument values and is only letting the `parse_config` function borrow
them, which means weâ€™d violate Rustâ€™s borrowing rules if `Config` tried to take
ownership of the values in `args`.
-->
<p>Nous avons ajoutÃ© une structure <code>Config</code> qui a deux champs <code>recherche</code> et
<code>nom_fichier</code>. La signature de <code>interpreter_config</code> indique maintenant qu'elle
retourne une valeur <code>Config</code>. Dans le corps de <code>interpreter_config</code>, oÃ¹ nous
retournions une slice de chaÃ®nes de caractÃ¨res qui pointaient sur des valeurs
<code>String</code> prÃ©sentes dans <code>args</code>, nous dÃ©finissons maintenant la structure
<code>Config</code> pour contenir des valeurs <code>String</code> qu'elle possÃ¨de. La variable <code>args</code>
du <code>main</code> est la propriÃ©taire des valeurs des arguments et permet uniquement Ã 
la fonction <code>interpreter_config</code> de les emprunter, ce qui signifie que nous
violons les rÃ¨gles d'emprunt de Rust si <code>Config</code> essaye de prendre possession
des valeurs provenant de <code>args</code>.</p>
<!--
We could manage the `String` data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the `clone` method on
the values. This will make a full copy of the data for the `Config` instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we donâ€™t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.
-->
<p>Nous pourrions gÃ©rer les donnÃ©es <code>String</code> de plusieurs maniÃ¨res, mais la faÃ§on
la plus facile, bien que non optimisÃ©e, est d'appeler la mÃ©thode <code>clone</code> sur
les valeurs. Cela va produire une copie complÃ¨te des donnÃ©es pour que
l'instance de <code>Config</code> puisse se les approprier, ce qui va prendre plus de
temps et de mÃ©moire que de stocker une rÃ©fÃ©rence vers les donnÃ©es de la chaÃ®ne
de caractÃ¨res. Cependant le clonage des donnÃ©es rend votre code trÃ¨s simple
car nous n'avons pas Ã  gÃ©rer les durÃ©es de vie des rÃ©fÃ©rencesÂ ; dans ces
circonstances, sacrifier un peu de performances pour gagner en simplicitÃ© est
un compromis qui en vaut la peine.</p>
<!--
> ### The Trade-Offs of Using `clone`
>
> Thereâ€™s a tendency among many Rustaceans to avoid using `clone` to fix
> ownership problems because of its runtime cost. In
> [Chapter 13][ch13]<!-- ignore -- >, youâ€™ll learn how to use more efficient
> methods in this type of situation. But for now, itâ€™s okay to copy a few
> strings to continue making progress because youâ€™ll make these copies only
> once and your filename and query string are very small. Itâ€™s better to have
> a working program thatâ€™s a bit inefficient than to try to hyperoptimize code
> on your first pass. As you become more experienced with Rust, itâ€™ll be
> easier to start with the most efficient solution, but for now, itâ€™s
> perfectly acceptable to call `clone`.
-->
<blockquote>
<h3 id="les-contre-parties-de-lutilisation-de-clone"><a class="header" href="#les-contre-parties-de-lutilisation-de-clone">Les contre-parties de l'utilisation de <code>clone</code></a></h3>
<p>Il y a une tendance chez les RustacÃ©s de s'interdire l'utilisation de <code>clone</code>
pour rÃ©gler les problÃ¨mes d'appartenance Ã  cause du coÃ»t Ã  l'exÃ©cution. Dans
le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->, vous allez apprendre Ã  utiliser des
mÃ©thodes plus efficaces dans ce genre de situation. Mais pour le moment, ce
n'est pas un problÃ¨me de copier quelques chaÃ®nes de caractÃ¨res pour continuer
Ã  progresser car vous allez le faire une seule fois et votre <code>nom_fichier</code> et
<code>recherche</code> sont trÃ¨s courts. Il est plus important d'avoir un programme
fonctionnel qui est n'est trÃ¨s optimisÃ© plutÃ´t que d'essayer d'optimiser Ã 
outrance le code dÃ¨s sa premiÃ¨re Ã©criture. Plus vous deviendrez expÃ©rimentÃ©
en Rust, plus il sera facile de commencer par la solution la plus
performante, mais pour le moment, il est parfaitement acceptable de faire
appel Ã  <code>clone</code>.</p>
</blockquote>
<!--
Weâ€™ve updated `main` so it places the instance of `Config` returned by
`parse_config` into a variable named `config`, and we updated the code that
previously used the separate `query` and `filename` variables so it now uses
the fields on the `Config` struct instead.
-->
<p>Nous avons actualisÃ© <code>main</code> pour qu'il utilise l'instance de <code>Config</code> retournÃ©e
par <code>interpreter_config</code> dans une variable <code>config</code>, et nous avons rafraÃ®chi le
code qui utilisait les variables sÃ©parÃ©es <code>recherche</code> et <code>nom_fichier</code> pour
qu'il utilise maintenant les champs de la structure <code>Config</code> Ã  la place.</p>
<!--
Now our code more clearly conveys that `query` and `filename` are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the `config` instance in the fields
named for their purpose.
-->
<p>Maintenant, notre code indique clairement que <code>recherche</code> et <code>nom_fichier</code> sont
reliÃ©s et que leur but est de configurer le fonctionnement du programme.
N'importe quel code qui utilise ces valeurs sait comment les retrouver dans les
champs de l'instance <code>config</code> grÃ¢ce Ã  leurs noms donnÃ©s Ã  cet effet.</p>
<!--
#### Creating a Constructor for `Config`
-->
<h4 id="crÃ©er-un-constructeur-pour-config"><a class="header" href="#crÃ©er-un-constructeur-pour-config">CrÃ©er un constructeur pour <code>Config</code></a></h4>
<!--
So far, weâ€™ve extracted the logic responsible for parsing the command line
arguments from `main` and placed it in the `parse_config` function. Doing so
helped us to see that the `query` and `filename` values were related and that
relationship should be conveyed in our code. We then added a `Config` struct to
name the related purpose of `query` and `filename` and to be able to return the
valuesâ€™ names as struct field names from the `parse_config` function.
-->
<p>Pour l'instant, nous avons extrait la logique en charge d'interprÃ©ter les
arguments de la ligne de commande Ã  partir du <code>main</code> et nous l'avons placÃ© dans
la fonction <code>interpreter_config</code>. Cela nous a aidÃ© Ã  dÃ©couvrir que les valeurs
<code>recherche</code> et <code>nom_fichier</code> Ã©taient liÃ©es et que ce lien devait Ãªtre
retranscrit dans notre code. Nous avons ensuite crÃ©Ã© une structure <code>Config</code>
afin de donner un nom au rÃ´le apparentÃ© Ã  <code>recherche</code> et Ã  <code>nom_fichier</code>, et
pour pouvoir retourner les noms des valeurs sous la forme de noms de champs Ã 
partir de la fonction <code>interpreter_config</code>.</p>
<!--
So now that the purpose of the `parse_config` function is to create a `Config`
instance, we can change `parse_config` from a plain function to a function
named `new` that is associated with the `Config` struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as `String`, by calling `String::new`. Similarly, by
changing `parse_config` into a `new` function associated with `Config`, weâ€™ll
be able to create instances of `Config` by calling `Config::new`. Listing 12-7
shows the changes we need to make.
-->
<p>Maintenant que le but de la fonction <code>interpreter_config</code> est de crÃ©er une
instance de <code>Config</code>, nous pouvons transformer <code>interpreter_config</code> d'une
simple fonction Ã  une fonction <code>new</code> qui est associÃ©e Ã  la structure <code>Config</code>.
Ce changement rendra le code plus familier. Habituellement, nous crÃ©ons des
instances de types de la bibliothÃ¨que standard, comme <code>String</code>, en appelant
<code>String::new</code>. Si on change le <code>interpreter_config</code> en une fonction <code>new</code>
associÃ©e Ã  <code>Config</code>, nous pourrons crÃ©er de la mÃªme faÃ§on des instances de
<code>Config</code> en appelant <code>Config::new</code>. L'encart 12-7 nous montre les changements
que nous devons faire pour cela.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);

    // --snip--
}

// --snip--

# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>
    // -- partie masquÃ©e ici --
}

// -- partie masquÃ©e ici --

<span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Config { recherche, nom_fichier }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-7: Changing `parse_config` into
`Config::new`</span>
-->
<p><span class="caption">Encart 12-7Â : Transformer <code>interpreter_config</code> en
<code>Config::new</code></span></p>
<!--
Weâ€™ve updated `main` where we were calling `parse_config` to instead call
`Config::new`. Weâ€™ve changed the name of `parse_config` to `new` and moved it
within an `impl` block, which associates the `new` function with `Config`. Try
compiling this code again to make sure it works.
-->
<p>Nous avons actualisÃ© le <code>main</code> oÃ¹ nous appelions <code>interpreter_config</code> pour
appeler Ã  la place le <code>Config::new</code>. Nous avons changÃ© le nom de
<code>interpreter_config</code> par <code>new</code> et nous l'avons dÃ©placÃ© dans un bloc <code>impl</code>,
ce qui relie la fonction <code>new</code> Ã  <code>Config</code>. Essayez Ã  nouveau de compiler ce
code pour vous assurer qu'il fonctionne.</p>
<!--
### Fixing the Error Handling
-->
<h3 id="corriger-la-gestion-des-erreurs"><a class="header" href="#corriger-la-gestion-des-erreurs">Corriger la gestion des erreurs</a></h3>
<!--
Now weâ€™ll work on fixing our error handling. Recall that attempting to access
the values in the `args` vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:
-->
<p>Maintenant, nous allons nous pencher sur la correction de la gestion des
erreurs. Rappellez-vous que la tentative d'accÃ©der aux valeurs dans le vecteur
<code>args</code> aux indices 1 ou 2 va faire paniquer le programme si le vecteur contient
moins de trois Ã©lÃ©ments. Essayez de lancer le programme sans aucun argumentÂ ;
cela donnera quelque chose comme ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
The line `index out of bounds: the len is 1 but the index is 1` is an error
message intended for programmers. It wonâ€™t help our end users understand what
happened and what they should do instead. Letâ€™s fix that now.
-->
<p>La ligne <code>index out of bounds: the len is 1 but the index is 1</code> est un
message d'erreur destinÃ© aux dÃ©veloppeurs. Il n'aidera pas nos utilisateurs
finaux Ã  comprendre ce qu'il s'est passÃ© et ce qu'ils devraient faire Ã  la
place. Corrigeons cela dÃ¨s maintenant.</p>
<!--
#### Improving the Error Message
-->
<h4 id="amÃ©liorer-le-message-derreur"><a class="header" href="#amÃ©liorer-le-message-derreur">AmÃ©liorer le message d'erreur</a></h4>
<!--
In Listing 12-8, we add a check in the `new` function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isnâ€™t long
enough, the program panics and displays a better error message than the `index
out of bounds` message.
-->
<p>Dans l'encart 12-8, nous ajoutons une vÃ©rification dans la fonction <code>new</code>, qui
va vÃ©rifier que le slice est suffisamment grand avant d'accÃ©der aux indices 1
et 2. Si le slice n'est pas suffisamment grand, le programme va paniquer et
afficher un meilleur message d'erreur que le message <code>index out of bounds</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
    // --snip--
    fn new(args: &[String]) -> Config {
        if args.len() < 3 {
            panic!("not enough arguments");
        }
        // --snip--
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Config { query, filename }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // -- partie masquÃ©e ici --
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;il n'y a pas assez d'arguments&quot;);
        }
        // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { recherche, nom_fichier }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-rust ignore">// -- partie masquÃ©e ici --
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;il n'y a pas assez d'arguments&quot;);
    }
    // -- partie masquÃ©e ici --
</code></pre>
<!--
<span class="caption">Listing 12-8: Adding a check for the number of
arguments</span>
-->
<p><span class="caption">Encart 12-8Â : Ajout d'une vÃ©rification du nombre
d'arguments</span></p>
<!--
This code is similar to [the `Guess::new` function we wrote in Listing
9-10][ch9-custom-types]<!-- ignore -- >, where we called `panic!` when the
`value` argument was out of the range of valid values. Instead of checking for
a range of values here, weâ€™re checking that the length of `args` is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If `args` has fewer than three items, this condition
will be true, and we call the `panic!` macro to end the program immediately.
-->
<p>Ce code est similaire Ã  <a href="ch09-03-to-panic-or-not-to-panic.html">la fonction Supposition::new que nous avons Ã©crit
dans l'encart 9-10</a><!-- ignore -->, dans lequel nous
appelions <code>panic!</code> lorsque l'argument <code>valeur</code> Ã©tait hors de l'intervalle des
valeurs valides. PlutÃ´t que de vÃ©rifier un intervalle de valeurs dans le cas
prÃ©sent, nous vÃ©rifions que la taille de <code>args</code> est au moins de 3 et que le
reste de la fonction puisse fonctionner en s'appuyant sur l'affirmation que
cette condition a bien Ã©tÃ© remplie. Si <code>args</code> avait moins de trois Ã©lÃ©ments,
cette fonction serait vraie, et nous appellerions alors la macro <code>panic!</code>
pour mettre fin au programme immÃ©diatement.</p>
<!--
With these extra few lines of code in `new`, letâ€™s run the program without any
arguments again to see what the error looks like now:
-->
<p>Avec ces quelques lignes de code en plus dans <code>new</code>, lanÃ§ons le programme sans
aucun argument Ã  nouveau pour voir Ã  quoi ressemble dÃ©sormais l'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'il n'y a pas assez d'arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
This output is better: we now have a reasonable error message. However, we also
have extraneous information we donâ€™t want to give to our users. Perhaps using
the technique we used in Listing 9-10 isnâ€™t the best to use here: a call to
`panic!` is more appropriate for a programming problem than a usage problem,
[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -- >. Instead, we
can use the other technique you learned about in Chapter 9â€”[returning a
`Result`][ch9-result]<!-- ignore -- > that indicates either success or an error.
-->
<p>Cette sortie est meilleureÂ : nous avons maintenant un message d'erreur
comprÃ©hensible. Cependant, nous avons aussi des informations superflues que
nous ne souhaitons pas afficher Ã  nos utilisateurs. Peut-Ãªtre que la technique
que nous avons utilisÃ© dans l'encart 9-10 n'est pas la plus appropriÃ©e dans ce
casÂ : un appel Ã  <code>panic!</code> est plus appropriÃ© pour un problÃ¨me de dÃ©veloppement
qu'un problÃ¨me d'utilisation, <a href="ch09-03-to-panic-or-not-to-panic.html">comme nous l'avons appris au chapitre
9</a><!-- ignore -->. A la place, nous pourrions utiliser
une autre technique que vous avez appris au chapitre 9 â€” <a href="ch09-02-recoverable-errors-with-result.html">retourner un
<code>Result</code></a><!-- ignore --> qui indique si c'est un succÃ¨s ou une
erreur.</p>
<!--
#### Returning a `Result` from `new` Instead of Calling `panic!`
-->
<h4 id="retourner-un-result-Ã -partir-de-new-plutÃ´t-que-dappeler-panic"><a class="header" href="#retourner-un-result-Ã -partir-de-new-plutÃ´t-que-dappeler-panic">Retourner un <code>Result</code> Ã  partir de <code>new</code> plutÃ´t que d'appeler <code>panic!</code></a></h4>
<!--
We can instead return a `Result` value that will contain a `Config` instance in
the successful case and will describe the problem in the error case. When
`Config::new` is communicating to `main`, we can use the `Result` type to
signal there was a problem. Then we can change `main` to convert an `Err`
variant into a more practical error for our users without the surrounding text
about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.
-->
<p>Nous pouvons Ã  la place retourner une valeur <code>Result</code> qui contiendra une
instance de <code>Config</code> dans le cas d'un succÃ¨s et va dÃ©crire le problÃ¨me dans le
cas d'une erreur. Lorsque <code>Config::new</code> communiquera avec le <code>main</code>, nous
pourrons utiliser le type de <code>Result</code> pour signaler oÃ¹ il y a un problÃ¨me.
Ensuite, nous pourrons changer le <code>main</code> pour convertir une variante de <code>Err</code>
dans une erreur plus pratique pour nos utilisateurs sans avoir le texte Ã 
propos de <code>thread 'main'</code> et de <code>RUST_BACKTRACE</code> qui sont provoquÃ©s par l'appel
Ã  <code>panic!</code>.</p>
<!--
Listing 12-9 shows the changes we need to make to the return value of
`Config::new` and the body of the function needed to return a `Result`. Note
that this wonâ€™t compile until we update `main` as well, which weâ€™ll do in the
next listing.
-->
<p>L'encart 12-9 nous montre les changements que nous devons faire pour Ã  la
valeur de retour de <code>Config::new</code> et le corps de la fonction qui doit retourner
un <code>Result</code>. Notez que cela ne va pas se compiler tant que nous ne corrigeons
pas aussi le <code>main</code>, ce que nous allons faire dans le prochain encart.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Ok(Config { recherche, nom_fichier })
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-9: Returning a `Result` from
`Config::new`</span>
-->
<p><span class="caption">Encart 12-9Â : Retourner un <code>Result</code> Ã  partir de
<code>Config::new</code></span></p>
<!--
Our `new` function now returns a `Result` with a `Config` instance in the
success case and a `&'static str` in the error case. Recall from [â€œThe Static
Lifetimeâ€][the-static-lifetime]<!-- ignore -- > section in Chapter 10 that
`&'static str` is the type of string literals, which is our error message type
for now.
-->
<p>Notre fonction <code>new</code> retourne dÃ©sormais un <code>Result</code> contenant une instance de
<code>Config</code> dans le cas d'un succÃ¨s et une <code>&amp;'static str</code> dans le cas d'une
erreur. Pour rappel, nous avons vu dans une section du
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> que <code>&amp;'static str</code> est le
type des chaÃ®nes de caractÃ¨res littÃ©rales, ce qui est dÃ©sormais le type de
notre message d'erreur.</p>
<!--
Weâ€™ve made two changes in the body of the `new` function: instead of calling
`panic!` when the user doesnâ€™t pass enough arguments, we now return an `Err`
value, and weâ€™ve wrapped the `Config` return value in an `Ok`. These changes
make the function conform to its new type signature.
-->
<p>Nous avons fait deux changements dans le corps de notre fonction <code>new</code>Â :
plutÃ´t que d'avoir Ã  appeler <code>panic!</code> lorsque l'utilisateur n'envoie pas assez
d'arguments, nous retournons maintenant une valeur <code>Err</code>, et nous avons intÃ©grÃ©
la valeur de retour <code>Config</code> dans un <code>Ok</code>. Ces modifications font en sorte que
la fonction soit dÃ©sormais conformes Ã  son nouveau type de signature.</p>
<!--
Returning an `Err` value from `Config::new` allows the `main` function to
handle the `Result` value returned from the `new` function and exit the process
more cleanly in the error case.
-->
<p>Retourner une valeur <code>Err</code> Ã  partir de <code>Config::new</code> permet Ã  la fonction
<code>main</code> de gÃ©rer la valeur <code>Result</code> retournÃ©e par la fonction <code>new</code> et de
terminer plus proprement le processus dans cas d'une erreur.</p>
<!--
#### Calling `Config::new` and Handling Errors
-->
<h4 id="appeler-confignew-et-gÃ©rer-les-erreurs"><a class="header" href="#appeler-confignew-et-gÃ©rer-les-erreurs">Appeler <code>Config::new</code> et gÃ©rer les erreurs</a></h4>
<!--
To handle the error case and print a user-friendly message, we need to update
`main` to handle the `Result` being returned by `Config::new`, as shown in
Listing 12-10. Weâ€™ll also take the responsibility of exiting the command line
tool with a nonzero error code from `panic!` and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.
-->
<p>Pour gÃ©rer les cas d'erreurs et afficher un message correct pour
l'utilisateur, nous devons mettre Ã  jour <code>main</code> pour gÃ©rer le <code>Result</code>
retournÃ© par <code>Config::new</code>, comme dans l'encart 12-10. Nous allons aussi
prendre la dÃ©cision de quitter l'outil en ligne de commande avec un code
d'erreur diffÃ©rent de zÃ©ro avec <code>panic!</code> et nous allons l'implÃ©menter
manuellement. Un statut de sortie diffÃ©rent de zÃ©ro est une convention pour
signaler au processus qui a appelÃ© notre programme que le programme s'est
terminÃ© dans un Ã©tat d'erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-10: Exiting with an error code if creating a
new `Config` fails</span>
-->
<p><span class="caption">Encart 12-10Â : Quitter avec un code d'erreur si la
crÃ©ation d'une nouvelle <code>Config</code> Ã©choue.
</span></p>
<!--
In this listing, weâ€™ve used a method we havenâ€™t covered before:
`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.
Using `unwrap_or_else` allows us to define some custom, non-`panic!` error
handling. If the `Result` is an `Ok` value, this methodâ€™s behavior is similar
to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value
is an `Err` value, this method calls the code in the *closure*, which is an
anonymous function we define and pass as an argument to `unwrap_or_else`. Weâ€™ll
cover closures in more detail in [Chapter 13][ch13]<!-- ignore -- >. For now,
you just need to know that `unwrap_or_else` will pass the inner value of the
`Err`, which in this case is the static string `not enough arguments` that we
added in Listing 12-9, to our closure in the argument `err` that appears
between the vertical pipes. The code in the closure can then use the `err`
value when it runs.
-->
<p>Dans cet encart, nous avons utilisÃ© une mÃ©thode que nous n'avons pas encore
abordÃ©Â : <code>unwrap_or_else</code>, qui est dÃ©fini sur <code>Result&lt;T, E&gt;</code> par la bibliothÃ¨que
standard. L'utilisation de <code>unwrap_or_else</code> nous permet de dÃ©finir une gestion
des erreurs personnalisÃ©e, exempt de <code>panic!</code>. Si le <code>Result</code> est une valeur
<code>Ok</code>, le comportement de cette mÃ©thode est similaire Ã  <code>unwrap</code>Â : elle retourne
la valeur Ã  l'intÃ©rieur du <code>Ok</code>. Cependant, si la valeur est une valeur <code>Err</code>,
cette mÃ©thode appelle le code dans la <em>fermeture</em>, qui est une fonction anonyme
que nous dÃ©finissons et passons en argument de <code>unwrap_or_else</code>. Nous verrons
les fermetures plus en dÃ©tail dans le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->. Pour
l'instant, vous avez juste Ã  savoir que le <code>unwrap_or_else</code> va passer la valeur
interne du <code>Err</code> (qui dans ce cas est la chaÃ®ne de caractÃ¨res statique
<code>pas assez d'arguments</code> que nous avons ajoutÃ© dans l'encart 12-9) Ã  notre
fermeture dans l'argument <code>err</code> qui est prÃ©sent entre deux barres verticales. Le
code dans la fermeture peut ensuite utiliser la valeur <code>err</code> lorsqu'il est
exÃ©cutÃ©.</p>
<!--
Weâ€™ve added a new `use` line to bring `process` from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the `err` value and then call `process::exit`. The
`process::exit` function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
`panic!`-based handling we used in Listing 12-8, but we no longer get all the
extra output. Letâ€™s try it:
-->
<p>Nous avons ajoutÃ© une nouvelle ligne <code>use</code> pour importer <code>portÃ©</code> dans la portÃ©e
Ã  partir de la bibliothÃ¨que standard. Le code dans la fermeture qui sera exÃ©cutÃ©
dans le cas d'une erreur fait uniquement deux lignesÂ : nous affichons la valeur
de <code>err</code> et nous appelons ensuite <code>process::exit</code>. La fonction <code>process::exit</code>
va stopper le programme immÃ©diatement et retourner le nombre qui lui a Ã©tÃ© donnÃ©
en paramÃ¨tre comme code de statut de sortie. C'est semblable Ã  la gestion basÃ©e
sur <code>panic!</code> que nous avons utilisÃ© Ã  l'encart 12-8, mais nous n'avons plus tout
le texte en plus. Essayons celaÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : il n'y a pas assez d'arguments
</code></pre>
<!--
Great! This output is much friendlier for our users.
-->
<p>TrÃ¨s bien ! Cette sortie est bien plus comprÃ©hensible pour nos utilisateurs.</p>
<!--
### Extracting Logic from `main`
-->
<h3 id="extraction-de-la-logique-du-main"><a class="header" href="#extraction-de-la-logique-du-main">Extraction de la logique du <code>main</code></a></h3>
<!--
Now that weâ€™ve finished refactoring the configuration parsing, letâ€™s turn to
the programâ€™s logic. As we stated in [â€œSeparation of Concerns for Binary
Projectsâ€](#separation-of-concerns-for-binary-projects)<!-- ignore -- >, weâ€™ll
extract a function named `run` that will hold all the logic currently in the
`main` function that isnâ€™t involved with setting up configuration or handling
errors. When weâ€™re done, `main` will be concise and easy to verify by
inspection, and weâ€™ll be able to write tests for all the other logic.
-->
<p>Maintenant que nous avons fini le remaniement de l'interprÃ©tation de la
configuration, occupons-nous de logique du programme. Comme nous l'avons dit
dans <a href="#separation-of-concerns-for-binary-projects">â€œSÃ©paration des tÃ¢ches des projets de
binairesâ€</a><!-- ignore -->, nous
allons extraire une fonction <code>run</code> qui va contenir toute la logique qui est
actuellement dans la fonction <code>main</code> qui n'est pas liÃ©e au rÃ©glage de la
configuration ou la gestion des erreurs. Lorsque nous aurons terminÃ©, <code>main</code>
sera plus concise et facile Ã  vÃ©rifier en l'inspectant, et nous pourrons Ã©crire
des tests pour toutes les autres logiques.</p>
<!--
Listing 12-11 shows the extracted `run` function. For now, weâ€™re just making
the small, incremental improvement of extracting the function. Weâ€™re still
defining the function in *src/main.rs*.
-->
<p>L'encart 12-11 montre la fonction <code>run</code> extraite. Pour le moment, nous faisons
des petites amÃ©liorations progressives pour extraire les fonctions. Nous
continuons Ã  dÃ©finir la fonction dans <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masquÃ©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);

    run(config);
}

fn run(config: Config) {
    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte :\n{}&quot;, contenu);
}

// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-11: Extracting a `run` function containing the
rest of the program logic</span>
-->
<p><span class="caption">Encart 12-11Â : Extraction d'une fonction <code>run</code> qui
contient le reste de la logique du programme</span></p>
<!--
The `run` function now contains all the remaining logic from `main`, starting
from reading the file. The `run` function takes the `Config` instance as an
argument.
-->
<p>La fonction <code>run</code> contient maintenant toute la logique qui restait dans le
<code>main</code>, en commenÃ§ant par la lecture du fichier. La fonction <code>run</code> prend
l'instance de <code>Config</code> en argument.</p>
<!--
#### Returning Errors from the `run` Function
-->
<h4 id="retourner-des-erreurs-avec-la-fonction-run"><a class="header" href="#retourner-des-erreurs-avec-la-fonction-run">Retourner des erreurs avec la fonction <code>run</code></a></h4>
<!--
With the remaining program logic separated into the `run` function, we can
improve the error handling, as we did with `Config::new` in Listing 12-9.
Instead of allowing the program to panic by calling `expect`, the `run`
function will return a `Result<T, E>` when something goes wrong. This will let
us further consolidate into `main` the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of `run`.
-->
<p>Avec le restant de la logique du programme maintenant sÃ©parÃ©e dans la fonction
<code>run</code>, nous pouvons amÃ©liorer la gestion des erreurs, comme nous l'avons fait
avec <code>Config::new</code> dans l'encart 12-9. PlutÃ´t que de permettre au programme Ã 
paniquer en appelant <code>expect</code>, la fonction <code>run</code> va retourner un <code>Result&lt;T, E&gt;</code>
lorsque quelque chose se passe mal. Cela va nous permettre de consolider
davantage la logique de gestion des erreurs dans le <code>main</code> pour qu'elle soit
plus conviviale pour l'utilisateur. L'encart 12-12 montre les changements que
nous devons appliquer Ã  la signature et au corps du <code>run</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
use std::error::Error;

// --snip--

# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     run(config);
# }
# 
fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// -- partie masquÃ©e ici --

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    println!(&quot;Dans le texte :\n{}&quot;, contenu);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-12: Changing the `run` function to return
`Result`</span>
-->
<p><span class="caption">Encart 12-12Â : Changer la fonction <code>run</code> pour retourner
un <code>Result</code></span></p>
<!--
Weâ€™ve made three significant changes here. First, we changed the return type of
the `run` function to `Result<(), Box<dyn Error>>`. This function previously
returned the unit type, `()`, and we keep that as the value returned in the
`Ok` case.
-->
<p>Nous avons fait trois changements significatifs ici. PremiÃ¨rement, nous avons
changÃ© le type de retour de la fonction <code>run</code> en <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>.
Cette fonction renvoyait prÃ©cÃ©demment le type unitÃ©, <code>()</code>, que nous gardons
comme valeur de retour dans le cas de <code>Ok</code>.</p>
<!--
For the error type, we used the *trait object* `Box<dyn Error>` (and weâ€™ve
brought `std::error::Error` into scope with a `use` statement at the top).
Weâ€™ll cover trait objects in [Chapter 17][ch17]<!-- ignore -- >. For now, just
know that `Box<dyn Error>` means the function will return a type that
implements the `Error` trait, but we donâ€™t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The `dyn` keyword is short
for â€œdynamic.â€
-->
<p>En ce qui concerne le type d'erreur, nous avons utilisÃ© <em>l'objet trait</em>
<code>Box&lt;dyn Error&gt;</code> (et nous avons importÃ© <code>std::error::Error</code> dans la portÃ©e avec
une instruction <code>use</code> en haut). Nous allons voir les objets trait dans le
<a href="ch17-00-oop.html">chapitre 17</a><!-- ignore -->. Pour l'instant, retenez juste que
<code>Box&lt;dyn Error&gt;</code> signifie que la fonction va retourner un type qui implÃ©mente
le trait <code>Error</code>, mais que nous n'avons pas Ã  prÃ©ciser quel sera prÃ©cisÃ©ment le
type de la valeur de retour. Cela nous donne de la flexibilitÃ© sur les valeurs
d'erreurs de retour qui peuvent Ãªtre diffÃ©rentes dans diffÃ©rents cas d'erreurs.
Le mot-clÃ© <code>dyn</code> est un raccourci pour â€œdynamiqueâ€.</p>
<!--
Second, weâ€™ve removed the call to `expect` in favor of the `?` operator, as we
talked about in [Chapter 9][ch9-question-mark]<!-- ignore -- >. Rather than
`panic!` on an error, `?` will return the error value from the current function
for the caller to handle.
-->
<p>DeuxiÃ¨mement, nous avons enlevÃ© l'appel Ã  <code>expect</code> pour privilÃ©gier l'opÃ©rateur
<code>?</code>, que nous avons vu dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore -->.
Au lieu de faire un <code>panic!</code> sur une erreur, <code>?</code> va retourner la valeur d'erreur
de la fonction courante vers le code qui l'a appelÃ© pour qu'il la gÃ¨re.</p>
<!--
Third, the `run` function now returns an `Ok` value in the success case. Weâ€™ve
declared the `run` functionâ€™s success type as `()` in the signature, which
means we need to wrap the unit type value in the `Ok` value. This `Ok(())`
syntax might look a bit strange at first, but using `()` like this is the
idiomatic way to indicate that weâ€™re calling `run` for its side effects only;
it doesnâ€™t return a value we need.
-->
<p>TroisiÃ¨mement, la fonction <code>run</code> retourne maintenant une valeur <code>Ok</code> dans les
cas de succÃ¨s. Nous avons dÃ©clarÃ© dans la signature que le type de succÃ¨s de la
fonction <code>run</code> Ã©tait <code>()</code>, ce qui signifie que nous avons envelopper la valeur
de type unitÃ© dans la valeur <code>Ok</code>. Cette syntaxe <code>Ok(())</code> peut sembler un peu
Ã©trange au dÃ©part, mais utiliser <code>()</code> de cette maniÃ¨re est la faÃ§on idÃ©ale
d'indiquer que nous appelons <code>run</code> uniquement pour ses effets secondairesÂ ; elle
ne retourne pas de valeur que nous pourrions avoir besoin.</p>
<!--
When you run this code, it will compile but will display a warning:
-->
<p>Lorsque vous exÃ©cutez ce code, il va se compiler mais il va afficher un
avertissementÂ :</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `std::result::Result` that must be used
  -- > src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
On rechercheÂ : the
Dans le fichierÂ : poem.txt
Dans le texte :
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Rust tells us that our code ignored the `Result` value and the `Result` value
might indicate that an error occurred. But weâ€™re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Letâ€™s rectify that problem now.
-->
<p>Rust nous informe que notre code ignore la valeur <code>Result</code> et que cette valeur
<code>Result</code> pourrait indiquer qu'une erreur s'est passÃ©e. Mais nous ne vÃ©rifions
pas pour savoir si oui ou non il y a eu une erreur, et le compilateur nous
rappelle que nous devrions avoir du code de gestion des erreurs ici !
Corrigeons dÃ¨s Ã  prÃ©sent ce problÃ¨me.</p>
<!--
#### Handling Errors Returned from `run` in `main`
-->
<h4 id="gÃ©rer-les-erreurs-retournÃ©es-par-run-dans-main"><a class="header" href="#gÃ©rer-les-erreurs-retournÃ©es-par-run-dans-main">GÃ©rer les erreurs retournÃ©es par <code>run</code> dans <code>main</code></a></h4>
<!--
Weâ€™ll check for errors and handle them using a technique similar to one we used
with `Config::new` in Listing 12-10, but with a slight difference:
-->
<p>Nous allons vÃ©rifier les erreurs et les gÃ©rer en utilisant une technique
similaire Ã  celle que nous avons utilisÃ© avec <code>Config::new</code> dans l'encart
12-10, mais avec une lÃ©gÃ¨re diffÃ©renceÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}
# 
# fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masquÃ©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);

    if let Err(e) = run(config) {
        println!(&quot;Erreur applicativeÂ : {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We use `if let` rather than `unwrap_or_else` to check whether `run` returns an
`Err` value and call `process::exit(1)` if it does. The `run` function doesnâ€™t
return a value that we want to `unwrap` in the same way that `Config::new`
returns the `Config` instance. Because `run` returns `()` in the success case,
we only care about detecting an error, so we donâ€™t need `unwrap_or_else` to
return the unwrapped value because it would only be `()`.
-->
<p>Nous utilisons <code>if let</code> plutÃ´t que <code>unwrap_or_else</code> pour vÃ©rifier si <code>run</code>
retourne un valeure <code>Err</code> et appeler <code>process::exit(1)</code> le cas Ã©chÃ©ant. La
fonction <code>run</code> ne retourne pas de valeur que nous avons besoin de <code>unwrap</code>
comme nous l'avions fait avec le <code>Config::new</code> qui retournait une instance de
<code>Config</code>. Comme <code>run</code> retourne <code>()</code> dans le cas d'un succÃ¨s, nous nous
prÃ©occupons uniquement de dÃ©tecter les erreurs, donc n'avons pas besoin de
<code>unwrap_or_else</code> pour retourner la valeur extraite car elle sera toujours
<code>()</code>.</p>
<!--
The bodies of the `if let` and the `unwrap_or_else` functions are the same in
both cases: we print the error and exit.
-->
<p>Les corps du <code>if let</code> et de la fonction <code>unwrap_or_else</code> sont identiques dans
les deux casÂ : nous affichons l'erreur et nous quittons.</p>
<!--
### Splitting Code into a Library Crate
-->
<h3 id="dÃ©placer-le-code-dans-une-crate-de-bibliothÃ¨que"><a class="header" href="#dÃ©placer-le-code-dans-une-crate-de-bibliothÃ¨que">DÃ©placer le code dans une crate de bibliothÃ¨que</a></h3>
<!--
Our `minigrep` project is looking good so far! Now weâ€™ll split the
*src/main.rs* file and put some code into the *src/lib.rs* file so we can test
it and have a *src/main.rs* file with fewer responsibilities.
-->
<p>Notre projet <code>minigrep</code> se prÃ©sente plutÃ´t bien pour le momentÂ ! Maintenant,
nous allons diviser notre fichier <em>src/main.rs</em> et dÃ©placer du code dans le
fichier <em>src/lib.rs</em> pour que nous puissions le tester et avoir fichier
<em>src/main.rs</em> qui hÃ©berge moins de fonctionnalitÃ©s.</p>
<!--
Letâ€™s move all the code that isnâ€™t the `main` function from *src/main.rs* to
*src/lib.rs*:
-->
<p>DÃ©plaÃ§ons tout le code qui ne fait pas partie de la fonction <code>main</code> dans le
<em>src/main.rs</em> vers le <em>src/lib.rs</em>Â :</p>
<!--
* The `run` function definition
* The relevant `use` statements
* The definition of `Config`
* The `Config::new` function definition
-->
<ul>
<li>La dÃ©finition de la fonction <code>run</code></li>
<li>Les instructions <code>use</code> correspondantes</li>
<li>La dÃ©finition de <code>Config</code></li>
<li>La dÃ©finition de la fonction <code>Config::new</code></li>
</ul>
<!--
The contents of *src/lib.rs* should have the signatures shown in Listing 12-13
(weâ€™ve omitted the bodies of the functions for brevity). Note that this wonâ€™t
compile until we modify *src/main.rs* in Listing 12-14.
-->
<p>Le contenu du <em>src/lib.rs</em> devrait contenir les signatures de l'encart 12-13
(nous avons enlevÃ© les corps des fonctions pour des raisons de briÃ¨vetÃ©). Notez
que cela ne va pas se compiler jusqu'Ã  ce que nous modifions le <em>src/main.rs</em>
dans l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        // --snip--
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // -- partie masquÃ©e ici --
<span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 12-13: Moving `Config` and `run` into
*src/lib.rs*</span>
-->
<p><span class="caption">Encart 12-13Â : DÃ©placement de <code>Config</code> et de <code>run</code> dans
<em>src/lib.rs</em></span></p>
<!--
Weâ€™ve made liberal use of the `pub` keyword: on `Config`, on its fields and its
`new` method, and on the `run` function. We now have a library crate that has a
public API that we can test!
-->
<p>Nous avons fait un usage gÃ©nÃ©reux du mot-clÃ© <code>pub</code>Â : sur <code>Config</code>, sur ses
champs et sur la mÃ©thode <code>new</code>, et sur la fonction <code>run</code>. Nous avons maintenant
une crate de bibliothÃ¨que qui a une API publique que nous pouvons testerÂ !</p>
<!--
Now we need to bring the code we moved to *src/lib.rs* into the scope of the
binary crate in *src/main.rs*, as shown in Listing 12-14.
-->
<p>Maintenant nous devons importer le code que nous avons dÃ©placÃ© dans
<em>src/lib.rs</em> dans la portÃ©e de la crate binaire dans <em>src/main.rs</em>, comme dans
l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
    if let Err(e) = minigrep::run(config) {
        // --snip--
#         println!("Application error: {}", e);
# 
#         process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // -- partie masquÃ©e ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // -- partie masquÃ©e ici --
<span class="boring">        println!(&quot;Erreur applicativeÂ : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 12-14: Using the `minigrep` library crate in
*src/main.rs*</span>
-->
<p><span class="caption">Encart 12-14Â : Utilisation de la crate de bibliothÃ¨que
<code>minigrep</code> dans <em>src/main.rs</em></span></p>
<!--
We add a `use minigrep::Config` line to bring the `Config` type from the
library crate into the binary crateâ€™s scope, and we prefix the `run` function
with our crate name. Now all the functionality should be connected and should
work. Run the program with `cargo run` and make sure everything works
correctly.
-->
<p>Nous avons ajoutÃ© une ligne <code>use minigrep::Config</code> pour importer le type
<code>Config</code> de la crate de bibliothÃ¨que dans la portÃ©e de la crate binaire, et
nous avons avons prÃ©fixÃ© la fonction <code>run</code> avec le nom de notre crate.
Maintenant, toutes les fonctionnalitÃ©s devraient Ãªtre connectÃ©es et devraient
fonctionner. Lancez le programme avec <code>cargo run</code> pour vous assurer que tout
fonctionne correctement.</p>
<!--
Whew! That was a lot of work, but weâ€™ve set ourselves up for success in the
future. Now itâ€™s much easier to handle errors, and weâ€™ve made the code more
modular. Almost all of our work will be done in *src/lib.rs* from here on out.
-->
<p>OuahÂ ! C'Ã©tait pas mal de travail, mais nous sommes organisÃ©s pour nous assurer
le succÃ¨s Ã  venir. Maintenant il est bien plus facile de gÃ©rer les erreurs, et
nous avons rendu le code plus modulaire. A partir de maintenant, l'essentiel de
notre travail sera effectuÃ© dans <em>src/lib.rs</em>.</p>
<!--
Letâ€™s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: weâ€™ll
write some tests!
-->
<p>Profitons de cette nouvelle modularitÃ© en accomplissant quelque chose qui
aurait Ã©tÃ© difficile Ã  faire avec l'ancien code, mais qui est facile avec ce
nouveau codeÂ : nous allons Ã©crire des testsÂ !</p>
<!--
[the-static-lifetime]: ch10-03-lifetime-syntax.html#the-static-lifetime
[ch13]: ch13-00-functional-features.html
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[ch9-result]: ch09-02-recoverable-errors-with-result.html
[ch17]: ch17-00-oop.html
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
