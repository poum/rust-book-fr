<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html" class="active"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/189">Pull Request</a>.</p>
</blockquote>
<!--
## Treating Smart Pointers Like Regular References with the `Deref` Trait
-->
<h2><a class="header" href="#considÃ©rer-les-pointeurs-intelligents-comme-des-rÃ©fÃ©rences-grÃ¢ce-au-trait-deref" id="considÃ©rer-les-pointeurs-intelligents-comme-des-rÃ©fÃ©rences-grÃ¢ce-au-trait-deref">ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait <code>Deref</code></a></h2>
<!--
Implementing the `Deref` trait allows you to customize the behavior of the
*dereference operator*, `*` (as opposed to the multiplication or glob
operator). By implementing `Deref` in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.
-->
<p>L'implÃ©mentation du trait <code>Deref</code> vous permet de personnaliser le comportement
de <em>l'opÃ©rateur de dÃ©rÃ©fÃ©rencement</em> <code>*</code> (qui n'est pas l'opÃ©rateur de
multiplication ou le joker global). En implÃ©mentant <code>Deref</code> de maniÃ¨re Ã  ce
qu'un pointeur intelligent puisse Ãªtre considÃ©rÃ© comme une rÃ©fÃ©rence classique,
vous pouvez Ã©crire du code qui fonctionne avec des rÃ©fÃ©rences mais aussi avec
des pointeurs intelligents.</p>
<!--
Letâ€™s first look at how the dereference operator works with regular references.
Then weâ€™ll try to define a custom type that behaves like `Box<T>`, and see why
the dereference operator doesnâ€™t work like a reference on our newly defined
type. Weâ€™ll explore how implementing the `Deref` trait makes it possible for
smart pointers to work in ways similar to references. Then weâ€™ll look at
Rustâ€™s *deref coercion* feature and how it lets us work with either references
or smart pointers.
-->
<p>Regardons d'abord comment l'opÃ©rateur de dÃ©rÃ©fÃ©rencement fonctionne avec des
rÃ©fÃ©rences classiques. Ensuite nous essayerons de dÃ©finir un type personnalisÃ©
qui se comporte comme <code>Box&lt;T&gt;</code>, et voir pourquoi l'opÃ©rateur de dÃ©rÃ©fÃ©rencement
ne fonctionne pas comme une rÃ©fÃ©rence sur notre type fraÃ®chement dÃ©fini. Nous
allons dÃ©couvrir comment implÃ©menter le trait <code>Deref</code> de maniÃ¨re Ã  ce qu'il soit
possible que les pointeurs intelligents fonctionnent comme les rÃ©fÃ©rences.
Ensuite nous verons la fonctionnalitÃ© d'<em>extrapolation de dÃ©rÃ©fÃ©rencement</em> de
Rust et voir comment elle nous permet de travailler Ã  la fois avec des
rÃ©fÃ©rences et des pointeurs intelligents.</p>
<!--
> Note: thereâ€™s one big difference between the `MyBox<T>` type weâ€™re about to
> build and the real `Box<T>`: our version will not store its data on the heap.
> We are focusing this example on `Deref`, so where the data is actually stored
> is less important than the pointer-like behavior.
-->
<blockquote>
<p>RemarqueÂ : il y a une grosse diffÃ©rence entre le type <code>MaBoite&lt;T&gt;</code> que nous
allons construire et la vraie <code>Box&lt;T&gt;</code>Â : notre version ne va pas stocker ses
donnÃ©es sur le tas. Nous allons concentrer cet exemple sur <code>Deref</code>, donc
l'endroit oÃ¹ est concrÃ¨tement stockÃ© la donnÃ©e est moins important que le
comportement similaire aux pointeurs.</p>
</blockquote>
<!--
### Following the Pointer to the Value with the Dereference Operator
-->
<h3><a class="header" href="#suivre-le-pointeur-vers-la-valeur-grÃ¢ce-Ã -lopÃ©rateur-de-dÃ©rÃ©fÃ©rencement" id="suivre-le-pointeur-vers-la-valeur-grÃ¢ce-Ã -lopÃ©rateur-de-dÃ©rÃ©fÃ©rencement">Suivre le pointeur vers la valeur grÃ¢ce Ã  l'opÃ©rateur de dÃ©rÃ©fÃ©rencement</a></h3>
<!--
A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an `i32` value and then use the dereference operator to follow the
reference to the data:
-->
<p>Une rÃ©fÃ©rence classique est un type de pointeur, et une maniÃ¨re de modÃ©liser un
pointeur est d'imaginer une flÃ¨che pointant vers une valeur stockÃ©e autre part.
Dans l'encart 15-6, nous crÃ©ons une rÃ©fÃ©rence vers une valeur <code>i32</code> et utilisons
ensuite l'opÃ©rateur de dÃ©rÃ©fÃ©rencement pour suivre la rÃ©fÃ©rence vers la donnÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an `i32` value</span>
-->
<p><span class="caption">Encart 15-6Â : utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement pour
suivre une rÃ©fÃ©rence vers une valeur <code>i32</code></span></p>
<!--
The variable `x` holds an `i32` value, `5`. We set `y` equal to a reference to
`x`. We can assert that `x` is equal to `5`. However, if we want to make an
assertion about the value in `y`, we have to use `*y` to follow the reference
to the value itâ€™s pointing to (hence *dereference*). Once we dereference `y`,
we have access to the integer value `y` is pointing to that we can compare with
`5`.
-->
<p>La variable <code>x</code> stocke une valeur <code>i32</code>Â : <code>5</code>. Nous avons assignÃ© Ã  <code>y</code> une
rÃ©fÃ©rence vers <code>x</code>. Nous pouvons faire une <code>assert</code> pour vÃ©rifier que <code>x</code> est
Ã©gal Ã  <code>5</code>. Cependant, si nous souhaitons faire une <code>assert</code> sur la valeur dans
<code>y</code>, nous devons utiliser <code>*y</code> pour suivre la rÃ©fÃ©rence vers la valeur sur
laquelle elle pointe (d'oÃ¹ le <em>dÃ©rÃ©fÃ©rencement</em>). Une fois que nous avons
dÃ©rÃ©fÃ©rencÃ© <code>y</code>, nous avons accÃ¨s Ã  la valeur de l'entier sur laquelle <code>y</code>
pointe afin que nous puissions la comparer avec <code>5</code>.</p>
<!--
If we tried to write `assert_eq!(5, y);` instead, we would get this compilation
error:
-->
<p>Si nous avions essayÃ© d'Ã©crire <code>assert_eq!(5, y);</code> Ã  la place, nous aurions
obtenu cette erreur de compilationÂ :</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 -- > src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Comparing a number and a reference to a number isnâ€™t allowed because theyâ€™re
different types. We must use the dereference operator to follow the reference
to the value itâ€™s pointing to.
-->
<p>Comparer un nombre et une rÃ©fÃ©rence vers un nombre n'est pas autorisÃ© car ils
sont de types diffÃ©rents. Nous devons utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement
pour suivre la rÃ©fÃ©rence vers la valeur sur laquelle elle pointe.</p>
<!--
### Using `Box<T>` Like a Reference
-->
<h3><a class="header" href="#utiliser-boxt-comme-Ã©tant-une-rÃ©fÃ©rence" id="utiliser-boxt-comme-Ã©tant-une-rÃ©fÃ©rence">Utiliser <code>Box&lt;T&gt;</code> comme Ã©tant une rÃ©fÃ©rence</a></h3>
<!--
We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a
reference; the dereference operator will work as shown in Listing 15-7:
-->
<p>Nous pouvons rÃ©Ã©crire le code l'encart 15-6 pour utiliser une <code>Box&lt;T&gt;</code> au lieu
d'une rÃ©fÃ©renceÂ ; l'opÃ©rateur de dÃ©rÃ©fÃ©rencement devrait fonctionner comme
montrÃ© dans l'encart 15-7Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-7: Using the dereference operator on a
`Box<i32>`</span>
-->
<p><span class="caption">Encart 15-7Â : utilisation de l'opÃ©rateur de
dÃ©rÃ©fÃ©rencement sur un <code>Box&lt;i32&gt;</code></span></p>
<!--
The only difference between Listing 15-7 and Listing 15-6 is that here we set
`y` to be an instance of a box pointing to a copied value of `x` rather than a
reference pointing to the value of `x`. In the last assertion, we can use the
dereference operator to follow the boxâ€™s pointer in the same way that we did
when `y` was a reference. Next, weâ€™ll explore what is special about `Box<T>`
that enables us to use the dereference operator by defining our own box type.
-->
<p>La seule diffÃ©rence entre l'encart 15-7 et l'encart 15-6 est qu'ici nous avons
fait en sorte que <code>y</code> soit une instance de boite qui pointe sur une copie de la
valeur de <code>x</code> plutÃ´t qu'avoir une rÃ©fÃ©rence vers la valeur de <code>x</code>. Dans la
derniÃ¨re assertion, nous pouvons utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement pour
suivre le pointeur de la boite de la mÃªme maniÃ¨re que nous l'avons fait lorsque
<code>y</code> Ã©tait une rÃ©fÃ©rence. Maintenant, nous allons regarder ce qu'il y a de si
spÃ©cial dans <code>Box&lt;T&gt;</code> qui nous permet d'utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement
en dÃ©finissant notre propre type de boite.</p>
<!--
### Defining Our Own Smart Pointer
-->
<h3><a class="header" href="#dÃ©finir-notre-propre-pointeur-intelligent" id="dÃ©finir-notre-propre-pointeur-intelligent">DÃ©finir notre propre pointeur intelligent</a></h3>
<!--
Letâ€™s build a smart pointer similar to the `Box<T>` type provided by the
standard library to experience how smart pointers behave differently from
references by default. Then weâ€™ll look at how to add the ability to use the
dereference operator.
-->
<p>Construisons un pointeur intelligent similaire au type <code>Box&lt;T&gt;</code> fourni par la
bibliothÃ¨que standard pour apprendre comment les pointeurs intelligents se
comportent diffÃ©remment des rÃ©fÃ©rences classiques. Ensuite nous regarderons
comment lui ajouter la possibilitÃ© d'utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement.</p>
<!--
The `Box<T>` type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a `MyBox<T>` type in the same way. Weâ€™ll also define a
`new` function to match the `new` function defined on `Box<T>`.
-->
<p>Le type <code>Box&lt;T&gt;</code> est essentiellement dÃ©fini comme Ã©tant une structure de tuple
d'un seul Ã©lÃ©ment, donc l'encart 15-8 dÃ©finit un type <code>MaBoite&lt;T&gt;</code> de la mÃªme
maniÃ¨re. Nous allons aussi dÃ©finir une fonction <code>new</code> pour correspondre Ã  la
fonction <code>new</code> dÃ©finie sur <code>Box&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MaBoite&lt;T&gt;(T);

impl&lt;T&gt; MaBoite&lt;T&gt; {
    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
        MaBoite(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-8: Defining a `MyBox<T>` type</span>
-->
<p><span class="caption">Encart 15-8Â : dÃ©finition du type <code>MaBoite&lt;T&gt;</code></span></p>
<!--
We define a struct named `MyBox` and declare a generic parameter `T`, because
we want our type to hold values of any type. The `MyBox` type is a tuple struct
with one element of type `T`. The `MyBox::new` function takes one parameter of
type `T` and returns a `MyBox` instance that holds the value passed in.
-->
<p>Nous dÃ©finissons une structure <code>MaBoite</code> et on dÃ©clare un paramÃ¨tre gÃ©nÃ©rique
<code>T</code>, car nous souhaitons que notre type stocke des valeurs de n'importe quel
type. Le type <code>MaBoite</code> est une structure de tuple avec un seul Ã©lÃ©ment de type
<code>T</code>. La fonction <code>MaBoite::new</code> prend un paramÃ¨tre de type <code>T</code> et retourne une
instance <code>MaBoite</code> qui stocke la valeur qui lui est passÃ©e.</p>
<!--
Letâ€™s try adding the `main` function in Listing 15-7 to Listing 15-8 and
changing it to use the `MyBox<T>` type weâ€™ve defined instead of `Box<T>`. The
code in Listing 15-9 wonâ€™t compile because Rust doesnâ€™t know how to dereference
`MyBox`.
-->
<p>Essayons d'ajouter la fonction <code>main</code> de l'encart 15-7 dans l'encart 15-8 et la
modifier pour utiliser le type <code>MaBoite&lt;T&gt;</code> que nous avons dÃ©fini Ã  la place de
<code>Box&lt;T&gt;</code>. Le code de l'encart 15-9 ne se compile pas car Rust ne sait pas
comment dÃ©rÃ©fÃ©rencer <code>MaBoite</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MaBoite::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<!--
<span class="caption">Listing 15-9: Attempting to use `MyBox<T>` in the same
way we used references and `Box<T>`</span>
-->
<p><span class="caption">Encart 15-9Â : tentative d'utiliser <code>MaBoite&lt;T&gt;</code> de la mÃªme
maniÃ¨re que nous avions utilisÃ© les rÃ©fÃ©rences et <code>Box&lt;T&gt;</code></span></p>
<!--
Hereâ€™s the resulting compilation error:
-->
<p>Voici l'erreur de compilation qui en rÃ©sulteÂ :</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  -- > src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MaBoite&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Our `MyBox<T>` type canâ€™t be dereferenced because we havenâ€™t implemented that
ability on our type. To enable dereferencing with the `*` operator, we
implement the `Deref` trait.
-->
<p>Notre type <code>MaBoite&lt;T&gt;</code> ne peut pas Ãªtre dÃ©rÃ©fÃ©rencÃ©e car nous n'avons pas
implÃ©mentÃ© cette fonctionnalitÃ© sur notre type. Pour permettre le
dÃ©rÃ©fÃ©rencement avec l'opÃ©rateur <code>*</code>, nous devons implÃ©menter le trait <code>Deref</code>.</p>
<!--
### Treating a Type Like a Reference by Implementing the `Deref` Trait
-->
<h3><a class="header" href="#considÃ©rer-un-type-comme-une-rÃ©fÃ©rence-en-implÃ©mentant-le-trait-deref" id="considÃ©rer-un-type-comme-une-rÃ©fÃ©rence-en-implÃ©mentant-le-trait-deref">ConsidÃ©rer un type comme une rÃ©fÃ©rence en implÃ©mentant le trait <code>Deref</code></a></h3>
<!--
As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the traitâ€™s required methods. The `Deref` trait, provided
by the standard library, requires us to implement one method named `deref` that
borrows `self` and returns a reference to the inner data. Listing 15-10
contains an implementation of `Deref` to add to the definition of `MyBox`:
-->
<p>Comme nous l'avons vu dans le chapitre 10, pour implÃ©menter un trait, nous
devons fournir les implÃ©mentations des mÃ©thodes nÃ©cessaires pour ce trait. Le
trait <code>Deref</code>, fourni par la bibliothÃ¨que standard, nÃ©cessite que nous
implÃ©mentions une mÃ©thode <code>deref</code> qui prend possession de <code>self</code> et retourne une
rÃ©fÃ©rence vers la donnÃ©e interne. L'encart 15-10 contient une implÃ©mentation de
<code>Deref</code> Ã  ajouter Ã  la dÃ©finition de <code>MaBoite</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn main() {
#     let x = 5;
#     let y = MyBox::new(x);
# 
#     assert_eq!(5, x);
#     assert_eq!(5, *y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MaBoite::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-10: Implementing `Deref` on `MyBox<T>`</span>
-->
<p><span class="caption">Encart 15-10Â : implÃ©mentation de <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code>
</span></p>
<!--
The `type Target = T;` syntax defines an associated type for the `Deref` trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you donâ€™t need to worry about them for now; weâ€™ll cover them in
more detail in Chapter 19.
-->
<p>La syntaxe <code>type Target = T;</code> dÃ©finit un type associÃ© pour le trait <code>Deref</code> Ã 
utiliser. Les types associÃ©s sont une maniÃ¨re lÃ©gÃ¨rement diffÃ©rente de dÃ©clarer
un paramÃ¨tre gÃ©nÃ©rique, mais vous n'avez pas Ã  vous prÃ©occuper d'eux pour le
momentÂ ; nous les verrons plus en dÃ©tail au chapitre 19.</p>
<!--
We fill in the body of the `deref` method with `&self.0` so `deref` returns a
reference to the value we want to access with the `*` operator. The `main`
function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles,
and the assertions pass!
-->
<p>Nous renseignons le corps de la mÃ©thode <code>deref</code> avec <code>&amp;self.0</code> afin que <code>deref</code>
retourne une rÃ©fÃ©rence vers la valeur que nous souhaitons accÃ©der avec
l'opÃ©rateur <code>*</code>. La fonction <code>main</code> de l'encart 15-9 qui appelle <code>*</code> sur la
valeur <code>MaBoite&lt;T&gt;</code> se compile dÃ©sormais, et le <code>assert</code> rÃ©ussit aussiÂ !</p>
<!--
Without the `Deref` trait, the compiler can only dereference `&` references.
The `deref` method gives the compiler the ability to take a value of any type
that implements `Deref` and call the `deref` method to get a `&` reference that
it knows how to dereference.
-->
<p>Sans le trait <code>Deref</code>, le compilateur peut seulement dÃ©rÃ©fÃ©rencer des rÃ©fÃ©rences
<code>&amp;</code>. La mÃ©thode <code>deref</code> donne la possibilitÃ© au compilateur d'obtenir la valeur
de n'importe quel type qui implÃ©mente <code>Deref</code> en appelant la mÃ©thode <code>deref</code>
pour obtenir une rÃ©fÃ©rence <code>&amp;</code> qu'il sait comment dÃ©rÃ©fÃ©rencer.</p>
<!--
When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this
code:
-->
<p>Lorsque nous avons prÃ©cisÃ© <code>*y</code> dans l'encart 15-9, Rust fait tourner ce code en
coulissesÂ :</p>
<!--
```rust,ignore
*(y.deref())
```
-->
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!--
Rust substitutes the `*` operator with a call to the `deref` method and then a
plain dereference so we donâ€™t have to think about whether or not we need to
call the `deref` method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
`Deref`.
-->
<p>Rust remplace l'opÃ©rateur <code>*</code> par un appel Ã  la mÃ©thode <code>deref</code> suivi par un
simple dÃ©rÃ©fÃ©rencement afin que nous n'ayons pas Ã  nous demander si nous devons
ou non appeler la mÃ©thode <code>deref</code>. Cette fonctionnalitÃ© de Rust nous permet
d'Ã©crire du code qui fonctionne de maniÃ¨re identique que nous ayons une
rÃ©fÃ©rence classique ou un type qui implÃ©mente <code>Deref</code>.</p>
<!--
The reason the `deref` method returns a reference to a value, and that the plain
dereference outside the parentheses in `*(y.deref())` is still necessary, is the
ownership system. If the `deref` method returned the value directly instead of
a reference to the value, the value would be moved out of `self`. We donâ€™t want
to take ownership of the inner value inside `MyBox<T>` in this case or in most
cases where we use the dereference operator.
-->
<p>La raison pour laquelle la mÃ©thode <code>deref</code> retourne une rÃ©fÃ©rence Ã  une valeur,
et que le dÃ©rÃ©fÃ©rencement du tout dans les parenthÃ¨ses externes de
<code>*(y.deref())</code> reste nÃ©cessaire, est le systÃ¨me de possession. Si la mÃ©thode
<code>deref</code> retournait la valeur directement au lieu d'une rÃ©fÃ©rence Ã  cette valeur,
la valeur serait <em>dÃ©placÃ©e</em> Ã  l'extÃ©rieur de <code>self</code>. Nous ne souhaitons pas
prendre possession de la valeur Ã  l'intÃ©rieur de <code>MaBoite&lt;T&gt;</code> dans ce cas ainsi
que la plupart des cas oÃ¹ nous utilisons l'opÃ©rateur de dÃ©rÃ©fÃ©rencement.</p>
<!--
Note that the `*` operator is replaced with a call to the `deref` method and
then a call to the `*` operator just once, each time we use a `*` in our code.
Because the substitution of the `*` operator does not recurse infinitely, we
end up with data of type `i32`, which matches the `5` in `assert_eq!` in
Listing 15-9.
-->
<p>Notez que l'opÃ©rateur <code>*</code> est remplacÃ© par un appel Ã  la mÃ©thode <code>deref</code> suivi
par un appel Ã  l'opÃ©rateur <code>*</code> une seule fois, Ã  chaque fois que nous utilisons
un <code>*</code> dans notre code. Comme la substitution de l'opÃ©rateur <code>*</code> ne s'effectue
pas de maniÃ¨re rÃ©cursive et infinie, nous rÃ©cupÃ©rerons une donnÃ©e de type <code>i32</code>,
qui correspond au <code>5</code> du <code>assert_eq!</code> de l'encart 15-9.</p>
<!--
### Implicit Deref Coercions with Functions and Methods
-->
<h3><a class="header" href="#extrapolation-de-dÃ©rÃ©fÃ©rencement-implicite-avec-les-fonctions-et-les-mÃ©thodes" id="extrapolation-de-dÃ©rÃ©fÃ©rencement-implicite-avec-les-fonctions-et-les-mÃ©thodes">Extrapolation de dÃ©rÃ©fÃ©rencement implicite avec les fonctions et les mÃ©thodes</a></h3>
<!--
*Deref coercion* is a convenience that Rust performs on arguments to functions
and methods. Deref coercion works only on types that implement the `Deref`
trait. Deref coercion converts such a type into a reference to another type.
For example, deref coercion can convert `&String` to `&str` because `String`
implements the `Deref` trait such that it returns `str`. Deref coercion happens
automatically when we pass a reference to a particular typeâ€™s value as an
argument to a function or method that doesnâ€™t match the parameter type in the
function or method definition. A sequence of calls to the `deref` method
converts the type we provided into the type the parameter needs.
-->
<p>L'<em>extrapolation de dÃ©rÃ©fÃ©rencement</em> est une commoditÃ© que Rust applique sur les
arguments des fonctions et des mÃ©thodes. L'extrapolation de dÃ©rÃ©fÃ©rencement
fonctionne uniquement avec un type qui implÃ©mente le trait <code>Deref</code>.
L'extrapolation de dÃ©rÃ©fÃ©rencement convertit ce type en une rÃ©fÃ©rence vers un
autre type. Par exemple, l'extrapolation de dÃ©rÃ©fÃ©rencement peut convertir
<code>&amp;String</code> en <code>&amp;str</code> car <code>String</code> implÃ©mente le trait <code>Deref</code> de sorte qu'il
puisse retourner <code>str</code>. L'extrapolation de dÃ©rÃ©fÃ©rencement s'applique
automatiquement lorsque nous passons une rÃ©fÃ©rence vers une valeur d'un type
particulier en argument d'une fonction ou d'une mÃ©thode qui ne correspond pas Ã 
ce type de paramÃ¨tre dans la dÃ©finition de la fonction ou de la mÃ©thode. Une
sÃ©rie d'appels Ã  la mÃ©thode <code>deref</code> convertit le type que nous donnons dans le
type que le paramÃ¨tre nÃ©cessite.</p>
<!--
Deref coercion was added to Rust so that programmers writing function and
method calls donâ€™t need to add as many explicit references and dereferences
with `&` and `*`. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.
-->
<p>L'extrapolation de dÃ©rÃ©fÃ©rencement a Ã©tÃ© ajoutÃ© Ã  Rust afin de permettre aux
dÃ©veloppeurs d'Ã©crire des appels de fonctions et de mÃ©thodes qui n'ont pas
besoin d'indiquer explicitement les rÃ©fÃ©rences et les dÃ©rÃ©fÃ©rencements avec <code>&amp;</code>
et <code>*</code>. La fonctionnalitÃ© d'extrapolation de dÃ©rÃ©fÃ©rencement nous permet aussi
d'Ã©crire plus de code qui peut fonctionner Ã  la fois pour les rÃ©fÃ©rences ou pour
les pointeurs intelligents.</p>
<!--
To see deref coercion in action, letâ€™s use the `MyBox<T>` type we defined in
Listing 15-8 as well as the implementation of `Deref` that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:
-->
<p>Pour voir l'extrapolation de dÃ©rÃ©fÃ©rencement en action, utilisons le type
<code>MaBoite&lt;T&gt;</code> que nous avons dÃ©fini dans l'encart 15-8 ainsi que l'implÃ©mentation
de <code>Deref</code> que nous avons ajoutÃ© dans l'encart 15-10. L'encart 15-11 montre la
dÃ©finition d'une fonction qui a un paramÃ¨tre qui est une slice de chaÃ®ne de
caractÃ¨resÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn saluer(nom: &amp;str) {
    println!(&quot;Salutations, {}Â !&quot;, nom);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-11: A `hello` function that has the parameter
`name` of type `&str`</span>
-->
<p><span class="caption">Encart 15-11Â : une fonction <code>saluer</code> qui prend en
paramÃ¨tre <code>nom</code> du type <code>&amp;str</code></span></p>
<!--
We can call the `hello` function with a string slice as an argument, such as
`hello("Rust");` for example. Deref coercion makes it possible to call `hello`
with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12:
-->
<p>Nous pouvons appeler la fonction <code>saluer</code> avec une slice de chaÃ®ne de caractÃ¨res
en argument, comme par exemple <code>saluer(&quot;Rust&quot;);</code>. L'extrapolation de
dÃ©rÃ©fÃ©rencement rend possible l'appel de <code>saluer</code> avec une rÃ©fÃ©rence Ã  une
valeur du type <code>MaBoite&lt;String&gt;</code>, comme dans l'encart 15-12Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {}Â !&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-12: Calling `hello` with a reference to a
`MyBox<String>` value, which works because of deref coercion</span>
-->
<p><span class="caption">Encart 15-12Â : appel Ã  <code>saluer</code> avec une rÃ©fÃ©rence Ã  une
valeur du type <code>MaBoite&lt;String&gt;</code>, qui fonctionne grÃ¢ce Ã  l'extrapolation de
dÃ©rÃ©fÃ©rencement</span></p>
<!--
Here weâ€™re calling the `hello` function with the argument `&m`, which is a
reference to a `MyBox<String>` value. Because we implemented the `Deref` trait
on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String`
by calling `deref`. The standard library provides an implementation of `Deref`
on `String` that returns a string slice, and this is in the API documentation
for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which
matches the `hello` functionâ€™s definition.
-->
<p>Ici nous appelons la fonction <code>saluer</code> avec l'argument <code>&amp;m</code>, qui est une
rÃ©fÃ©rence vers une valeur de type <code>MaBoite&lt;String&gt;</code>. Comme nous avons implÃ©mentÃ©
le trait <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code> dans l'encart 15-10, Rust peut transformer le
<code>&amp;MaBoite&lt;String&gt;</code> en <code>&amp;String</code> en appelant <code>deref</code>. La bibliothÃ¨que standard
fournit une implÃ©mentation de <code>Deref</code> sur <code>String</code> qui retourne une slice de
chaÃ®ne de caractÃ¨res, comme expliquÃ© dans la documentation de l'API de <code>Deref</code>.
Rust appelle Ã  nouveau <code>deref</code> pour transformer le <code>&amp;String</code> en <code>&amp;str</code>, qui
correspond Ã  la dÃ©finition de la fonction <code>saluer</code>.</p>
<!--
If Rust didnâ€™t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value
of type `&MyBox<String>`.
-->
<p>Si Rust n'avait pas implÃ©mentÃ© l'extrapolation de dÃ©rÃ©fÃ©rencement, nous aurions
dÃ» Ã©crire le code de l'encart 15-13 au lieu du code de l'encart 15-12 pour
appeler <code>saluer</code> avec une valeur du type <code>&amp;MaBoite&lt;String&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {}Â !&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;(*m)[..]);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-13: The code we would have to write if Rust
didnâ€™t have deref coercion</span>
-->
<p><span class="caption">Encart 15-13Â : le code que nous aurions dÃ» Ã©crire si Rust
n'avait pas d'extrapolation de dÃ©rÃ©fÃ©rencement</span></p>
<!--
The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and
`[..]` take a string slice of the `String` that is equal to the whole string to
match the signature of `hello`. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.
-->
<p>Le <code>(*m)</code> dÃ©rÃ©fÃ©rence la <code>MaBoite&lt;String&gt;</code> en une <code>String</code>. Ensuite le <code>&amp;</code> et le
<code>[..]</code> crÃ©ent une slice de chaÃ®ne de caractÃ¨res Ã  partir de la <code>String</code> qui est
Ã©gale Ã  l'intÃ©gralitÃ© du contenu de la <code>String</code>, ceci afin de correspondre Ã  la
signature de <code>saluer</code>. Le code sans l'extrapolation de dÃ©rÃ©fÃ©rencement est bien
plus difficile Ã  lire, Ã©crire et comprendre avec la prÃ©sence de tous ces
symboles. L'extrapolation de dÃ©rÃ©fÃ©rencement permet Ã  Rust d'automatiser ces
convertions pour nous.</p>
<!--
When the `Deref` trait is defined for the types involved, Rust will analyze the
types and use `Deref::deref` as many times as necessary to get a reference to
match the parameterâ€™s type. The number of times that `Deref::deref` needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!
-->
<p>Lorsque le trait <code>Deref</code> est dÃ©fini pour les types concernÃ©s, Rust va analyser
les types et utiliser <code>Deref::deref</code> autant de fois que nÃ©cessaire pour obtenir
une rÃ©fÃ©rence qui correspond au type du paramÃ¨tre. Le nombre de fois qu'il est
nÃ©cessaire d'insÃ©rer <code>Deref::deref</code> est rÃ©solu au moment de la compilation,
ainsi il n'y a pas de surcoÃ»t au moment de l'exÃ©cution pour bÃ©nÃ©ficier de
l'extrapolation de dÃ©rÃ©fÃ©rencementÂ !</p>
<!--
### How Deref Coercion Interacts with Mutability
-->
<h3><a class="header" href="#linteraction-de-lextrapolation-de-dÃ©rÃ©fÃ©rencement-avec-la-mutabilitÃ©" id="linteraction-de-lextrapolation-de-dÃ©rÃ©fÃ©rencement-avec-la-mutabilitÃ©">L'interaction de l'extrapolation de dÃ©rÃ©fÃ©rencement avec la mutabilitÃ©</a></h3>
<!--
Similar to how you use the `Deref` trait to override the `*` operator on
immutable references, you can use the `DerefMut` trait to override the `*`
operator on mutable references.
-->
<p>De la mÃªme maniÃ¨re que vous pouvez utiliser le trait <code>Deref</code> pour remplacer le
comportement de l'opÃ©rateur <code>*</code> sur les rÃ©fÃ©rences immuables, vous pouvez
utiliser le trait <code>DerefMut</code> pour remplacer le comportement de l'opÃ©rateur <code>*</code>
sur les rÃ©fÃ©rences mutables.</p>
<!--
Rust does deref coercion when it finds types and trait implementations in three
cases:
-->
<p>Rust procÃ¨de Ã  l'extrapolation de dÃ©rÃ©fÃ©rencement lorsqu'il trouve des types et
des implÃ©mentations de traits dans trois casÂ :</p>
<!--
* From `&T` to `&U` when `T: Deref<Target=U>`
* From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`
* From `&mut T` to `&U` when `T: Deref<Target=U>`
-->
<ul>
<li>Passer de <code>&amp;T</code> Ã  <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> Ã  <code>&amp;mut U</code> lorsque <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> Ã  <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<!--
The first two cases are the same except for mutability. The first case states
that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can
get a `&U` transparently. The second case states that the same deref coercion
happens for mutable references.
-->
<p>Les deux premiers cas sont exactement les mÃªmes, sauf pour la mutabilitÃ©. Le
premier cas signifie que si vous avez un <code>&amp;T</code> et que <code>T</code> implÃ©mente <code>Deref</code> pour
le type <code>U</code>, vous pouvez obtenir un <code>&amp;U</code> de maniÃ¨re transparente. Le second cas
signifie que la mÃªme extrapolation de dÃ©rÃ©fÃ©rencement se dÃ©roule pour les
rÃ©fÃ©rences mutables.</p>
<!--
The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is *not* possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldnâ€™t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules donâ€™t guarantee that. Therefore, Rust canâ€™t make the
assumption that converting an immutable reference to a mutable reference is
possible.
-->
<p>Le troisiÃ¨me cas est plus ardueÂ : Rust va aussi procÃ©der Ã  une extrapolation de
dÃ©rÃ©fÃ©rencement d'une rÃ©fÃ©rence immuable vers une rÃ©fÃ©rence mutable. A cause des
rÃ¨gles d'emprunt, si vous avez une rÃ©fÃ©rence mutable, cette rÃ©fÃ©rence mutable
doit Ãªtre la seule rÃ©fÃ©rence vers cette donnÃ©e (autrement, le programme ne peut
pas Ãªtre compilÃ©). Convertir une rÃ©fÃ©rence mutable vers une rÃ©fÃ©rence immuable
ne va jamais casser les rÃ¨gles d'emprunt. Convertir une rÃ©fÃ©rence immuable vers
une rÃ©fÃ©rence mutable nÃ©cessite que la rÃ©fÃ©rence immuable initiale soit la seule
rÃ©fÃ©rence immuable vers cette donnÃ©e, mais les rÃ¨gles d'emprunt n'empÃªchent pas
cela. Ainsi, Rust ne peut pas dÃ©duire que la conversion d'une rÃ©fÃ©rence immuable
vers une rÃ©fÃ©rence mutable soit possible.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch15-01-box.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch15-03-drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch15-01-box.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch15-03-drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
