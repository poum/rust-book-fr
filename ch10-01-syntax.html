<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les types de donnÃ©es gÃ©nÃ©riques - Le langage de programmation Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../ferris.css">
                <link rel="stylesheet" href="../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html" class="active"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/109">Pull Request</a>.</p>
</blockquote>
<!--
## Generic Data Types
-->
<h2 id="les-types-de-donnÃ©es-gÃ©nÃ©riques"><a class="header" href="#les-types-de-donnÃ©es-gÃ©nÃ©riques">Les types de donnÃ©es gÃ©nÃ©riques</a></h2>
<!--
We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Letâ€™s
first look at how to define functions, structs, enums, and methods using
generics. Then weâ€™ll discuss how generics affect code performance.
-->
<p>Nous pouvons utiliser la gÃ©nÃ©ricitÃ© pour crÃ©er des dÃ©finitions pour des Ã©lÃ©ments
comme les signatures de fonctions ou les structures, que nous pouvons ensuite
utiliser sur de nombreux types de donnÃ©es concrets. CommenÃ§ons par regarder
comment dÃ©finir des fonctions, des structures, des Ã©numÃ©rations, et des mÃ©thodes
en utilisant la gÃ©nÃ©ricitÃ©. Ensuite nous verrons comment la gÃ©nÃ©ricitÃ© impacte
la performance du code.</p>
<!--
### In Function Definitions
-->
<h3 id="dans-la-dÃ©finition-dune-fonction"><a class="header" href="#dans-la-dÃ©finition-dune-fonction">Dans la dÃ©finition d'une fonction</a></h3>
<!--
When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.
-->
<p>Lorsque nous dÃ©finissons une fonction en utilisant la gÃ©nÃ©ricitÃ©, nous utilisons
des types gÃ©nÃ©riques dans la signature de la fonction lÃ  oÃ¹ nous prÃ©cisons
habituellement
les types de donnÃ©es des paramÃ¨tres et de la valeur de retour. Faire ainsi rend
notre code plus flexible et apporte plus de fonctionnalitÃ©s au code appelant
notre fonction, tout en Ã©vitant la duplication de code.</p>
<!--
Continuing with our `largest` function, Listing 10-4 shows two functions that
both find the largest value in a slice.
-->
<p>Pour continuer avec notre fonction <code>le_plus_grand</code>, l'encart 10-4 nous montre
deux fonctions qui trouvent toutes les deux la valeur la plus grande dans une
slice.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
#     assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
#     assert_eq!(result, 'y');
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand_i32(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn le_plus_grand_caractere(liste: &amp;[char]) -&gt; char {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand_i32(&amp;liste_de_nombres);
    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand_caractere(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 'y');
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span>
-->
<p><span class="caption">Encart 10-4Â : deux fonctions qui se distinguent seulement
par leur nom et le type dans leur signature</span></p>
<!--
The `largest_i32` function is the one we extracted in Listing 10-3 that finds
the largest `i32` in a slice. The `largest_char` function finds the largest
`char` in a slice. The function bodies have the same code, so letâ€™s eliminate
the duplication by introducing a generic type parameter in a single function.
-->
<p>La fonction <code>le_plus_grand_i32</code> est celle que nous avons construite Ã  l'encart 10-3
lorsqu'elle trouvait le plus grand <code>i32</code> dans une slice. La fonction
<code>le_plus_grand_caractere</code> recherche le plus grand <code>char</code> dans une slice. Les
corps des fonctions ont le mÃªme code, donc essayons d'Ã©viter cette duplication
en utilisant un paramÃ¨tre de type gÃ©nÃ©rique dans une seule et unique fonction.</p>
<!--
To parameterize the types in the new function weâ€™ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But weâ€™ll use `T` because, by
convention, parameter names in Rust are short, often just a letter, and Rustâ€™s
type-naming convention is CamelCase. Short for â€œtype,â€ `T` is the default
choice of most Rust programmers.
-->
<p>Pour paramÃ©trer les types dans la nouvelle fonction que nous allons dÃ©finir,
nous avons besoin de donner un nom au paramÃ¨tre de type, comme nous l'avons
fait pour les paramÃ¨tres de valeur des fonctions. Vous pouvez utiliser
n'importe quel identificateur pour nommer le paramÃ¨tre de type. Mais ici nous allons
utiliser <code>T</code> car, par convention, les noms de paramÃ¨tres en Rust sont courts,
souvent mÃªme une seule lettre, et la convention de nommage des types en Rust est
d'utiliser le CamelCase. Et puisque la version courte de â€œtypeâ€ est <code>T</code>, c'est
le choix par dÃ©faut de nombreux dÃ©veloppeurs Rust.</p>
<!--
When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
`largest` function, place type name declarations inside angle brackets, `<>`,
between the name of the function and the parameter list, like this:
-->
<p>Lorsqu'on utilise un paramÃ¨tre dans le corps de la fonction, nous devons
dÃ©clarer le nom du paramÃ¨tre dans la signature afin que le compilateur puisse
savoir Ã  quoi rÃ©fÃ¨re ce nom. De la mÃªme maniÃ¨re, lorsqu'on utilise un nom de
paramÃ¨tre de type dans la signature d'une fonction, nous devons dÃ©clarer le nom
du paramÃ¨tre de type avant de pouvoir l'utiliser. Pour dÃ©clarer la fonction
gÃ©nÃ©rique <code>le_plus_grand</code>, il faut placer la dÃ©claration du nom du type entre
des chevrons <code>&lt;&gt;</code>, le tout entre le nom de la fonction et la liste des
paramÃ¨tres, comme ceciÂ :</p>
<!--
```rust,ignore
fn largest<T>(list: &[T]) -> T {
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; &amp;T {
</code></pre>
<!--
We read this definition as: the function `largest` is generic over some type
`T`. This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a value of the
same type `T`.
-->
<p>Cette dÃ©finition se lit comme ceciÂ : la fonction <code>le_plus_grand</code> est gÃ©nÃ©rique
en fonction du type <code>T</code>. Cette fonction a un paramÃ¨tre qui s'appelle <code>liste</code>,
qui est une slice de valeurs de type <code>T</code>. Cette fonction <code>le_plus_grand</code> va
retourner une rÃ©fÃ©rence vers la valeur du mÃªme type <code>T</code>.</p>
<!--
Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code wonâ€™t
compile yet, but weâ€™ll fix it later in this chapter.
-->
<p>L'encart 10-5 nous montre la combinaison de la dÃ©finition de la fonction
<code>le_plus_grand</code> avec le type de donnÃ©es gÃ©nÃ©rique prÃ©sent dans sa signature.
L'encart montre aussi que nous pouvons appeler la fonction avec une slice soit
de valeurs <code>i32</code>, soit de valeurs <code>char</code>. Notez que ce code ne se compile pas
encore, mais nous allons y remÃ©dier plus tard dans ce chapitre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-5: A definition of the `largest` function that
uses generic type parameters but doesnâ€™t compile yet</span>
-->
<p><span class="caption">Encart 10-5Â : une dÃ©finition de la fonction
<code>le_plus_grand</code> qui utilise des paramÃ¨tres de type gÃ©nÃ©riques, mais qui ne
compile pas encore</span></p>
<!--
If we compile this code right now, weâ€™ll get this error:
-->
<p>Si nous essayons de compiler ce code dÃ¨s maintenant, nous aurons l'erreur
suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                  ^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
</code></pre>
<!--
The note mentions `std::cmp::PartialOrd`, which is a *trait*. Weâ€™ll talk about
traits in the next section. For now, this error states that the body of
`largest` wonâ€™t work for all possible types that `T` could be. Because we want
to compare values of type `T` in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
`std::cmp::PartialOrd` trait that you can implement on types (see Appendix C
for more on this trait). Youâ€™ll learn how to specify that a generic type has a
particular trait in the [â€œTraits as Parametersâ€][traits-as-parameters]<!--
ignore -- > section, but letâ€™s first explore other ways of using generic type
parameters.
-->
<p>La note cite <code>std::cmp::PartialOrd</code>, qui est un <em>trait</em>. Nous allons voir les
traits dans la prochaine section. Pour le moment, cette erreur nous informe que
le corps de <code>le_plus_grand</code> ne va pas fonctionner pour tous les types possibles
que <code>T</code> peut reprÃ©senter. Comme nous voulons comparer des valeurs de type <code>T</code>
dans le corps, nous pouvons utiliser uniquement des types dont les valeurs
peuvent Ãªtre triÃ©es dans l'ordre. Pour effectuer des comparaisons, la bibliothÃ¨que
standard propose le trait <code>std::cmp::PartialOrd</code> que vous pouvez implÃ©menter sur
des types (voir l'annexe C pour en savoir plus sur ce trait). Vous allez
apprendre Ã  indiquer qu'un type gÃ©nÃ©rique a un trait spÃ©cifique dans la section
<a href="ch10-02-traits.html#des-traits-en-param%C3%A8tres">â€œDes traits en paramÃ¨tresâ€</a><!-- ignore -->, mais d'abord
nous allons explorer d'autres maniÃ¨res d'utiliser les paramÃ¨tres de types
gÃ©nÃ©riques.</p>
<!--
### In Struct Definitions
-->
<h3 id="dans-la-dÃ©finition-des-structures"><a class="header" href="#dans-la-dÃ©finition-des-structures">Dans la dÃ©finition des structures</a></h3>
<!--
We can also define structs to use a generic type parameter in one or more
fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>`
struct to hold `x` and `y` coordinate values of any type.
-->
<p>Nous pouvons aussi dÃ©finir des structures en utilisant des paramÃ¨tres de type
gÃ©nÃ©riques dans un ou plusieurs champs en utilisant la syntaxe <code>&lt;&gt;</code>. L'encart
10-6 nous montre comment dÃ©finir une structure <code>Point&lt;T&gt;</code> pour stocker des
valeurs de coordonnÃ©es <code>x</code> et <code>y</code> de n'importe quel type.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let entiers = Point { x: 5, y: 10 };
    let flottants = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y`
values of type `T`</span>
-->
<p><span class="caption">Encart 10-6Â : une structure <code>Point&lt;T&gt;</code> qui stocke les
valeurs <code>x</code> et <code>y</code> de type <code>T</code></span></p>
<!--
The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.
-->
<p>La syntaxe pour l'utilisation des gÃ©nÃ©riques dans les dÃ©finitions de structures
est similaire Ã  celle utilisÃ©e dans les dÃ©finitions de fonctions. D'abord, on
dÃ©clare le nom du paramÃ¨tre de type entre des chevrons juste aprÃ¨s le nom de la
structure. Ensuite, on peut utiliser le type gÃ©nÃ©rique dans la dÃ©finition de la
structure lÃ  oÃ¹ on indiquerait en temps normal des types de donnÃ©es concrets.</p>
<!--
Note that because weâ€™ve used only one generic type to define `Point<T>`, this
definition says that the `Point<T>` struct is generic over some type `T`, and
the fields `x` and `y` are *both* that same type, whatever that type may be. If
we create an instance of a `Point<T>` that has values of different types, as in
Listing 10-7, our code wonâ€™t compile.
-->
<p>Notez que comme nous n'avons utilisÃ© qu'un seul type gÃ©nÃ©rique pour dÃ©finir
<code>Point&lt;T&gt;</code>, cette dÃ©finition dit que la structure <code>Point&lt;T&gt;</code> est gÃ©nÃ©rique en
fonction d'un type <code>T</code>, et les champs <code>x</code> et <code>y</code> sont <em>tous les deux</em> de ce mÃªme
type, quel qu'il soit. Si nous crÃ©ons une instance de <code>Point&lt;T&gt;</code> qui a des
valeurs de types diffÃ©rents, comme dans l'encart 10-7, notre code ne va pas se
compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
}
</code></pre>
<!--
<span class="caption">Listing 10-7: The fields `x` and `y` must be the same
type because both have the same generic data type `T`.</span>
-->
<p><span class="caption">Encart 10-7Â : les champs <code>x</code> et <code>y</code> doivent Ãªtre du mÃªme
type car ils ont tous les deux le mÃªme type de donnÃ©es gÃ©nÃ©rique <code>T</code>.</span></p>
<!--
In this example, when we assign the integer value 5 to `x`, we let the
compiler know that the generic type `T` will be an integer for this instance of
`Point<T>`. Then when we specify 4.0 for `y`, which weâ€™ve defined to have the
same type as `x`, weâ€™ll get a type mismatch error like this:
-->
<p>Dans cet exemple, lorsque nous assignons l'entier 5 Ã  <code>x</code>, nous laissons
entendre au compilateur que le type gÃ©nÃ©rique <code>T</code> sera un entier pour cette
instance de <code>Point&lt;T&gt;</code>. Ensuite, lorsque nous assignons 4.0 Ã  <code>y</code>, que nous avons
dÃ©fini comme ayant le mÃªme type que <code>x</code>, nous obtenons une erreur d'incompatibilitÃ© de
type comme celle-ciÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 -- > src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
  |                                                ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
</code></pre>
<!--
To define a `Point` struct where `x` and `y` are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of `Point` to be generic over types
`T` and `U` where `x` is of type `T` and `y` is of type `U`.
-->
<p>Pour dÃ©finir une structure <code>Point</code> oÃ¹ <code>x</code> et <code>y</code> sont tous les deux gÃ©nÃ©riques
mais peuvent avoir des types diffÃ©rents, nous pouvons utiliser plusieurs 
paramÃ¨tres de types gÃ©nÃ©riques diffÃ©rents. Par exemple, dans l'encart 10-8, 
nous pouvons changer la dÃ©finition de <code>Point</code> pour Ãªtre gÃ©nÃ©rique en 
fonction des types <code>T</code> et <code>U</code> oÃ¹ <code>x</code> est de type <code>T</code> et <code>y</code> est de type <code>U</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let deux_entiers = Point { x: 5, y: 10 };
    let deux_flottants = Point { x: 1.0, y: 4.0 };
    let un_entier_et_un_flottant = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so
that `x` and `y` can be values of different types</span>
-->
<p><span class="caption">Encart 10-8: un <code>Point&lt;T, U&gt;</code> gÃ©nÃ©rique en fonction de
deux types <code>x</code> et <code>y</code> qui peuvent Ãªtre des valeurs de types diffÃ©rents</span></p>
<!--
Now all the instances of `Point` shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.
-->
<p>Maintenant, toutes les instances de <code>Point</code> montrÃ©es ici sont validesÂ ! Vous
pouvez utiliser autant de paramÃ¨tres de type gÃ©nÃ©riques que vous souhaitez dans
la dÃ©claration de la dÃ©finition, mais en utiliser plus de quelques-uns rend
votre code difficile Ã  lire. Lorsque vous avez besoin de nombreux types
gÃ©nÃ©riques dans votre code, cela peut Ãªtre un signe que votre code a besoin
d'Ãªtre remaniÃ© en Ã©lÃ©ments plus petits.</p>
<!--
### In Enum Definitions
-->
<h3 id="dans-les-dÃ©finitions-dÃ©numÃ©rations"><a class="header" href="#dans-les-dÃ©finitions-dÃ©numÃ©rations">Dans les dÃ©finitions d'Ã©numÃ©rations</a></h3>
<!--
As we did with structs, we can define enums to hold generic data types in their
variants. Letâ€™s take another look at the `Option<T>` enum that the standard
library provides, which we used in Chapter 6:
-->
<p>Comme nous l'avons fait avec les structures, nous pouvons dÃ©finir des
Ã©numÃ©rations qui utilisent des types de donnÃ©es gÃ©nÃ©riques dans leurs variantes.
CommenÃ§ons par regarder Ã  nouveau l'Ã©numÃ©ration <code>Option&lt;T&gt;</code> que fournit la
bibliothÃ¨que standard, et que nous avons utilisÃ©e au chapitre 6Â :</p>
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This definition should now make more sense to you. As you can see, `Option<T>`
is an enum that is generic over type `T` and has two variants: `Some`, which
holds one value of type `T`, and a `None` variant that doesnâ€™t hold any value.
By using the `Option<T>` enum, we can express the abstract concept of having an
optional value, and because `Option<T>` is generic, we can use this abstraction
no matter what the type of the optional value is.
-->
<p>Cette dÃ©finition devrait dÃ©sormais avoir plus de sens pour vous. Comme vous pouvez le
constater, <code>Option&lt;T&gt;</code> est une Ã©numÃ©ration qui est gÃ©nÃ©rique en fonction du type
<code>T</code> et a deux variantesÂ : <code>Some</code>, qui contient une valeur de type <code>T</code>, et une
variante <code>None</code> qui ne contient aucune valeur. En utilisant l'Ã©numÃ©ration
<code>Option&lt;T&gt;</code>, nous pouvons exprimer le concept abstrait d'avoir une valeur
optionnelle, et comme <code>Option&lt;T&gt;</code> est gÃ©nÃ©rique, nous pouvons utiliser cette
abstraction peu importe le type de la valeur optionnelle.</p>
<!--
Enums can use multiple generic types as well. The definition of the `Result`
enum that we used in Chapter 9 is one example:
-->
<p>Les Ã©numÃ©rations peuvent aussi utiliser plusieurs types gÃ©nÃ©riques. La
dÃ©finition de l'Ã©numÃ©ration <code>Result</code> que nous avons utilisÃ©e au chapitre 9 en est
un exempleÂ :</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result` enum is generic over two types, `T` and `E`, and has two variants:
`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type
`E`. This definition makes it convenient to use the `Result` enum anywhere we
have an operation that might succeed (return a value of some type `T`) or fail
(return an error of some type `E`). In fact, this is what we used to open a
file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when
the file was opened successfully and `E` was filled in with the type
`std::io::Error` when there were problems opening the file.
-->
<p>L'Ã©numÃ©ration <code>Result</code> est gÃ©nÃ©rique en fonction de deux types, <code>T</code> et <code>E</code>, et a
deux variantesÂ : <code>Ok</code>, qui contient une valeur de type <code>T</code>, et <code>Err</code>, qui
contient une valeur de type <code>E</code>. Cette dÃ©finition rend possible l'utilisation de
l'Ã©numÃ©ration <code>Result</code> partout oÃ¹ nous avons une opÃ©ration qui peut rÃ©ussir (et
retourner une valeur du type <code>T</code>) ou Ã©chouer (et retourner une erreur du type
<code>E</code>). En fait, c'est ce qui est utilisÃ© pour ouvrir un fichier dans l'encart
9-3, oÃ¹ <code>T</code> contenait un type <code>std::fs::File</code> lorsque le fichier Ã©tait ouvert
avec succÃ¨s et <code>E</code> contenait un type <code>std::io::Error</code> lorsqu'il y avait des
problÃ¨mes pour ouvrir le fichier.</p>
<!--
When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.
-->
<p>Lorsque vous reconnaÃ®trez des cas dans votre code oÃ¹ vous aurez plusieurs
dÃ©finitions de structures ou d'Ã©numÃ©rations qui se distinguent uniquement par le
type de valeurs qu'elles stockent, vous pourrez Ã©viter les doublons en utilisant
des types gÃ©nÃ©riques Ã  la place.</p>
<!--
### In Method Definitions
-->
<h3 id="dans-la-dÃ©finition-des-mÃ©thodes"><a class="header" href="#dans-la-dÃ©finition-des-mÃ©thodes">Dans la dÃ©finition des mÃ©thodes</a></h3>
<!--
We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the `Point<T>`
struct we defined in Listing 10-6 with a method named `x` implemented on it.
-->
<p>Nous pouvons implÃ©menter des mÃ©thodes sur des structures et des Ã©numÃ©rations
(comme nous l'avons fait dans le chapitre 5) et aussi utiliser des types
gÃ©nÃ©riques dans leurs dÃ©finitions. L'encart 10-9 montre la structure <code>Point&lt;T&gt;</code>
que nous avons dÃ©finie dans l'encart 10-6 avec une mÃ©thode qui s'appelle <code>x</code>
implÃ©mentÃ©e sur cette derniÃ¨re.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-9: Implementing a method named `x` on the
`Point<T>` struct that will return a reference to the `x` field of type
`T`</span>
-->
<p><span class="caption">Encart 10-9Â : implÃ©mentation d'une mÃ©thode <code>x</code> sur la
structure <code>Point&lt;T&gt;</code> qui va retourner une rÃ©fÃ©rence au champ <code>x</code>, de type <code>T</code>
</span></p>
<!--
Here, weâ€™ve defined a method named `x` on `Point<T>` that returns a reference
to the data in the field `x`.
-->
<p>Ici, nous avons dÃ©fini une mÃ©thode qui s'appelle <code>x</code> sur <code>Point&lt;T&gt;</code> qui retourne
une rÃ©fÃ©rence Ã  la donnÃ©e prÃ©sente dans le champ <code>x</code>.</p>
<!--
Note that we have to declare `T` just after `impl` so we can use it to specify
that weâ€™re implementing methods on the type `Point<T>`.  By declaring `T` as a
generic type after `impl`, Rust can identify that the type in the angle
brackets in `Point` is a generic type rather than a concrete type.
-->
<p>Notez que nous devons dÃ©clarer <code>T</code> juste aprÃ¨s <code>impl</code> afin de pouvoir l'utiliser
pour prÃ©ciser que nous implÃ©mentons des mÃ©thodes sur le type <code>Point&lt;T&gt;</code>. En
dÃ©clarant <code>T</code> comme un type gÃ©nÃ©rique aprÃ¨s <code>impl</code>, Rust peut comprendre que le
type entre les chevrons dans <code>Point</code> est un type gÃ©nÃ©rique plutÃ´t qu'un type
concret.</p>
<!--
We could, for example, implement methods only on `Point<f32>` instances rather
than on `Point<T>` instances with any generic type. In Listing 10-10 we use the
concrete type `f32`, meaning we donâ€™t declare any types after `impl`.
-->
<p>Nous pouvons par exemple implÃ©menter des mÃ©thodes uniquement sur des instances
de <code>Point&lt;f32&gt;</code> plutÃ´t que sur des instances de n'importe quel type <code>Point&lt;T&gt;</code>.
Dans l'encart 10-10, nous utilisons le type concret <code>f32</code>, ce qui veut dire que
nous n'avons pas besoin de dÃ©clarer un type aprÃ¨s <code>impl</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
# 
# impl<T> Point<T> {
#     fn x(&self) -> &T {
#         &self.x
#     }
# }
# 
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
# 
# fn main() {
#     let p = Point { x: 5, y: 10 };
# 
#     println!("p.x = {}", p.x());
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_depuis_lorigine(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-10: An `impl` block that only applies to a
struct with a particular concrete type for the generic type parameter `T`</span>
-->
<p><span class="caption">Encart 10-10Â : un bloc <code>impl</code> qui ne s'applique que sur
une structure d'un type concret particulier pour le paramÃ¨tre de type gÃ©nÃ©rique
<code>T</code>
</span></p>
<!--
This code means the type `Point<f32>` will have a method named
`distance_from_origin` and other instances of `Point<T>` where `T` is not of
type `f32` will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.
-->
<p>Ce code signifie que le type <code>Point&lt;f32&gt;</code> va avoir une mÃ©thode qui s'appelle
<code>distance_depuis_lorigine</code> et les autres instances de <code>Point&lt;T&gt;</code> oÃ¹ <code>T</code> n'est
pas du type <code>f32</code> ne pourront pas appeler cette mÃ©thode. Cette mÃ©thode 
calcule la distance entre notre point et la coordonnÃ©e (0.0, 0.0) et utilise des
opÃ©rations mathÃ©matiques qui ne sont disponibles que pour les types de
flottants.</p>
<!--
Generic type parameters in a struct definition arenâ€™t always the same as those
you use in that structâ€™s method signatures. For example, Listing 10-11 defines
the method `mixup` on the `Point<T, U>` struct from Listing 10-8. The method
takes another `Point` as a parameter, which might have different types from the
`self` `Point` weâ€™re calling `mixup` on. The method creates a new `Point`
instance with the `x` value from the `self` `Point` (of type `T`) and the `y`
value from the passed-in `Point` (of type `W`).
-->
<p>Les paramÃ¨tres de type gÃ©nÃ©riques dans la dÃ©finition d'une structure ne sont
pas toujours les mÃªmes que ceux qui sont utilisÃ©s dans la signature des
mÃ©thodes de cette structure. Par exemple, l'encart 10-11 dÃ©finit la mÃ©thode
<code>melange</code> sur la structure <code>Point&lt;T, U&gt;</code> de l'encart 10-8. La mÃ©thode prend un
autre <code>Point</code> en paramÃ¨tre, qui peut avoir des types diffÃ©rents du <code>Point</code>
<code>self</code> sur lequel nous appelons <code>melange</code>. La mÃ©thode crÃ©e une nouvelle
instance de <code>Point</code> avec la valeur de <code>x</code> provenant du <code>Point</code> <code>self</code> (de type
<code>T</code>) et la valeur de <code>y</code> provenant du <code>Point</code> en paramÃ¨tre (de type <code>W</code>).</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn melange&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.melange(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-11: A method that uses different generic types
from its structâ€™s definition</span>
-->
<p><span class="caption">Encart 10-11Â : une mÃ©thode qui utilise diffÃ©rents types
gÃ©nÃ©riques provenant de la dÃ©finition de la structure</span></p>
<!--
In `main`, weâ€™ve defined a `Point` that has an `i32` for `x` (with value `5`)
and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct
that has a string slice for `x` (with value `"Hello"`) and a `char` for `y`
(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,
which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable
will have a `char` for `y`, because `y` came from `p2`. The `println!` macro
call will print `p3.x = 5, p3.y = c`.
-->
<p>Dans le <code>main</code>, nous avons dÃ©fini un <code>Point</code> qui a un <code>i32</code> pour <code>x</code> (avec la
valeur <code>5</code>) et un <code>f64</code> pour <code>y</code> (avec la valeur 10.4). La variable <code>p2</code> est une
structure <code>Point</code> qui a une slice de chaine de caractÃ¨res pour <code>x</code> (avec la
valeur <code>&quot;Hello&quot;</code>) et un caractÃ¨re <code>char</code> pour <code>y</code> (avec la valeur <code>c</code>). L'appel
Ã  <code>melange</code> sur <code>p1</code> avec l'argument <code>p2</code> nous donne <code>p3</code>, qui aura un <code>i32</code> pour
<code>x</code>, car <code>x</code> provient de <code>p1</code>. La variable <code>p3</code> aura un caractÃ¨re <code>char</code> pour
<code>y</code>, car <code>y</code> provient de <code>p2</code>. L'appel Ã  la macro <code>println!</code> va afficher
<code>p3.x = 5, p3.y = c</code>.</p>
<!--
The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with `impl` and some are declared with the method
definition. Here, the generic parameters `T` and `U` are declared after `impl`,
because they go with the struct definition. The generic parameters `V` and `W`
are declared after `fn mixup`, because theyâ€™re only relevant to the method.
-->
<p>Le but de cet exemple est de montrer une situation dans laquelle des paramÃ¨tres
gÃ©nÃ©riques sont dÃ©clarÃ©s avec <code>impl</code> et d'autres sont dÃ©clarÃ©s dans la
dÃ©finition de la mÃ©thode. Ici, les paramÃ¨tres gÃ©nÃ©riques <code>T</code> et <code>U</code> sont
dÃ©clarÃ©s aprÃ¨s <code>impl</code>, car ils sont liÃ©s Ã  la dÃ©finition de la structure. Les
paramÃ¨tres gÃ©nÃ©riques <code>V</code> et <code>W</code> sont dÃ©clarÃ©s aprÃ¨s <code>fn melange</code>, car ils ne
sont liÃ©s qu'Ã  cette mÃ©thode.</p>
<!--
### Performance of Code Using Generics
-->
<h3 id="performance-du-code-utilisant-les-gÃ©nÃ©riques"><a class="header" href="#performance-du-code-utilisant-les-gÃ©nÃ©riques">Performance du code utilisant les gÃ©nÃ©riques</a></h3>
<!--
You might be wondering whether there is a runtime cost when youâ€™re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesnâ€™t run any slower using generic types than it would
with concrete types.
-->
<p>Vous vous demandez peut-Ãªtre s'il y a un coÃ»t Ã  l'exÃ©cution lorsque vous
utilisez des paramÃ¨tres de type gÃ©nÃ©riques. La bonne nouvelle est que Rust
implÃ©mente les gÃ©nÃ©riques de maniÃ¨re Ã  ce que votre code ne s'exÃ©cute pas plus
lentement que vous utilisiez les types gÃ©nÃ©riques ou des types concrets.</p>
<!--
Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. *Monomorphization* is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.
-->
<p>Rust accomplit cela en pratiquant la monomorphisation Ã  la compilation du code
qui utilise les gÃ©nÃ©riques. La <em>monomorphisation</em> est un processus qui transforme
du code gÃ©nÃ©rique en code spÃ©cifique en dÃ©finissant au moment de la compilation les
types concrets utilisÃ©s dans le code.</p>
<!--
In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.
-->
<p>Dans ce processus, le compilateur fait l'inverse des Ã©tapes que nous avons suivies
pour crÃ©er la fonction gÃ©nÃ©rique de l'encart 10-5Â : le compilateur cherche tous
les endroits oÃ¹ le code gÃ©nÃ©rique est utilisÃ© et gÃ©nÃ¨re du code pour les types
concrets avec lesquels le code gÃ©nÃ©rique est appelÃ©.</p>
<!--
Letâ€™s look at how this works with an example that uses the standard libraryâ€™s
`Option<T>` enum:
-->
<p>Regardons comment cela fonctionne avec un exemple qui utilise l'Ã©numÃ©ration
<code>Option&lt;T&gt;</code> de la bibliothÃ¨que standardÂ :</p>
<!--
```rust
let integer = Some(5);
let float = Some(5.0);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entier = Some(5);
let flottant = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<!--
When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in `Option<T>`
instances and identifies two kinds of `Option<T>`: one is `i32` and the other
is `f64`. As such, it expands the generic definition of `Option<T>` into
`Option_i32` and `Option_f64`, thereby replacing the generic definition with
the specific ones.
-->
<p>Lorsque Rust compile ce code, il applique la monomorphisation. Pendant ce
processus, le compilateur lit les valeurs qui ont Ã©tÃ© utilisÃ©es dans les
instances de <code>Option&lt;T&gt;</code> et en dÃ©duit les deux sortes de <code>Option&lt;T&gt;</code>Â : une est
<code>i32</code> et l'autre est <code>f64</code>. Ainsi, il dÃ©compose la dÃ©finition gÃ©nÃ©rique de
<code>Option&lt;T&gt;</code> en <code>Option_i32</code> et en <code>Option_f64</code>, remplaÃ§ant ainsi la dÃ©finition
gÃ©nÃ©rique par deux dÃ©finitions concrÃ¨tes.</p>
<!--
The monomorphized version of the code looks like the following. The generic
`Option<T>` is replaced with the specific definitions created by the compiler:
-->
<p>La version monomorphe du code ressemble Ã  ce qui suit. Le <code>Option&lt;T&gt;</code> gÃ©nÃ©rique
est remplacÃ© par deux dÃ©finitions concrÃ¨tes crÃ©Ã©es par le compilateurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let entier = Option_i32::Some(5);
    let flottant = Option_f64::Some(5.0);
}
</code></pre></pre>
<!--
Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rustâ€™s generics extremely efficient at
runtime.
-->
<p>Comme Rust compile le code gÃ©nÃ©rique dans du code qui prÃ©cise le type dans
chaque instance, l'utilisation des gÃ©nÃ©riques n'a pas de consÃ©quence sur les
performances de l'exÃ©cution. Quand le code s'exÃ©cute, il fonctionne comme il
devrait le faire si nous avions dupliquÃ© chaque dÃ©finition Ã  la main. Le
processus de monomorphisation rend les gÃ©nÃ©riques de Rust trÃ¨s performants au
moment de l'exÃ©cution.</p>
<!--
[traits-as-parameters]: ch10-02-traits.html#traits-as-parameters
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../ferris.js"></script>
                <script type="text/javascript" src="github-button.js"></script>
        
        
    </body>
</html>
