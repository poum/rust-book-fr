<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html" class="active"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/194">Pull Request</a>.</p>
</blockquote>
<!--
## `RefCell<T>` and the Interior Mutability Pattern
-->
<h2><a class="header" href="#refcellt-et-le-motif-de-mutabilitÃ©-interne" id="refcellt-et-le-motif-de-mutabilitÃ©-interne"><code>RefCell&lt;T&gt;</code> et le motif de mutabilitÃ© interne</a></h2>
<!--
*Interior mutability* is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
`unsafe` code inside a data structure to bend Rustâ€™s usual rules that govern
mutation and borrowing. We havenâ€™t yet covered unsafe code; we will in Chapter
19. We can use types that use the interior mutability pattern when we can
ensure that the borrowing rules will be followed at runtime, even though the
compiler canâ€™t guarantee that. The `unsafe` code involved is then wrapped in a
safe API, and the outer type is still immutable.
-->
<p>La <em>mutabilitÃ© interne</em> est un motif de conception en Rust qui vous permet de
muter une donnÃ©e mÃªme s'il existe des rÃ©fÃ©rences immuablesÂ ; normalement, cette
action n'est pas autorisÃ©e par les rÃ¨gles d'emprunt. Pour muter des donnÃ©es, le
motif utilise du code <code>unsafe</code> dans une structure de donnÃ©es pour contourner les
rÃ¨gles courantes de Rust qui gouvernent la mutation et l'emprunt. Nous n'avons
pas encore parlÃ© du code unsafeÂ ; nous le ferons au chapitre 19. Nous pouvons
utiliser des types qui utilisent le motif de mutabilitÃ© interne lorsque nous
pouvons Ãªtre sÃ»r que les rÃ¨gles d'emprunt seront suivies au moment de
l'exÃ©cution, mÃªme si le compilateur ne peut pas en Ãªtre sÃ»r. Le code <code>unsafe</code>
concernÃ© est ensuite incorporÃ© dans une API stable, et le type externe reste
immuable.</p>
<!--
Letâ€™s explore this concept by looking at the `RefCell<T>` type that follows the
interior mutability pattern.
-->
<p>DÃ©couvrons ce concept en examinant le type <code>RefCell&lt;T&gt;</code> qui applique le motif
de mutabilitÃ© interne.</p>
<!--
### Enforcing Borrowing Rules at Runtime with `RefCell<T>`
-->
<h3><a class="header" href="#appliquer-les-rÃ¨gles-demprunt-au-moment-de-lexÃ©cution-avec-refcellt" id="appliquer-les-rÃ¨gles-demprunt-au-moment-de-lexÃ©cution-avec-refcellt">Appliquer les rÃ¨gles d'emprunt au moment de l'exÃ©cution avec <code>RefCell&lt;T&gt;</code></a></h3>
<!--
Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the data
it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`?
Recall the borrowing rules you learned in Chapter 4:
-->
<p>Contrairement Ã  <code>Rc&lt;T&gt;</code>, le type <code>RefCell&lt;T&gt;</code> reprÃ©sente un seul propriÃ©taire
de la donnÃ©e qu'il contient. Donc, qu'est-ce qui rend <code>RefCell&lt;T&gt;</code> diffÃ©rent
d'un type comme <code>Box&lt;T&gt;</code>Â ? Souvenez-vous des rÃ¨gles d'emprunt que vous avez
appris au chapitre 4Â :</p>
<!--
* At any given time, you can have *either* (but not both of) one mutable
  reference or any number of immutable references.
* References must always be valid.
-->
<ul>
<li>A un instant donnÃ©, vous pouvez avoir <em>soit</em> (mais pas les deux) une
rÃ©fÃ©rence mutable, soit n'importe quelle quantitÃ© de rÃ©fÃ©rences immuables</li>
<li>Les rÃ©fÃ©rences doivent toujours Ãªtre en vigueur.</li>
</ul>
<!--
With references and `Box<T>`, the borrowing rulesâ€™ invariants are enforced at
compile time. With `RefCell<T>`, these invariants are enforced *at runtime*.
With references, if you break these rules, youâ€™ll get a compiler error. With
`RefCell<T>`, if you break these rules, your program will panic and exit.
-->
<p>Avec les rÃ©fÃ©rences et <code>Box&lt;T&gt;</code>, les rÃ¨gles d'emprunt obligatoires sont
appliquÃ©es au moment de la compilation. Avec <code>RefCell&lt;T&gt;</code>, ces obligations
sont appliquÃ©es <em>au moment de l'exÃ©cution</em>. Avec les rÃ©fÃ©rences, si vous ne
respectez pas ces rÃ¨gles, vous allez obtenir une erreur de compilation. Avec
<code>RefCell&lt;T&gt;</code>, si vous ne les respectez pas, votre programme va paniquer et se
fermer.</p>
<!--
The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rustâ€™s default.
-->
<p>Les avantages de vÃ©rifier les rÃ¨gles d'emprunt au moment de la compilation est
que les erreurs vont se produire plus tÃ´t dans le processus de dÃ©veloppement,
et il n'y a pas d'impact sur la performance Ã  l'exÃ©cution car toute l'analyse
a dÃ©jÃ  Ã©tÃ© faite au prÃ©alable. Pour ces raisons, la vÃ©rification des rÃ¨gles
d'emprunt au moment de compilation est le meilleur choix Ã  faire dans la
majoritÃ© des cas, ce qui explique pourquoi c'est le choix par dÃ©faut de Rust.</p>
<!--
The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.
-->
<p>L'avantage de vÃ©rifier les rÃ¨gles d'emprunt plutÃ´t Ã  l'exÃ©cution est que cela
permet certains scÃ©narios qui restent sÃ»rs pour la mÃ©moire, bien qu'interdites
Ã  cause des vÃ©rifications Ã  la compilation. L'analyse statique, comme le
compilateur Rust, est de nature prudente. Certaines propriÃ©tÃ©s du code sont
impossibles Ã  dÃ©tecter en analysant le codeÂ : l'exemple le plus connu est le
<em>problÃ¨me de l'arrÃªt</em>, qui dÃ©passe le cadre de ce livre mais qui reste un
sujet intÃ©ressant Ã  Ã©tudier.</p>
<!--
Because some analysis is impossible, if the Rust compiler canâ€™t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, itâ€™s conservative. If Rust accepted an incorrect program, users
wouldnâ€™t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The `RefCell<T>` type is useful when youâ€™re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.
-->
<p>Comme certaines analyses sont impossibles, si le compilateur Rust ne peut pas
s'assurer que le code respecte les rÃ¨gles d'emprunt, il risque de rejeter un
programme valideÂ ; dans ce sens, il est prudent. Si Rust accepte un programme
incorrecte, les utilisateurs ne pourront pas avoir confiance dans les
garanties qu'apporte Rust. Cependant, si Rust rejette un programme valide, le
dÃ©veloppeur sera importunÃ©, mais rien de catastrophique ne va se passer. Le
type <code>RefCell&lt;T&gt;</code> est utile lorsque vous Ãªtes sÃ»r que votre code suit bien
les rÃ¨gles d'emprunt mais que le compilateur est incapable de comprendre et
de garantir cela.</p>
<!--
Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. Weâ€™ll talk about how to get the functionality of `RefCell<T>` in a
multithreaded program in Chapter 16.
-->
<p>De la mÃªme maniÃ¨re que <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> sert uniquement pour des
scÃ©narios Ã  une seule tÃ¢che et va vous donner une erreur Ã  la compilation si
vous essayez de l'utiliser dans un contexte multitÃ¢ches. Nous verrons
comment bÃ©nÃ©ficier les des fonctionnalitÃ©s de <code>RefCell&lt;T&gt;</code> dans un programme
multi-processus au chapitre 16.</p>
<!--
Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:
-->
<p>Voici un rÃ©sumÃ© des raisons pour choisir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, ou <code>RefCell&lt;T&gt;</code>Â :</p>
<!--
* `Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>`
  have single owners.
* `Box<T>` allows immutable or mutable borrows checked at compile time; `Rc<T>`
  allows only immutable borrows checked at compile time; `RefCell<T>` allows
  immutable or mutable borrows checked at runtime.
* Because `RefCell<T>` allows mutable borrows checked at runtime, you can
  mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is
  immutable.
-->
<ul>
<li><code>Rc&lt;T&gt;</code> permet d'avoir plusieurs propriÃ©taires pour une mÃªme donnÃ©eÂ ;
<code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code> n'ont qu'un seul propriÃ©taire.</li>
<li><code>Box&lt;T&gt;</code> permet des emprunts immuables ou mutables Ã  la compilationÂ ;
<code>Rc&lt;T&gt;</code> permet uniquement des emprunts immuables, vÃ©rifiÃ©s Ã  la
compilationÂ ; <code>RefCell&lt;T&gt;</code> permet des emprunts immuables ou mutables,
vÃ©rifiÃ©s Ã  l'exÃ©cution.</li>
<li>Comme <code>RefCell&lt;T&gt;</code> permet des emprunts mutables, vÃ©rifiÃ©s Ã  l'exÃ©cution,
vous pouvez muter la valeur Ã  l'intÃ©rieur du <code>RefCell&lt;T&gt;</code> mÃªme si le
<code>RefCell&lt;T&gt;</code> est immuable.</li>
</ul>
<!--
Mutating the value inside an immutable value is the *interior mutability*
pattern. Letâ€™s look at a situation in which interior mutability is useful and
examine how itâ€™s possible.
-->
<p>Modifer une valeur Ã  l'intÃ©rieur d'une valeur immuable est ce qu'on appelle
le motif de <em>mutabilitÃ© interne</em>. DÃ©couvrons une situation pour laquelle la
mutabilitÃ© interne est utile est examinons comment c'est possible.</p>
<!--
### Interior Mutability: A Mutable Borrow to an Immutable Value
-->
<h3><a class="header" href="#mutabilitÃ©-interne--un-emprunt-mutable-dune-valeur-immuable" id="mutabilitÃ©-interne--un-emprunt-mutable-dune-valeur-immuable">MutabilitÃ© interneÂ : un emprunt mutable d'une valeur immuable</a></h3>
<!--
A consequence of the borrowing rules is that when you have an immutable value,
you canâ€™t borrow it mutably. For example, this code wonâ€™t compile:
-->
<p>Une des consÃ©quences des rÃ¨gles d'emprunt est que lorsque vous avez une valeur
immuable, vous ne pouvez pas emprunter sa mutabilitÃ©. Par exemple, ce code ne
va pas se compilerÂ :</p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    let y = &mut x;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<!--
If you tried to compile this code, youâ€™d get the following error:
-->
<p>Si vous essayez de compiler ce code, vous allez obtenir l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 -- > src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
valueâ€™s methods would not be able to mutate the value. Using `RefCell<T>` is
one way to get the ability to have interior mutability. But `RefCell<T>`
doesnâ€™t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, youâ€™ll get a `panic!` instead of
a compiler error.
-->
<p>Cependant, il existe des situations pour lesquelles il serait utile qu'une
valeur puisse se modifier elle-mÃªme dans ses propres mÃ©thodes mais qui semble
Ãªtre immuable pour le reste du code. Le code Ã  l'extÃ©rieur des mÃ©thodes de la
valeur n'est pas capable de modifier la valeur. L'utilisation de <code>RefCell&lt;T&gt;</code>
est une maniÃ¨re de pouvoir procÃ©der Ã  des mutations internes. Mais
<code>RefCell&lt;T&gt;</code> ne contourne pas complÃ¨tement les rÃ¨gles d'empruntÂ : le
vÃ©rificateur d'emprunt du compilateur permet cette mutabilitÃ© interne, et les
rÃ¨gles d'emprunt sont plutÃ´t vÃ©rifiÃ©es Ã  l'exÃ©cution. Si vous violez les
rÃ¨gles, vous allez provoquer un <code>panic!</code> plutÃ´t que d'avoir une erreur de
compilation.</p>
<!--
Letâ€™s work through a practical example where we can use `RefCell<T>` to mutate
an immutable value and see why that is useful.
-->
<p>Voyons un exemple pratique dans lequel nous pouvons utiliser <code>RefCell&lt;T&gt;</code> pour
modifier une valeur immuable et voir en quoi cela est utile.</p>
<!--
#### A Use Case for Interior Mutability: Mock Objects
-->
<h4><a class="header" href="#un-cas-dutilisation-de-la-mutabilitÃ©-interne--le-mock-object" id="un-cas-dutilisation-de-la-mutabilitÃ©-interne--le-mock-object">Un cas d'utilisation de la mutabilitÃ© interneÂ : le mock object</a></h4>
<!--
A *test double* is the general programming concept for a type used in place of
another type during testing. *Mock objects* are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.
-->
<p>Un <em>double de test</em> est un concept de programmation gÃ©nÃ©ral pour un type
utilisÃ© Ã  la place d'un autre type pendant des tests. Un <em>mock object</em> est un
type particulier de double de test qui enregistre ce qui se passe lors d'un
test afin que vous puissiez vÃ©rifier que les actions se sont passÃ©es
correctement.</p>
<!--
Rust doesnâ€™t have objects in the same sense as other languages have objects,
and Rust doesnâ€™t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.
-->
<p>Rust n'a pas d'objets dans le sens qu'entendent les autres langages qui ont
des objets, et Rust n'a pas de fonctionnalitÃ© de mock object construit dans
la bibliothÃ¨que standard comme l'entendent d'autres langages. Cependant, vous
pouvez trÃ¨s bien crÃ©er une structure qui va rÃ©pondre aux mÃªmes besoins qu'un
mock object.</p>
<!--
Hereâ€™s the scenario weâ€™ll test: weâ€™ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
userâ€™s quota for the number of API calls theyâ€™re allowed to make, for example.
-->
<p>Voici le scÃ©nario que nous allons testerÂ : nous allons crÃ©er une bibliothÃ¨que
qui traque une valeur par rapport Ã  une valeur maximale et envoie des messages
en fonction de la proximitÃ© de la valeur courante. Cette bibliothÃ¨que peut
Ãªtre utilisÃ©e pour suivre un quota d'un utilisateur pour le nombre d'appels
aux API qu'il est autorisÃ© Ã  faire, par exemple.</p>
<!--
Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesnâ€™t need to know
that detail. All it needs is something that implements a trait weâ€™ll provide
called `Messenger`. Listing 15-20 shows the library code:
-->
<p>Notre bibliothÃ¨que va seulement fournir la fonctionnalitÃ© de suivi en fonction
de la valeur maximale et quels seront les messages Ã  chaque moment. Les
applications qui utiliseront notre bibliothÃ¨que devront fournir un mÃ©canisme
pour envoyer les messagesÂ : l'application peut afficher le message dans
l'application, l'envoyer par email, l'envoyer par SMS, ou autre chose. La
bibliothÃ¨que n'a pas Ã  se charger de ce dÃ©tail. Tout ce que ce mÃ©canisme doit
faire est d'implÃ©menter un trait <code>Messager</code> que nous allons fournir. L'encart
15-20 propose du code pour cette bibliothÃ¨queÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messager {
    fn envoyer(&amp;self, msg: &amp;str);
}

pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
    messager: &amp;'a T,
    valeur: usize,
    max: usize,
}

impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
where
    T: Messager,
{
    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
        TraqueurDeLimite {
            messager,
            valeur: 0,
            max,
        }
    }

    pub fn set_valeur(&amp;mut self, valeur: usize) {
        self.valeur = valeur;

        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;

        if pourcentage_du_maximum &gt;= 1.0 {
            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
        } else if pourcentage_du_maximum &gt;= 0.9 {
            self.messager
                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
        } else if pourcentage_du_maximum &gt;= 0.75 {
            self.messager
                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span>
-->
<p><span class="caption">Encart 15-20Â : une bibliothÃ¨que qui suit la proximitÃ©
d'une valeur avec une valeur maximale et avertit lorsque cette valeur atteint
un certain seuil</span></p>
<!--
One important part of this code is that the `Messenger` trait has one method
called `send` that takes an immutable reference to `self` and the text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the `set_value` method
on the `LimitTracker`. We can change what we pass in for the `value` parameter,
but `set_value` doesnâ€™t return anything for us to make assertions on. We want
to be able to say that if we create a `LimitTracker` with something that
implements the `Messenger` trait and a particular value for `max`, when we pass
different numbers for `value`, the messenger is told to send the appropriate
messages.
-->
<p>La partie la plus importante de ce code est celle oÃ¹ le trait <code>Messager</code> a une
mÃ©thode qui fait appel Ã  <code>envoyer</code> en prenant une rÃ©fÃ©rence immuable Ã  <code>self</code>
ainsi que le texte du message. C'est l'interface que notre mock object doit
avoir. L'autre partie importante est lorsque nous souhaitons tester le
comportement de la mÃ©thode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code>. Nous pouvons
changer ce que nous envoyons dans le paramÃ¨tre <code>valeur</code>, mais <code>set_valeur</code> ne
nous retourne rien qui nous permet de le vÃ©rifier. Nous voulons pouvoir dire que
si nous crÃ©ons un <code>TraqueurDeLimite</code> avec quelque chose qui implÃ©mente le trait
<code>Messager</code> et une valeur prÃ©cise pour <code>max</code>, lorsque nous passons diffÃ©rents
nombres pour <code>valeur</code>, que le messager puisse confirmer l'envoi des messages
correspondants.</p>
<!--
We need a mock object that, instead of sending an email or text message when we
call `send`, will only keep track of the messages itâ€™s told to send. We can
create a new instance of the mock object, create a `LimitTracker` that uses the
mock object, call the `set_value` method on `LimitTracker`, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker wonâ€™t allow it:
-->
<p>Nous avons besoin d'un mock object qui, au lieu d'envoyer un email ou un SMS
lorsque nous faisons appel Ã  <code>envoyer</code>, va seulement enregistrer les messages
qu'on lui demande d'envoyer. Nous pouvons crÃ©er une nouvelle instance du mock
object, crÃ©er un <code>TraqueurDeLimite</code> qui utilise le mock object, faire appel Ã  la
mÃ©thode <code>set_value</code> sur le <code>TraqueurDeLimite</code>, et ensuite vÃ©rifier que le mock
object a bien les messages que nous attendions. L'encart 15-21 montre une
tentative d'implÃ©mentation d'un mock object qui fait ceci, mais le vÃ©rificateur
d'emprunt ne nous autorise pas Ã  le faireÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MessagerMock {
        messages_envoyes: Vec&lt;String&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: vec![],
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        let messager_mock = MessagerMock::new();
        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);

        traqueur.set_valeur(80);

        assert_eq!(messager_mock.messages_envoyes.len(), 1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-21: An attempt to implement a `MockMessenger`
that isnâ€™t allowed by the borrow checker</span>
-->
<p><span class="caption">Encart 15-21Â : une tentative d'implÃ©mentation d'un
<code>MessagerMock</code> qui n'est pas autorisÃ© par le vÃ©rificateur d'emprunt</span></p>
<!--
This test code defines a `MockMessenger` struct that has a `sent_messages`
field with a `Vec` of `String` values to keep track of the messages itâ€™s told
to send. We also define an associated function `new` to make it convenient to
create new `MockMessenger` values that start with an empty list of messages. We
then implement the `Messenger` trait for `MockMessenger` so we can give a
`MockMessenger` to a `LimitTracker`. In the definition of the `send` method, we
take the message passed in as a parameter and store it in the `MockMessenger`
list of `sent_messages`.
-->
<p>Ce code de test dÃ©finit une structure <code>MessagerMock</code> qui a un champ
<code>messages_envoyes</code> qui est un <code>Vec</code> de valeurs <code>String</code>, afin d'y enregistrer
les messages qui lui sont envoyÃ©s. Nous dÃ©finissons Ã©galement une fonction
associÃ©e <code>new</code> pour faciliter la crÃ©ation de valeurs <code>MessagerMock</code> qui
commencent avec une liste vide de messages. Nous implÃ©mentons ensuite le trait
<code>Messager</code> sur <code>MessagerMock</code> afin de donner un <code>MessagerMock</code> Ã  un
<code>TraqueurDeLimite</code>. Dans la dÃ©finition de la mÃ©thode <code>envoyer</code>, nous prenons
le message envoyÃ© en paramÃ¨tre et nous le stockons dans la liste
<code>messages_envoyes</code> du <code>MessagerMock</code>.</p>
<!--
In the test, weâ€™re testing what happens when the `LimitTracker` is told to set
`value` to something that is more than 75 percent of the `max` value. First, we
create a new `MockMessenger`, which will start with an empty list of messages.
Then we create a new `LimitTracker` and give it a reference to the new
`MockMessenger` and a `max` value of 100. We call the `set_value` method on the
`LimitTracker` with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the `MockMessenger` is keeping track
of should now have one message in it.
-->
<p>Dans le test, nous vÃ©rifions ce qui se passe lorsque le <code>TraqueurDeLimite</code>
doit atteindre une valeur qui est supÃ©rieure Ã  75 pourcent de la valeur <code>max</code>.
D'abord, nous crÃ©ons un nouveau <code>MessagerMock</code>, qui va dÃ©marrer avec une liste
vide de messages. Ensuite, nous crÃ©ons un nouveau <code>TraqueurDeLimite</code> et nous
lui donnons une rÃ©fÃ©rence vers ce <code>MessagerMock</code> et une valeur <code>max</code> de 100.
Nous appelons la mÃ©thode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code> avec une
valeur de 80, qui est plus grande que 75 pourcent de 100. Enfin, nous
vÃ©rifions que la liste de messages qu'a enregistrÃ© le <code>MessagerMock</code> a bien
un message Ã  l'intÃ©rieur.</p>
<!--
However, thereâ€™s one problem with this test, as shown here:
-->
<p>Cependant, il reste un problÃ¨me avec ce test, qui est montrÃ© ci-dessousÂ :</p>
<!--
```text
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference
  -- > src/lib.rs:58:13
   |
57 |         fn send(&self, message: &str) {
   |                 ----- help: consider changing this to be a mutable reference: `&mut self`
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-text">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.messages_envoyes` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
57 |         fn envoyer(&amp;self, message: &amp;str) {
   |                    ----- help: consider changing this to be a mutable reference: `&amp;mut self`
58 |             self.messages_envoyes.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
We canâ€™t modify the `MockMessenger` to keep track of the messages, because the
`send` method takes an immutable reference to `self`. We also canâ€™t take the
suggestion from the error text to use `&mut self` instead, because then the
signature of `send` wouldnâ€™t match the signature in the `Messenger` trait
definition (feel free to try and see what error message you get).
-->
<p>Nous ne pouvons pas modifier le <code>MessagerMock</code> pour enregistrer les messages,
car la mÃ©thode <code>envoyer</code> utilise une rÃ©fÃ©rence immuable Ã  <code>self</code>. Nous ne
pouvons pas non plus suivre la suggestion du texte d'erreur pour utiliser
<code>&amp;mut self</code> Ã  la place, car ensuite la signature de <code>envoyer</code> ne va pas
correspondre Ã  la signature de la dÃ©finition du trait <code>Messager</code> (essayez et
vous constaterez le message d'erreur que vous obtiendrez).</p>
<!--
This is a situation in which interior mutability can help! Weâ€™ll store the
`sent_messages` within a `RefCell<T>`, and then the `send` message will be
able to modify `sent_messages` to store the messages weâ€™ve seen. Listing 15-22
shows what that looks like:
-->
<p>C'est une situation dans laquelle la mutabilitÃ© interne peut nous aiderÂ !
Nous allons stocker <code>messages_envoyes</code> dans une <code>RefCell&lt;T&gt;</code>, et ensuite le
message de <code>envoyer</code> pourra modifier <code>messages_envoyes</code> pour stocker les
messages que nous avons avons vu. L'encart 15-22 montre Ã  quoi cela peut
ressemblerÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MessagerMock {
        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: RefCell::new(vec![]),
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        // -- partie masquÃ©e ici --
<span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span>
        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-22: Using `RefCell<T>` to mutate an inner
value while the outer value is considered immutable</span>
-->
<p><span class="caption">Encart 15-22Â : utilisation du <code>RefCell&lt;T&gt;</code> pour muter
une valeur interne que les valeurs externes considÃ¨rent comme immuable
</span></p>
<!--
The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of
`Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>`
instance around the empty vector.
-->
<p>Le champ <code>messages_envoyes</code> est maintenant du type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> au
lieu de <code>Vec&lt;String&gt;</code>. Dans la fonction <code>new</code>, nous crÃ©ons une nouvelle
instance de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> autour du vecteur vide.</p>
<!--
For the implementation of the `send` method, the first parameter is still an
immutable borrow of `self`, which matches the trait definition. We call
`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a
mutable reference to the value inside the `RefCell<Vec<String>>`, which is
the vector. Then we can call `push` on the mutable reference to the vector to
keep track of the messages sent during the test.
-->
<p>En ce qui concerne l'implÃ©mentation de la mÃ©thode <code>envoyer</code>, le premier
paramÃ¨tre est toujours un emprunt immuable de <code>self</code>, ce qui correspond Ã  la
dÃ©finition du trait. Nous appelons la mÃ©thode <code>borrow_mut</code> sur le
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> prÃ©sent dans <code>self.messages_envoyes</code> pour obtenir une
rÃ©fÃ©rence mutable vers la valeur prÃ©sente dans le <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, qui
correspond au vecteur. Ensuite, nous appelons <code>push</code> sur la rÃ©fÃ©rence mutable
vers le vecteur pour enregistrer le message envoyÃ© pendant le test.</p>
<!--
The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get an
immutable reference to the vector.
-->
<p>Le dernier changement que nous devons appliquer est dans la vÃ©rificationÂ :
pour savoir combien d'Ã©lÃ©ments sont prÃ©sents dans le vecteur, nous faisons
appel Ã  <code>borrow</code> de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> pour obtenir une rÃ©fÃ©rence
immuable vers le vecteur.</p>
<!--
Now that youâ€™ve seen how to use `RefCell<T>`, letâ€™s dig into how it works!
-->
<p>Maintenant que vous avez appris Ã  utiliser <code>RefCell&lt;T&gt;</code>, regardons comment il
fonctionneÂ !</p>
<!--
#### Keeping Track of Borrows at Runtime with `RefCell<T>`
-->
<h4><a class="header" href="#suivre-les-emprunts-Ã -lexÃ©cution-avec-refcellt" id="suivre-les-emprunts-Ã -lexÃ©cution-avec-refcellt">Suivre les emprunts Ã  l'exÃ©cution avec <code>RefCell&lt;T&gt;</code></a></h4>
<!--
When creating immutable and mutable references, we use the `&` and `&mut`
syntax, respectively. With `RefCell<T>`, we use the `borrow` and `borrow_mut`
methods, which are part of the safe API that belongs to `RefCell<T>`. The
`borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut`
returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so we
can treat them like regular references.
-->
<p>Lorsque nous crÃ©ons des rÃ©fÃ©rences immuables et mutables, nous utilisons
respectivement les syntaxes <code>&amp;</code> et <code>&amp;mut</code>. Avec <code>RefCell&lt;T&gt;</code>, nous utilisons
les mÃ©thodes <code>borrow</code> et <code>borrow_mut</code>, qui font partie de l'API stable de
<code>RefCell&lt;T&gt;</code>. La mÃ©thode <code>borrow</code> retourne un pointeur intelligent du type
<code>Ref&lt;T&gt;</code> et <code>borrow_mut</code> retourne le pointeur intelligent du type <code>RefMut&lt;T&gt;</code>.
Les deux implÃ©mentent <code>Deref</code>, donc nous pouvons les considÃ©rer comme des
rÃ©fÃ©rences classiques.</p>
<!--
The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart
pointers are currently active. Every time we call `borrow`, the `RefCell<T>`
increases its count of how many immutable borrows are active. When a `Ref<T>`
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, `RefCell<T>` lets us have many immutable
borrows or one mutable borrow at any point in time.
-->
<p>Le <code>RefCell&lt;T&gt;</code> suit combien de pointeurs intelligents <code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>
sont actuellement actifs. A chaque fois que nous faisons appel Ã  <code>borrow</code>, le
<code>RefCell&lt;T&gt;</code> augmente son compteur du nombre d'emprunts immuables qui existent.
Lorsqu'une valeur <code>Ref&lt;T&gt;</code> sort de la portÃ©e, le compteur d'emprunts immuables
est dÃ©crÃ©mentÃ© de un. <code>RefCell&lt;T&gt;</code> nous permet d'avoir autant d'emprunts
immuables ou alors un seul emprunt mutable au mÃªme moment, exactement comme les
rÃ¨gles d'emprunt Ã  la compilation.</p>
<!--
If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of `RefCell<T>` will panic at
runtime. Listing 15-23 shows a modification of the implementation of `send` in
Listing 15-22. Weâ€™re deliberately trying to create two mutable borrows active
for the same scope to illustrate that `RefCell<T>` prevents us from doing this
at runtime.
-->
<p>Si nous ne respectons pas ces rÃ¨gles, l'implÃ©mentation de <code>RefCell&lt;T&gt;</code> va
paniquer Ã  l'exÃ©cution plutÃ´t que d'avoir une erreur de compilation comme nous
l'aurions avec des rÃ©fÃ©rences classiques. L'encart 15-23 nous montre une
modification apportÃ©e Ã  l'implÃ©mentation de <code>envoyer</code> de l'encart 15-22. Nous
essayons dÃ©libÃ©rÃ©ment de crÃ©er deux emprunts mutables actifs dans la mÃªme
portÃ©e pour montrer que <code>RefCell&lt;T&gt;</code> nous empÃªche de faire ceci Ã  l'exÃ©cution.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,panics
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
#     use std::cell::RefCell;
# 
#     struct MockMessenger {
#         sent_messages: RefCell<Vec<String>>,
#     }
# 
#     impl MockMessenger {
#         fn new() -> MockMessenger {
#             MockMessenger {
#                 sent_messages: RefCell::new(vec![]),
#             }
#         }
#     }
# 
    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
# 
#     #[test]
#     fn it_sends_an_over_75_percent_warning_message() {
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);
# 
#         assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
#     }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MessagerMock {
</span><span class="boring">        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MessagerMock {
</span><span class="boring">        fn new() -&gt; MessagerMock {
</span><span class="boring">            MessagerMock {
</span><span class="boring">                messages_envoyes: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            let mut premier_emprunt = self.messages_envoyes.borrow_mut();
            let mut second_emprunt = self.messages_envoyes.borrow_mut();

            premier_emprunt.push(String::from(message));
            second_emprunt.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
</span><span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that `RefCell<T>` will panic</span>
-->
<p><span class="caption">Encart 15-23Â : crÃ©ation de deux rÃ©fÃ©rences mutables dans
la mÃªme portÃ©e pour voir si <code>RefCell&lt;T&gt;</code> va paniquer</span></p>
<!--
We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned
from `borrow_mut`. Then we create another mutable borrow in the same way in the
variable `two_borrow`. This makes two mutable references in the same scope,
which isnâ€™t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:
-->
<p>Nous crÃ©ons une variable <code>premier_emprunt</code> pour le pointeur intelligent
<code>RefMut&lt;T&gt;</code> retournÃ© par <code>borrow_mut</code>. Ensuite nous crÃ©ons un autre emprunt de
la mÃªme maniÃ¨re, qui s'appelle <code>second_emprunt</code>. Cela fait deux rÃ©fÃ©rences
mutables dans la mÃªme portÃ©e, ce qui n'est pas autorisÃ©. Lorsque nous lanÃ§ons
les tests sur notre bibliothÃ¨que, le code de l'encart 15-23 va se compiler
sans erreur, mais les tests vont Ã©chouerÂ :</p>
<!--
```console
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent ... FAILED

failures:

---- tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Notice that the code panicked with the message `already borrowed:
BorrowMutError`. This is how `RefCell<T>` handles violations of the borrowing
rules at runtime.
-->
<p>Remarquez que le code a paniquÃ© avec le message
<code>already borrowed: BorrowMutError</code> (NdTÂ : <code>dÃ©jÃ  empruntÃ©</code>). C'est ainsi que
<code>RefCell&lt;T&gt;</code> gÃ¨re les violations des rÃ¨gles d'emprunt Ã  l'exÃ©cution.</p>
<!--
Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until your code was deployed to production. Also, your code would incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using `RefCell<T>` makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while youâ€™re using it in a context where only immutable
values are allowed. You can use `RefCell<T>` despite its trade-offs to get more
functionality than regular references provide.
-->
<p>La dÃ©tection des erreurs d'emprunt Ã  l'exÃ©cution plutÃ´t qu'Ã  la compilation
signifie que vous allez trouver une erreur dans votre code plus tard dans le
processus de dÃ©veloppement et peut-Ãªtre mÃªme pas avant que votre code soit
dÃ©ployÃ© en production. De plus, votre code va subir une petite perte de
performances Ã  l'exÃ©cution en raison du contrÃ´le des emprunts Ã  l'exÃ©cution
plutÃ´t qu'Ã  la compilation. Cependant, l'utilisation de <code>RefCell&lt;T&gt;</code> rend
possible l'Ã©criture d'un mock object qui peut se modifier lui-mÃªme afin
d'enregistrer les messages qu'il a vu passer alors que vous l'utilisez dans un
contexte oÃ¹ seules les valeurs immuables sont permises. Vous pouvez utiliser
<code>RefCell&lt;T&gt;</code> malgrÃ© ses inconvÃ©nients pour obtenir plus de fonctionnalitÃ©s
que celles qu'offre une rÃ©fÃ©rence classique.</p>
<!--
### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>`
-->
<h3><a class="header" href="#permettre-plusieurs-propriÃ©taires-de-donnÃ©es-mutables-en-combinant-rct-et-refcellt" id="permettre-plusieurs-propriÃ©taires-de-donnÃ©es-mutables-en-combinant-rct-et-refcellt">Permettre plusieurs propriÃ©taires de donnÃ©es mutables en combinant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code></a></h3>
<!--
A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that
`Rc<T>` lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you can
get a value that can have multiple owners *and* that you can mutate!
-->
<p>Il est courant d'utiliser <code>RefCell&lt;T&gt;</code> en tandem avec <code>Rc&lt;T&gt;</code>. Rappelez-vous
que <code>Rc&lt;T&gt;</code> vous permet d'avoir plusieurs propriÃ©taires d'une mÃªme donnÃ©e, mais
qu'il vous donne seulement un accÃ¨s immuable Ã  cette donnÃ©e. Si vous avez un
<code>Rc&lt;T&gt;</code> qui contient un <code>RefCell&lt;T&gt;</code>, vous pouvez obtenir une valeur qui peut
avoir plusieurs propriÃ©taires <em>et</em> que vous pouvez modifierÂ !</p>
<!--
For example, recall the cons list example in Listing 15-18 where we used
`Rc<T>` to allow multiple lists to share ownership of another list. Because
`Rc<T>` holds only immutable values, we canâ€™t change any of the values in the
list once weâ€™ve created them. Letâ€™s add in `RefCell<T>` to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
`RefCell<T>` in the `Cons` definition, we can modify the value stored in all
the lists:
-->
<p>Souvenez-vous de l'exemple de la liste de construction de l'encart 15-18 oÃ¹ nous
avions utilisÃ© <code>Rc&lt;T&gt;</code> pour permettre d'avoir plusieurs listes de se partager la
possession d'une autre liste. Comme <code>Rc&lt;T&gt;</code> stocke seulement des valeurs
immuables, nous ne pouvons changer aucune valeur dans la liste une fois que
nous l'avons crÃ©Ã©. Ajoutons un <code>RefCell&lt;T&gt;</code> pour pouvoir changer les valeurs
dans les listes. L'encart 15-24 nous montre ceci en ajoutant un <code>RefCell&lt;T&gt;</code>
dans la dÃ©finition de <code>Cons</code>, nous pouvons ainsi modifier les valeurs stockÃ©es
dans n'importe quelle listeÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let valeur = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valeur), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *valeur.borrow_mut() += 10;

    println!(&quot;a aprÃ¨s les opÃ©rations = {:?}&quot;, a);
    println!(&quot;b aprÃ¨s les opÃ©rations = {:?}&quot;, b);
    println!(&quot;c aprÃ¨s les opÃ©rations = {:?}&quot;, c);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-24: Using `Rc<RefCell<i32>>` to create a
`List` that we can mutate</span>
-->
<p><span class="caption">Encart 15-24Â : utilisation de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> pour
crÃ©er une <code>List</code> que nous pouvons modifier</span></p>
<!--
We create a value that is an instance of `Rc<RefCell<i32>>` and store it in a
variable named `value` so we can access it directly later. Then we create a
`List` in `a` with a `Cons` variant that holds `value`. We need to clone
`value` so both `a` and `value` have ownership of the inner `5` value rather
than transferring ownership from `value` to `a` or having `a` borrow from
`value`.
-->
<p>Nous crÃ©ons une valeur qui est une instance de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> et nous la
stockons dans une variable <code>valeur</code> afin que nous puissions y avoir accÃ¨s plus
tard. Ensuite, nous crÃ©ons une <code>List</code> dans <code>a</code> avec une variante de <code>Cons</code> qui
utilise <code>valeur</code>. Nous devons utiliser clone sur <code>valeur</code> afin que <code>a</code> et
<code>valeur</code> soient toutes les deux propriÃ©taires de la valeur interne <code>5</code> plutÃ´t
que d'avoir Ã  transfÃ©rer la possession de <code>valeur</code> Ã  <code>a</code> ou avoir <code>a</code> qui
emprunte <code>valeur</code>.</p>
<!--
We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, they
can both refer to `a`, which is what we did in Listing 15-18.
-->
<p>Nous insÃ©rons la liste <code>a</code> dans un <code>Rc&lt;T&gt;</code> pour que lorsque nous crÃ©ons <code>b</code> et
<code>c</code>, elles puissent toutes les deux utiliser <code>a</code>, ce que nous avions dÃ©jÃ  fait
dans l'encart 15-18.</p>
<!--
After weâ€™ve created the lists in `a`, `b`, and `c`, we add 10 to the value in
`value`. We do this by calling `borrow_mut` on `value`, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
[â€œWhereâ€™s the `->` Operator?â€][wheres-the---operator]<!-- ignore -- >) to
dereference the `Rc<T>` to the inner `RefCell<T>` value. The `borrow_mut`
method returns a `RefMut<T>` smart pointer, and we use the dereference operator
on it and change the inner value.
-->
<p>AprÃ¨s avoir crÃ©Ã© les listes dans <code>a</code>, <code>b</code>, et <code>c</code>, nous ajoutons 10 Ã  la valeur
dans <code>valeur</code>. Nous faisons cela en appelant <code>borrow_mut</code> sur <code>valeur</code>, ce qui
utilise la fonctionnalitÃ© de dÃ©rÃ©fÃ©rencement automatique que nous avons vu au
chapitre 5 (voir la section
<a href="ch05-03-method-syntax.html#o%C3%B9-est-lop%C3%A9rateur---">â€œOÃ¹ est l'opÃ©rateur -&gt; ?â€</a><!-- ignore -->) pour
dÃ©rÃ©fÃ©rencer le <code>Rc&lt;T&gt;</code> dans la valeur interne <code>RefCell&lt;T&gt;</code>. La mÃ©thode
<code>borrow_mut</code> retourne un pointeur intelligent <code>RefMut&lt;T&gt;</code>, et nous utilisons
l'opÃ©rateur de dÃ©rÃ©fÃ©rencement sur lui pour changer sa valeur interne.</p>
<!--
When we print `a`, `b`, and `c`, we can see that they all have the modified
value of 15 rather than 5:
-->
<p>Lorsque nous affichons <code>a</code>, <code>b</code> et <code>c</code>, nous pouvons constater qu'elles ont
toutes la valeur modifiÃ©e de 15 au lieu de 5Â :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a aprÃ¨s les opÃ©rations = Cons(RefCell { value: 15 }, Nil)
b aprÃ¨s les opÃ©rations = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c aprÃ¨s les opÃ©rations = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<!--
This technique is pretty neat! By using `RefCell<T>`, we have an outwardly
immutable `List` value. But we can use the methods on `RefCell<T>` that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and itâ€™s
sometimes worth trading a bit of speed for this flexibility in our data
structures.
-->
<p>Cette technique est plutÃ´t ingÃ©nieuseÂ ! En utilisant <code>RefCell&lt;T&gt;</code>, nous avons
une valeur <code>List</code> qui est immuable de l'extÃ©rieur. Mais nous pouvons utiliser
les mÃ©thodes de <code>RefCell&lt;T&gt;</code> qui nous donne accÃ¨s Ã  sa mutabilitÃ© interne afin
que nous puissions modifier notre donnÃ©e lorsque nous en avons besoin. Les
vÃ©rifications des rÃ¨gles d'emprunt Ã  l'exÃ©cution nous protÃ¨gent des accÃ¨s
concurrents, et il est parfois intÃ©ressant de sacrifier un peu de vitesse pour
cette flexibilitÃ© dans nos structures de donnÃ©es.</p>
<!--
The standard library has other types that provide interior mutability, such as
`Cell<T>`, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the `Cell<T>`. Thereâ€™s also
`Mutex<T>`, which offers interior mutability thatâ€™s safe to use across threads;
weâ€™ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.
-->
<p>La bibliothÃ¨que standard a d'autres types qui fournissent de la mutabilitÃ©
interne, comme <code>Cell&lt;T&gt;</code>, qui est similaire sauf qu'au lieu de fournir des
rÃ©fÃ©rences Ã  la valeur interne, la valeur est copiÃ©e Ã  l'intÃ©rieur et Ã 
l'extÃ©rieur du <code>Cell&lt;T&gt;</code>. Il existe aussi <code>Mutex&lt;T&gt;</code> qui offre de la mutabilitÃ©
interne qui est sÃ©curisÃ©e pour une utilisation partagÃ©e entre plusieures
tÃ¢chesÂ ; nous allons voir son utilisation au chapitre 16. Plongez-vous dans la
documentation de la bibliothÃ¨que standard pour plus de dÃ©tails entre ces
diffÃ©rents types.</p>
<!--
[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
