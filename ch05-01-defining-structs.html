<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DÃ©finir et instancier des structures - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html" class="active"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Defining and Instantiating Structs
-->
<h2 id="dÃ©finir-et-instancier-des-structures"><a class="header" href="#dÃ©finir-et-instancier-des-structures">DÃ©finir et instancier des structures</a></h2>
<!--
Structs are similar to tuples, which were discussed in Chapter 3. Like tuples,
the pieces of a struct can be different types. Unlike with tuples, youâ€™ll name
each piece of data so itâ€™s clear what the values mean. As a result of these
names, structs are more flexible than tuples: you donâ€™t have to rely on the
order of the data to specify or access the values of an instance.
-->
<p>Les structures sont similaires aux tuples, qu'on a vus au chapitre 3. Comme pour
les tuples, les Ã©lÃ©ments d'une structure peuvent Ãªtre de diffÃ©rents types.
Contrairement aux tuples, on doit nommer chaque Ã©lÃ©ment des donnÃ©es afin de
clarifier le rÃ´le de chaque valeur. GrÃ¢ce Ã  ces noms, les structures sont plus
flexibles que les tuplesÂ : on n'a pas Ã  utiliser l'ordre des donnÃ©es pour
spÃ©cifier ou accÃ©der aux valeurs d'une instance.</p>
<!--
To define a struct, we enter the keyword `struct` and name the entire struct. A
structâ€™s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call *fields*. For example, Listing 5-1 shows a
struct that stores information about a user account.
-->
<p>Pour dÃ©finir une structure, on tape le mot-clÃ© <code>struct</code> et on donne un nom Ã 
toute la structure. Le nom d'une structure devrait dÃ©crire l'utilisation des
Ã©lÃ©ments des donnÃ©es regroupÃ©s. Ensuite, entre des accolades, on dÃ©finit le nom
et le type de chaque Ã©lÃ©ment des donnÃ©es, qu'on appelle un <em>champ</em>. Par exemple,
l'encart 5-1 montre une structure qui stocke des informations Ã  propos d'un
compte d'utilisateur.</p>
<!--
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Utilisateur {
    pseudo: String,
    email: String,
    nombre_de_connexions: u64,
    actif: bool,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-1: A `User` struct definition</span>
-->
<p><span class="caption">Encart 5-1Â : La dÃ©finition d'une structure
<code>Utilisateur</code></span></p>
<!--
To use a struct after weâ€™ve defined it, we create an *instance* of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing `key:
value` pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We donâ€™t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.
-->
<p>Pour utiliser une structure aprÃ¨s l'avoir dÃ©finie, on crÃ©e une <em>instance</em> de
cette structure en indiquant des valeurs concrÃ¨tes pour chacun des champs.
On crÃ©e une instance en indiquant le nom de la structure puis en ajoutant des
accolades qui contiennent des paires de <code>clÃ©: valeur</code>, oÃ¹ les clÃ©s sont les noms
des champs et les valeurs sont les donnÃ©es que l'on souhaite stocker dans ces
champs. Nous n'avons pas Ã  prÃ©ciser les champs dans le mÃªme ordre qu'on les a
dÃ©clarÃ©s dans la structure. En d'autres termes, la dÃ©finition de la structure
dÃ©crit un gabarit pour le type, et les instances remplissent ce gabarit avec des
donnÃ©es prÃ©cises pour crÃ©er des valeurs de ce type. Par exemple, nous pouvons
dÃ©clarer un utilisateur prÃ©cis comme dans l'encart 5-2.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-2: Creating an instance of the `User`
struct</span>
-->
<p><span class="caption">Encart 5-2Â : CrÃ©ation d'une instance de la structure
<code>Utilisateur</code></span></p>
<!--
To get a specific value from a struct, we can use dot notation. If we wanted
just this userâ€™s email address, we could use `user1.email` wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the `email` field of a mutable `User` instance.
-->
<p>Pour obtenir une valeur spÃ©cifique depuis une structure, on utilise la notation
avec le point. Si nous voulions seulement l'adresse e-mail de cet utilisateur,
on pourrait utiliser <code>utilisateur1.email</code> partout oÃ¹ on voudrait utiliser cette
valeur. Si l'instance est mutable, nous pourrions changer une valeur en
utilisant la notation avec le point et assigner une valeur Ã  ce champ en
particulier. L'encart 5-3 montre comment changer la valeur du champ <code>email</code>
d'une instance mutable de <code>Utilisateur</code>.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
    
    utilisateur1.email = String::from(&quot;unautremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-3: Changing the value in the `email` field of a
`User` instance</span>
-->
<p><span class="caption">Encart 5-3Â : Changement de la valeur du champ <code>email</code>
d'une instance de <code>Utilisateur</code></span></p>
<!--
Note that the entire instance must be mutable; Rust doesnâ€™t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.
-->
<p>Ã€ noter que l'instance tout entiÃ¨re doit Ãªtre mutableÂ ; Rust ne nous permet pas
de marquer seulement certains champs comme mutables. Comme pour toute
expression, nous pouvons construire une nouvelle instance de la structure comme
derniÃ¨re expression du corps d'une fonction pour retourner implicitement cette
nouvelle instance.</p>
<!--
Listing 5-4 shows a `build_user` function that returns a `User` instance with
the given email and username. The `active` field gets the value of `true`, and
the `sign_in_count` gets a value of `1`.
-->
<p>L'encart 5-4 montre une fonction <code>creer_utilisateur</code> qui retourne une instance
de <code>Utilisateur</code> avec l'adresse e-mail et le pseudo fournis. Le champ <code>actif</code>
prend la valeur <code>true</code> et le <code>nombre_de_connexions</code> prend la valeur <code>1</code>.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email: email,
        pseudo: pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-4: A `build_user` function that takes an email
and username and returns a `User` instance</span>
-->
<p><span class="caption">Encart 5-4Â : Une fonction <code>creer_utilisateur</code> qui prend
en entrÃ©e une adresse e-mail et un pseudo et retourne une instance de
<code>Utilisateur</code></span></p>
<!--
It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the `email` and `username` field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, thereâ€™s a convenient shorthand!
-->
<p>Il est logique de nommer les paramÃ¨tres de fonction avec le mÃªme nom que les
champs de la structure, mais devoir rÃ©pÃ©ter les noms de variables et de champs
<code>email</code> et <code>pseudo</code> est un peu pÃ©nible. Si la structure avait plus de champs,
rÃ©pÃ©ter chaque nom serait encore plus fatigant. Heureusement, il existe un
raccourci pratiqueÂ !</p>
<!--
### Using the Field Init Shorthand when Variables and Fields Have the Same Name
-->
<h3 id="utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-mÃªme-nom"><a class="header" href="#utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-mÃªme-nom">Utiliser le raccourci d'initialisation des champs lorsque les variables et les champs ont le mÃªme nom</a></h3>
<!--
Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the *field init shorthand* syntax to rewrite
`build_user` so that it behaves exactly the same but doesnâ€™t have the
repetition of `email` and `username`, as shown in Listing 5-5.
-->
<p>Puisque les noms des paramÃ¨tres et les noms de champs de la structure sont
exactement les mÃªmes dans l'encart 5-4, on peut utiliser la syntaxe de
<em>raccourci d'initialisation des champs</em> pour rÃ©Ã©crire <code>creer_utilisateur</code> de
sorte qu'elle se comporte exactement de la mÃªme faÃ§on sans avoir Ã  rÃ©pÃ©ter
<code>email</code> et <code>pseudo</code>, comme le montre l'encart 5-5.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email,
        pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-5: A `build_user` function that uses field init
shorthand because the `email` and `username` parameters have the same name as
struct fields</span>
-->
<p><span class="caption">Encart 5-5Â : Une fonction <code>creer_utilisateur</code> qui utilise
le raccourci d'initialisation des champs parce que les paramÃ¨tres <code>email</code> et
<code>pseudo</code> ont le mÃªme nom que les champs de la structure</span></p>
<!--
Here, weâ€™re creating a new instance of the `User` struct, which has a field
named `email`. We want to set the `email` fieldâ€™s value to the value in the
`email` parameter of the `build_user` function. Because the `email` field and
the `email` parameter have the same name, we only need to write `email` rather
than `email: email`.
-->
<p>Ici, on crÃ©e une nouvelle instance de la structure <code>Utilisateur</code>, qui possÃ¨de
un champ nommÃ© <code>email</code>. On veut donner au champ <code>email</code> la valeur du paramÃ¨tre
<code>email</code> de la fonction <code>creer_utilisateur</code>. Comme le champ <code>email</code> et le
paramÃ¨tre <code>email</code> ont le mÃªme nom, on a uniquement besoin d'Ã©crire <code>email</code>
plutÃ´t que <code>email: email</code>.</p>
<!--
### Creating Instances From Other Instances With Struct Update Syntax
-->
<h3 id="crÃ©er-des-instances-Ã -partir-dautres-instances-avec-la-syntaxe-de-mise-Ã -jour-de-structure"><a class="header" href="#crÃ©er-des-instances-Ã -partir-dautres-instances-avec-la-syntaxe-de-mise-Ã -jour-de-structure">CrÃ©er des instances Ã  partir d'autres instances avec la syntaxe de mise Ã  jour de structure</a></h3>
<!--
Itâ€™s often useful to create a new instance of a struct that uses most of an old
instanceâ€™s values but changes some. Youâ€™ll do this using *struct update syntax*.
-->
<p>Il est souvent utile de crÃ©er une nouvelle instance de structure qui utilise la
plupart des valeurs d'une ancienne instance tout en en changeant certaines. On
utilisera pour cela la <em>syntaxe de mise Ã  jour de structure</em>.</p>
<!--
First, Listing 5-6 shows how we create a new `User` instance in `user2` without
the update syntax. We set new values for `email` and `username` but otherwise
use the same values from `user1` that we created in Listing 5-2.
-->
<p>Tout d'abord, l'encart 5-6 nous montre comment crÃ©er une nouvelle instance de
<code>Utilisateur</code> dans <code>utilisateur2</code> sans la syntaxe de mise Ã  jour de structure.
On donne de nouvelles valeurs Ã  <code>email</code> et <code>pseudo</code> mais on utilise pour les
autres champs les mÃªmes valeurs que dans <code>utilisateur1</code> qu'on a crÃ©Ã© Ã 
l'encart 5-2.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };
# 
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let utilisateur2 = Utilisateur {
        email: String::from(&quot;quelquundautre@example.com&quot;),
        pseudo: String::from(&quot;autrepseudo567&quot;),
        actif: utilisateur1.actif,
        nombre_de_connexions: utilisateur1.nombre_de_connexions,
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-6: Creating a new `User` instance using some of
the values from `user1`</span>
-->
<p><span class="caption">Encart 5-6Â : CrÃ©ation d'une nouvelle instance de
<code>Utilisateur</code> en utilisant certaines valeurs de <code>utilisateur1</code>.</span></p>
<!--
Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax `..` specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.
-->
<p>En utilisant la syntaxe de mise Ã  jour de structure, on peut produire le mÃªme
rÃ©sultat avec moins de code, comme le montre l'encart 5-7. La syntaxe <code>..</code>
indique que les autres champs auxquels on ne donne pas explicitement de valeur
devraient avoir la mÃªme valeur que dans l'instance prÃ©cisÃ©e.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };
# 
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let utilisateur2 = Utilisateur {
        email: String::from(&quot;quelquundautre@example.com&quot;),
        pseudo: String::from(&quot;autrepseudo567&quot;),
        ..utilisateur1
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-7: Using struct update syntax to set new
`email` and `username` values for a `User` instance but use the rest of the
values from the fields of the instance in the `user1` variable</span>
-->
<p><span class="caption">Encart 5-7Â : Utilisation de la syntaxe de mise Ã  jour de
structure pour assigner de nouvelles valeurs Ã  <code>email</code> et <code>pseudo</code> Ã  une
nouvelle instance de <code>Utilisateur</code> tout en utilisant les autres valeurs des
champs de l'instance de la variable <code>utilisateur1</code></span></p>
<!--
The code in Listing 5-7 also creates an instance in `user2` that has a
different value for `email` and `username` but has the same values for the
`active` and `sign_in_count` fields from `user1`.
-->
<p>Le code dans l'encart 5-7 crÃ©e aussi une instance dans <code>utilisateur2</code> qui a une
valeur diffÃ©rente pour <code>email</code> et <code>pseudo</code> mais qui a les mÃªmes valeurs pour les
champs <code>actif</code> et <code>nombre_de_connexions</code> que <code>utilisateur1</code>.</p>
<!--
### Using Tuple Structs without Named Fields to Create Different Types
-->
<h3 id="utilisation-de-structures-tuples-sans-champ-nommÃ©-pour-crÃ©er-des-types-diffÃ©rents"><a class="header" href="#utilisation-de-structures-tuples-sans-champ-nommÃ©-pour-crÃ©er-des-types-diffÃ©rents">Utilisation de structures tuples sans champ nommÃ© pour crÃ©er des types diffÃ©rents</a></h3>
<!--
You can also define structs that look similar to tuples, called *tuple
structs*. Tuple structs have the added meaning the struct name provides but
donâ€™t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type from other tuples, and naming each
field as in a regular struct would be verbose or redundant.
-->
<p>On peut aussi dÃ©finir des structures qui ressemblent Ã  des tuples, appelÃ©es
<em>structures tuples</em>. La signification d'une structure tuple est donnÃ©e par son
nom. En revanche, ses champs ne sont pas nommÃ©sÂ ; on ne prÃ©cise que leurs types.
Les structures tuples servent lorsqu'on veut donner un nom Ã  un tuple pour qu'il
ait un type diffÃ©rent des autres tuples, mais que nommer chaque champ comme dans
une structure classique serait trop verbeux ou redondant.</p>
<!--
To define a tuple struct, start with the `struct` keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named `Color` and `Point`:
-->
<p>La dÃ©finition d'une structure tuple commence par le mot-clÃ© <code>struct</code> et le nom
de la structure suivis des types des champs du tuple. Par exemple, voici une
dÃ©finition et une utilisation de deux structures tuples nommÃ©es <code>Couleur</code> et
<code>Point</code>Â :</p>
<!--
```rust
# fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Couleur(i32, i32, i32);
    struct Point(i32, i32, i32);

    let noir = Couleur(0, 0, 0);
    let origine = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the `black` and `origin` values are different types, because theyâ€™re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type `Color` cannot take a `Point` as an
argument, even though both types are made up of three `i32` values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a `.` followed by the index to access an
individual value, and so on.
-->
<p>Notez que les valeurs <code>noir</code> et <code>origine</code> sont de types diffÃ©rents parce que ce
sont des instances de structures tuples diffÃ©rentes. Chaque structure que l'on
dÃ©finit constitue son propre type, mÃªme si les champs au sein de la structure
ont les mÃªmes types. Par exemple, une fonction qui prend un paramÃ¨tre de type
<code>Couleur</code> ne peut pas prendre un argument de type <code>Point</code> Ã  la place, bien que
ces deux types soient tous les deux constituÃ©s de trois valeurs <code>i32</code>. Mis Ã 
part cela, les instances de stuctures tuples se comportent comme des tuplesÂ : on
peut les dÃ©structurer en Ã©lÃ©ments individuels, on peut utiliser un <code>.</code> suivi de
l'indice pour accÃ©der individuellement Ã  une valeur, et ainsi de suite.</p>
<!--
### Unit-Like Structs Without Any Fields
-->
<h3 id="les-structures-unitÃ©-sans-champs"><a class="header" href="#les-structures-unitÃ©-sans-champs">Les structures unitÃ©Â sans champs</a></h3>
<!--
You can also define structs that donâ€™t have any fields! These are called
*unit-like structs* because they behave similarly to `()`, the unit type.
Unit-like structs can be useful in situations in which you need to implement a
trait on some type but donâ€™t have any data that you want to store in the type
itself. Weâ€™ll discuss traits in Chapter 10.
-->
<p>On peut aussi dÃ©finir des structures qui n'ont pas de champsÂ ! Cela s'appelle
des <em>structures unitÃ©</em> parce qu'elles se comportent d'une faÃ§on analogue au type
unitÃ©, <code>()</code>. Les structures unitÃ© sont utiles lorsqu'on doit implÃ©menter un
trait sur un type mais qu'on n'a aucune donnÃ©e Ã  stocker dans le type en
lui-mÃªme. Nous aborderons les traits au chapitre 10.</p>
<!--
> ### Ownership of Struct Data
>
> In the `User` struct definition in Listing 5-1, we used the owned `String`
> type rather than the `&str` string slice type. This is a deliberate choice
> because we want instances of this struct to own all of its data and for that
> data to be valid for as long as the entire struct is valid.
>
> Itâ€™s possible for structs to store references to data owned by something else,
> but to do so requires the use of *lifetimes*, a Rust feature that weâ€™ll
> discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
> is valid for as long as the struct is. Letâ€™s say you try to store a reference
> in a struct without specifying lifetimes, like this, which wonâ€™t work:
>
> <span class="filename">Filename: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -- >
>
> ```rust,ignore,does_not_compile
> struct User {
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
>     active: bool,
> }
>
> fn main() {
>     let user1 = User {
>         email: "someone@example.com",
>         username: "someusername123",
>         active: true,
>         sign_in_count: 1,
>     };
> }
> ```
>
> The compiler will complain that it needs lifetime specifiers:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:2:15
>   |
> 2 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 | struct User<'a> {
> 2 |     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:3:12
>   |
> 3 |     email: &str,
>   |            ^ expected lifetime parameter
>
> error: aborting due to 2 previous errors
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs`
>
> To learn more, run the command again with --verbose.
> ```
>
> In Chapter 10, weâ€™ll discuss how to fix these errors so you can store
> references in structs, but for now, weâ€™ll fix errors like these using owned
> types like `String` instead of references like `&str`.
-->
<blockquote>
<h3 id="la-possession-des-donnÃ©es-dune-structure"><a class="header" href="#la-possession-des-donnÃ©es-dune-structure">La possession des donnÃ©es d'une structure</a></h3>
<p>Dans la dÃ©finition de la structure <code>Utilisateur</code> de l'encart 5-1, nous avions
utilisÃ© le type possÃ©dÃ© <code>String</code> plutÃ´t que le type de <em>slice</em> de chaÃ®ne de
caractÃ¨res <code>&amp;str</code>. Il s'agit d'un choix dÃ©libÃ©rÃ© puisque nous voulons que les
instances de cette structure possÃ¨dent toutes leurs donnÃ©es et que ces donnÃ©es
restent valides tant que la structure tout entiÃ¨re est valide.</p>
<p>Il est possible pour les structures de stocker des rÃ©fÃ©rences vers des donnÃ©es
possÃ©dÃ©es par autre chose, mais cela nÃ©cessiterait d'utiliser des
<em>durÃ©es de vie</em>, une fonctionnalitÃ© de Rust que nous aborderons au
chapitre 10. Les durÃ©es de vie assurent que les donnÃ©es rÃ©fÃ©rencÃ©es par une
structure restent valides tant que la structure l'est aussi. Disons que vous
essayiez de stocker une rÃ©fÃ©rence dans une structure sans indiquer de durÃ©es
de vie, comme ceci, ce qui ne fonctionnera pasÂ :</p>
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct Utilisateur {
    pseudo: &amp;str,
    email: &amp;str,
    nombre_de_connexions: u64,
    actif: bool,
}

fn main() {
    let utilisateur1 = Utilisateur {
        email: &quot;quelquun@example.com&quot;,
        pseudo: &quot;pseudoquelconque123&quot;,
        actif: true,
        nombre_de_connexions: 1,
    };
}
</code></pre>
<p>Le compilateur rÃ©clamera l'ajout des durÃ©es de vieÂ :</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     pseudo: &amp;str,
  |             ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Utilisateur&lt;'a&gt; {
2 |     pseudo: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Utilisateur&lt;'a&gt; {
2 |     pseudo: &amp;str,
3 |     email: &amp;'a str,
  |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`

To learn more, run the command again with --verbose.
</code></pre>
<p>Au chapitre 10, nous aborderons la faÃ§on de corriger ces erreurs pour qu'on
puisse stocker des rÃ©fÃ©rences dans des structures, mais pour le moment, nous
rÃ©soudrons les erreurs comme celles-ci en utilisant des types possÃ©dÃ©s comme
<code>String</code> plutÃ´t que des rÃ©fÃ©rences comme <code>&amp;str</code>.</p>
</blockquote>
<!--
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -- >
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
