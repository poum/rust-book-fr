<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traiter une sÃ©rie d&#x27;Ã©lÃ©ments avec un itÃ©rateur - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html" class="active"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Processing a Series of Items with Iterators
-->
<h2 id="traiter-une-sÃ©rie-dÃ©lÃ©ments-avec-un-itÃ©rateur"><a class="header" href="#traiter-une-sÃ©rie-dÃ©lÃ©ments-avec-un-itÃ©rateur">Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></h2>
<!--
The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you donâ€™t
have to reimplement that logic yourself.
-->
<p>Les itÃ©rateurs vous permettent d'effectuer une tÃ¢che sur une sÃ©quence d'Ã©lÃ©ments
Ã  tour de rÃ´le. Un <em>itÃ©rateur</em> est responsable de la logique d'itÃ©ration sur
chaque Ã©lÃ©ment et de dÃ©terminer lorsque la sÃ©quence est terminÃ©e. Lorsque nous
utilisons des itÃ©rateurs, nous n'avons pas besoin de rÃ©-implÃ©menter cette
logique nous-mÃªmes.</p>
<!--
In Rust, iterators are *lazy*, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector `v1` by calling
the `iter` method defined on `Vec<T>`. This code by itself doesnâ€™t do anything
useful.
-->
<p>En Rust, un itÃ©rateur est <em>une Ã©valuation paresseuse</em>, ce qui signifie qu'il n'a
aucun effet jusqu'Ã  ce que nous appelions des mÃ©thodes qui consomment
l'itÃ©rateur pour l'utiliser. Par exemple, le code dans l'encart 13-13 crÃ©e un
itÃ©rateur sur les Ã©lÃ©ments du vecteur <code>v1</code> en appelant la mÃ©thode <code>iter</code> dÃ©finie
sur <code>Vec&lt;T&gt;</code>. Ce code en lui-mÃªme ne fait rien d'utile.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-13: Creating an iterator</span>
-->
<p><span class="caption">Encart 13-13Â : crÃ©ation d'un itÃ©rateur</span></p>
<!--
Once weâ€™ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with `for` loops to execute some code on
each item, although we glossed over what the call to `iter` did until now.
-->
<p>Une fois que nous avons crÃ©Ã© un itÃ©rateur, nous pouvons l'utiliser de diverses
maniÃ¨res. Dans l'encart 3-4 du chapitre 3, nous avions utilisÃ© des itÃ©rateurs
avec des boucles <code>for</code> pour exÃ©cuter du code sur chaque Ã©lÃ©ment, bien que nous
ayons laissÃ© de cÃ´tÃ© ce que l'appel Ã  <code>iter</code> faisait jusqu'Ã  prÃ©sent.</p>
<!--
The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the `for` loop. The iterator is stored in the `v1_iter`
variable, and no iteration takes place at that time. When the `for` loop is
called using the iterator in `v1_iter`, each element in the iterator is used in
one iteration of the loop, which prints out each value.
-->
<p>L'exemple dans l'encart 13-14 sÃ©pare la crÃ©ation de l'itÃ©rateur de son
utilisation dans la boucle <code>for</code>. L'itÃ©rateur est stockÃ© dans la variable
<code>v1_iter</code>, et aucune itÃ©ration n'a lieu Ã  ce moment-lÃ . Lorsque la boucle <code>for</code>
est appelÃ©e en utilisant l'itÃ©rateur <code>v1_iter</code>, chaque Ã©lÃ©ment de l'itÃ©rateur
est utilisÃ© Ã  chaque itÃ©ration de la boucle, qui affiche chaque valeur.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;On aÂ : {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-14: Using an iterator in a `for` loop</span>
-->
<p><span class="caption">Encart 13-14Â : utilisation d'un itÃ©rateur dans une boucle
<code>for</code></span></p>
<!--
In languages that donâ€™t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.
-->
<p>Dans les langages qui n'ont pas d'itÃ©rateurs fournis par leur bibliothÃ¨que
standard, nous Ã©cririons probablement cette mÃªme fonctionnalitÃ© en dÃ©marrant une
variable Ã  l'indice 0, utiliser cette variable comme indice sur le vecteur afin
d'obtenir une valeur, et incrÃ©menter la valeur de cette variable dans une boucle
jusqu'Ã  ce qu'elle atteigne le nombre total d'Ã©lÃ©ments dans le vecteur.</p>
<!--
Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Letâ€™s examine how iterators do that.
-->
<p>Les itÃ©rateurs s'occupent de toute cette logique pour nous, rÃ©duisant le code
redondant dans lequel nous pourrions potentiellement faire des erreurs. Les
itÃ©rateurs nous donnent plus de flexibilitÃ© pour utiliser la mÃªme logique avec
de nombreux types de sÃ©quences diffÃ©rentes, et non pas uniquement avec des
structures de donnÃ©es avec lesquelles nous pouvons utiliser des indices, comme
les vecteurs. Voyons comment les itÃ©rateurs font cela.</p>
<!--
### The `Iterator` Trait and the `next` Method
-->
<h3 id="le-trait-iterator-et-la-mÃ©thode-next"><a class="header" href="#le-trait-iterator-et-la-mÃ©thode-next">Le trait <code>Iterator</code> et la mÃ©thode <code>next</code></a></h3>
<!--
All iterators implement a trait named `Iterator` that is defined in the
standard library. The definition of the trait looks like this:
-->
<p>Tous les itÃ©rateurs implÃ©mentent un trait appelÃ© <code>Iterator</code> qui est dÃ©fini dans
la bibliothÃ¨que standard. La dÃ©finition du trait ressemble Ã  ceciÂ :</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // les mÃ©thodes avec des implÃ©mentations par dÃ©faut ont Ã©tÃ© exclues
}
<span class="boring">}
</span></code></pre></pre>
<!--
Notice this definition uses some new syntax: `type Item` and `Self::Item`,
which are defining an *associated type* with this trait. Weâ€™ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the `Iterator` trait requires that you also define
an `Item` type, and this `Item` type is used in the return type of the `next`
method. In other words, the `Item` type will be the type returned from the
iterator.
-->
<p>Remarquez que cette dÃ©finition utilise une nouvelle syntaxeÂ : <code>type Item</code> et
<code>Self::Item</code>, qui dÃ©finissent un <em>type associÃ©</em> Ã  ce trait. Nous verrons ce que
sont les types associÃ©s au chapitre 19. Pour l'instant, tout ce que vous devez
savoir est que ce code dit que l'implÃ©mentation du trait <code>Iterator</code> nÃ©cessite
que vous dÃ©finissiez aussi un type <code>Item</code>, et ce type <code>Item</code> est utilisÃ© dans le
type de retour de la mÃ©thode <code>next</code>. En d'autres termes, le type <code>Item</code> sera le
type retournÃ© par l'itÃ©rateur.</p>
<!--
The `Iterator` trait only requires implementors to define one method: the
`next` method, which returns one item of the iterator at a time wrapped in
`Some` and, when iteration is over, returns `None`.
-->
<p>Le trait <code>Iterator</code> exige la dÃ©finition d'une seule mÃ©thode par les
dÃ©veloppeursÂ : la mÃ©thode <code>next</code>, qui retourne un Ã©lÃ©ment de l'itÃ©rateur Ã  la
fois intÃ©grÃ© dans un <code>Some</code>, et lorsque l'itÃ©ration est terminÃ©e, il retourne
<code>None</code>.</p>
<!--
We can call the `next` method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to `next` on the iterator created
from the vector.
-->
<p>On peut appeler la mÃ©thode <code>next</code> directement sur les itÃ©rateursÂ ; l'encart
13-15 montre quelles valeurs sont retournÃ©es par des appels rÃ©pÃ©tÃ©s Ã  <code>next</code> sur
l'itÃ©rateur crÃ©Ã© Ã  partir du vecteur.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn demo_iterateur() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-15: Calling the `next` method on an
iterator</span>
-->
<p><span class="caption">Encart 13-15Â : appel de la mÃ©thode <code>next</code> sur un itÃ©rateur
</span></p>
<!--
Note that we needed to make `v1_iter` mutable: calling the `next` method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code *consumes*, or uses up, the
iterator. Each call to `next` eats up an item from the iterator. We didnâ€™t need
to make `v1_iter` mutable when we used a `for` loop because the loop took
ownership of `v1_iter` and made it mutable behind the scenes.
-->
<p>Remarquez que nous avons eu besoin de rendre mutable <code>v1_iter</code>Â : appeler la
mÃ©thode <code>next</code> sur un iterator change son Ã©tat interne qui garde en mÃ©moire oÃ¹
il est dans la sÃ©quence. En d'autres termes, ce code <em>consomme</em>, ou utilise,
l'itÃ©rateur. Chaque appel Ã  <code>next</code> consomme un Ã©lÃ©ment de l'itÃ©rateur. Nous
n'avions pas eu besoin de rendre mutable <code>v1_iter</code> lorsque nous avions utilisÃ©
une boucle <code>for</code> parce que la boucle avait pris possession de <code>v1_iter</code> et l'a
rendu mutable en coulisses.</p>
<!--
Also note that the values we get from the calls to `next` are immutable
references to the values in the vector. The `iter` method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of `v1` and returns owned values, we can call `into_iter` instead of
`iter`. Similarly, if we want to iterate over mutable references, we can call
`iter_mut` instead of `iter`.
-->
<p>Notez Ã©galement que les valeurs que nous obtenons des appels Ã  <code>next</code> sont des
rÃ©fÃ©rences immuables aux valeurs dans le vecteur. La mÃ©thode <code>iter</code> produit un
itÃ©rateur pour des rÃ©fÃ©rences immuables. Si nous voulons crÃ©er un itÃ©rateur qui
prend possession de <code>v1</code> et retourne les valeurs possÃ©dÃ©es, nous pouvons appeler
<code>into_iter</code> au lieu de <code>iter</code>. De mÃªme, si nous voulons itÃ©rer sur des
rÃ©fÃ©rences mutables, nous pouvons appeler <code>iter_mut</code> au lieu de <code>iter</code>.</p>
<!--
### Methods that Consume the Iterator
-->
<h3 id="les-mÃ©thodes-qui-consomment-un-itÃ©rateur"><a class="header" href="#les-mÃ©thodes-qui-consomment-un-itÃ©rateur">Les mÃ©thodes qui consomment un itÃ©rateur</a></h3>
<!--
The `Iterator` trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the `Iterator`
trait. Some of these methods call the `next` method in their definition, which
is why youâ€™re required to implement the `next` method when implementing the
`Iterator` trait.
-->
<p>Le trait <code>Iterator</code> a un certain nombre de mÃ©thodes diffÃ©rentes avec des
implÃ©mentations par dÃ©faut que nous fournit la bibliothÃ¨que standardÂ ; vous
pouvez dÃ©couvrir ces mÃ©thodes en regardant dans la documentation de l'API de la
bibliothÃ¨que standard pour le trait <code>Iterator</code>. Certaines de ces mÃ©thodes
appellent la mÃ©thode <code>next</code> dans leur dÃ©finition, c'est pourquoi nous devons
toujours implÃ©menter la mÃ©thode <code>next</code> lors de l'implÃ©mentation du trait
<code>Iterator</code>.</p>
<!--
Methods that call `next` are called *consuming adaptors*, because calling them
uses up the iterator. One example is the `sum` method, which takes ownership of
the iterator and iterates through the items by repeatedly calling `next`, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the `sum` method:
-->
<p>Les mÃ©thodes qui appellent <code>next</code> sont appelÃ©es des
<em>adaptateurs de consommation</em>, parce que les appeler consomme l'itÃ©rateur. Un
exemple est la mÃ©thode <code>sum</code>, qui prend possession de l'itÃ©rateur et itÃ©re sur
ses Ã©lÃ©ments en appelant plusieurs fois <code>next</code>, consommant ainsi l'itÃ©rateur. A
chaque Ã©tape de l'itÃ©ration, il ajoute chaque Ã©lÃ©ment Ã  un total en cours et
retourne le total une fois l'itÃ©ration terminÃ©e. L'encart 13-16 a un test
illustrant une utilisation de la mÃ©thode <code>sum</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-16: Calling the `sum` method to get the total
of all items in the iterator</span>
-->
<p><span class="caption">Encart 13-16Â : appel de la mÃ©thode <code>sum</code> pour obtenir la
somme de tous les Ã©lÃ©ments prÃ©sents dans l'itÃ©rateur</span></p>
<!--
We arenâ€™t allowed to use `v1_iter` after the call to `sum` because `sum` takes
ownership of the iterator we call it on.
-->
<p>Nous ne sommes pas autorisÃ©s Ã  utiliser <code>v1_iter</code> aprÃ¨s l'appel Ã  <code>sum</code> car
<code>sum</code> a pris possession de l'itÃ©rateur sur lequel nous l'appelons.</p>
<!--
### Methods that Produce Other Iterators
-->
<h3 id="mÃ©thodes-qui-produisent-dautres-itÃ©rateurs"><a class="header" href="#mÃ©thodes-qui-produisent-dautres-itÃ©rateurs">MÃ©thodes qui produisent d'autres itÃ©rateurs</a></h3>
<!--
Other methods defined on the `Iterator` trait, known as *iterator adaptors*,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.
-->
<p>D'autres mÃ©thodes dÃ©finies sur le trait <code>Iterator</code>, connues sous le nom
<em>d'adaptateurs d'itÃ©ration</em>, nous permettent de transformer un itÃ©rateur en un
type d'itÃ©rateur diffÃ©rent. Nous pouvons enchaÃ®ner plusieurs appels Ã  des
adaptateurs d'itÃ©ration pour effectuer des actions complexes de maniÃ¨re
comprÃ©hensible. Mais comme les itÃ©rateurs sont <em>des Ã©valuations paresseuses</em>,
nous devons faire appel Ã  l'une des mÃ©thodes d'adaptation de consommation pour
obtenir les rÃ©sultats des appels aux adaptateurs d'itÃ©ration.</p>
<!--
Listing 13-17 shows an example of calling the iterator adaptor method `map`,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:
-->
<p>L'encart 13-17 montre un exemple d'appel Ã  la mÃ©thode d'adaptation d'itÃ©ration
<code>map</code>, qui prend en paramÃ¨tre une fermeture qui va s'exÃ©cuter sur chaque Ã©lÃ©ment
pour produire un nouvel itÃ©rateur. La fermeture crÃ©e ici un nouvel itÃ©rateur
dans lequel chaque Ã©lÃ©ment du vecteur a Ã©tÃ© incrÃ©mentÃ© de 1. Cependant, ce code
dÃ©clenche un avertissementÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,not_desired_behavior
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
# }
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-17: Calling the iterator adaptor `map` to
create a new iterator</span>
-->
<p><span class="caption">Encart 13-17Â : appel de l'adaptateur d'itÃ©ration <code>map</code>
pour crÃ©er un nouvel itÃ©rateur</span></p>
<!--
The warning we get is this:
-->
<p>Voici l'avertissement que nous obtenonsÂ :</p>
<!--
```console
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 -- > src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```
-->
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<!--
The code in Listing 13-17 doesnâ€™t do anything; the closure weâ€™ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.
-->
<p>Le code dans l'encart 13-17 ne fait rienÂ ; la fermeture que nous avons renseignÃ©
n'est jamais exÃ©cutÃ©. L'avertissement nous rappelle pourquoiÂ : les adaptateurs
d'itÃ©ration sont des <em>Ã©valuations paresseuses</em>, c'est pourquoi nous devons
consommer l'itÃ©rateur ici.</p>
<!--
To fix this and consume the iterator, weâ€™ll use the `collect` method, which we
used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.
-->
<p>Pour corriger ceci et consommer l'itÃ©rateur, nous utiliserons la mÃ©thode
<code>collect</code>, que vous avez utilisÃ© avec <code>env::args</code> dans l'encart 12-1 du
chapitre 12. Cette mÃ©thode consomme l'itÃ©rateur et collecte les valeurs
rÃ©sultantes dans un type de collection de donnÃ©es.</p>
<!--
In Listing 13-18, we collect the results of iterating over the iterator thatâ€™s
returned from the call to `map` into a vector. This vector will end up
containing each item from the original vector incremented by 1.
-->
<p>Dans l'encart 13-18, nous recueillons les rÃ©sultats de l'itÃ©ration sur
l'itÃ©rateur qui sont retournÃ©s par l'appel Ã  <code>map</code> sur un vecteur. Ce vecteur
finira par contenir chaque Ã©lÃ©ment du vecteur original incrÃ©mentÃ© de 1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-18: Calling the `map` method to create a new
iterator and then calling the `collect` method to consume the new iterator and
create a vector</span>
-->
<p><span class="caption">Encart 13-18Â : appel de la mÃ©thode <code>map</code> pour crÃ©er un
nouvel itÃ©rateur, puis appel de la mÃ©thode <code>collect</code> pour consommer le nouvel
itÃ©rateur afin de crÃ©er un vecteur</span></p>
<!--
Because `map` takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the `Iterator` trait
provides.
-->
<p>Comme <code>map</code> prend en paramÃ¨tre une fermeture, nous pouvons renseigner n'importe
quelle opÃ©ration que nous souhaitons exÃ©cuter sur chaque Ã©lÃ©ment. C'est un bon
exemple de la faÃ§on dont les fermetures nous permettent de personnaliser
certains comportements tout en rÃ©utilisant le comportement d'itÃ©ration fourni
par le trait <code>Iterator</code>.</p>
<!--
### Using Closures that Capture Their Environment
-->
<h3 id="utilisation-de-fermetures-capturant-leur-environnement"><a class="header" href="#utilisation-de-fermetures-capturant-leur-environnement">Utilisation de fermetures capturant leur environnement</a></h3>
<!--
Now that weâ€™ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the `filter` iterator adaptor.
The `filter` method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns `true`, the value
will be included in the iterator produced by `filter`. If the closure returns
`false`, the value wonâ€™t be included in the resulting iterator.
-->
<p>Maintenant que nous avons prÃ©sentÃ© les itÃ©rateurs, nous pouvons illustrer une
utilisation commune des fermetures qui capturent leur environnement en utilisant
l'adaptateur d'itÃ©ration <code>filter</code>. La mÃ©thode <code>filter</code> appelÃ©e sur un itÃ©rateur
prend en paramÃ¨tre une fermeture qui s'exÃ©cute sur chaque Ã©lÃ©ment de l'itÃ©rateur
et retourne un boolÃ©en pour chacun. Si la fermeture retourne <code>true</code>, la valeur
sera incluse dans l'itÃ©rateur produit par <code>filter</code>. Si la fermeture retourne
<code>false</code>, la valeur ne sera pas incluse dans l'itÃ©rateur rÃ©sultant.</p>
<!--
In Listing 13-19, we use `filter` with a closure that captures the `shoe_size`
variable from its environment to iterate over a collection of `Shoe` struct
instances. It will return only shoes that are the specified size.
-->
<p>Dans l'encart 13-19, nous utilisons <code>filter</code> avec une fermeture qui capture la
variable <code>pointure_chaussure</code> de son environnement pour itÃ©rer sur une
collection d'instances de la structure <code>Chaussure</code>. Il ne retournera que les
chaussures avec la pointure demandÃ©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Debug)]
struct Chaussure {
    pointure: u32,
    style: String,
}

fn chaussures_a_la_pointure(chaussures: Vec&lt;Chaussure&gt;, pointure_chaussure: u32) -&gt; Vec&lt;Chaussure&gt; {
    chaussures.into_iter()
              .filter(|s| s.pointure == pointure_chaussure)
              .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filtres_par_pointure() {
        let chaussures = vec![
            Chaussure {
                pointure: 10,
                style: String::from(&quot;baskets&quot;),
            },
            Chaussure {
                pointure: 13,
                style: String::from(&quot;sandale&quot;),
            },
            Chaussure {
                pointure: 10,
                style: String::from(&quot;bottes&quot;),
            },
        ];

        let a_ma_pointure = chaussures_a_la_pointure(chaussures, 10);

        assert_eq!(
            a_ma_pointure,
            vec![
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;baskets&quot;)
                },
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;bottes&quot;)
                },
            ]
        );
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 13-19: Using the `filter` method with a closure
that captures `shoe_size`</span>
-->
<p><span class="caption">Encart 13-19Â : utilisation de la mÃ©thode <code>filter</code> avec une
fermeture capturant <code>pointure_chaussure</code></span></p>
<!--
The `shoes_in_my_size` function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.
-->
<p>La fonction <code>chaussures_a_la_pointure</code> prend possession d'un vecteur de
chaussures et d'une pointure comme paramÃ¨tres. Il retourne un vecteur contenant
uniquement des chaussures de la pointure demandÃ©e.</p>
<!--
In the body of `shoes_in_my_size`, we call `into_iter` to create an iterator
that takes ownership of the vector. Then we call `filter` to adapt that
iterator into a new iterator that only contains elements for which the closure
returns `true`.
-->
<p>Dans le corps de <code>chaussures_a_la_pointure</code>, nous appelons <code>into_iter</code> pour
crÃ©er un itÃ©rateur qui prend possession du vecteur. Ensuite, nous appelons
<code>filter</code> pour adapter cet itÃ©rateur dans un nouvel itÃ©rateur qui ne contient que
les Ã©lÃ©ments pour lesquels la fermeture retourne <code>true</code>.</p>
<!--
The closure captures the `shoe_size` parameter from the environment and
compares the value with each shoeâ€™s size, keeping only shoes of the size
specified. Finally, calling `collect` gathers the values returned by the
adapted iterator into a vector thatâ€™s returned by the function.
-->
<p>La fermeture capture le paramÃ¨tre <code>pointure_chaussure</code> de l'environnement et
compare la valeur avec la pointure de chaque chaussure, en ne gardant que les
chaussures de la pointure spÃ©cifiÃ©e. Enfin, l'appel Ã  <code>collect</code> retourne un
vecteur qui regroupe les valeurs renvoyÃ©es par l'itÃ©rateur.</p>
<!--
The test shows that when we call `shoes_in_my_size`, we get back only shoes
that have the same size as the value we specified.
-->
<p>Le test confirme que lorsque nous appelons <code>chaussures_a_la_pointure</code>, nous
n'obtenons que des chaussures qui ont la mÃªme pointure que la valeur que nous
avons demandÃ©.</p>
<!--
### Creating Our Own Iterators with the `Iterator` Trait
-->
<h3 id="crÃ©er-nos-propres-itÃ©rateurs-avec-le-trait-iterator"><a class="header" href="#crÃ©er-nos-propres-itÃ©rateurs-avec-le-trait-iterator">CrÃ©er nos propres itÃ©rateurs avec le trait <code>Iterator</code></a></h3>
<!--
Weâ€™ve shown that you can create an iterator by calling `iter`, `into_iter`, or
`iter_mut` on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the `Iterator` trait on your own
types. As previously mentioned, the only method youâ€™re required to provide a
definition for is the `next` method. Once youâ€™ve done that, you can use all
other methods that have default implementations provided by the `Iterator`
trait!
-->
<p>Nous avons vu que nous pouvons crÃ©er un itÃ©rateur en appelant <code>iter</code>,
<code>into_iter</code>, ou <code>iter_mut</code> sur un vecteur. Nous pouvons crÃ©er des itÃ©rateurs Ã 
partir d'autres types de collections de la bibliothÃ¨que standard, comme les
tables de hachage. Nous pouvons aussi crÃ©er des itÃ©rateurs qui font tout ce que
nous voulons en implÃ©mentant le trait <code>Iterator</code> sur nos propres types. Comme
nous l'avons mentionnÃ© prÃ©cÃ©demment, la seule mÃ©thode pour laquelle nous devons
fournir une dÃ©finition est la mÃ©thode <code>next</code>. Une fois que nous avons fait cela,
nous pouvons utiliser toutes les autres mÃ©thodes qui ont des implÃ©mentations par
dÃ©faut fournies par le trait <code>Iterator</code>Â !</p>
<!--
To demonstrate, letâ€™s create an iterator that will only ever count from 1 to 5.
First, weâ€™ll create a struct to hold some values. Then weâ€™ll make this struct
into an iterator by implementing the `Iterator` trait and using the values in
that implementation.
-->
<p>Pour preuve, crÃ©ons un itÃ©rateur qui ne comptera que de 1 Ã  5. D'abord, nous
allons crÃ©er une structure contenant quelques valeurs. Ensuite nous
transformerons cette structure en itÃ©rateur en implÃ©mentant le trait <code>Iterator</code>
et nous utiliserons les valeurs de cette implÃ©mentation.</p>
<!--
Listing 13-20 has the definition of the `Counter` struct and an associated
`new` function to create instances of `Counter`:
-->
<p>L'encart 13-20 montre la dÃ©finition de la structure <code>Compteur</code> et une fonction
associÃ©e <code>new</code> pour crÃ©er des instances de <code>Compteur</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Compteur {
    compteur: u32,
}

impl Compteur {
    fn new() -&gt; Compteur {
        Compteur { compteur: 0 }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 13-20: Defining the `Counter` struct and a `new`
function that creates instances of `Counter` with an initial value of 0 for
`count`</span>
-->
<p><span class="caption">Encart 13-20Â : dÃ©finition de la structure <code>Compteur</code> et
d'une fonction <code>new</code> qui crÃ©e des instances de <code>Compteur</code> avec une valeur
initiale de 0 pour le champ <code>compteur</code>.</span></p>
<!--
The `Counter` struct has one field named `count`. This field holds a `u32`
value that will keep track of where we are in the process of iterating from 1
to 5. The `count` field is private because we want the implementation of
`Counter` to manage its value. The `new` function enforces the behavior of
always starting new instances with a value of 0 in the `count` field.
-->
<p>La structure <code>Compteur</code> a un champ <code>compteur</code>. Ce champ contient une valeur
<code>u32</code> qui gardera la trace de l'endroit oÃ¹ nous sommes dans le processus
d'itÃ©ration de 1 Ã  5. Le champ <code>compteur</code> est privÃ© car nous voulons que ce soit
l'implÃ©mentation de <code>Compteur</code> qui gÃ¨re sa valeur. La fonction <code>new</code> impose le
de toujours dÃ©marrer de nouvelles instances avec une valeur de 0 pour le champ
<code>compteur</code>.</p>
<!--
Next, weâ€™ll implement the `Iterator` trait for our `Counter` type by defining
the body of the `next` method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:
-->
<p>Ensuite, nous allons implÃ©menter le trait <code>Iterator</code> sur notre type <code>Compteur</code>
en dÃ©finissant le corps de la mÃ©thode <code>next</code> pour prÃ©ciser ce que nous voulons
qu'il se passe quand cet itÃ©rateur est utilisÃ©, comme dans l'encart 13-21Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.compteur &lt; 5 {
            self.compteur += 1;
            Some(self.compteur)
        } else {
            None
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-21: Implementing the `Iterator` trait on our
`Counter` struct</span>
-->
<p><span class="caption">Encart 13-21Â : implÃ©mentation du trait <code>Iterator</code> sur
notre structure <code>Compteur</code></span></p>
<!--
We set the associated `Item` type for our iterator to `u32`, meaning the
iterator will return `u32` values. Again, donâ€™t worry about associated types
yet, weâ€™ll cover them in Chapter 19.
-->
<p>Nous avons dÃ©fini le type associÃ© <code>Item</code> pour notre itÃ©rateur Ã  <code>u32</code>, ce qui
signifie que l'itÃ©rateur renverra des valeurs <code>u32</code>. Encore une fois, ne vous
prÃ©occupez pas des types associÃ©s, nous les aborderons au chapitre 19.</p>
<!--
We want our iterator to add 1 to the current state, so we initialized `count`
to 0 so it would return 1 first. If the value of `count` is less than 5, `next`
will increment `count` and return the current value wrapped in `Some`. Once
`count` is 5, our iterator will stop incrementing `count` and always return
`None`.
-->
<p>Nous voulons que notre itÃ©rateur ajoute 1 Ã  l'Ã©tat courant, donc nous avons
initialisÃ© <code>compteur</code> Ã  0 pour qu'il retourne 1 lors du premier appel Ã  <code>next</code>.
Si la valeur de <code>compteur</code> est strictement infÃ©rieure Ã  5, <code>next</code> va incrÃ©menter
<code>compteur</code> puis va retourner valeur courante intÃ©grÃ©e dans un <code>Some</code>. Une fois
que <code>compteur</code> vaudra 5, notre itÃ©rateur va arrÃªter d'incrÃ©menter <code>compteur</code> et
retournera toujours <code>None</code>.</p>
<!--
#### Using Our `Counter` Iteratorâ€™s `next` Method
-->
<h3 id="utiliser-la-mÃ©thode-next-de-notre-itÃ©rateur-compteur"><a class="header" href="#utiliser-la-mÃ©thode-next-de-notre-itÃ©rateur-compteur">Utiliser la mÃ©thode <code>next</code> de notre ItÃ©rateur <code>Compteur</code></a></h3>
<!--
Once weâ€™ve implemented the `Iterator` trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
`Counter` struct by calling the `next` method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.
-->
<p>Une fois que nous avons implÃ©mentÃ© le trait <code>Iterator</code>, nous avons un
itÃ©rateurÂ ! L'encart 13-22 montre un test dÃ©montrant que nous pouvons utiliser
la fonctionnalitÃ© d'itÃ©ration de notre structure <code>Compteur</code> en appelant
directement la mÃ©thode <code>next</code>, comme nous l'avons fait avec l'itÃ©rateur crÃ©Ã© Ã 
partir d'un vecteur dans l'encart 13-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_direct_a_next() {
        let mut compteur = Compteur::new();

        assert_eq!(compteur.next(), Some(1));
        assert_eq!(compteur.next(), Some(2));
        assert_eq!(compteur.next(), Some(3));
        assert_eq!(compteur.next(), Some(4));
        assert_eq!(compteur.next(), Some(5));
        assert_eq!(compteur.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-22: Testing the functionality of the `next`
method implementation</span>
-->
<p><span class="caption">Encart 13-22Â : test de l'implÃ©mentation de la mÃ©thode
<code>next</code></span></p>
<!--
This test creates a new `Counter` instance in the `counter` variable and then
calls `next` repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.
-->
<p>Ce test crÃ©Ã© une nouvelle instance de <code>Compteur</code> dans la variable <code>compteur</code> et
appelle ensuite <code>next</code> Ã  plusieurs reprises, en vÃ©rifiant que nous avons
implÃ©mentÃ© le comportement que nous voulions que cet itÃ©rateur suiveÂ : renvoyer
les valeurs de 1 Ã  5.</p>
<!--
#### Using Other `Iterator` Trait Methods
-->
<h4 id="utiliser-dautres-mÃ©thodes-du-trait-iterator"><a class="header" href="#utiliser-dautres-mÃ©thodes-du-trait-iterator">Utiliser d'autres mÃ©thodes du trait <code>Iterator</code></a></h4>
<!--
We implemented the `Iterator` trait by defining the `next` method, so we
can now use any `Iterator` trait methodâ€™s default implementations as defined in
the standard library, because they all use the `next` methodâ€™s functionality.
-->
<p>Maintenant que nous avons implÃ©mentÃ© le trait <code>Iterator</code> en dÃ©finissant la
mÃ©thode <code>next</code>, nous pouvons maintenant utiliser les implÃ©mentations par dÃ©faut
de n'importe quelle mÃ©thode du trait <code>Iterator</code> telles que dÃ©finies dans la
bibliothÃ¨que standard, car elles utilisent toutes la mÃ©thode <code>next</code>.</p>
<!--
For example, if for some reason we wanted to take the values produced by an
instance of `Counter`, pair them with values produced by another `Counter`
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:
-->
<p>Par exemple, si pour une raison quelconque nous voulions prendre les valeurs
produites par une instance de <code>Compteur</code>, les coupler avec des valeurs produites
par une autre instance de <code>Compteur</code> aprÃ¨s avoir sautÃ© la premiÃ¨re valeur,
multiplier chaque paire ensemble, ne garder que les rÃ©sultats qui sont
divisibles par 3 et additionner toutes les valeurs rÃ©sultantes ensemble, nous
pourrions le faire, comme le montre le test dans l'encart 13-23Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn calling_next_directly() {
#         let mut counter = Counter::new();
# 
#         assert_eq!(counter.next(), Some(1));
#         assert_eq!(counter.next(), Some(2));
#         assert_eq!(counter.next(), Some(3));
#         assert_eq!(counter.next(), Some(4));
#         assert_eq!(counter.next(), Some(5));
#         assert_eq!(counter.next(), None);
#     }
# 
    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn appel_direct_a_next() {
</span><span class="boring">        let mut compteur = Compteur::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(compteur.next(), Some(1));
</span><span class="boring">        assert_eq!(compteur.next(), Some(2));
</span><span class="boring">        assert_eq!(compteur.next(), Some(3));
</span><span class="boring">        assert_eq!(compteur.next(), Some(4));
</span><span class="boring">        assert_eq!(compteur.next(), Some(5));
</span><span class="boring">        assert_eq!(compteur.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn utilisation_des_autres_methodes_du_trait_iterator() {
        let somme: u32 = Compteur::new()
            .zip(Compteur::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, somme);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-23: Using a variety of `Iterator` trait
methods on our `Counter` iterator</span>
-->
<p><span class="caption">Encart 13-23Â : utilisation d'une gamme de mÃ©thodes de
traits <code>Iterator</code> sur notre itÃ©rateur <code>Counter</code> </span></p>
<!--
Note that `zip` produces only four pairs; the theoretical fifth pair `(5,
None)` is never produced because `zip` returns `None` when either of its input
iterators return `None`.
-->
<p>Notez que <code>zip</code> ne produit que quatre pairesÂ ; la cinquiÃ¨me paire thÃ©orique
<code>(5, None)</code> n'est jamais produite car <code>zip</code> retourne <code>None</code> lorsque l'un de
ses itÃ©rateurs d'entrÃ©e retourne <code>None</code>.</p>
<!--
All of these method calls are possible because we specified how the `next`
method works, and the standard library provides default implementations for
other methods that call `next`.
-->
<p>Tous ces appels de mÃ©thode sont possibles car nous avons renseignÃ© comment
la mÃ©thode <code>next</code> fonctionne et la bibliothÃ¨que standard fournit des
implÃ©mentations par dÃ©faut pour les autres mÃ©thodes qui appellent <code>next</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
