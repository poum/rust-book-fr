<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Développer les fonctionnalités de la bibliothèque avec le TDD - Le langage de programmation Rust</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrôle</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les références et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Définir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des méthodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les énumérations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Définir une énumération</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrôle match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrôle concise : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Gérer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Définir des modules pour gérer la portée et la visibilité</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Désigner un élément dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portée via le mot-clé use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Séparer les modules dans différents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodé en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clés associées à des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrécupérables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs récupérables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types génériques, les traits et les durées de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de données génériques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Définir des comportements partagés avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformité des références avec les durées de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisés</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment écrire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Gérer l'exécution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrée/sortie : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Récupérer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour améliorer sa modularité et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html" class="active"><strong aria-hidden="true">12.4.</strong> Développer les fonctionnalités de la bibliothèque avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalités des langages fonctionnels : les itérateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une série d'éléments avec un itérateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Amélioration de notre projet d'entrée/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances : les boucles et les itérateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires à partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalités de cargo avec des commandes personnalisées</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des données présentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Considérer les pointeurs intelligents comme des références grâce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Exécuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les références</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilité interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de références qui peuvent provoquer des fuites de mémoire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les tâches pour exécuter simultanément du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transférer des données entre les tâches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'état en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalités orientées objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caractéristiques des langages orientés objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types différents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implémenter un patron de conception orienté-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits où les motifs peuvent être utilisés</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La réfutabilité : lorsqu'un motif peut échouer à correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalités avancées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non sécurisé (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avancés</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avancés</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avancées</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multitâches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Développer un serveur web monotâche</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monotâche en serveur multitâches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arrêt propre et nettoyage</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Developing the Library’s Functionality with Test-Driven Development
-->
<h2 id="développer-les-fonctionnalités-de-la-bibliothèque-avec-le-tdd"><a class="header" href="#développer-les-fonctionnalités-de-la-bibliothèque-avec-le-tdd">Développer les fonctionnalités de la bibliothèque avec le TDD</a></h2>
<!--
Now that we’ve extracted the logic into *src/lib.rs* and left the argument
collecting and error handling in *src/main.rs*, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the `Config::new` and `run` functions on your own.
-->
<p>Maintenant que nous avons extrait la logique dans <em>src/lib.rs</em> et que nous
avons laissé la récupération des arguments et la gestion des erreurs dans
<em>src/main.rs</em>, il est bien plus facile d'écrire les tests pour les
fonctionnalités de base de notre code. Nous pouvons appeler les fonctions
directement avec différents arguments et vérifier les valeurs de retour sans
avoir à appeler notre binaire dans la ligne de commande. N'hésitez pas à écrire
quelques tests par vous-même pour les fonctions <code>Config::new</code> et <code>run</code>.</p>
<!--
In this section, we’ll add the searching logic to the `minigrep` program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:
-->
<p>Dans cette section, nous allons ajouter la logique de recherche au programme
<code>minigrep</code> en utilisant le processus de développement orienté par les tests
(c'est le TDD : <em>Test-Driven Development</em>). Cette technique de développement
de logiciels suit ces trois étapes :</p>
<!--
1. Write a test that fails and run it to make sure it fails for the reason you
   expect.
2. Write or modify just enough code to make the new test pass.
3. Refactor the code you just added or changed and make sure the tests
   continue to pass.
4. Repeat from step 1!
-->
<ol>
<li>Ecrire un test qui échoue et lancez-le pour vous assurer qu'il va échouer
pour la raison que vous attendiez.</li>
<li>Ecrire ou modifier juste assez de code pour faire réussir ce nouveau test.</li>
<li>Remanier le code que vous venez d'ajouter ou de changer pour vous assurer
que les tests continuent à réussir.</li>
<li>Recommencer à l'étape 1 !</li>
</ol>
<!--
This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.
-->
<p>Ce processus n'est qu'une des différentes manières d'écrire des programmes,
mais le TDD peut aussi aider à piloter sa conception. Ecrire les tests avant
d'écrire le code qui fait réussir les tests aide à maintenir une haute
couverture de tests tout le long du processus.</p>
<!--
We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
`search`.
-->
<p>Nous allons expérimenter cela avec l'implémentation de la fonctionnalité qui va
rechercher la chaîne de caractères demandée dans le contenu du fichier et
générer une liste de lignes qui correspond à cette recherche. Nous ajouterons
cette fonctionnalité dans une fonction <code>rechercher</code>.</p>
<!--
### Writing a Failing Test
-->
<h3 id="ecrire-un-test-qui-échoue"><a class="header" href="#ecrire-un-test-qui-échoue">Ecrire un test qui échoue</a></h3>
<!--
Because we don’t need them anymore, let’s remove the `println!` statements from
*src/lib.rs* and *src/main.rs* that we used to check the program’s behavior.
Then, in *src/lib.rs*, we’ll add a `tests` module with a test function, as we
did in [Chapter 11][ch11-anatomy]<!-- ignore -- >. The test function specifies
the behavior we want the `search` function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which won’t compile
yet.
-->
<p>Comme nous n'en avons plus besoin, enlevons les instructions <code>println!</code> de
<em>src/lib.rs</em> et <em>src/main.rs</em> que nous avions utilisé pour vérifier le bon
comportement du programme. Ensuite, dans <em>src/lib.rs</em>, nous allons ajouter un
module <code>tests</code> avec une fonction de test, comme nous l'avions fait dans le
<a href="ch11-01-writing-tests.html">chapitre 11</a><!-- ignore -->. La fonction de test définit le
comportement que nous voulons qu'ait la fonction <code>rechercher</code> : elle va prendre
en arguments une recherche et le texte dans lequel rechercher, et elle va
retourner seulement les lignes du texte qui correspondent à la recherche.
L'encart 12-15 montre ce test, qui ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_resultat() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
sécurité, rapidité, productivité.
Obtenez les trois en même temps.&quot;;

        assert_eq!(
            vec![&quot;sécurité, rapidité, productivité.&quot;],
            rechercher(recherche, contenu)
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-15: Creating a failing test for the `search`
function we wish we had</span>
-->
<p><span class="caption">Encart 12-15 : Création d'un test qui échoue pour la
fonction <code>rechercher</code> que nous souhaitons concevoir</span></p>
<!--
This test searches for the string `"duct"`. The text we’re searching is three
lines, only one of which contains `"duct"` (Note that the backslash after the
opening double quote tells Rust not to put a newline character at the beginning
of the contents of this string literal). We assert that the value returned from
the `search` function contains only the line we expect.
-->
<p>Ce test recherche la chaîne de caractères <code>&quot;duct&quot;</code>. Le texte dans lequel nous
recherchons fait trois lignes, et seulement une d'entre elles contient <code>&quot;duct&quot;</code>
(remarquez que l'antislash après la double-guillet ouvrante indique à Rust de
ne pas insérer un caractère de nouvelle ligne au début du contenu de ce litéral
de chaîne de caractère). Nous vérifions que la valeur retournée par la fonction
<code>rechercher</code> contient seulement la ligne que nous avions prévu.</p>
<!--
We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the `search` function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the `search`
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line `"safe, fast, productive."`
-->
<p>Nous ne pouvons pas encore exécuter ce test et vérifier s'il échoue car même le
test ne peut pas se compiler : la fonction <code>rechercher</code> n'existe pas encore !
Donc pour le moment nous allons ajouter juste assez de code pour que le test
puisse compiler et s'exécuter en ajoutant une définition de la fonction
<code>rechercher</code> qui retourne un vecteur vide, comme dans l'encart 12-16. Ensuite
le test va compiler et échouer car un vecteur vide ne correspond pas au vecteur
qui contient la ligne <code>&quot;sécurité, rapidité, productivité.&quot;</code></p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-16: Defining just enough of the `search`
function so our test will compile</span>
-->
<p><span class="caption">Encart 12-16 : Définition du strict minimum de la fonction
<code>rechercher</code> pour que notre test puisse compiler</span></p>
<!--
Notice that we need an explicit lifetime `'a` defined in the signature of
`search` and used with the `contents` argument and the return value. Recall in
[Chapter 10][ch10-lifetimes]<!-- ignore -- > that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument `contents` (rather than the
argument `query`).
-->
<p>Remarquez que nous avons besoin de préciser explicitement une durée de vie <code>'a</code>
définie dans la signature de <code>rechercher</code> et l'utiliser sur l'argument <code>contenu</code>
et la valeur de retour. Rappelez-vous que dans le
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> nous avions vu que les paramètres
de durée de vie renseignent à quelle durée de vie des arguments sont connectées
aux durées de vie des valeurs de retour. Dans notre cas, nous indiquons que le
vecteur retourné devrait contenir des slices de chaînes de caractères qui sont
des slices de l'argument <code>contenu</code> (et non pas de l'argument <code>recherche</code>).</p>
<!--
In other words, we tell Rust that the data returned by the `search` function
will live as long as the data passed into the `search` function in the
`contents` argument. This is important! The data referenced *by* a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of `query` rather than `contents`, it will do its safety checking
incorrectly.
-->
<p>Autrement dit, nous disons à Rust que les données retournées par la fonction
<code>rechercher</code> vont vivre aussi longtemps que la donnée dans l'argument <code>contenu</code>
de la fonction <code>rechercher</code>. C'est très important ! Les données sur lesquelles
pointent les slices doivent être en vigueur pour que la référence reste valide ;
si le compilateur croit que nous créons des slices de <code>recherche</code> plutôt que de
<code>contenu</code>, ses vérifications de sécurité seront incorrectes.</p>
<!--
If we forget the lifetime annotations and try to compile this function, we’ll
get this error:
-->
<p>Si nous oublions les annotations de durée de vie et que nous essayons de
compiler cette fonction, nous allons obtenir cette erreur :</p>
<!--
```console
$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  -- > src/lib.rs:28:51
   |
28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {
   |              ^^^^        ^^^^^^^            ^^^^^^^         ^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn rechercher(recherche: &amp;str, contenu: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                              ----           ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `recherche` or `contenu`
help: consider introducing a named lifetime parameter
   |
28 | pub fn rechercher&lt;'a&gt;(recherche: &amp;'a str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |                  ^^^^            ^^^^^^^           ^^^^^^^         ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<!--
Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because `contents` is the argument that contains all of our text and we
want to return the parts of that text that match, we know `contents` is the
argument that should be connected to the return value using the lifetime syntax.
-->
<p>Rust ne peut pas deviner lequel des deux arguments nous allons utiliser, donc
nous devons lui dire. Comme <code>contenu</code> est l'argument qui contient tout notre
texte et que nous voulons retourner des extraits de ce texte qui correspondent à
la recherche, nous savons que <code>contenu</code> est l'argument qui doit être connecté à
la valeur de retour, en utilisant la syntaxe de durée de vie.</p>
<!--
Other programming languages don’t require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the [“Validating
References with Lifetimes”][validating-references-with-lifetimes]<!-- ignore
-- > section in Chapter 10.
-->
<p>Les autres langages de programmation n'ont pas besoin que vous connectiez les
arguments aux valeurs de retour dans la signature. Bien que cela puisse paraître
étrange, cela devient plus facile au fil du temps. Vous devriez peut-être
comparer cet exemple à la
<a href="ch10-03-lifetime-syntax.html">section 3 du chapitre 10</a><!-- ignore -->.</p>
<!--
Now let’s run the test:
-->
<p>Maintenant, exécutons le test :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... FAILED

failures:

---- tests::un_resultat stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;sécurité, rapidité, productivité.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_resultat

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Great, the test fails, exactly as we expected. Let’s get the test to pass!
-->
<p>Très bien, le test a échoué, comme nous nous y attendions. Faisons maintenant en
sorte qu'il réussisse !</p>
<!--
### Writing Code to Pass the Test
-->
<h3 id="ecrire-du-code-pour-réussir-au-test"><a class="header" href="#ecrire-du-code-pour-réussir-au-test">Ecrire du code pour réussir au test</a></h3>
<!--
Currently, our test is failing because we always return an empty vector. To fix
that and implement `search`, our program needs to follow these steps:
-->
<p>Pour le moment, notre test échoue car nous retournons toujours un vecteur vide.
Pour corriger cela et implémenter <code>rechercher</code>, notre programme doit suivre les
étapes suivantes :</p>
<!--
* Iterate through each line of the contents.
* Check whether the line contains our query string.
* If it does, add it to the list of values we’re returning.
* If it doesn’t, do nothing.
* Return the list of results that match.
-->
<ul>
<li>Itérer sur chacune des lignes de <code>contenu</code>.</li>
<li>Vérifier si la ligne contient la chaîne de caractères recherchée.</li>
<li>Si c'est le cas, l'ajouter à la liste des valeurs que nous retournerons.</li>
<li>Si ce n'est pas le cas, ne rien faire.</li>
<li>Retourner la liste des résultats qui ont été trouvés.</li>
</ul>
<!--
Let’s work through each step, starting with iterating through lines.
-->
<p>Travaillons sur chacune de ces étapes, en commençant par l'itération sur les
lignes.</p>
<!--
#### Iterating Through Lines with the `lines` Method
-->
<h4 id="itérer-sur-chacune-des-lignes-avec-la-méthode-lines"><a class="header" href="#itérer-sur-chacune-des-lignes-avec-la-méthode-lines">Itérer sur chacune des lignes avec la méthode <code>lines</code></a></h4>
<!--
Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named `lines`, that works as shown in Listing 12-17. Note this
won’t compile yet.
-->
<p>Rust a une méthode très pratique pour gérer l'itération ligne-par-ligne des
chaînes de caractères, judicieusement appelée <code>lines</code>, qui fonctionne comme dans
l'encart 12-17. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        // faire quelquechose avec ligne ici
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-17: Iterating through each line in `contents`
</span>
-->
<p><span class="caption">Encart 12-17 : Itération sur chacune des lignes de
<code>contenu</code> </span></p>
<!-- markdownlint-disable -->
<!--
The `lines` method returns an iterator. We’ll talk about iterators in depth in
[Chapter 13][ch13-iterators]<!-- ignore -- >, but recall that you saw this way of using an
iterator in [Listing 3-5][ch3-iter]<!-- ignore -- >, where we used a `for` loop
with an iterator to run some code on each item in a collection.
-->
<!-- markdownlint-restore -->
<p>La méthode <code>lines</code> retourne un itérateur. Nous verrons plus tard les itérateurs
dans le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, mais souvenez-vous que
vous avez vu cette façon d'utiliser un itérateur dans
<a href="ch03-05-control-flow.html">l'encart 3-5</a><!-- ignore -->, dans lequel nous avions utilisé une
boucle <code>for</code> sur un itérateur pour exécuter du code sur chaque élément d'une
collection.</p>
<!--
#### Searching Each Line for the Query
-->
<h4 id="trouver-chaque-ligne-correspondante-à-la-recherche"><a class="header" href="#trouver-chaque-ligne-correspondante-à-la-recherche">Trouver chaque ligne correspondante à la recherche</a></h4>
<!--
Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note this still won’t compile yet.
-->
<p>Ensuite, nous allons vérifier que la ligne courante contient la chaîne de
caractères que nous recherchons. Heureusement, les chaînes de caractères ont une
méthode <code>contains</code> assez pratique qui fait cela pour nous ! Ajoutez l'appel à
la méthode <code>contains</code> dans la fonction <code>rechercher</code>, comme dans l'encart 12-18.
Notez qu'ici non plus nous ne pouvons pas encore compiler.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            // faire quelquechose avec la ligne ici
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in `query`</span>
-->
<p><span class="caption">Encart 12-18 : Ajout d'une fonctionnalité pour trouver
quelle ligne contient la chaîne de caractères <code>recherche</code></span></p>
<!--
#### Storing Matching Lines
-->
<h4 id="stocker-les-lignes-trouvées"><a class="header" href="#stocker-les-lignes-trouvées">Stocker les lignes trouvées</a></h4>
<!--
We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the `for` loop and call the `push` method
to store a `line` in the vector. After the `for` loop, we return the vector, as
shown in Listing 12-19.
-->
<p>Nous avons aussi besoin d'un moyen de stocker les lignes qui contienent la
chaîne de caractères que nous recherchons. Pour cela, nous pouvons créer un
vecteur mutable avant la boucle <code>for</code> et appeler la méthode <code>push</code> pour
enregistrer la <code>ligne</code> dans le vecteur. Après la boucle <code>for</code>, nous retournons
le vecteur, comme dans l'encart 12-19 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span>
-->
<p><span class="caption">Encart 12-19 : Enregistrement des lignes qui sont
trouvées afin que nous puissions les retourner</span></p>
<!--
Now the `search` function should return only the lines that contain `query`,
and our test should pass. Let’s run the test:
-->
<p>Maintenant, notre fonction <code>rechercher</code> retourne uniquement les lignes qui
contiennent <code>recherche</code>, et notre test devrait réussir. Exécutons le test :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Our test passed, so we know it works!
-->
<p>Notre test a réussi, donc nous savons que cela fonctionne !</p>
<!--
At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in [Chapter 13][ch13-iterators]<!-- ignore -- >, where we’ll
explore iterators in detail, and look at how to improve it.
-->
<p>Arrivé à ce stade, nous pourrions envisager des pistes de remaniement pour
l'implémentation de la fonction de recherche tout en faisant en sorte que les
tests réussissent toujours afin de conserver les mêmes fonctionnalités. Le code
de la fonction de recherche n'est pas mauvais, mais il ne profite pas de
quelques fonctionnalités utiles des itérateurs. Nous retrouverons cet exemple dans
le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, dans lequel nous explorerons
les itérateurs en détail, et ainsi découvrir comment nous pourrions l'améliorer.</p>
<!--
#### Using the `search` Function in the `run` Function
-->
<h4 id="utiliser-la-fonction-rechercher-dans-la-fonction-run"><a class="header" href="#utiliser-la-fonction-rechercher-dans-la-fonction-run">Utiliser la fonction <code>rechercher</code> dans la fonction <code>run</code></a></h4>
<!--
Now that the `search` function is working and tested, we need to call `search`
from our `run` function. We need to pass the `config.query` value and the
`contents` that `run` reads from the file to the `search` function. Then `run`
will print each line returned from `search`:
-->
<p>Maintenant que la fonction <code>rechercher</code> fonctionne et est testée, nous devons
appeler <code>rechercher</code> dans notre fonction <code>run</code>. Nous devons passer à
<code>rechercher</code> la valeur de <code>config.recherche</code>  et le <code>contenu</code> que <code>run</code> obtient
en lisant le fichier. Ensuite, <code>run</code> devra afficher chaque ligne retournée par
<code>rechercher</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}
# 
# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
#     let mut results = Vec::new();
# 
#     for line in contents.lines() {
#         if line.contains(query) {
#             results.push(line);
#         }
#     }
# 
#     results
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We’re still using a `for` loop to return each line from `search` and print it.
-->
<p>Nous utilisons ici aussi une boucle <code>for</code> pour récupérer chaque ligne provenant
de <code>rechercher</code> et l'afficher.</p>
<!--
Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:
-->
<p>Maintenant, l'intégralité du programme devrait fonctionner ! Essayons-le, pour
commencer avec un mot qui devrait retourner exactement une seule ligne du poème
d'Emily Dickinson, “frog” :</p>
<!--
```console
$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```
-->
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!--
Cool! Now let’s try a word that will match multiple lines, like “body”:
-->
<p>Super ! Maintenant, essayons un mot qui devrait retourner plusieurs lignes,
comme “body” :</p>
<!--
```console
$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:
-->
<p>Et enfin, assurons-nous que nous n'obtenons aucune ligne lorsque nous cherchons
un mot qui n'est nulle part dans le poème, comme “monomorphization” :</p>
<!--
```console
$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```
-->
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!--
Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.
-->
<p>Très bien ! Nous avons construit notre propre mini-version d'un outil classique
et nous avons beaucoup appris à structurer nos applications. Nous avons aussi
appris un peu sur les entrées et sorties des fichiers, les durées de vie, les
tests, et l'interprétation de la ligne de commande.</p>
<!--
To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.
-->
<p>Pour clôturer ce projet, nous allons brièvement voir comment travailler avec les
variables d'environnement et comment écrire sur la sortie standard des erreurs,
qui sont tous les deux utiles lorsque vous écrivez des programmes en ligne de
commande.</p>
<!--
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch12-05-working-with-environment-variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch12-05-working-with-environment-variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>


    </body>
</html>
