<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>La syntaxe des mÃ©thodes - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html" class="active"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Method Syntax
-->
<h2><a class="header" href="#la-syntaxe-des-mÃ©thodes" id="la-syntaxe-des-mÃ©thodes">La syntaxe des mÃ©thodes</a></h2>
<!--
*Methods* are similar to functions: theyâ€™re declared with the `fn` keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when theyâ€™re called from somewhere else. However, methods are
different from functions in that theyâ€™re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always `self`, which represents the
instance of the struct the method is being called on.
-->
<p>Les <em>mÃ©thodes</em> sont similaires aux fonctionsÂ : on les dÃ©clare avec le mot-clÃ©
<code>fn</code> et leur nom, elles peuvent avoir des paramÃ¨tres et une valeur de retour, et
elles contiennent du code qui est exÃ©cutÃ© quand on les appelle depuis un autre
endroit. Cependant, les mÃ©thodes diffÃ¨rent des fonctions parce qu'elles sont
dÃ©finies dans le contexte d'une structure (ou d'une Ã©numÃ©ration ou d'un objet de
trait, que nous aborderons respectivement aux chapitres 6 et 17) et que leur
premier paramÃ¨tre est toujours <code>self</code>, un mot-clÃ© qui reprÃ©sente l'instance de
la structure sur laquelle on appelle la mÃ©thode.</p>
<!--
### Defining Methods
-->
<h3><a class="header" href="#dÃ©finir-des-mÃ©thodes" id="dÃ©finir-des-mÃ©thodes">DÃ©finir des mÃ©thodes</a></h3>
<!--
Letâ€™s change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p>RemplaÃ§ons la fonction <code>aire</code> qui prend une instance de <code>Rectangle</code> en paramÃ¨tre
par une mÃ©thode <code>aire</code> dÃ©finie sur la structure <code>Rectangle</code>, comme dans
l'encart 5-13.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrÃ©s.&quot;,
        rect1.aire()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-13Â : DÃ©finition d'une mÃ©thode <code>aire</code> sur la
structure <code>Rectangle</code></span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block. Then we move the `area` function within the `impl`
curly brackets and change the first (and in this case, only) parameter to be
`self` in the signature and everywhere within the body. In `main`, where we
called the `area` function and passed `rect1` as an argument, we can instead
use *method syntax* to call the `area` method on our `Rectangle` instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.
-->
<p>Pour dÃ©finir la fonction dans le contexte de <code>Rectangle</code>, nous dÃ©marrons un bloc
<code>impl</code> (<em>implÃ©mentation</em>). Puis nous dÃ©plaÃ§ons la fonction <code>aire</code> entre les
accolades du <code>impl</code> et nous remplaÃ§ons le premier paramÃ¨tre (et dans notre cas,
le seul) par <code>self</code> dans la signature et dans tout le corps. Dans <code>main</code>, oÃ¹
nous avons appelÃ© la fonction <code>aire</code> et passÃ© <code>rect1</code> en argument, nous pouvons
utiliser Ã  la place la <em>syntaxe des mÃ©thodes</em> pour appeler la mÃ©thode <code>aire</code> sur
notre instance de <code>Rectangle</code>. La syntaxe des mÃ©thodes se place aprÃ¨s
l'instanceÂ : on ajoute un point suivi du nom de la mÃ©thode et des parenthÃ¨ses
contenant les arguments s'il y en a.</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`
because Rust knows the type of `self` is `Rectangle` due to this methodâ€™s being
inside the `impl Rectangle` context. Note that we still need to use the `&`
before `self`, just as we did in `&Rectangle`. Methods can take ownership of
`self`, borrow `self` immutably as weâ€™ve done here, or borrow `self` mutably,
just as they can any other parameter.
-->
<p>Dans la signature de <code>aire</code>, nous utilisons <code>&amp;self</code> Ã  la place de
<code>rectangle: &amp;Rectangle</code> parce que Rust sait que le type de <code>self</code> est
<code>Rectangle</code> puisque la mÃ©thode se trouve au sein du contexte <code>impl Rectangle</code>.
Veuillez noter qu'il nous faut quand mÃªme utiliser le <code>&amp;</code> avant le <code>self</code>, comme
nous l'avions fait pour <code>&amp;Rectangle</code>. Les mÃ©thodes peuvent prendre possession de
<code>self</code>, emprunter <code>self</code> de faÃ§on immuable comme nous l'avons fait ici, ou
emprunter <code>self</code> de faÃ§on mutable, comme pour n'importe quel autre paramÃ¨tre.</p>
<!--
Weâ€™ve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we donâ€™t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
weâ€™ve called the method on as part of what the method does, weâ€™d use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and you want
to prevent the caller from using the original instance after the transformation.
-->
<p>Nous avons choisi <code>&amp;self</code> ici pour la mÃªme raison que nous avions utilisÃ©
<code>&amp;Rectangle</code> quand il s'agissait d'une fonctionÂ ; nous ne voulons pas en prendre
possession, et nous voulons seulement lire les donnÃ©es de la structure, pas les
modifier. Si nous voulions que la mÃ©thode modifie l'instance sur laquelle on
l'appelle, on utiliserait <code>&amp;mut self</code> comme premier paramÃ¨tre. Il est rare
d'avoir une mÃ©thode qui prend possession de l'instance en utilisant uniquement
<code>self</code> comme premier argumentÂ ; cette technique est gÃ©nÃ©ralement utilisÃ©e
lorsque la mÃ©thode transforme <code>self</code> en quelque chose d'autre et que vous voulez
empÃªcher le code appelant d'utiliser l'instance d'origine aprÃ¨s la
transformation.</p>
<!--
The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of `self` in every methodâ€™s
signature, is for organization. Weâ€™ve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>Outre l'utilisation de la syntaxe des mÃ©thodes et le fait de ne pas Ãªtre obligÃ©
de rÃ©pÃ©ter le type de <code>self</code> dans la signature de chaque mÃ©thode, le principal
avantage de l'utilisation de mÃ©thodes plutÃ´t que de fonctions est pour
l'organisation. Nous avons mis tout ce qu'on pouvait faire avec une instance de
notre type dans un bloc <code>impl</code> plutÃ´t que d'imposer aux futurs utilisateurs de
notre code Ã  rechercher les fonctionnalitÃ©s de <code>Rectangle</code> Ã  divers endroits de
la bibliothÃ¨que que nous fournissons.</p>
<!--
> ### Whereâ€™s the `->` Operator?
>
> In C and C++, two different operators are used for calling methods: you use
> `.` if youâ€™re calling a method on the object directly and `->` if youâ€™re
> calling the method on a pointer to the object and need to dereference the
> pointer first. In other words, if `object` is a pointer,
> `object->something()` is similar to `(*object).something()`.
>
> Rust doesnâ€™t have an equivalent to the `->` operator; instead, Rust has a
> feature called *automatic referencing and dereferencing*. Calling methods is
> one of the few places in Rust that has this behavior.
>
> Hereâ€™s how it works: when you call a method with `object.something()`, Rust
> automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
> the method. In other words, the following are the same:
>
<!-- CAN'T EXTRACT SEE BUG TODO -- >
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> The first one looks much cleaner. This automatic referencing behavior works
> because methods have a clear receiverâ€”the type of `self`. Given the receiver
> and name of a method, Rust can figure out definitively whether the method is
> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
> that Rust makes borrowing implicit for method receivers is a big part of
> making ownership ergonomic in practice.
-->
<blockquote>
<h3><a class="header" href="#oÃ¹-est-lopÃ©rateur---" id="oÃ¹-est-lopÃ©rateur---">OÃ¹ est l'opÃ©rateur <code>-&gt;</code>Â ?</a></h3>
<p>En C et en C++, deux opÃ©rateurs diffÃ©rents sont utilisÃ©s pour appeler les
mÃ©thodesÂ : on utilise <code>.</code> si on appelle une mÃ©thode directement sur l'objet
et <code>-&gt;</code> si on appelle la mÃ©thode sur un pointeur vers l'objet et qu'il faut
d'abord dÃ©rÃ©fÃ©rencer le pointeur. En d'autres termes, si <code>objet</code> est un
pointeur, <code>objet-&gt;methode()</code> est similaire Ã  <code>(*objet).methode()</code>.</p>
<p>Rust n'a pas d'Ã©quivalent Ã  l'opÃ©rateur <code>-&gt;</code>Â ; Ã  la place, Rust a une
fonctionnalitÃ© appelÃ©e <em>rÃ©fÃ©rencement et dÃ©rÃ©fÃ©rencement automatiques</em>.
L'appel de mÃ©thodes est l'un des rares endroits de Rust oÃ¹ on retrouve ce
comportement.</p>
<p>VoilÃ  comment cela fonctionneÂ : quand on appelle une mÃ©thode avec
<code>objet.methode()</code>, Rust ajoute automatiquement le <code>&amp;</code>, <code>&amp;mut</code> ou <code>*</code> pour que
<code>objet</code> corresponde Ã  la signature de la mÃ©thode. Autrement dit, ces deux
lignes sont identiquesÂ :</p>
</blockquote>
<!-- CAN'T EXTRACT SEE BUG TODO -->
<blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, autre: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_carre = f64::powi(autre.x - self.x, 2);
</span><span class="boring">       let y_carre = f64::powi(autre.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_carre + y_carre)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>La premiÃ¨re ligne semble bien plus propre. Ce comportement du
(dÃ©)rÃ©fÃ©rencement automatique fonctionne parce que les mÃ©thodes ont une
cible claireÂ : le type de <code>self</code>. Compte tenu du nom de la mÃ©thode et
de l'instance sur laquelle elle s'applique, Rust peut dÃ©terminer de maniÃ¨re
irrÃ©futable si la mÃ©thode lit (<code>&amp;self</code>), modifie (<code>&amp;mut self</code>) ou consomme
(<code>self</code>) l'instance. Le fait que Rust rend implicite l'emprunt pour les
instances sur lesquelles on appelle les mÃ©thodes amÃ©liore significativement
l'ergonomie de la possession.</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3><a class="header" href="#les-mÃ©thodes-avec-davantage-de-paramÃ¨tres" id="les-mÃ©thodes-avec-davantage-de-paramÃ¨tres">Les mÃ©thodes avec davantage de paramÃ¨tres</a></h3>
<!--
Letâ€™s practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self`; otherwise it should return `false`. That is, we want to be able
to write the program shown in Listing 5-14, once weâ€™ve defined the `can_hold`
method.
-->
<p>EntraÃ®nons-nous Ã  utiliser des mÃ©thodes en implÃ©mentant une seconde mÃ©thode sur
la structure <code>Rectangle</code>. Cette fois-ci, nous voulons qu'une instance de
<code>Rectangle</code> prenne une autre instance de <code>Rectangle</code> et qu'on retourne <code>true</code> si
le second <code>Rectangle</code> peut se dessiner intÃ©gralement Ã  l'intÃ©rieur de <code>self</code>Â ;
sinon, on renverra <code>false</code>. En d'autres termes, on veut pouvoir Ã©crire le
programme de l'encart 5-14 une fois qu'on aura dÃ©fini la mÃ©thode
<code>peut_contenir</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };
    let rect2 = Rectangle {
        largeur: 10,
        hauteur: 40
    };
    let rect3 = Rectangle {
        largeur: 60,
        hauteur: 45
    };

    println!(&quot;rect1 peut-il contenir rect2Â ? {}&quot;, rect1.peut_contenir(&amp;rect2));
    println!(&quot;rect1 peut-il contenir rect3Â ? {}&quot;, rect1.peut_contenir(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">Encart 5-14Â : Utilisation de la mÃ©thode <code>peut_contenir</code>
qui reste Ã  Ã©crire</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>Et on s'attend Ã  ce que le texte suivant s'affiche, puisque les deux dimensions
de <code>rect2</code> sont plus petites que les dimensions de <code>rect1</code>, mais <code>rect3</code> est
plus large que <code>rect1</code>Â :</p>
<!--
```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
-->
<pre><code class="language-text">rect1 peut-il contenir rect2Â ? true
rect1 peut-il contenir rect3Â ? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean weâ€™d need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Letâ€™s add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>Nous voulons dÃ©finir une mÃ©thode, donc elle doit se trouver dans le bloc
<code>impl Rectangle</code>. Le nom de la mÃ©thode sera <code>peut_contenir</code> et elle prendra une
rÃ©fÃ©rence immuable vers un autre <code>Rectangle</code> en paramÃ¨tre. On peut dÃ©terminer le
type du paramÃ¨tre en regardant le code qui appelle la mÃ©thodeÂ :
<code>rect1.peut_contenir(&amp;rect2)</code> prend en argument <code>&amp;rect2</code>, une rÃ©fÃ©rence immuable
vers <code>rect2</code>, une instance de <code>Rectangle</code>. Cela est logique puisque nous voulons
uniquement lire <code>rect2</code> (plutÃ´t que de la modifier, ce qui aurait nÃ©cessitÃ© une
rÃ©fÃ©rence mutable) et nous souhaitons que <code>main</code> garde possession de <code>rect2</code>
pour qu'on puisse le rÃ©utiliser aprÃ¨s avoir appelÃ© la mÃ©thode <code>peut_contenir</code>.
La valeur de retour de <code>peut_contenir</code> sera un boolÃ©en et l'implÃ©mentation de la
mÃ©thode vÃ©rifiera si la largeur et la hauteur de <code>self</code> sont respectivement plus
grandes que la largeur et la hauteur de l'autre <code>Rectangle</code>. Ajoutons la
nouvelle mÃ©thode <code>peut_contenir</code> dans le bloc <code>impl</code> de l'encart 5-13, comme le
montre l'encart 5-15.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }

    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2Â ? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3Â ? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">Encart 5-15Â : ImplÃ©mentation de la mÃ©thode <code>peut_contenir</code>
sur <code>Rectangle</code> qui prend une autre instance de <code>Rectangle</code> en paramÃ¨tre</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, weâ€™ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>Lorsque nous exÃ©cutons ce code avec la fonction <code>main</code> de l'encart 5-14, nous
obtenons l'affichage attendu. Les mÃ©thodes peuvent prendre plusieurs paramÃ¨tres
qu'on peut ajouter Ã  la signature aprÃ¨s le paramÃ¨tre <code>self</code>, et ces paramÃ¨tres
fonctionnent de la mÃªme maniÃ¨re que les paramÃ¨tres des fonctions.</p>
<!--
### Associated Functions
-->
<h3><a class="header" href="#les-fonctions-associÃ©es" id="les-fonctions-associÃ©es">Les fonctions associÃ©es</a></h3>
<!--
Another useful feature of `impl` blocks is that weâ€™re allowed to define
functions within `impl` blocks that *donâ€™t* take `self` as a parameter. These
are called *associated functions* because theyâ€™re associated with the struct.
Theyâ€™re still functions, not methods, because they donâ€™t have an instance of
the struct to work with. Youâ€™ve already used the `String::from` associated
function.
-->
<p>Une autre fonctionnalitÃ© utile des blocs <code>impl</code> est qu'on peut dÃ©finir des
fonctions dans des blocs <code>impl</code> qui ne prennent <em>pas</em> <code>self</code> en paramÃ¨tre. Cela
s'appelle des <em>fonctions associÃ©es</em> parce qu'elles sont associÃ©es Ã  la
structure. Cela reste des fonctions, pas des mÃ©thodes, parce qu'elles ne
s'appliquent pas Ã  une instance de structure. Vous avez dÃ©jÃ  utilisÃ© la fonction
associÃ©e <code>String::from</code>.</p>
<!--
Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both width and height,
thus making it easier to create a square `Rectangle` rather than having to
specify the same value twice:
-->
<p>Les fonctions associÃ©es sont souvent utilisÃ©es comme constructeurs qui vont
retourner une nouvelle instance de la structure. Par exemple, on pourrait Ã©crire
une fonction associÃ©e qui prend une unique dimension en paramÃ¨tre et l'utilise
Ã  la fois pour la largeur et pour la hauteur, ce qui rend plus aisÃ© la crÃ©ation
d'un <code>Rectangle</code> carrÃ© plutÃ´t que d'avoir Ã  indiquer la mÃªme valeur deux foisÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
# 
# fn main() {
#     let sq = Rectangle::square(3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn carre(cote: u32) -&gt; Rectangle {
        Rectangle {
            largeur: cote,
            hauteur: cote
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mon_carre = Rectangle::carre(3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. Weâ€™ll discuss modules in Chapter 7.
-->
<p>Pour appeler cette fonction associÃ©e, on utilise la syntaxe <code>::</code> avec le nom de
la structureÂ ; <code>let mon_carre = Rectangle::carre(3);</code> en est un exemple. Cette
fonction est cloisonnÃ©e dans l'espace de noms de la structureÂ : la syntaxe <code>::</code>
s'utilise aussi bien pour les fonctions associÃ©es que pour les espaces de noms
crÃ©Ã©s par des modules. Nous aborderons les modules au chapitre 7.</p>
<!--
### Multiple `impl` Blocks
-->
<h3><a class="header" href="#plusieurs-blocs-impl" id="plusieurs-blocs-impl">Plusieurs blocs <code>impl</code></a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>Chaque structure peut avoir plusieurs blocs <code>impl</code>. Par exemple, l'encart 5-15
est Ã©quivalent au code de l'encart 5-16, oÃ¹ chaque mÃ©thode est dans son propre
bloc <code>impl</code>.</p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

impl Rectangle {
    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2Â ? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3Â ? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">Encart 5-16Â : RÃ©Ã©criture de l'encart 5-15 en utilisant
plusieurs blocs <code>impl</code></span></p>
<!--
Thereâ€™s no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. Weâ€™ll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>Il n'y a aucune raison de sÃ©parer ces mÃ©thodes dans plusieurs blocs <code>impl</code> dans
notre exemple, mais c'est une syntaxe valide. Nous verrons un exemple de
l'utilitÃ© d'avoir plusieurs blocs <code>impl</code> au chapitre 10, oÃ¹ nous aborderons les
types gÃ©nÃ©riques et les traits.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©" id="rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. Methods let you specify the
behavior that instances of your structs have, and associated functions let you
namespace functionality that is particular to your struct without having an
instance available.
-->
<p>Les structures vous permettent de crÃ©er des types personnalisÃ©s significatifs
pour votre domaine. En utilisant des structures, on peut relier entre elles
des donnÃ©es associÃ©es et nommer chaque donnÃ©e pour rendre le code plus clair.
Les mÃ©thodes vous permettent de dÃ©finir le comportement des instances de vos
structures, et les fonctions associÃ©es vous permettent de cloisonner dans un
espace de noms des fonctionnalitÃ©s qui sont spÃ©cifiques Ã  votre structure sans
avoir besoin d'une instance disponible.</p>
<!--
But structs arenâ€™t the only way you can create custom types: letâ€™s turn to
Rustâ€™s enum feature to add another tool to your toolbox.
-->
<p>Mais les structures ne sont pas le seul moyen de crÃ©er des types personnalisÃ©sÂ :
nous allons maintenant voir les Ã©numÃ©rations de Rust, une fonctionnalitÃ© que
vous pourrez bientÃ´t ajouter Ã  votre boÃ®te Ã  outils.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch05-02-example-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch06-00-enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch05-02-example-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch06-00-enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
