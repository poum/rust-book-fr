<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/115">Pull Request</a>.</p>
</blockquote>
<!--
## Traits: Defining Shared Behavior
-->
<h2><a class="header" href="#dÃ©finir-des-comportements-partagÃ©s-avec-les-traits" id="dÃ©finir-des-comportements-partagÃ©s-avec-les-traits">DÃ©finir des comportements partagÃ©s avec les traits</a></h2>
<!--
A *trait* tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic can be any type
that has certain behavior.
-->
<p>Un <em>trait</em> dÃ©crit une fonctionnalitÃ© qu'a un type particulier et qu'il peut
partager avec d'autres types, Ã  destination du compilateur Rust. Nous pouvons
utiliser les traits pour dÃ©finir un comportement partagÃ© de maniÃ¨re abstraite.
Nous pouvons lier ces traits Ã  un gÃ©nÃ©rique pour exprimer le fait qu'il puisse
Ãªtre de n'importe quel type Ã  condition qu'il ai un comportement donnÃ©.</p>
<!--
> Note: Traits are similar to a feature often called *interfaces* in other
> languages, although with some differences.
-->
<blockquote>
<p>Remarque : les traits sont similaires Ã  ce qu'on appelle parfois les
<em>interfaces</em> dans d'autres langages, malgrÃ© quelques diffÃ©rences.</p>
</blockquote>
<!--
### Defining a Trait
-->
<h3><a class="header" href="#dÃ©finir-un-trait" id="dÃ©finir-un-trait">DÃ©finir un trait</a></h3>
<!--
A typeâ€™s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.
-->
<p>Le comportement d'un type s'exprime via les mÃ©thodes que nous pouvons appeler
sur ce type. DiffÃ©rents types peuvent partager le mÃªme comportement si nous
pouvons appeler les mÃªmes mÃ©thodes sur tous ces types. DÃ©finir un trait est une
maniÃ¨re de grouper ensemble les signatures des mÃ©thodes pour dÃ©finir un
comportement nÃ©cessaire pour accomplir un objectif.</p>
<!--
For example, letâ€™s say we have multiple structs that hold various kinds and
amounts of text: a `NewsArticle` struct that holds a news story filed in a
particular location and a `Tweet` that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.
-->
<p>Par exemple, imaginons que nous avons plusieurs structures qui stockent
diffÃ©rents types et quantitÃ© de texteÂ : une structure <code>ArticleDePresse</code>, qui
contient un reportage dans un endroit donnÃ© et un <code>Tweet</code> qui peut avoir jusqu'Ã 
280 caractÃ¨res maximum et des mÃ©tadonnÃ©es qui indiquent si cela est un nouveau
tweet, un retweet, ou une rÃ©ponse Ã  un autre tweet.</p>
<!--
We want to make a media aggregator library that can display summaries of data
that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we
need a summary from each type, and we need to request that summary by calling a
`summarize` method on an instance. Listing 10-12 shows the definition of a
`Summary` trait that expresses this behavior.
-->
<p>Nous voulons construire une bibliothÃ¨que pour des agrÃ©gateurs de mÃ©dias qui peut
afficher le rÃ©sumÃ© des donnÃ©es stockÃ©es dans une instance de <code>ArticleDePresse</code>
ou de <code>Tweet</code>. Pour cela, nous avons besoin d'un rÃ©sumÃ© pour chaque type, et
nous pouvons demander ce rÃ©sumÃ© en appelant la mÃ©thode <code>resumer</code> sur une
instance. L'encart 10-12 nous montre la dÃ©finition d'un trait <code>Resumable</code> qui
dÃ©crit ce comportement.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumable {
    fn resumer(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-12: A `Summary` trait that consists of the
behavior provided by a `summarize` method</span>
-->
<p><span class="caption">Encart 10-12Â : un trait <code>Resumable</code> qui reprÃ©sente le
comportement fourni par une mÃ©thode <code>resumer</code></span></p>
<!--
Here, we declare a trait using the `trait` keyword and then the traitâ€™s name,
which is `Summary` in this case. Inside the curly brackets, we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is `fn summarize(&self) -> String`.
-->
<p>Ici, nous dÃ©clarons un trait en utilisant le mot-clÃ© <code>trait</code> et ensuite le nom
du trait, qui est <code>Resumable</code> dans notre cas. Entre les accolades, nous
dÃ©clarons la signature de la mÃ©thode qui dÃ©crit le comportement des types qui
implÃ©mentent ce trait, qui est dans notre cas <code>fn resumer(&amp;self) -&gt; String</code>.</p>
<!--
After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the `Summary` trait will have the method `summarize`
defined with this signature exactly.
-->
<p>A la fin de la signature de la mÃ©thode, au lieu de renseigner une implÃ©mentation
entre des accolades, nous utilisons un point-virgule. Chaque type qui implÃ©mente
ce trait doit renseigner son propre comportement dans le corps de la mÃ©thode. Le
compilateur va s'assurer que tous les types qui ont le trait <code>Resumable</code> auront
la mÃ©thode <code>resumer</code> dÃ©fini avec cette signature prÃ©cise.</p>
<!--
A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.
-->
<p>Un trait peut avoir plusieurs mÃ©thodes dans son corpsÂ : les signatures des
mÃ©thodes sont ajoutÃ©es ligne par ligne et chaque ligne se termine avec un
point-virgule.</p>
<!--
### Implementing a Trait on a Type
-->
<h3><a class="header" href="#implÃ©menter-un-trait-sur-un-type" id="implÃ©menter-un-trait-sur-un-type">ImplÃ©menter un trait sur un type</a></h3>
<!--
Now that weâ€™ve defined the desired behavior using the `Summary` trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the `Summary` trait on the `NewsArticle` struct that uses the
headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.
-->
<p>Maintenant que nous avons dÃ©fini le comportement souhaitÃ© du trait <code>Resumable</code>,
nous pouvons maintenant l'implÃ©menter sur les types de notre agrÃ©gateur de
mÃ©dias. L'encart 10-13 nous montre l'implÃ©mentation du trait <code>Resumable</code> sur la
structure <code>ArticleDePresse</code> qui utilise le titre, le nom de l'auteur, et le lieu
pour crÃ©er la valeur de retour de <code>resume</code>. Pour la structure <code>Tweet</code>, nous
dÃ©finissons <code>resumer</code> avec le nom d'utilisateur suivi par le texte entier du
tweet, en supposant que le contenu du tweet est dÃ©jÃ  limitÃ© Ã  280 caractÃ¨res.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct ArticleDePresse {
    pub titre: String,
    pub lieu: String,
    pub auteur: String,
    pub contenu: String,
}

impl Resumable for ArticleDePresse {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
    }
}

pub struct Tweet {
    pub nom_utilisateur: String,
    pub contenu: String,
    pub reponse: bool,
    pub retweet: bool,
}

impl Resumable for Tweet {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-13: Implementing the `Summary` trait on the
`NewsArticle` and `Tweet` types</span>
-->
<p><span class="caption">Encart 10-13Â : implÃ©mentation du trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code></span></p>
<!--
Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put the trait name that we want to
implement, then use the `for` keyword, and then specify the name of the type we
want to implement the trait for. Within the `impl` block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.
-->
<p>L'implÃ©mentation d'un trait sur un type est similaire Ã  l'implÃ©mentation d'une
mÃ©thode classique. La diffÃ©rence est que nous ajoutons le nom du trait que nous
voulons implÃ©menter aprÃ¨s le <code>impl</code>, et que nous utilisons ensuite le mot-clÃ©
<code>for</code> ainsi que le nom du type sur lequel nous souhaitons implÃ©menter le trait.
A l'intÃ©rieur du bloc <code>impl</code>, nous ajoutons les signatures des mÃ©thodes
prÃ©sentes dans la dÃ©finition du trait. Au lieu d'ajouter un point-virgule aprÃ¨s
chaque signature, nous plaÃ§ons les accolades et on remplit le corps de la
mÃ©thode avec le comportement spÃ©cifique que nous voulons que les mÃ©thodes du
trait suive pour type en particulier.</p>
<!--
After implementing the trait, we can call the methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods, like this:
-->
<p>AprÃ¨s avoir implÃ©mentÃ© le trait, nous pouvons appeler les mÃ©thodes de
l'instance de <code>ArticleDePresse</code> et <code>Tweet</code> comme si elles Ã©taient des mÃ©thodes
classiques, comme ceciÂ :</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweetÂ : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.
-->
<p>Ce code affichera <code>1 nouveau tweetÂ : jeanÂ : Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ </code>.</p>
<!--
Note that because we defined the `Summary` trait and the `NewsArticle` and
`Tweet` types in the same *lib.rs* in Listing 10-13, theyâ€™re all in the same
scope. Letâ€™s say this *lib.rs* is for a crate weâ€™ve called `aggregator` and
someone else wants to use our crateâ€™s functionality to implement the `Summary`
trait on a struct defined within their libraryâ€™s scope. They would need to
bring the trait into their scope first. They would do so by specifying `use
aggregator::Summary;`, which then would enable them to implement `Summary` for
their type. The `Summary` trait would also need to be a public trait for
another crate to implement it, which it is because we put the `pub` keyword
before `trait` in Listing 10-12.
-->
<p>Remarquez que comme nous avons dÃ©fini le trait <code>Resumable</code> et les types
<code>ArticleDePresse</code> et <code>Tweet</code> dans le mÃªme fichier <em>lib.rs</em> de l'encart 10-13,
ils sont tous dans la mÃªme portÃ©e. Disons que ce fichier <em>lib.rs</em> est utilisÃ©
pour une crate que nous avons appelÃ© <code>agregateur</code> et que quelqu'un d'autre
souhaite utiliser les fonctionnalitÃ©s de notre crate pour implÃ©menter le trait
<code>Resumable</code> sur une structure dÃ©finie dans la portÃ©e de sa propre bibliothÃ¨que.
Il aura d'abord besoin d'importer le trait dans sa portÃ©e. Il pourra le faire en
utilisant <code>use agregateur::Resumable;</code>, ce qui lui permettra ensuite
d'implÃ©menter <code>Resumable</code> sur le type souhaitÃ©. Le trait <code>Resumable</code> devra alors
Ãªtre un trait public aux autres crates pour qu'elles puissent l'implÃ©menter,
c'est pourquoi nous avons placÃ© le mot-clÃ© <code>pub</code> devant le <code>trait</code> dans l'encart
10-12.</p>
<!--
One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to our crate.
For example, we can implement standard library traits like `Display` on a
custom type like `Tweet` as part of our `aggregator` crate functionality,
because the type `Tweet` is local to our `aggregator` crate. We can also
implement `Summary` on `Vec<T>` in our `aggregator` crate, because the
trait `Summary` is local to our `aggregator` crate.
-->
<p>Il y a une limitation Ã  souligner avec l'implÃ©mentation des traits, c'est que
nous ne pouvons implÃ©menter un trait sur un type qu'Ã  condition que le trait ou
le type soit dÃ©fini localement dans notre crate. Par exemple, nous pouvons
implÃ©menter des traits de la bibliothÃ¨que standard comme <code>Display</code> sur un type
personnalisÃ© comme <code>Tweet</code> comme une fonctionnalitÃ© de notre crate <code>agregateur</code>,
car le type <code>Tweet</code> est dÃ©fini localement dans notre crate <code>agregateur</code>. Nous
pouvons aussi implÃ©menter <code>Resumable</code> sur <code>Vec&lt;T&gt;</code> dans notre crate
<code>agregateur</code>, car le trait <code>Resumable</code> est dÃ©fini localement dans notre crate
<code>agregateur</code>.</p>
<!--
But we canâ€™t implement external traits on external types. For example, we canâ€™t
implement the `Display` trait on `Vec<T>` within our `aggregator` crate,
because `Display` and `Vec<T>` are defined in the standard library and arenâ€™t
local to our `aggregator` crate. This restriction is part of a property of
programs called *coherence*, and more specifically the *orphan rule*, so named
because the parent type is not present. This rule ensures that other peopleâ€™s
code canâ€™t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldnâ€™t know which
implementation to use.
-->
<p>Mais nous ne pouvons pas implÃ©menter des traits externes sur des types externes.
Par exemple, nous ne pouvons pas implÃ©menter le trait <code>Display</code> sur <code>Vec&lt;T&gt;</code> Ã 
l'intÃ©rieur de notre crate <code>agregateur</code>, car <code>Display</code> et <code>Vec&lt;T&gt;</code> sont dÃ©finis
dans la bibliothÃ¨que standard et ne sont donc pas dÃ©finis localement dans notre
crate <code>agregateur</code>. Cette limitation fait partie d'une propriÃ©tÃ© des programmes
que l'on appelle la <em>cohÃ©rence</em>, et plus prÃ©cisÃ©ment la <em>rÃ¨gle de l'orphelin</em>,
qui s'appelle ainsi car le type parent n'est pas prÃ©sent. Cette rÃ¨gle s'assure
que le code des autres personnes ne casse pas votre code et rÃ©ciproquement.
Sans cette rÃ¨gle, deux crates peuvent implÃ©menter le mÃªme trait sur le mÃªme
type, et Rust ne saura pas laquelle utiliser.</p>
<!--
### Default Implementations
-->
<h3><a class="header" href="#limplÃ©mentation-par-dÃ©faut" id="limplÃ©mentation-par-dÃ©faut">L'implÃ©mentation par dÃ©faut</a></h3>
<!--
Sometimes itâ€™s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each methodâ€™s default behavior.
-->
<p>Il est parfois utile d'avoir un comportement par dÃ©faut pour toutes ou une
partie des mÃ©thodes d'un trait plutÃ´t que de demander l'implÃ©mentation de toutes
les mÃ©thodes sur chaque type. Ainsi, si nous implÃ©mentons le trait sur un type
particulier, nous pouvons garder ou rÃ©Ã©crire le comportement par dÃ©faut de
chaque mÃ©thode. </p>
<!--
Listing 10-14 shows how to specify a default string for the `summarize` method
of the `Summary` trait instead of only defining the method signature, as we did
in Listing 10-12.
-->
<p>L'encart 10-14 nous montre comment prÃ©ciser une String par dÃ©faut pour la
mÃ©thode <code>resumer</code> du trait <code>Resumable</code> plutÃ´t que de dÃ©finir uniquement la
signature de la mÃ©thode, comme nous l'avons fait dans l'encart 10-12.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumable {
    fn resumer(&amp;self) -&gt; String {
        String::from(&quot;(En savoir plus ...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-14: Definition of a `Summary` trait with a
default implementation of the `summarize` method</span>
-->
<p><span class="caption">Encart 10-14Â : dÃ©finition du trait <code>Resumable</code> avec une
implÃ©mentation par dÃ©faut de la mÃ©thode <code>resume</code></span></p>
<!--
To use a default implementation to summarize instances of `NewsArticle` instead
of defining a custom implementation, we specify an empty `impl` block with
`impl Summary for NewsArticle {}`.
-->
<p>Pour pouvoir utiliser l'implÃ©mentation par dÃ©faut du rÃ©sumÃ© des instances de
<code>ArticleDePresse</code> plutÃ´t que de devoir prÃ©ciser un implÃ©mentation personnalisÃ©e,
nous prÃ©cisons un bloc <code>impl</code> vide avec <code>impl Resumable for ArticleDePresse {}</code>.</p>
<!--
Even though weâ€™re no longer defining the `summarize` method on `NewsArticle`
directly, weâ€™ve provided a default implementation and specified that
`NewsArticle` implements the `Summary` trait. As a result, we can still call
the `summarize` method on an instance of `NewsArticle`, like this:
-->
<p>MÃªme si nous n'avons pas dÃ©fini directement la mÃ©thode <code>resumer</code> sur
<code>ArticleDePresse</code>, nous avons fourni une implÃ©mentation par dÃ©faut et prÃ©cisÃ©
que <code>ArticleDePresse</code> implÃ©mente le trait <code>Resumable</code>. Par consÃ©quent, nous
pouvons toujours appeler la mÃ©thode <code>resumer</code> sur une instance de
<code>ArticleDePresse</code>, comme ceciÂ :</p>
<!--
```rust,ignore
# use chapter10::{self, NewsArticle, Summary};
# 
# fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, ArticleDePresse, Resumable};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = ArticleDePresse {
        titre: String::from(&quot;Les Pinguins ont gagnÃ© la Stanley Cup ChampionshipÂ !&quot;),
        lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
        auteur: String::from(&quot;Iceburgh&quot;),
        contenu: String::from(
            &quot;Les Pinguins de Pittsburgh sont une nouvelle fois la meilleure\
            Ã©quipe de hockey de la NHL.&quot;
        ),
    };
    
    println!(&quot;Nouvel article disponibleÂ ! {}&quot;, article.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `New article available! (Read more...)`.
-->
<p>Ce code va afficher <code>Nouvel article disponibleÂ ! (En savoir plus ...)</code>.</p>
<!--
Creating a default implementation for `summarize` doesnâ€™t require us to change
anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesnâ€™t have a default
implementation.
-->
<p>La crÃ©ation d'une implÃ©mentation par dÃ©faut pour <code>resumer</code> n'a pas besoin que
nous modifions quelque chose dans l'implÃ©mentation de <code>Resumable</code> sur <code>Tweet</code>
dans l'encart 10-13. C'est parce que la syntaxe pour rÃ©Ã©crire l'implÃ©mentation
par dÃ©faut est la mÃªme que la syntaxe pour implÃ©menter une mÃ©thode d'un trait
qui n'a pas d'implÃ©mentation par dÃ©faut.</p>
<!--
Default implementations can call other methods in the same trait, even if those
other methods donâ€™t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the `Summary` trait to have a
`summarize_author` method whose implementation is required, and then define a
`summarize` method that has a default implementation that calls the
`summarize_author` method:
-->
<p>Les implÃ©mentations par dÃ©faut peuvent appeler d'autres mÃ©thodes du mÃªme trait,
mÃªme si ces autres mÃ©thodes n'ont pas d'implÃ©mentation par dÃ©faut. Ainsi, un
trait peut fournir de nombreuses fonctionnalitÃ©s utiles et n'avoir besoin que
le dÃ©veloppeur qui l'utilise n'en ai qu'une petite partie Ã  implÃ©menter. Par
exemple, nous pouvons dÃ©finir le trait <code>Resumable</code> pour avoir une mÃ©thode
<code>resumer_auteur</code> dont l'implÃ©mentation est nÃ©cessaire, et ensuite dÃ©finir une
mÃ©thode <code>resumer</code> qui a une implÃ©mentation par dÃ©faut qui appelle la mÃ©thode
<code>resumer_auteur</code>Â :</p>
<!--
```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize_author(&self) -> String {
#         format!("@{}", self.username)
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumable {
    fn resumer_auteur(&amp;self) -&gt; String;

    fn resumer(&amp;self) -&gt; String {
        format!(&quot;(Lire plus d'Ã©lÃ©ments de {} ...)&quot;, self.resumer_auteur())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.nom_utilisateur)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
To use this version of `Summary`, we only need to define `summarize_author`
when we implement the trait on a type:
-->
<p>Pour pouvoir utiliser cette version de <code>Resumable</code>, nous avons seulement besoin
de dÃ©finir <code>resumer_auteur</code> lorsqu'on implÃ©mente le trait sur le typeÂ :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize_author(&self) -> String;
# 
#     fn summarize(&self) -> String {
#         format!("(Read more from {}...)", self.summarize_author())
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lire plus d'Ã©lÃ©ments de {} ...)&quot;, self.resumer_auteur())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Resumable for Tweet {
    fn resumer_auteur(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nom_utilisateur)
    }
}
</code></pre>
<!--
After we define `summarize_author`, we can call `summarize` on instances of the
`Tweet` struct, and the default implementation of `summarize` will call the
definition of `summarize_author` that weâ€™ve provided. Because weâ€™ve implemented
`summarize_author`, the `Summary` trait has given us the behavior of the
`summarize` method without requiring us to write any more code.
-->
<p>AprÃ¨s avoir dÃ©fini <code>resumer_auteur</code>, nous pouvons appeler <code>resumer</code> sur des
instances de la structure <code>Tweet</code>, et l'implÃ©mentation par dÃ©faut de <code>resumer</code>
va appeler <code>resumer_auteur</code>, que nous avons dÃ©fini. Comme nous avons implÃ©mentÃ©
<code>resumer_auteur</code>, le trait <code>Resumable</code> nous a donnÃ© le comportement de la
mÃ©thode <code>resumer</code> sans avoir besoin d'Ã©crire aucune ligne de code
supplÃ©mentaire.</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweetÂ : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: (Read more from @horse_ebooks...)`.
-->
<p>Ce code affichera <code>1 nouveau tweetÂ : (Lire plus d'Ã©lÃ©ments de @jean ...)</code>.</p>
<!--
Note that it isnâ€™t possible to call the default implementation from an
overriding implementation of that same method.
-->
<p>Notez qu'il n'est pas possible d'appeler l'implÃ©mentation par dÃ©faut Ã  partir
d'une rÃ©Ã©criture de cette mÃªme mÃ©thode.</p>
<!--
### Traits as Parameters
-->
<h3><a class="header" href="#des-traits-en-paramÃ¨tres" id="des-traits-en-paramÃ¨tres">Des traits en paramÃ¨tres</a></h3>
<!--
Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.
-->
<p>Maintenant que vous savez comment dÃ©finir et implÃ©menter les traits, nous
pouvons regarder comment utiliser les traits pour dÃ©finir des fonctions qui
acceptent plusieurs types diffÃ©rents.</p>
<!--
For example, in Listing 10-13, we implemented the `Summary` trait on the
`NewsArticle` and `Tweet` types. We can define a `notify` function that calls
the `summarize` method on its `item` parameter, which is of some type that
implements the `Summary` trait. To do this, we can use the `impl Trait`
syntax, like this:
-->
<p>Par exemple, dans l'encart 10-13, nous implÃ©mentons le trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code>. Nous pouvons dÃ©finir une fonction <code>notifier</code>
qui va appeler la fonction <code>resumer</code> sur son paramÃ¨tre <code>element</code>, qui est d'un
type qui implÃ©mente le trait <code>Resumable</code>. Pour faire ceci, nous pouvons utiliser
la syntaxe <code>impl Trait</code>, comme ceciÂ :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notifier(element: &amp;impl Resumable) {
    println!(&quot;Flash-infoÂ ! {}&quot;, element.resumer());
}
</code></pre>
<!--
Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, wonâ€™t compile
because those types donâ€™t implement `Summary`.
-->
<p>Au lieu d'un type concret pour le paramÃ¨tre <code>element</code>, nous prÃ©cisons le mot-clÃ©
<code>impl</code> et le nom du trait. Ce paramÃ¨tre accepte n'importe quel type qui
implÃ©mente le trait spÃ©cifiÃ©. Dans le corps de <code>notifier</code>, nous pouvons appeler
toutes les mÃ©thodes sur <code>element</code> qui proviennent du trait <code>Resumable</code>, comme
<code>resumer</code>. Nous pouvons appeler <code>notifier</code> et passer une instance de
<code>ArticleDePresse</code> ou de <code>Tweet</code>. Le code qui appellera la fonction avec un autre
type, comme une <code>String</code> ou un <code>i32</code>, ne va pas se compiler car ces types
n'implÃ©mentent pas <code>Resumable</code>.</p>
<!--
#### Trait Bound Syntax
-->
<h4><a class="header" href="#la-syntaxe-du-trait-liÃ©" id="la-syntaxe-du-trait-liÃ©">La syntaxe du trait liÃ©</a></h4>
<!--
The `impl Trait` syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a *trait bound*; it looks like
this:
-->
<p>La syntaxe <code>impl Trait</code> fonctionne bien pour des cas simples, mais est en
rÃ©alitÃ© du sucre syntaxique pour une forme plus longue, qui s'appelle le
<em>trait liÃ©</em>Â ; qui ressemble Ã  ceciÂ :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element: &amp;T) {
    println!(&quot;Flash-infoÂ ! {}&quot;, element.resumer());
}
</code></pre>
<!--
This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.
-->
<p>Cette forme plus longue est Ã©quivalente Ã  l'exemple dans la section prÃ©cÃ©dente,
mais est plus verbeuse. Nous plaÃ§ons les traits liÃ©s dans la dÃ©claration des
paramÃ¨tres de type gÃ©nÃ©rique aprÃ¨s les double-points dans les chevrons.</p>
<!--
The `impl Trait` syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement `Summary`. Using the `impl
Trait` syntax looks like this:
-->
<p>La syntaxe <code>impl Trait</code> est pratique pour rendre du code plus concis dans des
cas simples. La syntaxe du trait liÃ© exprime plus de complexitÃ© dans certains
cas. Par exemple, nous pouvons avoir deux paramÃ¨tres qui implÃ©mentent
<code>Resumable</code>. En utilisant la syntaxe <code>impl Trait</code>, nous aurons ceciÂ :</p>
<!--
```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element1: &amp;impl Resumable, element2: &amp;impl Resumable) {
</code></pre>
<!--
If we wanted this function to allow `item1` and `item2` to have different
types, using `impl Trait` would be appropriate (as long as both types implement
`Summary`). If we wanted to force both parameters to have the same type, thatâ€™s
only possible to express using a trait bound, like this:
-->
<p>Si nous souhaitons permettre Ã  <code>element1</code> et <code>element2</code> d'avoir des types
diffÃ©rents, l'utilisation de <code>impl Trait</code> est appropriÃ© (du moment que chacun de
ces types implÃ©mentent <code>Resumable</code>). Mais si nous souhaitons forcer les deux
paramÃ¨tres d'Ãªtre du mÃªme type, cela n'est possible Ã  exprimer qu'avec un trait
liÃ©, comme ceciÂ :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element1: &amp;T, element2: &amp;T) {
</code></pre>
<!--
The generic type `T` specified as the type of the `item1` and `item2`
parameters constrains the function such that the concrete type of the value
passed as an argument for `item1` and `item2` must be the same.
-->
<p>Le type gÃ©nÃ©rique <code>T</code> renseignÃ© comme type des paramÃ¨tres <code>element1</code> et
<code>element2</code> contraint la fonction de maniÃ¨re Ã  ce que les types concrets des
valeurs passÃ©es en arguments pour <code>element1</code> et <code>element2</code> soient identiques.</p>
<!--
#### Specifying Multiple Trait Bounds with the `+` Syntax
-->
<h4><a class="header" href="#renseigner-plusieurs-traits-liÃ©s-avec-la-syntaxe-" id="renseigner-plusieurs-traits-liÃ©s-avec-la-syntaxe-">Renseigner plusieurs traits liÃ©s avec la syntaxe <code>+</code></a></h4>
<!--
We can also specify more than one trait bound. Say we wanted `notify` to use
display formatting on `item` as well as the `summarize` method: we specify in
the `notify` definition that `item` must implement both `Display` and
`Summary`. We can do so using the `+` syntax:
-->
<p>Nous pouvons aussi prÃ©ciser que nous attendons plus d'un trait liÃ©. Imaginons
que nous souhaitons que <code>notifier</code> utilise le formatage d'affichage sur
<code>element</code> ainsi que la mÃ©thode <code>resumer</code>Â : nous indiquons dans la dÃ©finition de
<code>notify</code> que <code>element</code> doit implÃ©menter <code>Affichable</code> et <code>Resumable</code>. Nous
pouvons faire ceci avec la syntaxe <code>+</code>Â :</p>
<!--
```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element: &amp;(impl Resumable + Affichable)) {
</code></pre>
<!--
The `+` syntax is also valid with trait bounds on generic types:
-->
<p>La syntaxe <code>+</code> fonctionne aussi avec les traits liÃ©s sur des types gÃ©nÃ©riquesÂ :</p>
<!--
```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable + Affichable&gt;(element: &amp;T) {
</code></pre>
<!--
With the two trait bounds specified, the body of `notify` can call `summarize`
and use `{}` to format `item`.
-->
<p>Avec les deux traits liÃ©s renseignÃ©s, le corps de <code>notifier</code> va appeler
<code>resumer</code> et utiliser <code>{}</code> pour formater <code>element</code>.</p>
<!--
#### Clearer Trait Bounds with `where` Clauses
-->
<h4><a class="header" href="#des-traits-liÃ©s-plus-clairs-avec-linstruction-where" id="des-traits-liÃ©s-plus-clairs-avec-linstruction-where">Des traits liÃ©s plus clairs avec l'instruction <code>where</code></a></h4>
<!--
Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the functionâ€™s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a `where` clause after the function
signature. So instead of writing this:
-->
<p>L'utilisation de trop nombreux traits liÃ©s a aussi ses dÃ©savantages. Chaque
gÃ©nÃ©rique a ses propres traits liÃ©s, donc les fonctions avec plusieurs
paramÃ¨tres de types gÃ©nÃ©riques peuvent aussi avoir de nombreuses informations de
traits liÃ©s entre le nom de la fonction et la liste de ses paramÃ¨tres, ce qui
rend la signature de la fonction difficile Ã  lire. Pour cette raison, Rust a une
syntaxe alternative pour renseigner les traits liÃ©s, dans une instruction
<code>where</code> aprÃ¨s la signature de la fonction. Donc, Ã  la place d'Ã©crire ceci ...</p>
<!--
```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```
-->
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<!--
we can use a `where` clause, like this:
-->
<p>... nous pouvons utiliser l'instruction <code>where</code>, comme ceciÂ :</p>
<!--
```rust,ignore
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
```
-->
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!--
This functionâ€™s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.
-->
<p>La signature de cette fonction est moins encombrÃ©eÂ : le nom de la fonction, la
liste des paramÃ¨tres, et le type de retour sont plus proches l'un de l'autre,
comme une fonction sans traits liÃ©s.</p>
<!--
### Returning Types that Implement Traits
-->
<h3><a class="header" href="#retourner-des-types-qui-implÃ©mentent-des-traits" id="retourner-des-types-qui-implÃ©mentent-des-traits">Retourner des types qui implÃ©mentent des traits</a></h3>
<!--
We can also use the `impl Trait` syntax in the return position to return a
value of some type that implements a trait, as shown here:
-->
<p>Nous pouvons aussi utiliser la syntaxe <code>impl Trait</code> Ã  la place du retour afin
de retourner une valeur d'un type qui implÃ©mente un trait, comme ci-dessousÂ :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable() -&gt; impl Resumable {
    Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
        reponse: false,
        retweet: false,
    }
}
</code></pre>
<!--
By using `impl Summary` for the return type, we specify that the
`returns_summarizable` function returns some type that implements the `Summary`
trait without naming the concrete type. In this case, `returns_summarizable`
returns a `Tweet`, but the code calling this function doesnâ€™t know that.
-->
<p>En utilisant <code>impl Resumable</code> pour le type de retour, nous indiquons que la
fonction <code>retourne_resumable</code>retourne un type qui implÃ©mente le trait
<code>Resumable</code> sans avoir Ã  Ã©crire le nom du type concret. Dans notre cas,
<code>retourne_resumable</code> retourne un <code>Tweet</code>, mais le code qui appellera cette
fonction ne le saura pas.</p>
<!--
The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The `impl Trait` syntax lets you
concisely specify that a function returns some type that implements the
`Iterator` trait without needing to write out a very long type.
-->
<p>La capacitÃ© de retourner un type qui est uniquement caractÃ©risÃ© par le trait
qu'il implÃ©mente est tout particuliÃ¨rement utile dans le cas des fermetures et
des itÃ©rateurs, que nous allons voir au chapitre 13. Les fermetures et les
itÃ©rateurs crÃ©ent des types que seul le compilateur est en mesure de comprendre
ou alors des types qui sont trÃ¨s longs Ã  dÃ©finir. La syntaxe <code>impl Trait</code> vous
permet de renseigner de maniÃ¨re concise qu'une fonction retourne un type
particulier qui implÃ©mente le trait <code>Iterator</code> sans avoir Ã  Ã©crire un trÃ¨s long
type.</p>
<!--
However, you can only use `impl Trait` if youâ€™re returning a single type. For
example, this code that returns either a `NewsArticle` or a `Tweet` with the
return type specified as `impl Summary` wouldnâ€™t work:
-->
<p>Cependant, vous pouvez seulement utiliser <code>impl Trait</code> si vous retournez un
seul type possible. Par exemple, ce code va retourner soit un <code>ArticleDePresse</code>,
soit un <code>Tweet</code>, alors que le type de retour avec <code>impl Resumable</code> ne va pas
fonctionnerÂ :</p>
<!--
```rust,ignore,does_not_compile
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable(estArticle: bool) -&gt; impl Resumable {
    if estArticle {
        ArticleDePresse {
            titre: String::from(&quot;Les Pinguins ont gagnÃ© la Stanley Cup ChampionshipÂ !&quot;),
            lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
            auteur: String::from(&quot;Iceburgh&quot;),
            contenu: String::from(&quot;Les Pinguins de Pittsburgh sont une nouvelle fois la
            meilleure Ã©quipe de hockey de la NHL.&quot;),
        }
    } else {
        Tweet {
            nom_utilisateur: String::from(&quot;jean&quot;),
            contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
            reponse: false,
            retweet: false,
        }
    }
}
</code></pre>
<!--
Returning either a `NewsArticle` or a `Tweet` isnâ€™t allowed due to restrictions
around how the `impl Trait` syntax is implemented in the compiler. Weâ€™ll cover
how to write a function with this behavior in the [â€œUsing Trait Objects That
Allow for Values of Different
Typesâ€][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section of Chapter 17.
-->
<p>Retourner soit un <code>ArticleDePresse</code>, soit un <code>Tweet</code> n'est pas autorisÃ© Ã  cause
des restrictions sur comment la syntaxe <code>impl Trait</code> est implÃ©mentÃ©e dans le
compilateur. Nous allons voir comment Ã©crire une fonction avec ce comportement
dans une section du
<a href="ch17-02-trait-objects.html">chapitre 17</a><!--
ignore -->.</p>
<!--
### Fixing the `largest` Function with Trait Bounds
-->
<h3><a class="header" href="#rÃ©soudre-la-fonction-le_plus_grand-avec-les-traits-liÃ©s" id="rÃ©soudre-la-fonction-le_plus_grand-avec-les-traits-liÃ©s">RÃ©soudre la fonction <code>le_plus_grand</code> avec les traits liÃ©s</a></h3>
<!--
Now that you know how to specify the behavior you want to use using the generic
type parameterâ€™s bounds, letâ€™s return to Listing 10-5 to fix the definition of
the `largest` function that uses a generic type parameter! Last time we tried
to run that code, we received this error:
-->
<p>Maintenant que vous savez comment renseigner le comportement que vous souhaitez
utiliser en utilisant les paramÃ¨tres de types gÃ©nÃ©riques liÃ©s, retournons Ã 
l'encart 10-5 pour rÃ©soudre la dÃ©finition de la fonction <code>le_plus_grand</code> qui
utilise un paramÃ¨tre de type gÃ©nÃ©riqueÂ ! La derniÃ¨re fois qu'on a essayÃ© de
lancer ce code, nous avions l'erreur suivanteÂ :</p>
<!--
```text
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `&T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- &T
  |            |
  |            &T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-text">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; &amp;T {
  |                   ^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
</code></pre>
<!--
In the body of `largest` we wanted to compare two values of type `T` using the
greater than (`>`) operator. Because that operator is defined as a default
method on the standard library trait `std::cmp::PartialOrd`, we need to specify
`PartialOrd` in the trait bounds for `T` so the `largest` function can work on
slices of any type that we can compare. We donâ€™t need to bring `PartialOrd`
into scope because itâ€™s in the prelude. Change the signature of `largest` to
look like this:
-->
<p>Dans le corps de <code>le_plus_grand</code> nous voulions comparer les deux valeurs du
type <code>T</code> en utilisant l'opÃ©rateur <em>plus grand que</em> (<code>&gt;</code>). Comme cet opÃ©rateur
est dÃ©fini comme une mÃ©thode par dÃ©faut dans le trait de la bibliothÃ¨que
standard <code>std::cmp::PartialOrd</code>, nous devons prÃ©ciser <code>PartialOrd</code> dans les
traits liÃ©s pour <code>T</code> afin que la fonction <code>le_plus_grand</code> puisse fonctionner sur
les slices de n'importe quel type que nous pouvons comparer. Nous n'avons pas
besoin d'importer <code>PartialOrd</code> dans la portÃ©e car il est importÃ© dans l'Ã©tape
prÃ©liminaire. Changez la signature de <code>le_plus_grand</code> par quelque chose comme
ceciÂ :</p>
<!--
```rust,ignore
fn largest<T: PartialOrd>(list: &[T]) -> T {
#     let mut largest = list[0];
# 
#     for &item in list {
#         if item > largest {
#             largest = item;
#         }
#     }
# 
#     largest
# }
# 
# fn main() {
#     let number_list = vec![34, 50, 25, 100, 65];
# 
#     let result = largest(&number_list);
#     println!("The largest number is {}", result);
# 
#     let char_list = vec!['y', 'm', 'a', 'q'];
# 
#     let result = largest(&char_list);
#     println!("The largest char is {}", result);
# }
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T: PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
<span class="boring">    let mut le_plus_grand = liste[0];
</span><span class="boring">
</span><span class="boring">    for &amp;element in liste {
</span><span class="boring">        if element &gt; le_plus_grand {
</span><span class="boring">            le_plus_grand = element;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    le_plus_grand
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let liste_de_nombres = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_nombres);
</span><span class="boring">    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
</span><span class="boring">
</span><span class="boring">    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_caracteres);
</span><span class="boring">    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
</span><span class="boring">}
</span></code></pre>
<!--
This time when we compile the code, we get a different set of errors:
-->
<p>Cette fois, lorsque nous allons compiler le code, nous aurons un ensemble
d'erreurs diffÃ©rentÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- > src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 -- > src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- &gt; src/main.rs:2:23
  |
2 |     let mut le_plus_grand = liste[0];
  |                             ^^^^^^^^
  |                             |
  |                             cannot move out of here
  |                             move occurs because `liste[_]` has type `T`, which does not implement the `Copy` trait
  |                             help: consider borrowing here: `&amp;liste[0]`

error[E0507]: cannot move out of a shared reference
 -- &gt; src/main.rs:4:18
  |
4 |     for &amp;element in liste {
  |         --------    ^^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `element` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `element`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
</code></pre>
<!--
The key line in this error is `cannot move out of type [T], a non-copy slice`.
With our non-generic versions of the `largest` function, we were only trying to
find the largest `i32` or `char`. As discussed in the [â€œStack-Only Data:
Copyâ€][stack-only-data-copy]<!-- ignore -- > section in Chapter 4, types like
`i32` and `char` that have a known size can be stored on the stack, so they
implement the `Copy` trait. But when we made the `largest` function generic,
it became possible for the `list` parameter to have types in it that donâ€™t
implement the `Copy` trait. Consequently, we wouldnâ€™t be able to move the
value out of `list[0]` and into the `largest` variable, resulting in this
error.
-->
<p>L'Ã©lement-clÃ© dans ces erreurs est <code>cannot move out of type [T], a non-copy slice</code>. Avec notre version non gÃ©nÃ©rique de la fonction <code>le_plus_grand</code>, nous
avions essayÃ© de trouver le plus grand <code>i32</code> ou <code>char</code>. Comme nous l'avons vu
dans la section
<a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">â€œDonnÃ©es uniquement sur la pileÂ : la copieâ€</a><!--
ignore --> du chapitre 4, les types comme <code>i32</code> et <code>char</code> ont une taille connue
et peuvent Ãªtre stockÃ©s sur la pile, donc ils implÃ©mentent le trait <code>Copy</code>. Par
consÃ©quent, nous ne pouvons pas forcÃ©ment dÃ©placer la valeur de <code>list[0]</code> dans
notre variable <code>le_plus_grand</code>, ce qui engendre cette erreur.</p>
<!--
To call this code with only those types that implement the `Copy` trait, we can
add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of
a generic `largest` function that will compile as long as the types of the
values in the slice that we pass into the function implement the `PartialOrd`
*and* `Copy` traits, like `i32` and `char` do.
-->
<p>Pour pouvoir appeler ce code avec seulement les types qui implÃ©mentent le trait
<code>Copy</code>, nous pouvons ajouter <code>Copy</code> aux traits liÃ©s de <code>T</code>Â ! L'encart 10-15 nous
montre le code complet d'une fonction gÃ©nÃ©rique <code>le_plus_grand</code> qui va se
compiler tant que les types valeurs dans la slice que nous passons dans la
fonction implÃ©mente les traits <code>PartialOrd</code> <em>et</em> <code>Copy</code>, comme le font <code>i32</code> et
<code>char</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand&lt;T: PartialOrd + Copy&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-15: A working definition of the `largest`
function that works on any generic type that implements the `PartialOrd` and
`Copy` traits</span>
-->
<p><span class="caption">Encart 10-15Â : une dÃ©finition de la fonction
<code>le_plus_grand</code> qui fonctionne et s'applique sur n'importe quel type gÃ©nÃ©rique
qui implÃ©mente les traits <code>PartialOrd</code> et <code>Copy</code></span></p>
<!--
If we donâ€™t want to restrict the `largest` function to the types that implement
the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead
of `Copy`. Then we could clone each value in the slice when we want the
`largest` function to have ownership. Using the `clone` function means weâ€™re
potentially making more heap allocations in the case of types that own heap
data like `String`, and heap allocations can be slow if weâ€™re working with
large amounts of data.
-->
<p>Si nous ne souhaitons pas restreindre la fonction <code>le_plus_grand</code> aux types qui
implÃ©mentent le trait <code>Copy</code>, nous pouvons prÃ©ciser que <code>T</code> a le trait liÃ©
<code>Clone</code> plutÃ´t que <code>Copy</code>. Ainsi, nous pouvons cloner chaque valeur dans la
slice lorsque nous souhaitons que la fonction <code>le_plus_grand</code> en prenne
possession. L'utilisation de la fonction <code>clone</code> signifie que nous allons
potentiellement allouer plus d'espace sur le tas dans le cas des types qui
possÃ¨dent des donnÃ©es sur le tas, comme <code>String</code>, et les allocations sur le tas
peuvent Ãªtre lentes si nous travaillons avec des grandes quantitÃ©s de donnÃ©es.</p>
<!--
Another way we could implement `largest` is for the function to return a
reference to a `T` value in the slice. If we change the return type to `&T`
instead of `T`, thereby changing the body of the function to return a
reference, we wouldnâ€™t need the `Clone` or `Copy` trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
-->
<p>Une autre faÃ§on d'implÃ©menter <code>le_plus_grand</code> est de faire en sorte que la
fonction retourne une rÃ©fÃ©rence Ã  une valeur <code>T</code> de la slice. Si nous changeons
le type de retour en <code>&amp;T</code> Ã  la place de <code>T</code>, ainsi qu'adapter le corps de la
fonction afin de retourner une rÃ©fÃ©rence, nous n'aurions alors plus besoin des
traits liÃ©s <code>Clone</code> ou <code>Copy</code> et nous pourrions ainsi Ã©viter l'allocation sur
le tas. Essayez d'implÃ©menter cette solution alternative par vous-mÃªmeÂ !</p>
<!--
### Using Trait Bounds to Conditionally Implement Methods
-->
<h3><a class="header" href="#utiliser-les-traits-liÃ©s-pour-conditionner-limplÃ©mentation-des-mÃ©thodes" id="utiliser-les-traits-liÃ©s-pour-conditionner-limplÃ©mentation-des-mÃ©thodes">Utiliser les traits liÃ©s pour conditionner l'implÃ©mentation des mÃ©thodes</a></h3>
<!--
By using a trait bound with an `impl` block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type `Pair<T>` in Listing 10-16 always implements the
`new` function. But `Pair<T>` only implements the `cmp_display` method if its
inner type `T` implements the `PartialOrd` trait that enables comparison *and*
the `Display` trait that enables printing.
-->
<p>En utilisant un trait liÃ© avec un bloc <code>impl</code> qui utilise les paramÃ¨tres de type
gÃ©nÃ©rique, nous pouvons implÃ©menter des mÃ©thodes en fonction des types
qu'implÃ©mentent des traits particuliers. Par exemple, le type <code>Pair&lt;T&gt;</code> de
l'encart 10-16 implÃ©mente toujours la fonction <code>new</code>. Mais <code>Pair&lt;T&gt;</code> implÃ©mente
uniquement la mÃ©thode <code>affiche_comparaison</code> que si son type interne <code>T</code>
implÃ©mente le trait <code>PartialOrd</code> qui active la comparaison <em>et</em> le trait
<code>Display</code> qui permet l'affichage.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn affiche_comparaison(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Le plus grand Ã©lÃ©ment est x = {}&quot;, self.x);
        } else {
            println!(&quot;Le plus grand Ã©lÃ©ment est y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span>
-->
<p><span class="caption">Encart 10-16Â : implÃ©mentation de mÃ©thodes sur un type
gÃ©nÃ©rique en fonction du trait liÃ©</span></p>
<!--
We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called *blanket implementations* and are extensively used in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:
-->
<p>Nous pouvons Ã©galement appliquer un trait sur un type qui applique un autre
trait. L'implÃ©mentation d'un trait sur n'importe quel type qui a un trait liÃ©
est appelÃ©e <em>implÃ©mentation gÃ©nÃ©rale</em> et est largement utilisÃ©e dans la
bibliothÃ¨que standard Rust. Par exemple, la bibliothÃ¨que standard implÃ©mente le
trait <code>ToString</code> sur tous les types qui implÃ©mentent le trait <code>Display</code>. Le bloc
<code>impl</code> de la bibliothÃ¨que standard ressemble au code suivantÂ :</p>
<!--
```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
Because the standard library has this blanket implementation, we can call the
`to_string` method defined by the `ToString` trait on any type that implements
the `Display` trait. For example, we can turn integers into their corresponding
`String` values like this because integers implement `Display`:
-->
<p>Comme la bibliothÃ¨que standard a cette implÃ©mentation gÃ©nÃ©rale, nous pouvons
appeler la mÃ©thode <code>to_string</code> dÃ©finie par le trait <code>ToString</code> sur n'importe
quel type qui implÃ©mente le trait <code>Display</code>. Par exemple, nous pouvons
transformer les entiers en leur Ã©quivalent dans une <code>String</code> comme ci-dessous
car les entiers implÃ©mentent <code>Display</code>Â :</p>
<!--
```rust
let s = 3.to_string();
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
Blanket implementations appear in the documentation for the trait in the
â€œImplementorsâ€ section.
-->
<p>Les implÃ©mentations gÃ©nÃ©rales sont dÃ©crites dans la documentation du trait, dans
la section â€œImplementorsâ€.</p>
<!--
Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didnâ€™t define the method. But Rust
moves these errors to compile time so weâ€™re forced to fix the problems before
our code is even able to run. Additionally, we donâ€™t have to write code that
checks for behavior at runtime because weâ€™ve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.
-->
<p>Les traits et les traits liÃ©s nous permettent d'Ã©crire du code qui utilise des
paramÃ¨tres de type gÃ©nÃ©rique pour rÃ©duire la duplication de code, mais aussi
pour indiquer au compilateur que nous voulons que le type gÃ©nÃ©rique ait un
comportement particulier. Le compilateur peut ensuite utiliser les informations
liÃ©es aux traits pour vÃ©rifier que tous les types concrets utilisÃ©s dans notre
code suivent le comportement souhaitÃ©. Dans les langages typÃ©s dynamiquement,
nous aurons une erreur Ã  l'exÃ©cution si nous appelions une mÃ©thode sur un type
qui n'implÃ©mentait pas la mÃ©thode. Mais Rust dÃ©cale l'apparition de ces erreurs
au moment de la compilation afin de nous forcer Ã  rÃ©soudre les problÃ¨mes avant
mÃªme que notre code soit capable de s'exÃ©cuter. De plus, nous n'avons pas besoin
d'Ã©crire un code qui vÃ©rifie le comportement lors de l'exÃ©cution car nous
l'avons dÃ©jÃ  vÃ©rifiÃ© au moment de la compilation. Cela permet d'amÃ©liorer les
performances sans avoir Ã  sacrifier la flexibilitÃ© des gÃ©nÃ©riques.</p>
<!--
Another kind of generic that weâ€™ve already been using is called *lifetimes*.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Letâ€™s look at how
lifetimes do that.
-->
<p>Un autre type de gÃ©nÃ©rique que nous avons dÃ©jÃ  utilisÃ© est la <em>durÃ©e de vie</em>.
PlutÃ´t que de s'assurer qu'un type a le comportement que nous voulons, la durÃ©e
de vie s'assure que les rÃ©fÃ©rences sont en vigueur aussi longtemps que nous
avons besoin qu'elles le soient. Nous allons voir Ã  la page suivante comment la
durÃ©e de vie fait cela.</p>
<!-- markdownlint-disable -->
<!--
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<!-- markdownlint-restore -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
