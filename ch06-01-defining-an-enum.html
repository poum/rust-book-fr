<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DÃ©finir une Ã©numÃ©ration - Le langage de programmation Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../ferris.css">
                <link rel="stylesheet" href="../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html" class="active"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Defining an Enum
-->
<h2 id="dÃ©finir-une-Ã©numÃ©ration"><a class="header" href="#dÃ©finir-une-Ã©numÃ©ration">DÃ©finir une Ã©numÃ©ration</a></h2>
<!--
Letâ€™s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can *enumerate* all possible
variants, which is where enumeration gets its name.
-->
<p>Imaginons une situation que nous voudrions exprimer avec du code et regardons
pourquoi les Ã©numÃ©rations sont utiles et plus appropriÃ©es que les structures
dans ce cas. Disons que nous avons besoin de travailler avec des adresses IP.
Pour le moment, il existe deux normes principales pour les adresses IPÂ : la
version quatre et la version six. Ce seront les seules possibilitÃ©s d'adresse
IP que notre programme va rencontrerÂ : nous pouvons <em>Ã©numÃ©rer</em> toutes les
variantes possibles, d'oÃ¹ vient le nom de l'Ã©numÃ©ration.</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because enum values can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>N'importe quelle adresse IP peut Ãªtre soit une adresse en version quatre, soit
en version six, mais pas les deux en mÃªme temps. Cette propriÃ©tÃ© des adresses IP
est appropriÃ©e Ã  la structure de donnÃ©es d'Ã©numÃ©rations, car les valeurs de
l'Ã©numÃ©ration ne peuvent Ãªtre qu'une de ses variantes. Les adresses en version
quatre et six sont toujours fondamentalement des adresses IP, donc elles doivent
Ãªtre traitÃ©es comme Ã©tant du mÃªme type lorsque le code travaille avec des
situations qui s'appliquent Ã  n'importe quelle sorte d'adresse IP.</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are the
variants of the enum:
-->
<p>Nous pouvons exprimer ce concept dans le code en dÃ©finissant une Ã©numÃ©ration
<code>SorteAdresseIp</code> et en listant les diffÃ©rentes sortes possibles d'adresses IP
qu'elle peut avoir, <code>V4</code> et <code>V6</code>. Ce sont les variantes de l'Ã©numÃ©rationÂ :</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum SorteAdresseIp {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p><code>SorteAdresseIp</code> est maintenant un type de donnÃ©es personnalisÃ© que nous pouvons
utiliser n'importe oÃ¹ dans notre code.</p>
<!--
### Enum Values
-->
<h3 id="les-valeurs-dÃ©numÃ©rations"><a class="header" href="#les-valeurs-dÃ©numÃ©rations">Les valeurs d'Ã©numÃ©rations</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>Nous pouvons crÃ©er des instances de chacune des deux variantes de
<code>SorteAdresseIp</code> de cette maniÃ¨reÂ :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let quatre = SorteAdresseIp::V4;
    let six = SorteAdresseIp::V6;
<span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type:
`IpAddrKind`. We can then, for instance, define a function that takes any
`IpAddrKind`:
-->
<p>Remarquez que les variantes de l'Ã©numÃ©ration sont dans un espace de nom qui se
situe avant leur nom, et nous utilisons un double deux-points pour les sÃ©parer
tous les deux. C'est utile car maintenant les deux valeurs <code>SorteAdresseIp::V4</code>
et <code>SorteAdresseIp::V6</code> sont du mÃªme typeÂ : <code>SorteAdresseIp</code>. Ensuite, nous
pouvons, par exemple, dÃ©finir une fonction qui accepte n'importe quelle
<code>SorteAdresseIp</code>Â :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn router(sorte_ip: SorteAdresseIp) { }
</code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>Et nous pouvons appeler cette fonction avec chacune des variantesÂ :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span>    router(SorteAdresseIp::V4);
    router(SorteAdresseIp::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we donâ€™t have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1.
-->
<p>L'utilisation des Ã©numÃ©rations a encore plus d'avantages. En Ã©tudiant un peu
plus notre type d'adresse IP, nous constatons que pour le moment, nous ne
pouvons pas stocker <em>la donnÃ©e</em> de l'adresse IPÂ ; nous savons seulement de
quelle sorte elle est. Avec ce que vous avez appris au chapitre 5, vous pouvez
rÃ©soudre ce problÃ¨me comme dans l'encart 6-1.</p>
<!--
```rust
# fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SorteAdresseIp {
        V4,
        V6,
    }

    struct AdresseIp {
        sorte: SorteAdresseIp,
        adresse: String,
    }

    let local = AdresseIp {
        sorte: SorteAdresseIp::V4,
        adresse: String::from(&quot;127.0.0.1&quot;),
    };
    
    let rebouclage = AdresseIp {
        sorte: SorteAdresseIp::V6,
        adresse: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">Encart 6-1Â : Stockage de la donnÃ©e et de la variante de
<code>SorteAdresseIp</code> d'une adresse IP en utilisant une <code>struct</code></span></p>
<!--
Here, weâ€™ve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first, `home`, has
the value `IpAddrKind::V4` as its `kind` with associated address data of
`127.0.0.1`. The second instance, `loopback`, has the other variant of
`IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with
it. Weâ€™ve used a struct to bundle the `kind` and `address` values together, so
now the variant is associated with the value.
-->
<p>Ainsi, nous avons dÃ©fini une structure <code>AdresseIp</code> qui a deux champsÂ : un champ
<code>sorte</code> qui est du type <code>SorteAdresseIp</code> (l'Ã©numÃ©ration que nous avons dÃ©finie
prÃ©cÃ©demment) et un champ <code>adresse</code> qui est du type <code>String</code>. Nous avons deux
instances de cette structure. La premiÃ¨re, <code>local</code>, a la valeur
<code>SorteAdresseIp::V4</code> pour son champ <code>sorte</code>, associÃ© Ã  la donnÃ©e d'adresse qui
est <code>127.0.0.1</code>. La seconde instance, <code>rebouclage</code>, a comme valeur de champ
<code>sorte</code> l'autre variante de <code>SorteAdresseIp</code>, <code>V6</code>, et a l'adresse<code>::1</code> qui lui
est associÃ©e. Nous avons utilisÃ© une structure pour relier ensemble la <code>sorte</code>
et l'<code>adresse</code>, donc maintenant la variante est liÃ©e Ã  la valeur.</p>
<!--
We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>Nous pouvons appliquer le mÃªme principe de maniÃ¨re plus concise en utilisant
uniquement une Ã©numÃ©ration, plutÃ´t que d'utiliser une Ã©numÃ©ration dans une
structure, en insÃ©rant directement la donnÃ©e dans chaque variante de
l'Ã©numÃ©ration. Cette nouvelle dÃ©finition de l'Ã©numÃ©ration <code>AdresseIp</code> indique
que chacune des variantes <code>V4</code> et <code>V6</code> auront des valeurs associÃ©es de type
<code>String</code>Â :</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(String),
        V6(String),
    }
    
    let local = AdresseIp::V4(String::from(&quot;127.0.0.1&quot;));
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct.
-->
<p>Nous relions les donnÃ©es de chaque variante directement Ã  l'Ã©numÃ©ration, donc il
n'est pas nÃ©cessaire d'avoir une structure en plus.</p>
<!--
Thereâ€™s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldnâ€™t be able to with
a struct. Enums handle this case with ease:
-->
<p>Il y a un autre avantage Ã  utiliser une Ã©numÃ©ration plutÃ´t qu'une structureÂ :
chaque variante peut stocker des types diffÃ©rents, et aussi avoir une quantitÃ©
diffÃ©rente de donnÃ©es associÃ©es. Les adresses IP version quatre vont toujours
avoir quatre composantes numÃ©riques qui auront une valeur entre 0 et 255. Si
nous voulions stocker les adresses <code>V4</code> avec quatre valeurs de type <code>u8</code> mais
continuer Ã  stocker les adresses <code>V6</code> dans une <code>String</code>, nous ne pourrions pas
le faire avec une structure. Les Ã©numÃ©rations permettent de faire cela
facilementÂ :</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    
    let local = AdresseIp::V4(127, 0, 0, 1);
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
Weâ€™ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr]<!-- ignore -- > Letâ€™s look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
weâ€™ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>Nous avons vu diffÃ©rentes maniÃ¨res de dÃ©finir des structures de donnÃ©es pour
enregistrer des adresses IP en version quatre et version six. Cependant, il
s'avÃ¨re que vouloir stocker des adresses IP et identifier de quelle sorte elles
sont est si frÃ©quent que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la bibliothÃ¨que standard a une dÃ©finition que nous
pouvons utiliserÂ !</a><!-- ignore --> Analysons comment la bibliothÃ¨que
standard a dÃ©fini <code>IpAddr</code> (l'Ã©quivalent de notre <code>AdresseIp</code>)Â : nous retrouvons
la mÃªme Ã©numÃ©ration et les variantes que nous avons dÃ©finies et utilisÃ©es, mais
stocke les donnÃ©es d'adresse dans des variantes dans deux structures
diffÃ©rentes, qui sont dÃ©finies chacune pour chaque varianteÂ :</p>
<!--
[IpAddr]: ../std/net/enum.IpAddr.html
-->
<!--
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // -- code masquÃ© ici --
}

struct Ipv6Addr {
    // -- code masquÃ© ici --
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>Ce code montre comment vous pouvez insÃ©rer n'importe quel type de donnÃ©es dans
une variante d'Ã©numÃ©rationÂ : des chaÃ®nes de caractÃ¨res, des nombres ou des
structures, par exemple. Vous pouvez mÃªme y intÃ©grer d'autres Ã©numÃ©rationsÂ ! Par
ailleurs, les types de la bibliothÃ¨que standard ne sont parfois pas plus
compliquÃ©s que ce que vous pourriez inventer.</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
havenâ€™t brought the standard libraryâ€™s definition into our scope. Weâ€™ll talk
more about bringing types into scope in Chapter 7.
-->
<p>Notez aussi que mÃªme si la bibliothÃ¨que standard embarque une dÃ©finition de
<code>IpAddr</code>, nous pouvons quand mÃªme crÃ©er et utiliser notre propre dÃ©finition de
ce type sans avoir de conflit de nom car nous n'avons pas importÃ© cette
dÃ©finition de la bibliothÃ¨que standard dans la portÃ©e. Nous verrons plus en
dÃ©tail comment importer les types dans la portÃ©e au chapitre 7.</p>
<!--
Letâ€™s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>Analysons un autre exemple d'une Ã©numÃ©ration dans l'encart 6-2Â : celle-ci a une
grande diversitÃ© de types dans ses variantes.</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">Encart 6-2Â : Une Ã©numÃ©ration <code>Message</code> dont chaque
variante stocke des valeurs de diffÃ©rents types et en diffÃ©rentes
quantitÃ©s</span></p>
<!--
This enum has four variants with different types:
-->
<p>Cette Ã©numÃ©ration a quatre variantes avec des types diffÃ©rentsÂ :</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` includes an anonymous struct inside it.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quitter</code> n'a pas du tout de donnÃ©e associÃ©e.</li>
<li><code>Deplacer</code> intÃ¨gre une structure anonyme.</li>
<li><code>Ecrire</code> intÃ¨gre une seule <code>String</code>.</li>
<li><code>ChangerCouleur</code> intÃ¨gre trois valeurs de type <code>i32</code>.</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesnâ€™t use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>DÃ©finir une Ã©numÃ©ration avec des variantes comme celles dans l'encart 6-2
ressemble Ã  la dÃ©finition de diffÃ©rentes sortes de structures, sauf que
l'Ã©numÃ©ration n'utilise pas le mot-clÃ© <code>struct</code> et que toutes les variantes sont
regroupÃ©es ensemble sous le type <code>Message</code>. Les structures suivantes peuvent
stocker les mÃªmes donnÃ©es que celles stockÃ©es par les variantes prÃ©cÃ©dentesÂ :</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MessageQuitter; // une structure unitÃ©
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldnâ€™t as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<p>Mais si nous utilisions les diffÃ©rentes structures, qui ont chacune leur propre
type, nous ne pourrions pas dÃ©finir facilement une fonction qui prend en
paramÃ¨tre toutes les sortes de messages, tel que nous pourrions le faire avec
l'Ã©numÃ©ration <code>Message</code> que nous avons dÃ©finie dans l'encart 6-2, qui est un
seul type.</p>
<!--
There is one more similarity between enums and structs: just as weâ€™re able to
define methods on structs using `impl`, weâ€™re also able to define methods on
enums. Hereâ€™s a method named `call` that we could define on our `Message` enum:
-->
<p>Il y a un autre point commun entre les Ã©numÃ©rations et les structuresÂ : tout
comme on peut dÃ©finir des mÃ©thodes sur les structures en utilisant <code>impl</code>, on
peut aussi dÃ©finir des mÃ©thodes sur des Ã©numÃ©rations. Voici une mÃ©thode appelÃ©e
<code>appeler</code> que nous pouvons dÃ©finir sur notre Ã©numÃ©ration <code>Message</code>Â :</p>
<!--
```rust
# fn main() {
#     enum Message {
#         Quit,
#         Move { x: i32, y: i32 },
#         Write(String),
#         ChangeColor(i32, i32, i32),
#     }
# 
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quitter,
</span><span class="boring">        Deplacer { x: i32, y: i32 },
</span><span class="boring">        Ecrire(String),
</span><span class="boring">        ChangerCouleur(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn appeler(&amp;self) {
            // le corps de la mÃ©thode sera dÃ©fini ici
        }
    }
    
    let m = Message::Ecrire(String::from(&quot;hello&quot;));
    m.appeler();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, weâ€™ve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>Le corps de la mÃ©thode va utiliser <code>self</code> pour obtenir la valeur sur laquelle
nous avons utilisÃ© la mÃ©thode. Dans cet exemple, nous avons crÃ©Ã© une variable
<code>m</code> qui a la valeur <code>Message::Ecrire(String::from(&quot;hello&quot;))</code>, et cela sera ce
que <code>self</code> aura comme valeur dans le corps de la mÃ©thode <code>appeler</code> quand nous
lancerons <code>m.appeler()</code>.</p>
<!--
Letâ€™s look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>Regardons maintenant une autre Ã©numÃ©ration de la bibliothÃ¨que standard qui est
trÃ¨s utilisÃ©e et utileÂ : <code>Option</code>.</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3 id="lÃ©numÃ©ration-option-et-ses-avantages-par-rapport-Ã -la-valeur-null"><a class="header" href="#lÃ©numÃ©ration-option-et-ses-avantages-par-rapport-Ã -la-valeur-null">L'Ã©numÃ©ration <code>Option</code> et ses avantages par rapport Ã  la valeur null</a></h3>
<!--
In the previous section, we looked at how the `IpAddr` enum let us use Rustâ€™s
type system to encode more information than just the data into our program.
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check whether youâ€™ve handled all the cases you should be handling;
this functionality can prevent bugs that are extremely common in other
programming languages.
-->
<p>Dans la section prÃ©cÃ©dente, nous avons dÃ©couvert comment l'Ã©numÃ©ration
<code>AdresseIp</code> nous permet d'utiliser le systÃ¨me de types de Rust pour enregistrer
dans nos programmes encore plus d'informations qu'uniquement la donnÃ©e. Cette
section Ã©tudie le cas de <code>Option</code>, qui est une autre Ã©numÃ©ration dÃ©finie dans la
bibliothÃ¨que standard. Le type <code>Option</code> est utilisÃ© dans de nombreux endroits
car il dÃ©crit un scÃ©nario trÃ¨s courant oÃ¹ une valeur peut Ãªtre soit quelque
chose, soit rien du tout. Exprimer ce concept avec le systÃ¨me de types implique
que le compilateur peut vÃ©rifier si vous avez gÃ©rÃ© tous les cas que vous
pourriez rencontrerÂ ; cette fonctionnalitÃ© peut Ã©viter des bogues qui sont trÃ¨s
courants dans d'autres langages de programmation.</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesnâ€™t have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>La conception d'un langage de programmation est souvent pensÃ©e en fonction des
fonctionnalitÃ©s qu'on inclut, mais les fonctionnalitÃ©s qu'on refuse sont elles
aussi importantes. Rust n'a pas de fonctionnalitÃ© <em>null</em> qu'ont de nombreux
langages. <em>Null</em> est une valeur qui signifie qu'il n'y a pas de valeur Ã  cet
endroit. Avec les langages qui utilisent null, les variables peuvent toujours
Ãªtre dans deux Ã©tatsÂ : null ou non null.</p>
<!--
In his 2009 presentation â€œNull References: The Billion Dollar Mistake,â€ Tony
Hoare, the inventor of null, has this to say:
-->
<p>Dans sa thÃ¨se de 2009 â€œNull References: The Billion Dollar Mistakeâ€ (les
rÃ©fÃ©rences nullesÂ : l'erreur Ã  un milliard de dollars), Tony Hoare, l'inventeur
de null, a Ã©crit ceciÂ :</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldnâ€™t resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>Je l'appelle mon erreur Ã  un milliard de dollars. Ã€ cette Ã©poque, je concevais
le premier systÃ¨me de type complet pour des rÃ©fÃ©rences dans un langage orientÃ©
objet. Mon objectif Ã©tait de garantir que toutes les utilisations des
rÃ©fÃ©rences soient totalement sÃ»res, et soient vÃ©rifiÃ©es automatiquement par le
compilateur. Mais je n'ai pas pu rÃ©sister Ã  la tentation d'inclure la
rÃ©fÃ©rence nulle, simplement parce que c'Ã©tait si simple Ã  implÃ©menter. Cela a
conduit Ã  d'innombrables erreurs, vulnÃ©rabilitÃ©s, et pannes systÃ¨mes, qui ont
probablement causÃ© un milliard de dollars de dommages au cours des quarante
derniÃ¨res annÃ©es.</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, youâ€™ll get an error of some kind. Because this null or not-null
property is pervasive, itâ€™s extremely easy to make this kind of error.
-->
<p>Le problÃ¨me avec les valeurs nulles, c'est que si vous essayez d'utiliser une
valeur nulle comme si elle n'Ã©tait pas nulle, vous obtiendrez une erreur d'une
faÃ§on ou d'une autre. Comme cette propriÃ©tÃ© nulle ou non nulle est omniprÃ©sente,
il est trÃ¨s facile de faire cette erreur.</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>Cependant, le concept que null essaye d'exprimer reste utileÂ : une valeur nulle
est une valeur qui est actuellement invalide ou absente pour une raison ou une
autre.</p>
<!--
The problem isnâ€™t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]<!-- ignore -- >
as follows:
-->
<p>Le problÃ¨me ne vient pas vraiment du concept, mais de son implÃ©mentation. C'est
pourquoi Rust n'a pas de valeurs nulles, mais il a une Ã©numÃ©ration qui dÃ©crit le
concept d'une valeur qui peut Ãªtre soit prÃ©sente, soit absente. Cette
Ã©numÃ©ration est <code>Option&lt;T&gt;</code>, et elle est <a href="https://doc.rust-lang.org/std/option/enum.Option.html">dÃ©finie dans la bibliothÃ¨que
standard</a><!-- ignore --> comme ci-dessousÂ :</p>
<!--
[option]: ../std/option/enum.Option.html
-->
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that itâ€™s even included in the prelude; you
donâ€™t need to bring it into scope explicitly. In addition, so are its variants:
you can use `Some` and `None` directly without the `Option::` prefix. The
`Option<T>` enum is still just a regular enum, and `Some(T)` and `None` are
still variants of type `Option<T>`.
-->
<p>L'Ã©numÃ©ration <code>Option&lt;T&gt;</code> est tellement utile qu'elle est intÃ©grÃ©e dans l'Ã©tape
prÃ©liminaireÂ ; vous n'avez pas besoin de l'importer explicitement dans la
portÃ©e. De plus, voici ses variantesÂ : vous pouvez utiliser directement <code>Some</code>
(<em>quelque chose</em>) et <code>None</code> (<em>rien</em>) sans les prÃ©fixer par <code>Option::</code>.
L'Ã©numÃ©ration <code>Option&lt;T&gt;</code> reste une Ã©numÃ©ration normale, et <code>Some(T)</code> ainsi que
<code>None</code> sont toujours des variantes de type <code>Option&lt;T&gt;</code>.</p>
<!--
The `<T>` syntax is a feature of Rust we havenâ€™t talked about yet. Itâ€™s a
generic type parameter, and weâ€™ll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type. Here are some examples of
using `Option` values to hold number types and string types:
-->
<p>La syntaxe <code>&lt;T&gt;</code> est une fonctionnalitÃ© de Rust que nous n'avons pas encore
abordÃ©e. Il s'agit d'un paramÃ¨tre de type gÃ©nÃ©rique, et nous verrons la
gÃ©nÃ©ricitÃ© plus en dÃ©tail au chapitre 10. Pour le moment, dites-vous que ce
<code>&lt;T&gt;</code> signifie que la variante <code>Some</code> de l'Ã©numÃ©ration <code>Option</code> peut stocker un
Ã©lÃ©ment de donnÃ©e de n'importe quel type. Voici quelques exemples d'utilisation
de valeurs de <code>Option</code> pour stocker des types de nombres et des types de chaÃ®nes
de caractÃ¨resÂ :</p>
<!--
```rust
# fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let un_nombre = Some(5);
    let une_chaine = Some(&quot;une chaÃ®ne&quot;);

    let nombre_absent: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
If we use `None` rather than `Some`, we need to tell Rust what type of
`Option<T>` we have, because the compiler canâ€™t infer the type that the `Some`
variant will hold by looking only at a `None` value.
-->
<p>Si nous utilisons <code>None</code> plutÃ´t que <code>Some</code>, nous devons indiquer Ã  Rust quel
type de <code>Option&lt;T&gt;</code> nous avons, car le compilateur ne peut pas dÃ©duire le type
que cette variante <code>Some</code> va stocker en considÃ©rant uniquement une valeur
<code>None</code>.</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we donâ€™t have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p>Lorsque nous avons une valeur <code>Some</code>, nous savons que la valeur est prÃ©sente et
que la valeur est stockÃ©e dans le <code>Some</code>. Lorsque nous avons une valeur <code>None</code>,
en quelque sorte, cela veut dire la mÃªme chose que nullÂ : nous n'avons pas une
valeur valide. Donc pourquoi obtenir <code>Option&lt;T&gt;</code> est meilleur que d'avoir nullÂ ?</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler wonâ€™t let us use an `Option<T>` value as if it were
definitely a valid value. For example, this code wonâ€™t compile because itâ€™s
trying to add an `i8` to an `Option<i8>`:
-->
<p>En bref, comme <code>Option&lt;T&gt;</code> et <code>T</code> (oÃ¹ <code>T</code> reprÃ©sente n'importe quel type) sont
de types diffÃ©rents, le compilateur ne va pas nous autoriser Ã  utiliser une
valeur <code>Option&lt;T&gt;</code> comme si cela Ã©tait bien une valeur valide. Par exemple, le
code suivant ne se compile pas car il essaye d'additionner un <code>i8</code> et une
<code>Option&lt;i8&gt;</code>Â :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let somme = x + y;
<span class="boring">}
</span></code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>Si nous lanÃ§ons ce code, nous aurons un message d'erreur comme celui-ciÂ :</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 -- > src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let somme = x + y;
  |                   ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`

To learn more, run the command again with --verbose.
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesnâ€™t understand how
to add an `i8` and an `Option<i8>`, because theyâ€™re different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value weâ€™re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>IntenseÂ ! Effectivement, ce message d'erreur signifie que Rust ne comprend pas
comment additionner un <code>i8</code> et une <code>Option&lt;i8&gt;</code>, car ils sont de types
diffÃ©rents. Quand nous avons une valeur d'un type comme <code>i8</code> avec Rust, le
compilateur va s'assurer que nous avons toujours une valeur valide. Nous pouvons
continuer en toute confiance sans avoir Ã  vÃ©rifier que cette valeur n'est pas
nulle avant de l'utiliser. Ce n'est que lorsque nous avons une <code>Option&lt;i8&gt;</code> (ou
tout autre type de valeur avec lequel nous travaillons) que nous devons nous
inquiÃ©ter de ne pas avoir de valeur, et le compilateur va s'assurer que nous
gÃ©rons ce cas avant d'utiliser la valeur.</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isnâ€™t null when it actually
is.
-->
<p>Autrement dit, vous devez convertir une <code>Option&lt;T&gt;</code> en <code>T</code> pour pouvoir faire
avec elle des opÃ©rations du type <code>T</code>. GÃ©nÃ©ralement, cela permet de rÃ©soudre l'un
des problÃ¨mes les plus courants avec nullÂ : supposer qu'une valeur n'est pas
nulle alors qu'en rÃ©alitÃ©, elle l'est.</p>
<!--
Not having to worry about incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isnâ€™t an
`Option<T>`, you *can* safely assume that the value isnâ€™t null. This was a
deliberate design decision for Rust to limit nullâ€™s pervasiveness and increase
the safety of Rust code.
-->
<p>Ne pas avoir Ã  s'inquiÃ©ter que des valeurs nulles puissent Ãªtre mal gÃ©rÃ©es vous
aide Ã  Ãªtre plus confiant en votre code. Pour avoir une valeur qui peut
potentiellement Ãªtre nulle, vous devez l'indiquer explicitement en dÃ©clarant que
le type de cette valeur est <code>Option&lt;T&gt;</code>. Ensuite, quand vous utiliserez cette
valeur, il vous faudra gÃ©rer explicitement le cas oÃ¹ cette valeur est nulle. Si
vous utilisez une valeur qui n'est pas une <code>Option&lt;T&gt;</code>, alors vous <em>pouvez</em>
considÃ©rer que cette valeur ne sera jamais nulle sans prendre de risques. Il
s'agit d'un choix de conception dÃ©libÃ©rÃ© de Rust pour limiter l'omniprÃ©sence de
null et augmenter la sÃ©curitÃ© du code en Rust.</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]<!-- ignore -- >. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>Donc, comment rÃ©cupÃ©rer la valeur de type <code>T</code> d'une variante <code>Some</code> quand vous
avez une valeur de type <code>Option&lt;T&gt;</code> afin de l'utiliserÂ ? L'Ã©numÃ©ration
<code>Option&lt;T&gt;</code> a un large choix de mÃ©thodes qui sont plus ou moins utiles selon les
casÂ ; vous pouvez les dÃ©couvrir dans <a href="https://doc.rust-lang.org/std/option/enum.Option.html">sa documentation</a><!-- ignore -->. Se
familiariser avec les mÃ©thodes de <code>Option&lt;T&gt;</code> peut Ãªtre trÃ¨s utile dans votre
aventure avec Rust.</p>
<!--
[docs]: ../std/option/enum.Option.html
-->
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. You want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. You want some
other code to run if you have a `None` value, and that code doesnâ€™t have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>De maniÃ¨re gÃ©nÃ©rale, pour pouvoir utiliser une valeur de <code>Option&lt;T&gt;</code>, votre code
doit gÃ©rer chaque variante. On veut que du code soit exÃ©cutÃ© uniquement quand on
a une valeur <code>Some(T)</code>, et que ce code soit autorisÃ© Ã  utiliser la valeur de
type <code>T</code> Ã  l'intÃ©rieur. On veut aussi qu'un autre code soit exÃ©cutÃ© si on a une
valeur <code>None</code>, et ce code n'aura pas de valeur de type <code>T</code> de disponible.
L'expression <code>match</code> est une structure de contrÃ´le qui fait bien ceci
lorsqu'elle est utilisÃ©e avec les Ã©numÃ©rationsÂ : elle va exÃ©cuter du code
diffÃ©rent en fonction de quelle variante de l'Ã©numÃ©ration elle obtient, et ce
code pourra utiliser la donnÃ©e prÃ©sente dans la valeur correspondante.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../ferris.js"></script>
                <script type="text/javascript" src="github-button.js"></script>
        
        
    </body>
</html>
