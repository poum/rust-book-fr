<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Les macros - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html" class="active"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/212">Pull Request</a>.</p>
</blockquote>
<!--
## Macros
-->
<h2><a class="header" href="#les-macros" id="les-macros">Les macros</a></h2>
<!--
Weâ€™ve used macros like `println!` throughout this book, but we havenâ€™t fully
explored what a macro is and how it works. The term *macro* refers to a family
of features in Rust: *declarative* macros with `macro_rules!` and three kinds
of *procedural* macros:
-->
<p>Nous avons dÃ©jÃ  utilisÃ© des macros tout au long de ce livre, comme <code>println!</code>,
mais nous n'avons pas explorÃ© en profondeur ce qu'est une macro et comment
elles fonctionnent. Le terme <em>macro</em> revoit Ã  une famille de fonctionnalitÃ©s de
RustÂ : les macros <em>dÃ©claratives</em> avec <code>macro_rules!</code> et trois types de macros
<em>procÃ©durales</em>Â :</p>
<!--
* Custom `#[derive]` macros that specify code added with the `derive` attribute
  used on structs and enums
* Attribute-like macros that define custom attributes usable on any item
* Function-like macros that look like function calls but operate on the tokens
  specified as their argument
-->
<ul>
<li>Des macros <code>#[derive]</code> personnalisÃ©es qui renseigne du code ajoutÃ© grÃ¢ce Ã 
l'attribut <code>derive</code> utilisÃ© sur les structures et les Ã©numÃ©rations</li>
<li>Les macros qui ressemblent Ã  des attributs qui dÃ©finissent des attributs
personnalisÃ©s qui sont utilisables sur n'importe quel Ã©lÃ©ment</li>
<li>Les macros qui ressemblent Ã  des fonctions mais qui opÃ¨rent sur les Ã©lÃ©ments
renseignÃ©s en argument</li>
</ul>
<!--
Weâ€™ll talk about each of these in turn, but first, letâ€™s look at why we even
need macros when we already have functions.
-->
<p>Nous allons voir chacune d'entre elles Ã  leur tour, mais avant, posons-nous la
question de pourquoi nous avons besoin de macros alors que nous avons dÃ©jÃ  les
fonctions.</p>
<!--
### The Difference Between Macros and Functions
-->
<h3><a class="header" href="#la-diffÃ©rence-entre-les-macros-et-les-fonctions" id="la-diffÃ©rence-entre-les-macros-et-les-fonctions">La diffÃ©rence entre les macros et les fonctions</a></h3>
<!--
Fundamentally, macros are a way of writing code that writes other code, which
is known as *metaprogramming*. In Appendix C, we discuss the `derive`
attribute, which generates an implementation of various traits for you. Weâ€™ve
also used the `println!` and `vec!` macros throughout the book. All of these
macros *expand* to produce more code than the code youâ€™ve written manually.
-->
<p>Essentiellement, les macros sont une faÃ§on d'Ã©crire du code qui Ã©crit un autre
code, ce qui s'appelle la <em>mÃ©taprogrammation</em>. Dans l'annexe C, nous verrons
l'attribut <code>derive</code>, qui gÃ©nÃ¨re une implÃ©mentation de diffÃ©rents traits pour
vous. Nous avons aussi utilisÃ© les macros <code>println!</code> et <code>vec!</code> dans ce livre.
Toutes ces macros <em>se dÃ©ploient</em> pour produire plus de code que celui que vous
avez Ã©crit manuellement.</p>
<!--
Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions donâ€™t.
-->
<p>La mÃ©taprogrammation est utile pour rÃ©duire la quantitÃ© de code que vous avez Ã 
Ã©crire et Ã  maintenir, ce qui est aussi un des rÃ´les des fonctions. Cependant,
les macros ont quelques pouvoirs en plus que les fonctions n'ont pas.</p>
<!--
A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call `println!("hello")` with one argument or
`println!("hello {}", name)` with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function canâ€™t, because it gets
called at runtime and a trait needs to be implemented at compile time.
-->
<p>La signature d'une fonction doit dÃ©clarer le nombre et le type de paramÃ¨tres
qu'Ã  cette fonction. Les macros, d'un autre cÃ´tÃ©, peuvent prendre un nombre
variable de paramÃ¨tresÂ : nous pouvons faire appel Ã  <code>println!(&quot;salut&quot;)</code> avec un
seul argument, ou <code>println!(&quot;salut {}&quot;, nom)</code> avec deux arguments. Aussi, les
macros se dÃ©ploient avant que le compilateur interprÃ¨te la signification du
code, donc une macro peut, par exemple, implÃ©menter un trait sur un type donnÃ©.
Une fonction ne peut pas le faire, car elle est exÃ©cutÃ©e Ã  l'exÃ©cution et un
trait doit Ãªtre implÃ©mentÃ© Ã  la compilation.</p>
<!--
The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because youâ€™re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.
-->
<p>Le dÃ©savantage d'implÃ©menter une macro par rapport Ã  une fonction est que les
dÃ©finitions de macros sont plus complexes que les dÃ©finitions de fonction car
vous Ã©crivez du code Rust qui Ã©crit lui-mÃªme du code Rust. A cause de cette
approche, les dÃ©finitions de macro sont gÃ©nÃ©ralement plus difficiles Ã  lire,
comprendre et maintenir que les dÃ©finitions de fonctions.</p>
<!--
Another important difference between macros and functions is that you must
define macros or bring them into scope *before* you call them in a file, as
opposed to functions you can define anywhere and call anywhere.
-->
<p>Une autre diffÃ©rence importante entre les macros et les fonctions est que vous
devez dÃ©finir les macros ou les importer dans la portÃ©e <em>avant</em> de les utiliser
dans le fichier, contrairement aux fonctions que vous pouvez dÃ©finir n'importe
oÃ¹ et y faire appel n'importe oÃ¹.</p>
<!--
### Declarative Macros with `macro_rules!` for General Metaprogramming
-->
<h3><a class="header" href="#les-macros-dÃ©claratives-avec-macro_rules-pour-la-mÃ©taprogrammation-gÃ©nÃ©rale" id="les-macros-dÃ©claratives-avec-macro_rules-pour-la-mÃ©taprogrammation-gÃ©nÃ©rale">Les macros dÃ©claratives avec <code>macro_rules!</code> pour la mÃ©taprogrammation gÃ©nÃ©rale</a></h3>
<!--
The most widely used form of macros in Rust is *declarative macros*. These are
also sometimes referred to as â€œmacros by example,â€ â€œ`macro_rules!` macros,â€ or
just plain â€œmacros.â€ At their core, declarative macros allow you to write
something similar to a Rust `match` expression. As discussed in Chapter 6,
`match` expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.
-->
<p>La forme la plus utilisÃ©e de macro en Rust est la <em>macro dÃ©clarative</em>. Elles
sont parfois appelÃ©es â€œmacros dÃ©finies par un exempleâ€,
â€œmacros <code>macro_rules!</code>â€, ou simplement â€œmacrosâ€. Au fond, les macros
dÃ©claratives vous permettent d'Ã©crire quelque chose de similaire Ã  une
expression <code>match</code> de Rust. Comme nous l'avons vu au chapitre 6, les
expressions <code>match</code> sont des structures de contrÃ´le qui prennent en argument
une expression, compare la valeur qui en rÃ©sulte avec les motifs, et ensuite
exÃ©cute le code associÃ© au motif qui correspond. Les macros comparent elles
aussi une valeur avec des motifs qui sont associÃ©s Ã  code particulierÂ : dans
cette situation, la valeur est littÃ©ralement le code source Rust envoyÃ© Ã  la
macroÂ ; les motifs sont comparÃ©s avec la structure de ce code sourceÂ ; et le
code associÃ© Ã  chaque motif vient remplacer le code passÃ© Ã  la macro, lorsqu'il
correspond. Tout ceci se passe lors de la compilation.</p>
<!--
To define a macro, you use the `macro_rules!` construct. Letâ€™s explore how to
use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8
covered how we can use the `vec!` macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:
-->
<p>Pour dÃ©finir une macro, il faut utiliser la construction <code>macro_rules!</code>.
Explorons l'utilisation de <code>macro_rules!</code> en observant comment la macro <code>vec!</code>
est dÃ©finie. Le chapitre 8 nous a permis de comprendre comment utiliser la
macro <code>vec!</code> pour crÃ©er un nouveau vecteur avec des valeurs prÃ©cises. Par
exemple, la macro suivante crÃ©e un nouveau vecteur qui contient trois entiersÂ :</p>
<!--
```rust
let v: Vec<u32> = vec![1, 2, 3];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
We could also use the `vec!` macro to make a vector of two integers or a vector
of five string slices. We wouldnâ€™t be able to use a function to do the same
because we wouldnâ€™t know the number or type of values up front.
-->
<p>Nous aurions pu aussi utiliser la macro <code>vec!</code> pour crÃ©er un vecteur de deux
entiers ou un vecteur de cinq slices de chaÃ®nes de caractÃ¨res. Nous n'aurions
pas pu utiliser une fonction pour faire la mÃªme chose car nous n'aurions pas pu
connaÃ®tre le nombre ou le type de valeurs au dÃ©part.</p>
<!--
Listing 19-28 shows a slightly simplified definition of the `vec!` macro.
-->
<p>L'encart 19-28 montre une dÃ©finition lÃ©gÃ¨rement simplifiÃ©e de la macro <code>vec!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-28: A simplified version of the `vec!` macro
definition</span>
-->
<p><span class="caption">Encart 19-28Â : une version simplifiÃ©e de la dÃ©finition de
la macro <code>vec!</code></span></p>
<!--
> Note: The actual definition of the `vec!` macro in the standard library
> includes code to preallocate the correct amount of memory up front. That code
> is an optimization that we donâ€™t include here to make the example simpler.
-->
<blockquote>
<p>RemarqueÂ : la dÃ©finition actuelle de la macro <code>vec!</code> de la bibliothÃ¨que
standard embarque du code pour prÃ©-allouer la bonne quantitÃ© de mÃ©moire en
amont. Ce code est une optimisation que nous n'allons pas intÃ©grer ici pour
simplifier l'exemple.</p>
</blockquote>
<!--
The `#[macro_export]` annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro canâ€™t be brought into scope.
-->
<p>L'annotation <code>#[macro_export]</code> indique que cette macro doit Ãªtre disponible Ã 
chaque fois que la crate dans laquelle la macro est dÃ©finie est importÃ©e dans
la portÃ©e. Sans cette annotation, la macro ne pourrait pas Ãªtre importÃ©e dans
la portÃ©e.</p>
<!--
We then start the macro definition with `macro_rules!` and the name of the
macro weâ€™re defining *without* the exclamation mark. The name, in this case
`vec`, is followed by curly brackets denoting the body of the macro definition.
-->
<p>Ensuite, nous commenÃ§ons la dÃ©finition de la macro avec <code>macro_rules!</code> suivi du
nom de la macro que nous dÃ©finissons <em>sans</em> le point d'exclamation. Le nom, qui
dans ce cas est <code>vec</code>, est suivi par des accolades indiquant le corps de la
dÃ©finition de la macro.</p>
<!--
The structure in the `vec!` body is similar to the structure of a `match`
expression. Here we have one arm with the pattern `( $( $x:expr ),* )`,
followed by `=>` and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.
-->
<p>La structure dans le corps de <code>vec!</code> ressemble Ã  la structure d'une expression
<code>match</code>. Ici nous avons une branche avec le motif <code>( $( $x:expr ), * )</code>, suivi
par <code>=&gt;</code> et le code du bloc associÃ© Ã  ce motif. Si le motif correspond, le bloc
de code associÃ© sera dÃ©ployÃ©. Etant donnÃ© que c'est le seul motif dans cette
macro, il n'y a qu'une seule bonne faÃ§on d'y correspondreÂ ; tout autre motif va
dÃ©boucher sur une erreur. Des macros plus complexes auront plus qu'une seule
branche.</p>
<!--
Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Letâ€™s walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see [the reference].
-->
<p>La syntaxe correcte pour un motif dans les dÃ©finitions de macros est diffÃ©rente
de la syntaxe de motif que nous avons vu au chapitre 18 car les motifs de
macros sont comparÃ©s Ã  des structures de code Rust plutÃ´t qu'Ã  des valeurs.
Examinons la signification des Ã©lÃ©ments du motif de l'encart 19-28Â ; pour voir
l'intÃ©gralitÃ© de la syntaxe du motif de la macro, rendez-vous
<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Ã  la documentation</a>.</p>
<!--
[the reference]: ../reference/macros-by-example.html
-->
<!--
First, a set of parentheses encompasses the whole pattern. A dollar sign (`$`)
is next, followed by a set of parentheses that captures values that match the
pattern within the parentheses for use in the replacement code. Within `$()` is
`$x:expr`, which matches any Rust expression and gives the expression the name
`$x`.
-->
<p>PremiÃ¨rement, un jeu de parenthÃ¨ses englobent l'intÃ©gralitÃ© du motif. Ensuite
vient le symbole dollar (<code>$</code>), suivi par un jeu de parenthÃ¨ses qui capturent les
valeurs qui correspondent au motif entre les parenthÃ¨ses pour les utiliser dans
le code de remplacement. A l'intÃ©rieur du <code>$()</code> nous avons <code>$x:expr</code>, qui
correspond Ã  n'importe quelle expression Rust et donne le nom <code>$x</code> Ã 
l'expression.</p>
<!--
The comma following `$()` indicates that a literal comma separator character
could optionally appear after the code that matches the code in `$()`. The `*`
specifies that the pattern matches zero or more of whatever precedes the `*`.
-->
<p>La virgule qui suit le <code>$()</code> signifie que cette virgule littÃ©rale comme
caractÃ¨re littÃ©ral de sÃ©paration peut optionnellement apparaÃ®tre aprÃ¨s le code
qui correspond au code du <code>$()</code>. Le <code>*</code> informe que ce motif correspond Ã  zÃ©ro
ou plus Ã©lÃ©ments rÃ©pÃ©tÃ©s correspondant Ã  ce qui prÃ©cÃ¨de ce <code>*</code>.</p>
<!--
When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three
times with the three expressions `1`, `2`, and `3`.
-->
<p>Lorsque nous faisons appel Ã  cette macro avec <code>vec![1, 2, 3];</code>, le motif <code>$x</code>
correspond Ã  trois reprises avec les trois expressions <code>1</code>, <code>2</code>, et <code>3</code>.</p>
<!--
Now letâ€™s look at the pattern in the body of the code associated with this arm:
`temp_vec.push()` within `$()*` is generated for each part that matches `$()`
in the pattern zero or more times depending on how many times the pattern
matches. The `$x` is replaced with each expression matched. When we call this
macro with `vec![1, 2, 3];`, the code generated that replaces this macro call
will be the following:
-->
<p>Maintenant, penchons-nous sur le motif dans le corps du code associÃ© Ã  cette
brancheÂ : <code>temp_vec.push()</code> dans le <code>$()*</code> est gÃ©nÃ©rÃ© pour chacune des parties
qui correspondent au <code>$()</code> dans le motif pour zÃ©ro ou plus de fois, en fonction
de combien de fois le motif correspond. Le <code>$x</code> est remplacÃ© par chaque
expression qui correspond. Lorsque nous faisons appel Ã  cette macro avec
<code>vec![1, 2, 3];</code>, le code gÃ©nÃ©rÃ© qui remplace cet appel de macro ressemblera Ã 
ceciÂ :</p>
<!--
```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```
-->
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<!--
Weâ€™ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.
-->
<p>Nous avons dÃ©fini une macro qui peut prendre n'importe quel nombre d'arguments
de n'importe quel type et qui peut gÃ©nÃ©rer du code pour crÃ©er un vecteur qui
contient les Ã©lÃ©ments renseignÃ©s.</p>
<!--
There are some strange edge cases with `macro_rules!`. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, `macro_rules!` will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will *use* macros more than *write* macros, we wonâ€™t discuss
`macro_rules!` any further. To learn more about how to write macros, consult
the online documentation or other resources, such as [â€œThe Little Book of Rust
Macrosâ€][tlborm].
-->
<p>Il subsiste quelques cas marginaux Ã©tranges avec <code>macro_rules!</code>. BientÃ´t, Rust
rajoutera un second type de macro dÃ©clarative qui fonctionnera de la mÃªme
maniÃ¨re mais qui corrigera ces cas marginaux. AprÃ¨s cette mise Ã  jour,
<code>macro_rules!</code> sera dÃ©prÃ©ciÃ©e. En sachant cela, ainsi que le fait que la
plupart des dÃ©veloppeurs Rust vont plus <em>utiliser</em> les macros <em>qu'Ã©crire</em> des
macros, nous ne verrons plus Ã  nouveau <code>macro_rules!</code> Ã  l'avenir. Pour en
savoir plus sur l'Ã©criture des macros, consultez la documentation en ligne, ou
d'autres ressources comme <a href="https://danielkeep.github.io/tlborm/book/index.html">â€œThe Little Book of Rust Macrosâ€</a>.</p>
<!--
[tlborm]: https://danielkeep.github.io/tlborm/book/index.html
-->
<!--
### Procedural Macros for Generating Code from Attributes
-->
<h3><a class="header" href="#les-macros-procÃ©durales-pour-gÃ©nÃ©rer-du-code-Ã -partir-des-attributs" id="les-macros-procÃ©durales-pour-gÃ©nÃ©rer-du-code-Ã -partir-des-attributs">Les macros procÃ©durales pour gÃ©nÃ©rer du code Ã  partir des attributs</a></h3>
<!--
The second form of macros is *procedural macros*, which act more like functions
(and are a type of procedure). Procedural macros accept some code as an input,
operate on that code, and produce some code as an output rather than matching
against patterns and replacing the code with other code as declarative macros
do.
-->
<p>La seconde forme de macro est la <em>macro procÃ©durale</em>, qui se comporte plus
comme des fonctions (et sont un type de procÃ©dure). Les macros procÃ©durales
prennent du code en entrÃ©e, travaille sur ce code, et produit du code en sortie
plutÃ´t que de faire des correspondances sur des motifs et remplacer du code
avec un autre code, comme le font les macros dÃ©claratives.</p>
<!--
The three kinds of procedural macros (custom derive, attribute-like, and
function-like) all work in a similar fashion.
-->
<p>Les trois types de macros procÃ©durales (les dÃ©rivÃ©es personnalisÃ©es, celles qui
ressemblent aux attributs, et celles qui ressemblent Ã  des fonctions)
fonctionnent toutes de la mÃªme maniÃ¨re.</p>
<!--
When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. Using procedural macros looks like the code in
Listing 19-29, where `some_attribute` is a placeholder for using a specific
macro.
-->
<p>Lorsque vous crÃ©ez une macro procÃ©durale, les dÃ©finitions doivent Ãªtre rangÃ©es
dans leur propre crate avec un type spÃ©cial de crate. Ceci pour des raisons
techniques complexes que nous espÃ©rons supprimer dans l'avenir. L'utilisation
des macros procÃ©durales ressemble au code de l'encart 19-29, dans lequel
<code>un_attribut_quelconque</code> est un emplacement pour l'utilisation d'une macro
spÃ©cifique.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```
-->
<pre><code class="language-rust ignore">use proc_macro;

#[un_attribut_quelconque]
pub fn un_nom_quelconque(entree: TokenStream) -&gt; TokenStream {
}
</code></pre>
<!--
<span class="caption">Listing 19-29: An example of using a procedural
macro</span>
-->
<p><span class="caption">Encart 19-29Â : un exemple d'utilisation d'une macro
procÃ©durale</span></p>
<!--
The function that defines a procedural macro takes a `TokenStream` as an input
and produces a `TokenStream` as an output. The `TokenStream` type is defined by
the `proc_macro` crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input `TokenStream`, and the code the macro produces
is the output `TokenStream`. The function also has an attribute attached to it
that specifies which kind of procedural macro weâ€™re creating. We can have
multiple kinds of procedural macros in the same crate.
-->
<p>La fonction qui dÃ©finit une macro procÃ©durale prend un <code>TokenStream</code> en entrÃ©e
et produit un <code>TokenStream</code> en sortie. Le type <code>TokenStream</code> est dÃ©fini par la
crate <code>proc_macro</code> qui est fournie par Rust et reprÃ©sente une sÃ©quence de
jetons. C'est le cÅ“ur de la macroÂ : le code source sur lequel la macro opÃ¨re
compose l'entrÃ©e <code>TokenStream</code>, et le code que la macro produit est une sortie
<code>TokenStream</code>. La fonction a aussi un attribut qui lui est rattachÃ© qui
renseigne quel genre de macro procÃ©durale nous crÃ©ons. Nous pouvons avoir
diffÃ©rents types de macros procÃ©durales dans la mÃªme crate.</p>
<!--
Letâ€™s look at the different kinds of procedural macros. Weâ€™ll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.
-->
<p>Voyons maintenant les diffÃ©rents types de macros procÃ©durales. Nous allons
commencer par une macro dÃ©rivÃ©e personnalisÃ©e et nous expliquerons ensuite les
petites diffÃ©rences avec les autres types.</p>
<!--
### How to Write a Custom `derive` Macro
-->
<h3><a class="header" href="#comment-Ã©crire-une-macro-dÃ©rivÃ©e-personnalisÃ©e" id="comment-Ã©crire-une-macro-dÃ©rivÃ©e-personnalisÃ©e">Comment Ã©crire une macro dÃ©rivÃ©e personnalisÃ©e</a></h3>
<!--
Letâ€™s create a crate named `hello_macro` that defines a trait named
`HelloMacro` with one associated function named `hello_macro`. Rather than
making our crate users implement the `HelloMacro` trait for each of their
types, weâ€™ll provide a procedural macro so users can annotate their type with
`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro`
function. The default implementation will print `Hello, Macro! My name is
TypeName!` where `TypeName` is the name of the type on which this trait has
been defined. In other words, weâ€™ll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.
-->
<p>CrÃ©ons une crate <code>hello_macro</code> qui dÃ©finit un trait qui s'appelle <code>HelloMacro</code>
avec une fonction associÃ©e <code>hello_macro</code>. PlutÃ´t que de contraindre les
utilisateurs de notre crate Ã  implÃ©menter le trait <code>HelloMacro</code> sur chacun de
leurs types, nous allons fournir une macro procÃ©durale qui permettra aux
utilisateurs de pouvoir annoter leur type avec <code>#[derive(HelloMacro)]</code> afin
d'obtenir une implÃ©mentation par dÃ©faut de la fonction <code>hello_macro</code>.
L'implÃ©mentation par dÃ©faut affichera <code>Hello, MacroÂ ! Mon nom est TypeNameÂ !</code>,
dans lequel <code>TypeName</code> est le nom du type sur lequel ce trait a Ã©tÃ© dÃ©fini.
Autrement dit, nous allons Ã©crire une crate qui permet Ã  un autre dÃ©veloppeur
d'Ã©crire du code comme l'encart 19-30 en utilisant notre crate.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
<span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span>
-->
<p><span class="caption">Encart 19-30Â : le code qu'un utilisateur de notre crate
pourra Ã©crire lorsqu'il utilisera notre macro procÃ©durale</span></p>
<!--
This code will print `Hello, Macro! My name is Pancakes!` when weâ€™re done. The
first step is to make a new library crate, like this:
-->
<p>Ce code va afficher <code>Hello, MacroÂ ! Mon nom est PancakesÂ !</code> lorsque vous en
aurez fini. La premiÃ¨re Ã©tape est de crÃ©er une nouvelle crate de bibliothÃ¨que,
comme ceciÂ :</p>
<!--
```console
$ cargo new hello_macro --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<!--
Next, weâ€™ll define the `HelloMacro` trait and its associated function:
-->
<p>Ensuite, nous allons dÃ©finir le trait <code>HelloMacro</code> et sa fonction associÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait HelloMacro {
    fn hello_macro();
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<!--
We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:
-->
<p>Nous avons maintenant un trait et sa fonction. A partir de lÃ , notre
utilisateur de la crate peut implÃ©menter le trait pour accomplir la
fonctionnalitÃ© souhaitÃ©e, comme ceciÂ :</p>
<!--
```rust,ignore
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, MacroÂ ! Mon nom est PancakesÂ !&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
However, they would need to write the implementation block for each type they
wanted to use with `hello_macro`; we want to spare them from having to do this
work.
-->
<p>Cependant, l'utilisateur doit Ã©crire le bloc d'implÃ©mentation pour chacun des
types qu'il souhaite utiliser avec <code>hello_macro</code>Â ; nous souhaitons leur
Ã©pargner de faire ce travail.</p>
<!--
Additionally, we canâ€™t yet provide the `hello_macro` function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesnâ€™t have reflection capabilities, so it canâ€™t look up the typeâ€™s
name at runtime. We need a macro to generate code at compile time.
-->
<p>De plus, nous ne pouvons pas encore fournir la fonction <code>hello_macro</code> avec
l'implÃ©mentation par dÃ©faut qui va afficher le nom du type du trait sur lequel
nous l'implÃ©mentonsÂ : Rust n'est pas rÃ©flexif, donc il ne peut pas connaÃ®tre le
nom du type Ã  l'exÃ©cution. Nous avons besoin d'une macro pour gÃ©nÃ©rer le code Ã 
la compilation.</p>
<!--
The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named `foo`, a custom derive procedural macro crate is
called `foo_derive`. Letâ€™s start a new crate called `hello_macro_derive` inside
our `hello_macro` project:
-->
<p>La prochaine Ã©tape est de dÃ©finir la macro procÃ©durale. A l'heure de l'Ã©criture
de ces lignes, les macros procÃ©durales au besoin d'Ãªtre placÃ©es dans leur
propre crate. Cette restriction pourra Ã©ventuellement Ãªtre levÃ©e. La convention
pour structurer les crates et les crates de macros est la suivanteÂ : pour
une crate <code>foo</code>, une crate de macro procÃ©durale personnalisÃ©e de dÃ©rivÃ©e doit
s'appeler <code>foo_derive</code>. CrÃ©ons une nouvelle crate <code>hello_macro_derive</code> au sein
de notre projet <code>hello_macro</code>Â :</p>
<!--
```console
$ cargo new hello_macro_derive --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<!--
Our two crates are tightly related, so we create the procedural macro crate
within the directory of our `hello_macro` crate. If we change the trait
definition in `hello_macro`, weâ€™ll have to change the implementation of the
procedural macro in `hello_macro_derive` as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
`hello_macro` crate use `hello_macro_derive` as a dependency and re-export the
procedural macro code. However, the way weâ€™ve structured the project makes it
possible for programmers to use `hello_macro` even if they donâ€™t want the
`derive` functionality.
-->
<p>Nos deux crates sont Ã©troitement liÃ©es, donc nous crÃ©ons la crate de macro
procÃ©durale Ã  l'intÃ©rieur du dossier de notre crate <code>hello_macro</code>. Si nous
changeons la dÃ©finition du trait dans <code>hello_macro</code>, nous aurons aussi Ã 
changer l'implÃ©mentation de la macro procÃ©durale dans <code>hello_macro_derive</code>. Les
deux crates vont devoir Ãªtre publiÃ©es sÃ©parÃ©ment, et les dÃ©veloppeurs qui vont
utiliser ces crates vont avoir besoin d'ajouter les deux dÃ©pendances et les
importer dans la portÃ©e. Nous pouvons plutÃ´t faire en sorte que la crate
<code>hello_macro</code> utilise <code>hello_macro_derive</code> comme dÃ©pendance et rÃ©-exporter le
code de la macro procÃ©durale. Cependant, la faÃ§on dont nous avons structurÃ© le
projet donne la possibilitÃ© aux dÃ©veloppeurs d'utiliser <code>hello_macro</code> mÃªme s'ils
ne veulent pas la fonctionnalitÃ© <code>derive</code>.</p>
<!--
We need to declare the `hello_macro_derive` crate as a procedural macro crate.
Weâ€™ll also need functionality from the `syn` and `quote` crates, as youâ€™ll see
in a moment, so we need to add them as dependencies. Add the following to the
*Cargo.toml* file for `hello_macro_derive`:
-->
<p>Nous devons dÃ©clarer la crate <code>hello_macro_derive</code> comme Ã©tant une crate de
macro procÃ©durale. Nous allons aussi avoir besoin des fonctionnalitÃ©s des
crates <code>syn</code> et <code>quote</code>, comme vous allez de constater bientÃ´t, donc nous
allons les ajouter comme dÃ©pendances. Ajoutez ceci dans le fichier <em>Cargo.toml</em>
de <code>hello_macro_derive</code>Â :</p>
<!--
<span class="filename">Filename: hello_macro_derive/Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : hello_macro_derive/Cargo.toml</span></p>
<!--
```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```
-->
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<!--
To start defining the procedural macro, place the code in Listing 19-31 into
your *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code
wonâ€™t compile until we add a definition for the `impl_hello_macro` function.
-->
<p>Pour commencer Ã  dÃ©finir la macro procÃ©durale, placez le code de l'encart 19-31
dans votre fichier <em>src/lib.rs</em> de la crate <code>hello_macro_derive</code>. Notez que ce
code ne se compilera pas tant que nous n'ajouterons pas une dÃ©finition pour la
fonction <code>impl_hello_macro</code>.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construit une reprÃ©sentation du code Rust en arborescence
    // syntaxique que nous pouvons manipuler
    let ast = syn::parse(input).unwrap();

    // Construit l'implÃ©mentation du trait
    impl_hello_macro(&amp;ast)
}
</code></pre>
<!--
<span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span>
-->
<p><span class="caption">Encart 19-31Â : du code que la plupart des macros
procÃ©durales auront besoin pour travailler avec du code Rust</span></p>
<!--
Notice that weâ€™ve split the code into the `hello_macro_derive` function, which
is responsible for parsing the `TokenStream`, and the `impl_hello_macro`
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(`hello_macro_derive` in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (`impl_hello_macro` in this case) will be different
depending on your procedural macroâ€™s purpose.
-->
<p>Remarquez que nous avons divisÃ© le code dans la fonction <code>hello_macro_derive</code>,
qui est responsable de parcourir le <code>TokenStream</code>, et la fonction
<code>impl_hello_macro</code>, qui est responsable de transformer l'arborescence
syntaxiqueÂ : cela facilite l'Ã©criture de la macro procÃ©durale. Le code dans la
fonction englobante (qui est <code>hello_macro_derive</code> dans notre cas) sera le mÃªme
pour presque toutes les crates de macro procÃ©durales que vous allez voir ou
crÃ©er. Le code que vous renseignez dans le corps de la fonction (qui est
<code>impl_hello_macro</code> dans notre cas) diffÃ¨rera en fonction de ce que fait votre
macro procÃ©durale.</p>
<!--
Weâ€™ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The
`proc_macro` crate comes with Rust, so we didnâ€™t need to add that to the
dependencies in *Cargo.toml*. The `proc_macro` crate is the compilerâ€™s API that
allows us to read and manipulate Rust code from our code.
-->
<p>Nous avons ajoutÃ© trois nouvelles cratesÂ : <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, et <a href="https://crates.io/crates/quote"><code>quote</code></a>.
La crate <code>proc_macro</code> est fournie par Rust, donc nous n'avons pas besoin de
l'ajouter aux dÃ©pendances dans <em>Cargo.toml</em>. La crate <code>proc_macro</code> fournit une
API du compilateur qui nous permet de lire et manipuler le code Rust Ã  partir de
notre code.</p>
<!--
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
-->
<!--
The `syn` crate parses Rust code from a string into a data structure that we
can perform operations on. The `quote` crate turns `syn` data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.
-->
<p>La crate <code>syn</code> transforme le code Rust d'une chaÃ®ne de caractÃ¨res en une
structure de donnÃ©es sur laquelle nous pouvons procÃ©der Ã  des opÃ©rations. La
crate <code>quote</code> re-transforme les structures de donnÃ©es de <code>syn</code> en code Rust.
Ces crates facilite le parcours de toute sorte de code Rust que nous aurions
besoin de gÃ©rerÂ : l'Ã©criture d'un interprÃ©teur complet de code Rust n'a jamais
Ã©tÃ© aussi facile.</p>
<!--
The `hello_macro_derive` function will be called when a user of our library
specifies `#[derive(HelloMacro)]` on a type. This is possible because weâ€™ve
annotated the `hello_macro_derive` function here with `proc_macro_derive` and
specified the name, `HelloMacro`, which matches our trait name; this is the
convention most procedural macros follow.
-->
<p>La fonction <code>hello_macro_derive</code> va Ãªtre appelÃ©e lorsqu'un utilisateur de notre
bibliothÃ¨que utilisera <code>#[derive(HelloMacro)]</code> sur un type. Cela sera possible
car nous avons annotÃ© notre fonction <code>hello_macro_derive</code> avec
<code>proc_macro_derive</code> et nous avons renseignÃ© le nom, <code>HelloMacro</code>, qui
correspond au nom de notre traitÂ ; c'est la convention que la plupart des
macros procÃ©durales doivent suivre.</p>
<!--
The `hello_macro_derive` function first converts the `input` from a
`TokenStream` to a data structure that we can then interpret and perform
operations on. This is where `syn` comes into play. The `parse` function in
`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput`
struct we get from parsing the `struct Pancakes;` string:
-->
<p>La fonction <code>hello_macro_derive</code> commence par convertir le <code>input</code> qui est un
<code>TokenStream</code> en une structure de donnÃ©es que nous pouvons ensuite interprÃ©ter
et y faire des opÃ©rations dessus. C'est lÃ  que <code>syn</code> rentre en jeu. La fonction
<code>parse</code> de <code>syn</code> prend un <code>TokenStream</code> et retourne une structure <code>DeriveInput</code>
qui reprÃ©sente le code Rust. L'encart 19-32 montre les parties intÃ©ressantes de
la structure <code>DeriveInput</code> que nous obtenons en convertissant la chaÃ®ne de
caractÃ¨res <code>struct Pancakes;</code>Â :</p>
<!--
```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```
-->
<pre><code class="language-rust ignore">DeriveInput {
    // -- partie masquÃ©e ici --

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<!--
<span class="caption">Listing 19-32: The `DeriveInput` instance we get when
parsing the code that has the macroâ€™s attribute in Listing 19-30</span>
-->
<p><span class="caption">Encart 19-32Â : l'instance de <code>DeriveInput</code> que nous
obtenons lorsque nous convertissons le code qui l'attribut de la macro dans
l'encart 19-30</span></p>
<!--
The fields of this struct show that the Rust code weâ€™ve parsed is a unit struct
with the `ident` (identifier, meaning the name) of `Pancakes`. There are more
fields on this struct for describing all sorts of Rust code; check the [`syn`
documentation for `DeriveInput`][syn-docs] for more information.
-->
<p>Les champs de cette structure montrent que ce code Rust que nous avons converti
est une structure unitaire avec l'<code>ident</code> (raccourci de <code>identifier</code>, qui
dÃ©signe le nom) <code>Pancakes</code>. Il y a d'autres champs sur cette structure
dÃ©crivant toutes sortes de codes RustÂ ; regardez la
<a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">documentation de <code>syn</code> pour <code>DeriveInput</code></a> pour en savoir plus.</p>
<!--
[syn-docs]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
-->
<!--
Soon weâ€™ll define the `impl_hello_macro` function, which is where weâ€™ll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a `TokenStream`. The returned `TokenStream` is
added to the code that our crate users write, so when they compile their crate,
theyâ€™ll get the extra functionality that we provide in the modified
`TokenStream`.
-->
<p>BientÃ´t, nous dÃ©finirons la fonction <code>impl_hello_macro</code>, qui nous permettra de
construire de nous code Rust que nous souhaitons injecter. Mais avant de faire
cela, remarquez que la sortie de notre macro derive est aussi un <code>TokenStream</code>.
Le <code>TokenStream</code> retournÃ© est ajoutÃ© au code que les utilisateurs de notre
crate ont Ã©crit, donc lorsqu'ils compilent leur crate, ils rÃ©cupÃ©reront la
fonctionnalitÃ© additionnelle que nous injectons dans le <code>TokenStream</code> modifiÃ©.</p>
<!--
You might have noticed that weâ€™re calling `unwrap` to cause the
`hello_macro_derive` function to panic if the call to the `syn::parse` function
fails here. Itâ€™s necessary for our procedural macro to panic on errors because
`proc_macro_derive` functions must return `TokenStream` rather than `Result` to
conform to the procedural macro API. Weâ€™ve simplified this example by using
`unwrap`; in production code, you should provide more specific error messages
about what went wrong by using `panic!` or `expect`.
-->
<p>Vous avez peut-Ãªtre remarquÃ© que nous faisons appel Ã  <code>unwrap</code> pour faire
paniquer la fonction <code>hello_macro_derive</code> si l'appel Ã  la fonction <code>syn::parse</code>
que nous faisons Ã©choue. Il est nÃ©cessaire de faire paniquer notre macro
procÃ©durale si elle rencontre des erreurs car les fonctions <code>proc_macro_derive</code>
doivent retourner un <code>TokenStream</code> plutÃ´t qu'un <code>Result</code> pour se conformer Ã 
l'API de la macro procÃ©durale. Nous avons simplifiÃ© cet exemple en utilisant
<code>unwrap</code>Â ; dans du code en production, vous devriez renseigner des messages
d'erreur plus prÃ©cis sur ce qui s'est mal passÃ© en utilisant <code>panic!</code> ou
<code>expect</code>.</p>
<!--
Now that we have the code to turn the annotated Rust code from a `TokenStream`
into a `DeriveInput` instance, letâ€™s generate the code that implements the
`HelloMacro` trait on the annotated type, as shown in Listing 19-33.
-->
<p>Maintenant que nous avons le code pour transformer le code Rust annotÃ© d'un
<code>TokenStream</code> en une instance de <code>DeriveInput</code>, crÃ©ons le code qui implÃ©mente le
trait <code>HelloMacro</code> sur le type annotÃ©, comme l'encart 19-33.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore
# extern crate proc_macro;
# 
# use proc_macro::TokenStream;
# use quote::quote;
# use syn;
# 
# #[proc_macro_derive(HelloMacro)]
# pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
#     // Construct a representation of Rust code as a syntax tree
#     // that we can manipulate
#     let ast = syn::parse(input).unwrap();
# 
#     // Build the trait implementation
#     impl_hello_macro(&ast)
# }
# 
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construit une reprÃ©sentation du code Rust en arborescence
</span><span class="boring">    // syntaxique que nous pouvons manipuler
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Construit l'implÃ©mentation du trait
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let nom = &amp;ast.ident;
    let generation = quote! {
        impl HelloMacro for #nom {
            fn hello_macro() {
                println!(&quot;Hello, MacroÂ ! Mon nom estÂ {}&quot;, stringify!(#nom));
            }
        }
    };
    generation.into()
}
</code></pre>
<!--
<span class="caption">Listing 19-33: Implementing the `HelloMacro` trait using
the parsed Rust code</span>
-->
<p><span class="caption">Encart 19-33Â : implÃ©mentation du trait <code>HelloMacro</code> en
utilisant le code Rust interprÃ©tÃ©</span></p>
<!--
We get an `Ident` struct instance containing the name (identifier) of the
annotated type using `ast.ident`. The struct in Listing 19-32 shows that when
we run the `impl_hello_macro` function on the code in Listing 19-30, the
`ident` we get will have the `ident` field with a value of `"Pancakes"`. Thus,
the `name` variable in Listing 19-33 will contain an `Ident` struct instance
that, when printed, will be the string `"Pancakes"`, the name of the struct in
Listing 19-30.
-->
<p>Nous obtenons une instance de structure <code>Ident</code> qui contient le nom
(<code>identifier</code>) du type annotÃ© en utilisant <code>ast.ident</code>. La structure de l'encart
19-32 montre ceci lorsque nous exÃ©cutons la fonction <code>impl_hello_macro</code> sur le
code de l'encart 19-30, le <code>ident</code> que nous obtenons aura le champ <code>ident</code> avec
la valeur <code>&quot;Pancakes&quot;</code>. Ainsi, la variable <code>nom</code> de l'encart 19-33 contiendra
une instance de la structure <code>Ident</code> qui, une fois affichÃ©e, sera la chaÃ®ne de
caractÃ¨res <code>&quot;Pancakes&quot;</code>, le nom de la structure de l'encart 19-30.</p>
<!--
The `quote!` macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the `quote!`
macroâ€™s execution, so we need to convert it to a `TokenStream`. We do this by
calling the `into` method, which consumes this intermediate representation and
returns a value of the required `TokenStream` type.
-->
<p>La macro <code>quote!</code> nous permet de dÃ©finir le code Rust que nous souhaitons
retourner. Le compilateur attend quelque chose de diffÃ©rent en rÃ©sultat que le
ce qui correspond Ã  l'exÃ©cution de <code>quote!</code>, donc nous devons le convertir en
<code>TokenStream</code>. Nous faisons ceci en faisant appel Ã  la mÃ©thode <code>into</code>, qui se
base sur cette reprÃ©sentation intermÃ©diaire et retourne une valeur attendue,
comme ici du type <code>TokenStream</code>.</p>
<!--
The `quote!` macro also provides some very cool templating mechanics: we can
enter `#name`, and `quote!` will replace it with the value in the variable
`name`. You can even do some repetition similar to the way regular macros work.
Check out [the `quote` crateâ€™s docs][quote-docs] for a thorough introduction.
-->
<p>La macro <code>quote!</code> fournit aussi quelques mÃ©caniques de gabarit intÃ©ressantesÂ :
nous pouvons entrer <code>#nom</code>, et <code>quote!</code> va le remplacer avec la valeur dans la
variable <code>nom</code>. Vous pouvez mÃªme procÃ©der Ã  quelques rÃ©pÃ©tions de faÃ§on
similaire au fonctionnement des macros classiques. Regardez dans
<a href="https://docs.rs/quote">la documentation de <code>quote</code></a> pour une prÃ©sentation plus dÃ©taillÃ©e.</p>
<!--
[quote-docs]: https://docs.rs/quote
-->
<!--
We want our procedural macro to generate an implementation of our `HelloMacro`
trait for the type the user annotated, which we can get by using `#name`. The
trait implementation has one function, `hello_macro`, whose body contains the
functionality we want to provide: printing `Hello, Macro! My name is` and then
the name of the annotated type.
-->
<p>Nous souhaitons que notre macro procÃ©durale gÃ©nÃ¨re une implÃ©mentation de notre
trait <code>HelloMacro</code> pour le type que l'utilisateur a annotÃ©, que nous pouvons
obtenir en utilisant <code>#nom</code>. L'implÃ©mentation du trait utilise une fonction,
<code>hello_macro</code>, dont le corps contient la fonctionnalitÃ© que nous souhaitons
fournirÂ : l'affichage de <code>Hello, MacroÂ ! Mon nom est</code> suivi par le nom du type
annotÃ©.</p>
<!--
The `stringify!` macro used here is built into Rust. It takes a Rust
expression, such as `1 + 2`, and at compile time turns the expression into a
string literal, such as `"1 + 2"`. This is different than `format!` or
`println!`, macros which evaluate the expression and then turn the result into
a `String`. There is a possibility that the `#name` input might be an
expression to print literally, so we use `stringify!`. Using `stringify!` also
saves an allocation by converting `#name` to a string literal at compile time.
-->
<p>La macro <code>stringify!</code> utilisÃ©e ici est Ã©crite en Rust. Elle prend en argument
une expression Rust, comme <code>1 + 2</code>, et Ã  la compilation transforme l'expression
en une chaÃ®ne de caractÃ¨res littÃ©rale, comme <code>&quot;1 + 2&quot;</code>. Cela est diffÃ©rent de
<code>format!</code> ou de <code>println!</code>, des macros qui Ã©valuent l'expression et retourne
ensuite le rÃ©sultat dans une <code>String</code>. Il est possible que l'entrÃ©e <code>#nom</code> soit
une expression Ã  Ã©crire littÃ©ralement, donc nous utilisons <code>stringify!</code>.
L'utilisation de <code>stringify!</code> Ã©vite aussi une allocation en convertissant <code>#nom</code>
en une chaine de caractÃ¨res littÃ©rale Ã  la compilation.</p>
<!--
At this point, `cargo build` should complete successfully in both `hello_macro`
and `hello_macro_derive`. Letâ€™s hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your *projects* directory using `cargo new pancakes`. We need to add
`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`
crateâ€™s *Cargo.toml*. If youâ€™re publishing your versions of `hello_macro` and
`hello_macro_derive` to [crates.io](https://crates.io/), they would be regular
dependencies; if not, you can specify them as `path` dependencies as follows:
-->
<p>Maintenant, <code>cargo build</code> devrait fonctionner correctement pour <code>hello_macro</code> et
<code>hello_macro_derive</code>. Relions maintenant ces crates au code de l'encart 19-30
pour voir les macros procÃ©durales Ã  l'oeuvreÂ ! CrÃ©ez un nouveau projet binaire
dans votre dossier <em>projects</em> en utilisant <code>cargo new pancakes</code>. Nous avons
besoin d'ajouter <code>hello_macro</code> et <code>hello_macro_derive</code> comme dÃ©pendances dans le
<em>Cargo.toml</em> de la crate <code>pancakes</code>. Si vous publiez vos versions de
<code>hello_macro</code> et de <code>hello_macro_derive</code> sur <a href="https://crates.io">crates.io</a>,
elles sont des dÃ©pendances classiquesÂ ; sinon, vous pouvez les renseigner comme
dÃ©pendance locale avec <code>path</code> comme ceciÂ :</p>
<!--
```toml
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```
-->
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!--
Put the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it
should print `Hello, Macro! My name is Pancakes!` The implementation of the
`HelloMacro` trait from the procedural macro was included without the
`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the
trait implementation.
-->
<p>Renseignez le code l'encart 19-30 dans <em>src/main.rs</em>, puis lancez <code>cargo run</code>Â :
cela devrait afficher <code>Hello, MacroÂ ! Mon nom est PancakesÂ !</code>. L'implÃ©mentation
du trait <code>HelloMacro</code> Ã  l'aide de la macro procÃ©durale est injectÃ©e sans que la
crate <code>pancakes</code> n'ai besoin de le faire manuellementÂ ; le
<code>#[derive(HelloMacro)]</code> a rajoutÃ© automatiquement l'implÃ©mentation du trait.</p>
<!--
Next, letâ€™s explore how the other kinds of procedural macros differ from custom
derive macros.
-->
<p>Maintenant, dÃ©couvrons comment les autres types de macros procÃ©durales se
distinguent des macros derive personnalisÃ©es.</p>
<!--
### Attribute-like macros
-->
<h3><a class="header" href="#les-macros-qui-ressemblent-Ã -des-attributs" id="les-macros-qui-ressemblent-Ã -des-attributs">Les macros qui ressemblent Ã  des attributs</a></h3>
<!--
Attribute-like macros are similar to custom derive macros, but instead of
generating code for the `derive` attribute, they allow you to create new
attributes. Theyâ€™re also more flexible: `derive` only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Hereâ€™s an example of using an attribute-like macro: say you have an attribute
named `route` that annotates functions when using a web application framework:
-->
<p>Les macros qui ressemblent Ã  des attributs ressemblent aux macros derive
personnalisÃ©es, mais au lieu de gÃ©nÃ©rer du code pour l'attribut <code>derive</code>, elles
vous permettent de crÃ©er des nouveaux attributs. Elles sont aussi plus
flexiblesÂ : <code>derive</code> fonctionne uniquement pour les structures et les
Ã©numÃ©rationsÂ ; les attributs peuvent Ãªtre aussi appliquÃ©s aux autres Ã©lÃ©ments,
comme les fonctions. Voici un exemple d'utilisation d'une macro qui ressemble Ã 
un attributÂ : imaginons que vous avez un attribut <code>chemin</code> qui est une
annotation pour des fonctions lorsque vous utilisez un environnement de
dÃ©veloppement d'application webÂ :</p>
<!--
```rust,ignore
#[route(GET, "/")]
fn index() {
```
-->
<pre><code class="language-rust ignore">#[chemin(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<!--
This `#[route]` attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:
-->
<p>Cet attribut <code>#[chemin]</code> sera dÃ©fini par l'environnement de dÃ©veloppement comme
Ã©tant une macro procÃ©durale. La signature de la fonction de dÃ©finition de la
macro ressemblera Ã  ceciÂ :</p>
<!--
```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn chemin(attribut: TokenStream, element: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
Here, we have two parameters of type `TokenStream`. The first is for the
contents of the attribute: the `GET, "/"` part. The second is the body of the
item the attribute is attached to: in this case, `fn index() {}` and the rest
of the functionâ€™s body.
-->
<p>Maintenant, nous avons deux paramÃ¨tres de type <code>TokenStream</code>. Le premier
correspond au contenu de l'attributÂ : la partie <code>GET, &quot;/&quot;</code>. Le second est le
corps de l'Ã©lÃ©ment sur lequel cet attribut sera appliquÃ©Â : dans notre cas,
<code>fn index() {}</code> et le reste du corps de la fonction.</p>
<!--
Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the `proc-macro` crate type and implement a
function that generates the code you want!
-->
<p>Mis Ã  part cela, les macros qui ressemblent Ã  des attributs fonctionnent de la
mÃªme maniÃ¨re que les macros derive personnalisÃ©esÂ : vous gÃ©nÃ©rez une crate avec
le type de la crate <code>proc-macro</code> et implÃ©mentez une fonction qui gÃ©nÃ¨rera le
code que vous souhaitezÂ !</p>
<!--
### Function-like macros
-->
<h3><a class="header" href="#les-macros-qui-ressemblent-Ã -des-fonctions" id="les-macros-qui-ressemblent-Ã -des-fonctions">Les macros qui ressemblent Ã  des fonctions</a></h3>
<!--
Function-like macros define macros that look like function calls. Similarly to
`macro_rules!` macros, theyâ€™re more flexible than functions; for example, they
can take an unknown number of arguments. However, `macro_rules!` macros can be
defined only using the match-like syntax we discussed in the section
[â€œDeclarative Macros with `macro_rules!` for General Metaprogrammingâ€][decl]
earlier. Function-like macros take a `TokenStream` parameter and their
definition manipulates that `TokenStream` using Rust code as the other two
types of procedural macros do. An example of a function-like macro is an `sql!`
macro that might be called like so:
-->
<p>Les macros qui ressemblent Ã  des fonctions dÃ©finissent des macros qui
ressemblent Ã  des appels de fonction. De la mÃªme maniÃ¨re que les macros
<code>macro_rules!</code>, elles sont plus flexibles que les fonctionsÂ ; par exemple, elles
peuvent prendre une quantitÃ© non finie d'arguments. Cependant, les macros
<code>macro_rules!</code> peuvent Ãªtre dÃ©finies uniquement en utilisant la syntaxe qui
ressemble Ã  <code>match</code> que nous avons vu dans <a href="#les-macros-d%C3%A9claratives-avec-macro_rules-pour-la-m%C3%A9taprogrammation-g%C3%A9n%C3%A9rale">une section prÃ©cÃ©dente</a>. Les
macros qui ressemblent Ã  des fonctions prennent en paramÃ¨tre un <code>TokenStream</code> et
leurs dÃ©finitions manipulent ce <code>TokenStream</code> en utilisant du code Rust comme le
font les deux autres types de macros procÃ©durales. Voici un exemple d'une macro
qui ressemble Ã  une fonction qui est une macro <code>sql!</code> qui devrait Ãªtre utilisÃ©e
comme ceciÂ :</p>
<!--
[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming
-->
<!--
```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```
-->
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM publications WHERE id=1);
</code></pre>
<!--
This macro would parse the SQL statement inside it and check that itâ€™s
syntactically correct, which is much more complex processing than a
`macro_rules!` macro can do. The `sql!` macro would be defined like this:
-->
<p>Cette macro devrait interprÃ©ter l'instruction SQL qu'on lui envoie et vÃ©rifier
si elle est syntaxiquement correcte, ce qui est un procÃ©dÃ© bien plus complexe
que ce qu'une macro <code>macro_rules!</code> peut faire. La macro <code>sql!</code> sera dÃ©finie
comme ceciÂ :</p>
<!--
```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
This definition is similar to the custom derive macroâ€™s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.
-->
<p>Cette dÃ©finition ressemble Ã  la signature de la macro derive personnalisÃ©eÂ :
nous rÃ©cupÃ©rons les Ã©lÃ©ments entre parenthÃ¨ses et retournons le code que nous
souhaitons gÃ©nÃ©rer.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©" id="rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
Whew! Now you have some Rust features in your toolbox that you wonâ€™t use often,
but youâ€™ll know theyâ€™re available in very particular circumstances. Weâ€™ve
introduced several complex topics so that when you encounter them in error
message suggestions or in other peoplesâ€™ code, youâ€™ll be able to recognize
these concepts and syntax. Use this chapter as a reference to guide you to
solutions.
-->
<p>OuahÂ ! Maintenant vous avez quelques fonctionnalitÃ©s de Rust supplÃ©mentaires
dans votre boite Ã  outils que vous utiliserez probablement rarement, mais vous
savez maintenant qu'elles vous aideront dans des situations trÃ¨s particuliÃ¨res.
Nous avons abordÃ© plusieurs sujets complexes afin que vous puissiez les
reconnaÃ®tre ainsi que leur syntaxe lorsque vous les rencontrerez dans des
messages de suggestions dans des erreurs ou dans du code de quelqu'un d'autre.
Utilisez ce chapitre comme rÃ©fÃ©rence pour vous guider vers ces solutions.</p>
<!--
Next, weâ€™ll put everything weâ€™ve discussed throughout the book into practice
and do one more project!
-->
<p>Au chapitre suivant, nous allons mettre en pratique tout ce que nous avons
appris dans ce livre en l'appliquant Ã  un nouveau projetÂ !</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch20-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch20-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
