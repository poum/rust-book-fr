<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Le Rust non sÃ©curisÃ© (unsafe) - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html" class="active"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/210">Pull Request</a>.</p>
</blockquote>
<!--
## Unsafe Rust
-->
<h2 id="le-rust-non-sÃ©curisÃ©-unsafe"><a class="header" href="#le-rust-non-sÃ©curisÃ©-unsafe">Le Rust non sÃ©curisÃ© (<code>unsafe</code>)</a></h2>
<!--
All the code weâ€™ve discussed so far has had Rustâ€™s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesnâ€™t enforce these memory safety guarantees: itâ€™s called *unsafe Rust*
and works just like regular Rust, but gives us extra superpowers.
-->
<p>Tout le code Rust dont nous avons abordÃ© jusqu'Ã  prÃ©sent a bÃ©nÃ©ficiÃ© des
garanties de sÃ©curitÃ© de la mÃ©moire, vÃ©rifiÃ©es Ã  la compilation. Cependant, Rust
a un second langage cachÃ© en son sein qui n'appliquent pas ces vÃ©rifications
pour la sÃ©curitÃ© de la mÃ©moireÂ : il s'appelle le <em>Rust non sÃ©curisÃ©</em> et
fonctionne comme le Rust habituel, mais fournit quelques super-pouvoirs
supplÃ©mentaires.</p>
<!--
Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
itâ€™s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, itâ€™s not! In these cases, you can use unsafe code to tell the compiler,
â€œTrust me, I know what Iâ€™m doing.â€ The downside is that you use it at your own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.
-->
<p>Le Rust non sÃ©curisÃ© existe car, par nature, l'analyse statique est conservatif.
Lorsque le compilateur essaye de dÃ©terminer si le code respecte ou non les
garanties, il vaut mieux rejeter quelques programmes valides plutÃ´t que
d'accepter quelques programmes invalides. Bien que le code puisse Ãªtre correct,
dÃ¨s que Rust n'est pas capable de le comprendre, il ne l'est plusÂ ! Dans ce cas,
vous pouvez utiliser du code non sÃ©curisÃ© pour dire au compilateur â€œfais-moi
confiance, je sais ce que je faitâ€. La contrepartie pour cela est que vous
l'utilisez Ã  vos risques et pÃ©rilsÂ : si vous Ã©crivez du code non sÃ©curisÃ© de
maniÃ¨re incorrecte, des problÃ¨mes liÃ©s Ã  la sÃ©curitÃ© de la mÃ©moire peuvent se
produire, comme le dÃ©rÃ©fÃ©rencement d'un pointeur vide par exemple.</p>
<!--
Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didnâ€™t let you do unsafe operations, you
couldnâ€™t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Letâ€™s explore what we can do with unsafe
Rust and how to do it.
-->
<p>Une autre raison pour laquelle Rust embarque son alter-ego non sÃ©curisÃ© est que
le matÃ©riel des ordinateurs sur lequel il repose n'est pas sÃ©curisÃ© par essence.
Si Rust ne vous laisse pas procÃ©der Ã  des opÃ©rations non sÃ©curisÃ©es, vous ne
pourrez pas faire certaines choses. Rust doit pouvoir vous permettre de
dÃ©velopper du code bas-niveau, comme pouvoir interagir directement avec le
systÃ¨me d'exploitation ou mÃªme Ã©crire votre propre systÃ¨me d'exploitation.
Pouvoir travailler avec des systÃ¨mes bas-niveau est un des objectifs du langage.
Voyons ce que nous pouvons faire avec le Rust non sÃ©curisÃ© et comment le faire.</p>
<!--
### Unsafe Superpowers
-->
<h3 id="les-super-pouvoirs-du-code-non-sÃ©curisÃ©"><a class="header" href="#les-super-pouvoirs-du-code-non-sÃ©curisÃ©">Les super-pouvoirs du code non sÃ©curisÃ©</a></h3>
<!--
To switch to unsafe Rust, use the `unsafe` keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust, called
*unsafe superpowers*, that you canâ€™t in safe Rust. Those superpowers include
the ability to:
-->
<p>Pour pouvoir utiliser le Rust non sÃ©curisÃ©, il faut utiliser le mot-clÃ© <code>unsafe</code>
et ensuite crÃ©er un nouveau bloc qui contient le code non sÃ©curisÃ©. Vous pouvez
faire cinq actions en Rust non sÃ©curisÃ©, qui s'appellent <em>les super-pouvoirs du
non sÃ©curisÃ©</em>, que vous ne pouvez pas faire en Rust sÃ©curisÃ©. Ces super-pouvoirs
permettent deÂ :</p>
<!--
* Dereference a raw pointer
* Call an unsafe function or method
* Access or modify a mutable static variable
* Implement an unsafe trait
* Access fields of `union`s
-->
<ul>
<li>DÃ©rÃ©fÃ©rencer un pointeur brut</li>
<li>Faire appel Ã  une fonction ou une mÃ©thode non sÃ©curisÃ©e</li>
<li>Lire ou modifier une variable statique mutable</li>
<li>ImplÃ©menter un trait non sÃ©curisÃ©</li>
<li>AccÃ©der aux champs des <code>union</code></li>
</ul>
<!--
Itâ€™s important to understand that `unsafe` doesnâ€™t turn off the borrow checker
or disable any other of Rustâ€™s safety checks: if you use a reference in unsafe
code, it will still be checked. The `unsafe` keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. Youâ€™ll still get some degree of safety inside of an unsafe block.
-->
<p>Il est important de comprendre que <code>unsafe</code> ne dÃ©sactive pas le vÃ©rificateur
d'emprunt et ne dÃ©sactive pas les autres vÃ©rifications de sÃ©curitÃ© de RustÂ : si
vous utilisez une rÃ©fÃ©rence dans du code non sÃ©curisÃ©, elle sera toujours
vÃ©rifiÃ©e. Le mot-clÃ© <code>unsafe</code> vous donne seulement accÃ¨s Ã  ces cinq
fonctionnalitÃ©s qui ne sont alors pas vÃ©rifiÃ©es par le compilateur pour veiller
Ã  la sÃ©curitÃ© de la mÃ©moire. Vous conservez un certain niveau de sÃ©curitÃ© Ã 
l'intÃ©rieur d'un bloc <code>unsafe</code>.</p>
<!--
In addition, `unsafe` does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, youâ€™ll ensure the code inside an `unsafe` block will
access memory in a valid way.
-->
<p>De plus, <code>unsafe</code> ne signifie pas que le code Ã  l'intÃ©rieur du bloc est
obligatoirement dangereux ou qu'il va forcÃ©ment avoir des problÃ¨mes de sÃ©curitÃ©
mÃ©moireÂ : le but Ã©tant qu'en tant que dÃ©veloppeur, vous vous assurez que le code
Ã  l'intÃ©rieur d'un bloc <code>unsafe</code> va accÃ©der correctement Ã  la mÃ©moire.</p>
<!--
People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with `unsafe` youâ€™ll know that
any errors related to memory safety must be within an `unsafe` block. Keep
`unsafe` blocks small; youâ€™ll be thankful later when you investigate memory
bugs.
-->
<p>Personne n'est parfait, les erreurs arrivent, et en nÃ©cessitant que ces cinq
opÃ©rations non sÃ©curisÃ©s se trouvent dans des blocs marquÃ©s d'un <code>unsafe</code>, vous
saurez que des erreurs liÃ©es Ã  la sÃ©curitÃ© de la mÃ©moire se trouveront dans un
bloc <code>unsafe</code>. Essayez de minimiser la taille des blocs <code>unsafe</code>Â ; vous ne le
regretterez pas lorsque vous diagnostiquerez des bogues de mÃ©moire.</p>
<!--
To isolate unsafe code as much as possible, itâ€™s best to enclose unsafe code
within a safe abstraction and provide a safe API, which weâ€™ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`
from leaking out into all the places that you or your users might want to use
the functionality implemented with `unsafe` code, because using a safe
abstraction is safe.
-->
<p>Pour isoler autant que possible le code non sÃ©curisÃ©, il vaut mieux intÃ©grer du
code non sÃ©curisÃ© dans une abstraction et fournir ainsi une API sÃ©curisÃ©e, ce
que nous verrons plus tard dans ce chapitre lorsque nous examinerons les
fonctions et mÃ©thodes non sÃ©curisÃ©es. Certaines parties de la bibliothÃ¨que
standard sont implÃ©mentÃ©s comme Ã©tant des abstractions sÃ©curisÃ©es et basÃ©es sur
du code non sÃ©curisÃ© qui a Ã©tÃ© auditÃ©. Envelopper du code non sÃ©curisÃ© dans une
abstraction sÃ©curisÃ©e Ã©vite l'utilisation de <code>unsafe</code> de se propager dans des
endroits oÃ¹ vous ou vos utilisateurs souhaiteraient Ã©viter d'utiliser les
fonctionnalitÃ©s du code <code>unsafe</code>, car utiliser une abstraction sÃ©curisÃ©e doit
Ãªtre sÃ»re.</p>
<!--
Letâ€™s look at each of the five unsafe superpowers in turn. Weâ€™ll also look at
some abstractions that provide a safe interface to unsafe code.
-->
<p>Analysons chacun Ã  leur tour les cinq super-pouvoirs. Nous allons aussi
dÃ©couvrir quelques abstractions qui fournissent une interface sÃ©curisÃ©e pour
faire fonctionner du code non sÃ©curisÃ©.</p>
<!--
### Dereferencing a Raw Pointer
-->
<h3 id="dÃ©rÃ©fÃ©rencer-un-pointeur-brut"><a class="header" href="#dÃ©rÃ©fÃ©rencer-un-pointeur-brut">DÃ©rÃ©fÃ©rencer un pointeur brut</a></h3>
<!--
In Chapter 4, in the [â€œDangling Referencesâ€][dangling-references]<!-- ignore
-- > section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called *raw pointers* that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as `*const T` and `*mut T`, respectively. The asterisk isnâ€™t the
dereference operator; itâ€™s part of the type name. In the context of raw
pointers, *immutable* means that the pointer canâ€™t be directly assigned to
after being dereferenced.
-->
<p>Au chapitre 4, dans la section
<a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-pendouillantes">â€œLes rÃ©fÃ©rences pendouillantesâ€</a><!-- ignore -->, nous
avions mentionnÃ© que le compilateur s'assure que les rÃ©fÃ©rences sont toujours
valides. Le Rust non sÃ©curisÃ© a deux nouveaux types qui s'appellent les
<em>pointeurs brut</em> qui ressemblent aux rÃ©fÃ©rences. Comme les rÃ©fÃ©rences, les
pointeurs bruts peuvent Ãªtre immuables ou mutables et s'Ã©crivent respectivement
<code>*const T</code> et <code>*mut T</code>. L'astÃ©risque n'est pas l'opÃ©rateur de dÃ©rÃ©fÃ©rencementÂ ;
il fait partie du nom du type. Dans un contexte de pointeur brut, <em>immuable</em>
signifie que le pointeur ne peut pas Ãªtre affectÃ© directement aprÃ¨s avoir Ã©tÃ©
dÃ©rÃ©fÃ©rencÃ©.</p>
<!--
Different from references and smart pointers, raw pointers:
-->
<p>Par rapport aux rÃ©fÃ©rences et les pointeurs intelligents, les pointeurs
bruts peuventÂ :</p>
<!--
* Are allowed to ignore the borrowing rules by having both immutable and
  mutable pointers or multiple mutable pointers to the same location
* Arenâ€™t guaranteed to point to valid memory
* Are allowed to be null
* Donâ€™t implement any automatic cleanup
-->
<ul>
<li>ignorer les rÃ¨gles d'emprunt en ayant plusieurs pointeurs tant immuables que
mutables ou en ayant plusieurs pointeurs mutables qui pointent vers le mÃªme
endroit.</li>
<li>ne pas Ãªtre obligÃ© de pointer sur un emplacement mÃ©moire valide</li>
<li>Ãªtre autorisÃ© Ã  avoir la valeur nulle</li>
<li>ne pas implÃ©menter de fonctionnalitÃ© de nettoyage automatique</li>
</ul>
<!--
By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rustâ€™s guarantees donâ€™t apply.
-->
<p>En renonÃ§ant Ã  ce que Rust fasse respecter ces garanties, vous pouvez sacrifier
la sÃ©curitÃ© garantie pour obtenir de meilleures performances ou avoir la
possibilitÃ© de vous interfacer avec un autre langage ou matÃ©riel pour lesquels
les garanties de Rust ne s'appliquent pas.</p>
<!--
Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.
-->
<p>L'encart 19-1 montre comment crÃ©er un pointeur brut immuable et mutable Ã  partir
de rÃ©fÃ©rences.</p>
<!--
```rust
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-1: Creating raw pointers from references</span>
-->
<p><span class="caption">Encart 19-1Â : crÃ©ation de pointeurs bruts Ã  partir de
rÃ©fÃ©rences</span></p>
<!--
Notice that we donâ€™t include the `unsafe` keyword in this code. We can create
raw pointers in safe code; we just canâ€™t dereference raw pointers outside an
unsafe block, as youâ€™ll see in a bit.
-->
<p>Remarquez que nous n'incorporons pas le mot-clÃ© <code>unsafe</code> dans ce code. Nous
pouvons crÃ©er des pointeurs bruts dans du code sÃ©curisÃ©Â ; nous ne pouvons
simplement pas dÃ©rÃ©fÃ©rencer les pointeurs bruts Ã  l'extÃ©rieur d'un bloc non
sÃ©curisÃ©, comme vous allez le constater d'ici peu.</p>
<!--
Weâ€™ve created raw pointers by using `as` to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we canâ€™t make that assumption about just any raw
pointer.
-->
<p>Nous avons crÃ©Ã© des pointeurs bruts en utilisant <code>as</code> pour transformer les
rÃ©fÃ©rences immuables et mutables en leur type de pointeur brut correspondant.
Comme nous les avons crÃ©Ã©s directement Ã  partir de rÃ©fÃ©rences qui sont garanties
d'Ãªtre valides, nous savons que ces pointeurs bruts seront valides, mais nous ne
pouvons pas faire cette dÃ©duction sur tous les pointeurs bruts.</p>
<!--
Next, weâ€™ll create a raw pointer whose validity we canâ€™t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.
-->
<p>Ensuite, nous allons crÃ©er un pointeur brut dont la validitÃ© n'est pas
certaine. L'encart 19-2 montre comment crÃ©er un pointeur brut vers un
emplacement arbitraire de la mÃ©moire. Essayer d'utiliser de la mÃ©moire
arbitraire est incertainÂ : il peut y avoir des donnÃ©es Ã  cette adresse, ou il
peut ne pas y en avoir, le programme peut dÃ©boucher sur une erreur de
segmentation. Habituellement, il n'y a pas de bonne raison d'Ã©crire du code
comme celui-ci, mais c'est possible.</p>
<!--
```rust
# fn main() {
    let address = 0x012345usize;
    let r = address as *const i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let addresse = 0x012345usize;
    let r = addresse as *const i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span>
-->
<p><span class="caption">Encart 19-2Â : crÃ©ation d'un pointeur brut vers une
adresse mÃ©moire arbitraire</span></p>
<!--
Recall that we can create raw pointers in safe code, but we canâ€™t *dereference*
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator `*` on a raw pointer that requires an `unsafe` block.
-->
<p>Souvenez-vous que nous pouvons crÃ©er des pointeurs bruts dans du code sÃ©curisÃ©,
mais que nous ne pouvons pas y <em>dÃ©rÃ©fÃ©rencer</em> les pointeurs bruts et lire les
donnÃ©es sur lesquelles ils pointent. Dans l'encart 19-3, nous utilisons
l'opÃ©rateur de dÃ©rÃ©fÃ©rencement <code>*</code> sur un pointeur brut qui nÃ©cessite un bloc
<code>unsafe</code>.</p>
<!--
```rust,unsafe
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;

    unsafe {
        println!(&quot;r1 vautÂ : {}&quot;, *r1);
        println!(&quot;r2 vautÂ : {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-3: Dereferencing raw pointers within an
`unsafe` block</span>
-->
<p><span class="caption">Encart 19-3Â : dÃ©rÃ©fÃ©rencement d'un pointeur brut Ã 
l'intÃ©rieur d'un bloc <code>unsafe</code></span></p>
<!--
Creating a pointer does no harm; itâ€™s only when we try to access the value that
it points at that we might end up dealing with an invalid value.
-->
<p>La crÃ©ation de pointeur ne pose pas de problÃ¨mesÂ ; c'est seulement lorsque nous
essayons d'accÃ©der aux valeurs sur lesquelles elles pointent qu'on risque
d'obtenir une valeur invalide.</p>
<!--
Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`
raw pointers that both pointed to the same memory location, where `num` is
stored. If we instead tried to create an immutable and a mutable reference to
`num`, the code would not have compiled because Rustâ€™s ownership rules donâ€™t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!
-->
<p>Remarquez aussi que dans les encarts 19-1 et 19-3, nous avons crÃ©Ã© les
pointeurs bruts <code>*const i32</code> et <code>*mut i32</code> qui pointent tous les deux au mÃªme
endroit de la mÃ©moire, oÃ¹ <code>nombre</code> est stockÃ©. Si nous avions plutÃ´t tentÃ© de
crÃ©er une rÃ©fÃ©rence immuable et une mutable vers <code>nombre</code>, le code n'aurait pas
compilÃ© Ã  cause des rÃ¨gles de possession de Rust qui ne permettent pas d'avoir
une rÃ©fÃ©rence mutable en mÃªme temps qu'une ou plusieurs rÃ©fÃ©rences immuables.
Avec les pointeurs bruts, nous pouvons crÃ©er un pointeur mutable et un pointeur
immuable vers le mÃªme endroit et changer la donnÃ©e via le pointeur mutable, en
risquant un accÃ¨s concurrent. Soyez vigilantÂ !</p>
<!--
With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as youâ€™ll see in the next section,
[â€œCalling an Unsafe Function or
Method.â€](#calling-an-unsafe-function-or-method)<!-- ignore -- > Another case is
when building up safe abstractions that the borrow checker doesnâ€™t understand.
Weâ€™ll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.
-->
<p>Avec tous ces dangers, pourquoi vous risquer Ã  utiliser les pointeurs brutsÂ ?
Une des utilisations majeures et lorsque nous nous interfacons avec du code
C, comme vous allez le dÃ©couvrir dans la section suivante. Une autre
utilisation est lorsque nous crÃ©ons une abstraction sÃ©curisÃ©e qui le
vÃ©rificateur d'emprunt ne comprends pas. Nous allons dÃ©couvrir les fonctions
non sÃ©curisÃ©es et ensuite voir un exemple d'une abstraction sÃ©curisÃ©e qui
utilise du code non sÃ©curisÃ©.</p>
<!--
### Calling an Unsafe Function or Method
-->
<h3 id="faire-appel-Ã -une-fonction-ou-une-mÃ©thode-non-sÃ©curisÃ©e"><a class="header" href="#faire-appel-Ã -une-fonction-ou-une-mÃ©thode-non-sÃ©curisÃ©e">Faire appel Ã  une fonction ou une mÃ©thode non sÃ©curisÃ©e</a></h3>
<!--
The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra `unsafe` before the rest of the definition. The
`unsafe` keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust canâ€™t guarantee weâ€™ve
met these requirements. By calling an unsafe function within an `unsafe` block,
weâ€™re saying that weâ€™ve read this functionâ€™s documentation and take
responsibility for upholding the functionâ€™s contracts.
-->
<p>Le second type d'opÃ©ration qui nÃ©cessite un bloc <code>unsafe</code> est l'appel Ã  des
fonctions non sÃ©curisÃ©es. Les fonctions et mÃ©thodes non sÃ©curisÃ©es ressemblent
exactement pareil que les mÃ©thodes et fonctions habituelles, mais ont un
<code>unsafe</code> en plus devant le reste de leur dÃ©finition. Le mot-clÃ© <code>unsafe</code> dans
ce cas signifie que la fonction a des exigences Ã  respecter pour pouvoir y
faire appel, car Rust ne peut pas garantir que nous avons rempli ces exigences.
En faisant appel Ã  une fonction non sÃ©curisÃ©e dans un bloc <code>unsafe</code>, nous
signalons que nous avons lu la documentation de cette fonction et pris la
responsabilitÃ© de respecter les conditions d'utilisation de la fonction.</p>
<!--
Here is an unsafe function named `dangerous` that doesnâ€™t do anything in its
body:
-->
<p>Voici une fonction non sÃ©curisÃ©e <code>dangereux</code>, qui ne fait rien dans son corpsÂ :</p>
<!--
```rust,unsafe
# fn main() {
    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    unsafe fn dangereux() {}

    unsafe {
        dangereux();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
We must call the `dangerous` function within a separate `unsafe` block. If we
try to call `dangerous` without the `unsafe` block, weâ€™ll get an error:
-->
<p>Nous devons faire appel Ã  la fonction <code>dangereux</code> dans un bloc <code>unsafe</code> sÃ©parÃ©.
Si nous essayons d'appeler <code>dangereux</code> sans le bloc <code>unsafe</code>, nous obtenons une
erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 -- > src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangereux();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
By inserting the `unsafe` block around our call to `dangerous`, weâ€™re asserting
to Rust that weâ€™ve read the functionâ€™s documentation, we understand how to use
it properly, and weâ€™ve verified that weâ€™re fulfilling the contract of the
function.
-->
<p>En ajoutant le bloc <code>unsafe</code> autour de notre appel Ã  <code>dangereux</code>, nous
signalons Ã  Rust que nous avons lu la documentation de la fonction, que nous
comprenons comment l'utiliser correctement, et que nous avons vÃ©rifiÃ© que nous
rÃ©pondons bien aux exigences de la fonction.</p>
<!--
Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other
unsafe operations within an unsafe function, we donâ€™t need to add another
`unsafe` block.
-->
<p>Les corps des fonctions non sÃ©curisÃ©es sont bien des blocs <code>unsafe</code>, donc pour
pouvoir procÃ©der Ã  d'autres opÃ©rations non sÃ©curisÃ©es dans une fonction non
sÃ©curisÃ©e, nous n'avons pas besoin d'ajouter un autre bloc <code>unsafe</code>.</p>
<!--
#### Creating a Safe Abstraction over Unsafe Code
-->
<h4 id="crÃ©er-une-abstraction-sÃ©curisÃ©e-sur-du-code-non-sÃ©curisÃ©"><a class="header" href="#crÃ©er-une-abstraction-sÃ©curisÃ©e-sur-du-code-non-sÃ©curisÃ©">CrÃ©er une abstraction sÃ©curisÃ©e sur du code non sÃ©curisÃ©</a></h4>
<!--
Just because a function contains unsafe code doesnâ€™t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, letâ€™s study a function from the standard
library, `split_at_mut`, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use `split_at_mut`.
-->
<p>Ce n'est pas parce qu'une fonction contient du code non sÃ©curisÃ© que nous devons
forcÃ©ment marquer l'intÃ©gralitÃ© de cette fonction comme non sÃ©curisÃ©e. En fait,
envelopper du code non sÃ©curisÃ© dans une fonction sÃ©curisÃ©e est une abstraction
courante. Par exemple, Ã©tudions une fonction de la bibliothÃ¨que standard,
<code>split_at_mut</code>, qui nÃ©cessite du code non sÃ©curisÃ©, et Ã©tudions comment nous
devrions l'implÃ©menter. Cette mÃ©thode sÃ©curisÃ©e est dÃ©finie sur des slices
mutablesÂ : elle prend une slice en paramÃ¨tre et en crÃ©Ã©e deux autres en divisant
la slice Ã  l'indice donnÃ© en argument. L'encart 19-4 montre comment utiliser
<code>split_at_mut</code>.</p>
<!--
```rust
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-4: Using the safe `split_at_mut`
function</span>
-->
<p><span class="caption">Encart 19-4Â : utilisation de la fonction sÃ©curisÃ©e
<code>split_at_mut</code></span></p>
<!--
We canâ€™t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which wonâ€™t compile. For simplicity, weâ€™ll
implement `split_at_mut` as a function rather than a method and only for slices
of `i32` values rather than for a generic type `T`.
-->
<p>Nous ne pouvons pas implÃ©menter cette fonction en utilisant uniquement du Rust
sÃ©curisÃ©. Une tentative en ce sens ressemblerait Ã  l'encart 19-5, qui ne se
compilera pas. Par simplicitÃ©, nous allons implÃ©menter <code>split_at_mut</code> comme une
fonction plutÃ´t qu'une mÃ©thode et seulement pour des slices de valeurs <code>i32</code> au
lieu d'un type gÃ©nÃ©rique <code>T</code>.</p>
<!--
```rust,ignore,does_not_compile
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid], &mut slice[mid..])
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid], &amp;mut slice[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-5: An attempted implementation of
`split_at_mut` using only safe Rust</span>
-->
<p><span class="caption">Encart 19-5Â : une tentative d'implÃ©mentation de
<code>split_at_mut</code> en utilisant uniquement du Rust sÃ©curisÃ©</span></p>
<!--
This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether itâ€™s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.
-->
<p>Cette fonction commence par obtenir la longueur totale de la slice. Elle
vÃ©rifie ensuite que l'indice donnÃ© en paramÃ¨tre est bien Ã  l'intÃ©rieur de la
slice en vÃ©rifiant s'il est infÃ©rieur ou Ã©gal Ã  la longueur. La vÃ©rification
implique que si nous envoyons un indice qui est plus grand que la longueur de
la slice Ã  dÃ©couper, la fonction va paniquer avant d'essayer d'utiliser cet
indice.</p>
<!--
Then we return two mutable slices in a tuple: one from the start of the
original slice to the `mid` index and another from `mid` to the end of the
slice.
-->
<p>Ensuite, nous retournons deux slices mutables dans un tupleÂ : une Ã  partir du
dÃ©but de la slice initiale jusqu'Ã  l'indice <code>mod</code> et une autre Ã  partir de
l'indice jusqu'Ã  la fin de la slice.</p>
<!--
When we try to compile the code in Listing 19-5, weâ€™ll get an error.
-->
<p>Lorsque nous essayons de compiler le code de l'encart 19-5, nous allons obtenir
une erreur.</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 -- > src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&mut slice[..mid], &mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut slice[..mid], &amp;mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rustâ€™s borrow checker canâ€™t understand that weâ€™re borrowing different parts of
the slice; it only knows that weâ€™re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices arenâ€™t overlapping, but Rust isnâ€™t smart enough to know this. When we
know code is okay, but Rust doesnâ€™t, itâ€™s time to reach for unsafe code.
-->
<p>Le vÃ©rificateur d'emprunt de Rust ne comprend pas que nous empruntons
diffÃ©rentes parties de la sliceÂ ; il comprend seulement que nous empruntons la
mÃªme slice Ã  deux reprises. L'emprunt de diffÃ©rentes parties d'une slice ne
pose fondamentalement pas de problÃ¨mes car les deux slices ne se chevauchent
pas, mais Rust n'est pas suffisamment intelligent pour comprendre ceci. Lorsque
nous savons que ce code est correct, mais que Rust ne le sait pas, il est
appropriÃ© d'utiliser du code non sÃ©curisÃ©.</p>
<!--
Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls
to unsafe functions to make the implementation of `split_at_mut` work.
-->
<p>L'encart 19-6 montre comment utiliser un bloc <code>unsafe</code>, un pointeur brut, et
quelques appels Ã  des fonctions non sÃ©curisÃ©es pour construire une
implÃ©mentation de <code>split_at_mut</code> qui fonctionne.</p>
<!--
```rust,unsafe
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-6: Using unsafe code in the implementation of
the `split_at_mut` function</span>
-->
<p><span class="caption">Encart 19-6Â : utilisation de code non sÃ©curisÃ© dans
l'implÃ©mentation de la fonction <code>split_at_mut</code></span></p>
<!--
Recall from [â€œThe Slice Typeâ€][the-slice-type]<!-- ignore -- > section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the `len` method to get the length of a slice and the `as_mut_ptr`
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the type
`*mut i32`, which weâ€™ve stored in the variable `ptr`.
-->
<p>Souvenez-vous de la section <a href="ch04-03-slices.html#le-type-slice">â€œLe type sliceâ€</a><!-- ignore --> du
chapitre 4 dans laquelle nous avions dit qu'un slice est dÃ©fini par un pointeur
vers une donnÃ©e ainsi qu'une longueur de la slice. Nous avons utilisÃ© la mÃ©thode
<code>len</code> pour obtenir la longueur d'une slice ainsi que la mÃ©thode <code>as_mut_ptr</code>
pour accÃ©der au pointeur brut d'une slice. Dans ce cas, comme nous avons une
slice mutable de valeurs <code>i32</code>, <code>as_mut_ptr</code> retourne un pointeur brut avec le
type <code>*mut i32</code>, que nous avons stockÃ© dans la variable <code>ptr</code>.</p>
<!--
We keep the assertion that the `mid` index is within the slice. Then we get to
the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from `ptr` and is `mid` items long. Then we call the `add`
method on `ptr` with `mid` as an argument to get a raw pointer that starts at
`mid`, and we create a slice using that pointer and the remaining number of
items after `mid` as the length.
-->
<p>Nous avons conservÃ© la vÃ©rification que l'indice <code>mid</code> soit dans la slice.
Ensuite, nous utilisons le code non sÃ©curisÃ©Â : la fonction
<code>slice::from_raw_parts_mut</code> prend en paramÃ¨tre un pointeur brut et une longueur,
et elle crÃ©Ã©e une slice. Nous utilisons cette fonction pour crÃ©er une slice qui
dÃ©bute Ã  <code>ptr</code> et qui est long de <code>mid</code> Ã©lÃ©ments. Ensuite nous faisons appel Ã 
la mÃ©thode <code>add</code> sur <code>ptr</code> avec <code>mid</code> en argument pour obtenir un pointeur
brut qui dÃ©marre Ã  <code>mid</code>, et nous crÃ©ons une slice qui utilise ce pointeur et
le nombre restant d'Ã©lÃ©ments aprÃ¨s <code>mid</code> pour la longueur.</p>
<!--
The function `slice::from_raw_parts_mut` is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The `add` method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an `unsafe` block around our calls to
`slice::from_raw_parts_mut` and `add` so we could call them. By looking at
the code and by adding the assertion that `mid` must be less than or equal to
`len`, we can tell that all the raw pointers used within the `unsafe` block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of `unsafe`.
-->
<p>La fonction <code>slice::from_raw_parts_mut</code> est non sÃ©curisÃ© car elle prend en
argument un pointeur brut et doit avoir confiance en la validitÃ© de ce pointeur.
La mÃ©thode <code>add</code> sur les pointeurs bruts est aussi non sÃ©curisÃ©e, car elle
doit croire que l'emplacement dÃ©calÃ© est aussi un pointeur valide. VoilÃ 
pourquoi nous avons placÃ© un bloc <code>unsafe</code> autour de nos appels Ã 
<code>slice::from_raw_parts_mut</code> et <code>add</code> afin que nous puissions les appeler. En
analysant le code et en ayant ajoutÃ© la vÃ©rification que <code>mid</code> doit Ãªtre
infÃ©rieur ou Ã©gal Ã  <code>len</code>, nous pouvons affirmer que tous les pointeurs bruts
utilisÃ©s dans le bloc <code>unsafe</code> sont des pointeurs valides vers les donnÃ©es de la
slice. C'est une utilisation acceptable et appropriÃ©e de <code>unsafe</code>.</p>
<!--
Note that we donâ€™t need to mark the resulting `split_at_mut` function as
`unsafe`, and we can call this function from safe Rust. Weâ€™ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
`unsafe` code in a safe way, because it creates only valid pointers from the
data this function has access to.
-->
<p>Remarquez que nous n'avons pas eu besoin de marquer la fonction rÃ©sultante
<code>split_at_mut</code> comme Ã©tant <code>unsafe</code>, et que nous pouvons faire appel Ã  cette
fonction dans du code Rust sÃ©curisÃ©. Nous avons crÃ©Ã© une abstraction sÃ©curisÃ©e
du code non sÃ©curisÃ© avec une implÃ©mentation de la fonction qui utilise de
maniÃ¨re sÃ©curisÃ©e du code non sÃ©curisÃ©, car elle crÃ©Ã©e uniquement des pointeurs
valides Ã  partir des donnÃ©es dont cette fonction a accÃ¨s.</p>
<!--
In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.
-->
<p>En contre-partie, l'utilisation de <code>slice::from_raw_parts_mut</code> dans l'encart
19-7 peut planter lorsque la slice sera utilisÃ©e. Ce code prend un emplacement
arbitraire dans la mÃ©moire et crÃ©e un slice de 10 000 Ã©lÃ©ments.</p>
<!--
```rust,unsafe
# fn main() {
    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let slice: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    use std::slice;

    let addresse = 0x01234usize;
    let r = addresse as *mut i32;

    let slice: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span>
-->
<p><span class="caption">Encart 19-7Â : crÃ©ation d'une slice Ã  partir d'un
emplacement mÃ©moire arbitraire</span></p>
<!--
We donâ€™t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid `i32` values. Attempting to use
`slice` as though itâ€™s a valid slice results in undefined behavior.
-->
<p>Nous ne possÃ©dons par la mÃ©moire Ã  cet emplacement arbitraire, et il n'y a
aucune garantie que la slice crÃ©Ã©e par ce code contient des valeurs <code>i32</code>
valides. La tentative d'utilisation <code>slice</code> sera soumis Ã  un comportement
imprÃ©visible mÃªme si elle est une slice valide.</p>
<!--
#### Using `extern` Functions to Call External Code
-->
<h4 id="utiliser-des-fonctions-extern-pour-faire-appel-Ã -du-code-externe"><a class="header" href="#utiliser-des-fonctions-extern-pour-faire-appel-Ã -du-code-externe">Utiliser des fonctions <code>extern</code> pour faire appel Ã  du code externe</a></h4>
<!--
Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, `extern`, that facilitates the creation
and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.
-->
<p>Parfois, votre code Rust peut avoir besoin d'interagir avec du code Ã©crit dans
d'autres langages. Dans ce cas, Rust propose un mot-clÃ©, <code>extern</code>, qui facilite
la crÃ©ation et l'utilisation du <em>Foreign Function Interface (FFI)</em>. Le FFI est
un outil permettant Ã  un langage de programmation de dÃ©finir des fonctions et
permettre Ã  diffÃ©rents langages de programmation de faire appel Ã  ces
fonctions.</p>
<!--
Listing 19-8 demonstrates how to set up an integration with the `abs` function
from the C standard library. Functions declared within `extern` blocks are
always unsafe to call from Rust code. The reason is that other languages donâ€™t
enforce Rustâ€™s rules and guarantees, and Rust canâ€™t check them, so
responsibility falls on the programmer to ensure safety.
-->
<p>L'encart 19-8 montre comment rÃ©gler l'intÃ©gration avec la fonction <code>abs</code> de la
bibliothÃ¨que standard du C. Les fonctions dÃ©clarÃ©es dans les blocs <code>extern</code>
sont toujours non sÃ©curisÃ©s lorsqu'on les utilise dans du code Rust. La raison
Ã  cela est que les autres langages n'appliquent pas les rÃ¨gles et garanties de
Rust, et Rust ne peut pas les vÃ©rifier, donc la responsabilitÃ© de les utiliser
en toute sÃ©curitÃ© revient au dÃ©veloppeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,unsafe
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage CÂ : {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage CÂ : {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-8: Declaring and calling an `extern` function
defined in another language</span>
-->
<p><span class="caption">Encart 19-8Â : dÃ©claration et appel Ã  une fonction externe
qui est dÃ©finie dans un autre langage</span></p>
<!--
Within the `extern "C"` block, we list the names and signatures of external
functions from another language we want to call. The `"C"` part defines which
*application binary interface (ABI)* the external function uses: the ABI
defines how to call the function at the assembly level. The `"C"` ABI is the
most common and follows the C programming languageâ€™s ABI.
-->
<p>Au sein du bloc <code>extern &quot;C&quot;</code>, nous listons les noms et les signatures des
fonctions externes de l'autre langage que nous souhaitons solliciter. La partie
&quot;C&quot; dÃ©finit quelle est l'<em>application binary interface (ABI)</em> que la fonction
doit utiliserÂ : l'ABI dÃ©finit comment faire appel Ã  la fonction au niveau
assembleur. L'ABI <code>&quot;C&quot;</code> est la plus courante et respecte l'ABI du langage de
programmation C.</p>
<!--
> #### Calling Rust Functions from Other Languages
>
> We can also use `extern` to create an interface that allows other languages
> to call Rust functions. Instead of an `extern` block, we add the `extern`
> keyword and specify the ABI to use just before the `fn` keyword. We also need
> to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle
> the name of this function. *Mangling* is when a compiler changes the name
> weâ€™ve given a function to a different name that contains more information for
> other parts of the compilation process to consume but is less human readable.
> Every programming language compiler mangles names slightly differently, so
> for a Rust function to be nameable by other languages, we must disable the
> Rust compilerâ€™s name mangling.
>
> In the following example, we make the `call_from_c` function accessible from
> C code, after itâ€™s compiled to a shared library and linked from C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> This usage of `extern` does not require `unsafe`.
-->
<blockquote>
<h4 id="faire-appel-Ã -des-fonctions-rust-dans-dautres-langages"><a class="header" href="#faire-appel-Ã -des-fonctions-rust-dans-dautres-langages">Faire appel Ã  des fonctions Rust dans d'autres langages</a></h4>
<p>Nous pouvons aussi utiliser <code>extern</code> pour crÃ©er une interface qui permet Ã 
d'autres langages de faire appel Ã  des fonctions Rust. Au lieu d'avoir un
bloc <code>extern</code>, nous ajoutons le mot-clÃ© <code>extern</code> et nous renseignons l'ABI
Ã  utiliser juste avant le mot-clÃ© <code>fn</code>. Nous avons aussi besoin d'ajouter
l'annotation <code>#[no_mangle]</code> pour dire au compilateur Rust de ne pas dÃ©former
le nom de cette fonction. La <em>dÃ©formation</em> s'effectue lorsqu'un compilateur
change le nom que nous avons donnÃ© Ã  une fonction pour un nom qui contient
plus d'informations pour d'autres Ã©tapes du processus de compilation, mais
qui est moins lisible par l'humain. Tous les compilateurs de langages de
programmation dÃ©forment les noms de faÃ§on lÃ©gÃ¨rement diffÃ©rente, donc pour
que le nom d'une fonction Rust soit utilisable par d'autres langages, nous
devons dÃ©sactiver la dÃ©formation du nom par le compilateur de Rust.</p>
</blockquote>
<!--
### Accessing or Modifying a Mutable Static Variable
-->
<h3 id="lire-ou-modifier-une-variable-statique-mutable"><a class="header" href="#lire-ou-modifier-une-variable-statique-mutable">Lire ou modifier une variable statique mutable</a></h3>
<!--
Until now, weâ€™ve not talked about *global variables*, which Rust does support
but can be problematic with Rustâ€™s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.
-->
<p>Jusqu'Ã  prÃ©sent, nous n'avons pas parlÃ© des <em>variables globales</em>, que Rust
accepte mais qui peuvent poser des problÃ¨mes avec les rÃ¨gles de possession de
Rust. Si deux tÃ¢ches accÃ¨dent en mÃªme temps Ã  la mÃªme variable globale, cela
peut causer un accÃ¨s concurrent.</p>
<!--
In Rust, global variables are called *static* variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.
-->
<p>En Rust, les variables globales s'appellent des variables <em>statiques</em>. L'encart
19-9 montre un exemple de dÃ©claration et d'utilisation d'une variable statique
avec une slice de chaÃ®ne de caractÃ¨res comme valeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```
-->
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;Cela vautÂ : {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-9: Defining and using an immutable static
variable</span>
-->
<p><span class="caption">Encart 19-9Â : dÃ©finition et utilisation d'une variable
statique immuable</span></p>
<!--
Static variables are similar to constants, which we discussed in the
[â€œDifferences Between Variables and
Constantsâ€][differences-between-variables-and-constants]<!-- ignore -- >
section in Chapter 3. The names of static variables are in
`SCREAMING_SNAKE_CASE` by convention, and we *must* annotate the variableâ€™s
type, which is `&'static str` in this example. Static variables can only store
references with the `'static` lifetime, which means the Rust compiler can
figure out the lifetime; we donâ€™t need to annotate it explicitly. Accessing an
immutable static variable is safe.
-->
<p>Les variables statiques ressemblent aux constantes, que nous avons vu dans la
section
<a href="ch03-01-variables-and-mutability.html#diff%C3%A9rences-entre-les-variables-et-les-constantes">â€œDiffÃ©rences entre les variables et les constantesâ€</a><!-- ignore -->
du chapitre 3. Les noms des variables statiques sont par convention en
<code>SCREAMING_SNAKE_CASE</code>, et nous <em>devons</em> obligatoirement renseigner le type de
la variable, qui est <code>&amp;'static str</code> dans cet exemple. Les variables statiques
peuvent uniquement stocker des rÃ©fÃ©rences avec la durÃ©e de vie <code>'static</code>, ce
qui signifie que le compilateur Rust peut comprendre sa durÃ©e de vieÂ ; nous
n'avons pas besoin de la renseigner explicitement. L'accÃ¨s Ã  une variable
statique immuable est sÃ©curisÃ©.</p>
<!--
Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever theyâ€™re used.
-->
<p>Les constantes et les variables statiques immuables se ressemblent, mais leur
diffÃ©rence subtile est que les valeurs dans les variables statiques sont une
adresse fixe en mÃ©moire. L'utilisation de sa valeur va toujours accÃ©der Ã  la
mÃªme donnÃ©e. Les constantes en revanche, peuvent reproduire leurs donnÃ©es Ã 
chaque fois qu'elles sont utilisÃ©es.</p>
<!--
Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named `COUNTER`.
-->
<p>Une autre diffÃ©rence entre les constantes et les variables statiques est que
les variables statiques peuvent Ãªtre mutables. Lire et modifier des variables
statiques mutables est <em>non sÃ©curisÃ©</em>. L'encart 19-10 montre comment dÃ©clarer,
lire et modifier la variable statique mutable <code>COMPTEUR</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,unsafe
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">static mut COMPTEUR: u32 = 0;

fn ajouter_au_compteur(valeur: u32) {
    unsafe {
        COMPTEUR += valeur;
    }
}

fn main() {
    ajouter_au_compteur(3);

    unsafe {
        println!(&quot;COMPTEURÂ : {}&quot;, COMPTEUR);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span>
-->
<p><span class="caption">Encart 19-10Â : la lecture et l'Ã©criture d'une variable
statique mutable est non sÃ©curisÃ©</span></p>
<!--
As with regular variables, we specify mutability using the `mut` keyword. Any
code that reads or writes from `COUNTER` must be within an `unsafe` block. This
code compiles and prints `COUNTER: 3` as we would expect because itâ€™s single
threaded. Having multiple threads access `COUNTER` would likely result in data
races.
-->
<p>Comme avec les variables classiques, nous renseignons la mutabilitÃ© en
utilisant le mot-clÃ© <code>mut</code>. Tout code qui lit ou modifie <code>COMPTEUR</code> doit se
trouver dans un bloc <code>unsafe</code>. Ce code se compile et affiche <code>COMPTEURÂ : 3</code>
comme nous l'espÃ©rions car nous n'avons qu'une seule tÃ¢che. Si nous avions
plusieurs tÃ¢ches qui accÃ¨dent Ã  <code>COMPTEUR</code> nous pourrions avoir un accÃ¨s
concurrent.</p>
<!--
With mutable data that is globally accessible, itâ€™s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, itâ€™s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.
-->
<p>Avec les donnÃ©es mutables qui sont globalement accessibles, il devient
difficile de s'assurer qu'il n'y a pas d'accÃ¨s concurrent, c'est pourquoi Rust
considÃ¨re les variables statiques mutables comme Ã©tant non sÃ©curisÃ©es. Lorsque
c'est possible, il vaut mieux utiliser les techniques de concurrence et les
pointeurs intelligents adaptÃ©s au multitÃ¢che que nous avons vu au chapitre 16,
afin que le compilateur puisse vÃ©rifier que les donnÃ©es qu'utilisent les
diffÃ©rentes tÃ¢ches sont sÃ©curisÃ©es.</p>
<!--
### Implementing an Unsafe Trait
-->
<h3 id="implÃ©menter-un-trait-non-sÃ©curisÃ©"><a class="header" href="#implÃ©menter-un-trait-non-sÃ©curisÃ©">ImplÃ©menter un trait non sÃ©curisÃ©</a></h3>
<!--
The final action that works only with `unsafe` is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler canâ€™t verify. We can declare that a trait is `unsafe` by adding the
`unsafe` keyword before `trait` and marking the implementation of the trait as
`unsafe` too, as shown in Listing 19-11.
-->
<p>La derniÃ¨re action qui fonctionne uniquement avec <code>unsafe</code> est l'implÃ©mentation
d'un trait non sÃ©curisÃ©. Un trait n'est pas sÃ©curisÃ© lorsque au moins une de ses
mÃ©thodes contient une invariante que le compilateur ne peut pas vÃ©rifier. Nous
pouvons dÃ©clarer un trait qui n'est pas sÃ©curisÃ© en ajoutant le mot-clÃ© <code>unsafe</code>
devant <code>trait</code> et en marquant aussi l'implÃ©mentation du trait comme <code>unsafe</code>,
comme dans l'encart 19-11.</p>
<!--
```rust,unsafe
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">unsafe trait Foo {
    // les mÃ©thodes vont ici
}

unsafe impl Foo for i32 {
    // les implÃ©mentations des mÃ©thodes vont ici
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span>
-->
<p><span class="caption">Encart 19-11Â : dÃ©finition et implÃ©mentation d'un trait non
sÃ©curisÃ©</span></p>
<!--
By using `unsafe impl`, weâ€™re promising that weâ€™ll uphold the invariants that
the compiler canâ€™t verify.
-->
<p>En utilisant <code>unsafe impl</code>, nous promettons que nous veillons aux invariantes
que le compilateur ne peut pas vÃ©rifier.</p>
<!--
As an example, recall the `Sync` and `Send` marker traits we discussed in the
[â€œExtensible Concurrency with the `Sync` and `Send`
Traitsâ€][extensible-concurrency-with-the-sync-and-send-traits]<!-- ignore -- >
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of `Send` and `Sync` types. If we implement a
type that contains a type that is not `Send` or `Sync`, such as raw pointers,
and we want to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust
canâ€™t verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with `unsafe`.
-->
<p>Par exemple, souvenez-vous des traits <code>Sync</code> et <code>Send</code> que nous avions dÃ©couvert
dans une section du
<a href="ch16-04-extensible-concurrency-sync-and-send.html">chapitre 16</a><!-- ignore -->Â :
le compilateur implÃ©mente automatiquement ces traits si nos types sont
entiÃ¨rement composÃ©s des types <code>Send</code> et <code>Sync</code>. Si nous implÃ©mentions un type
qui contenait un type qui n'Ã©tait pas <code>Send</code> ou <code>Sync</code>, comme des pointeurs
bruts, et nous souhaitions marquer ce type comme Ã©tant <code>Send</code> ou <code>Sync</code>, nous
aurions dÃ» utiliser <code>unsafe</code>. Rust ne peut pas vÃ©rifier que notre type respecte
les garanties pour que ce type puisse Ãªtre envoyÃ© en toute sÃ©curitÃ© entre des
tÃ¢ches ou qu'il puisse Ãªtre utilisÃ© par plusieurs tÃ¢chesÂ ; toutefois, nous avons
besoin de faire ces vÃ©rifications manuellement et les signaler avec <code>unsafe</code>.</p>
<!--
### Accessing Fields of a Union
-->
<h3 id="utiliser-des-champs-dun-union"><a class="header" href="#utiliser-des-champs-dun-union">Utiliser des champs d'un Union</a></h3>
<!--
A `union` is similar to a `struct`, but only one declared field is used in a
particular instance at one time. Unions are primarily used to interface with
unions in C code. Accessing union fields is unsafe because Rust canâ€™t guarantee
the type of the data currently being stored in the union instance. You can
learn more about unions in [the reference][reference].
-->
<p>Un <code>union</code> ressemble Ã  une <code>struct</code>, mais un seul champ de ceux dÃ©clarÃ©s est
utilisÃ© dans une instance prÃ©cise au mÃªme moment. Les unions sont principalement
utilisÃ©s pour s'interfacer avec les unions du code C. L'accÃ¨s aux champs des
unions n'est pas sÃ©curisÃ© car Rust ne peut pas garantir le type de donnÃ©es qui
est actuellement stockÃ©e dans l'instance de l'union. Vous pouvez en apprendre
plus sur les unions dans <a href="https://doc.rust-lang.org/reference/items/unions.html">the reference</a>.</p>
<!--
### When to Use Unsafe Code
-->
<h3 id="quand-utiliser-du-code-non-sÃ©curisÃ©"><a class="header" href="#quand-utiliser-du-code-non-sÃ©curisÃ©">Quand utiliser du code non sÃ©curisÃ©</a></h3>
<!--
Using `unsafe` to take one of the five actions (superpowers) just discussed
isnâ€™t wrong or even frowned upon. But it is trickier to get `unsafe` code
correct because the compiler canâ€™t help uphold memory safety. When you have a
reason to use `unsafe` code, you can do so, and having the explicit `unsafe`
annotation makes it easier to track down the source of problems when they occur.
-->
<p>L'utilisation de <code>unsafe</code> pour s'approprier une des cinq actions (ou
super-pouvoirs) que nous venons d'aborder n'est pas une mauvaise chose et ne doit
pas Ãªtre mal vu. Mais il est plus difficile de sÃ©curiser du code <code>unsafe</code> car le
compilateur ne peut pas aider Ã  garantir la sÃ©curitÃ© de la mÃ©moire. Lorsque vous
avez une bonne raison d'utiliser du code non sÃ©curisÃ©, vous pouvez le faire, et
vous aurez l'annotation explicite <code>unsafe</code> pour faciliter la recherche de la
source de problÃ¨mes lorsqu'ils surviennent.</p>
<!--
[dangling-references]:
ch04-02-references-and-borrowing.html#dangling-references
[differences-between-variables-and-constants]:
ch03-01-variables-and-mutability.html#differences-between-variables-and-constants
[extensible-concurrency-with-the-sync-and-send-traits]:
ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits
[the-slice-type]: ch04-03-slices.html#the-slice-type
[reference]: ../reference/items/unions.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
