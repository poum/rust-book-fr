<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Les types avancÃ©s - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html" class="active"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/218">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Types
-->
<h2><a class="header" href="#les-types-avancÃ©s" id="les-types-avancÃ©s">Les types avancÃ©s</a></h2>
<!--
The Rust type system has some features that weâ€™ve mentioned in this book but
havenâ€™t yet discussed. Weâ€™ll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then weâ€™ll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. Weâ€™ll also
discuss the `!` type and dynamically sized types.
-->
<p>Le systÃ¨me de type de Rust offre quelques fonctionnalitÃ©s que nous avons
mentionnÃ© dans ce livre mais que nous n'avons pas encore Ã©tudiÃ©. Nous allons
commencer par voir les newtypes en gÃ©nÃ©ral lorsque nous examinerons pourquoi
les newtypes sont des types utiles. Ensuite nous nous pencherons sur les alias
de type, une fonctionnalitÃ© qui ressemble aux newtypes mais avec quelques
diffÃ©rences sÃ©mantiques. Nous allons aussi voir le type <code>!</code> et les types Ã 
taille dynamique.</p>
<!--
> Note: The next section assumes youâ€™ve read the earlier section [â€œUsing the
> Newtype Pattern to Implement External Traits on External
> Types.â€][using-the-newtype-pattern]<!-- ignore -- >
-->
<blockquote>
<p>RemarqueÂ : cette section suppose que vous avez lu la
<a href="ch19-03-advanced-traits.html">section prÃ©cÃ©dente</a><!-- ignore --></p>
</blockquote>
<!--
### Using the Newtype Pattern for Type Safety and Abstraction
-->
<h3><a class="header" href="#utiliser-le-motif-newtype-pour-la-sÃ©curitÃ©-et-labstraction-des-types" id="utiliser-le-motif-newtype-pour-la-sÃ©curitÃ©-et-labstraction-des-types">Utiliser le motif newtype pour la sÃ©curitÃ© et l'abstraction des types</a></h3>
<!--
The newtype pattern is useful for tasks beyond those weâ€™ve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-15: recall that the `Millimeters` and `Meters` structs wrapped `u32`
values in a newtype. If we wrote a function with a parameter of type
`Millimeters`, we couldnâ€™t compile a program that accidentally tried to call
that function with a value of type `Meters` or a plain `u32`.
-->
<p>Le motif newtype est utile pour des tÃ¢ches qui se prolongent en dehors de ce
que nous avons vu jusqu'Ã  prÃ©sent, notamment pour faire en sorte statiquement
que les valeurs ne soient jamais confondues et pour indiquer les unitÃ©s d'une
valeur. Vous avez vu un exemple d'utilisation des newtypes pour indiquer des
unitÃ©s dans l'encart 19-15Â : souvenez-vous des structures <code>Milimetres</code> et
<code>Metres</code> qui englobaient des valeurs <code>u32</code> dans ces newtypes. Si nous avions
Ã©crit une fonction avec un paramÃ¨tre de type <code>Milimetres</code>, nous ne pourrions
pas compiler un programme qui fait accidentellement appel Ã  cette fonction avec
une valeur du type <code>Metres</code> ou un <code>u32</code> pur.</p>
<!--
Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type if we used the new type directly to restrict
the available functionality, for example.
-->
<p>Une autre utilisation du motif newtype est de rendre abstrait certains dÃ©tails
d'implÃ©mentation d'un typeÂ : le newtype peut exposer une API publique qui est
diffÃ©rente de l'API du type interne privÃ© si nous avons utilisÃ© directement le
newtype pour restreindre les fonctionnalitÃ©s disponibles, par exemple.</p>
<!--
Newtypes can also hide internal implementation. For example, we could provide a
`People` type to wrap a `HashMap<i32, String>` that stores a personâ€™s ID
associated with their name. Code using `People` would only interact with the
public API we provide, such as a method to add a name string to the `People`
collection; that code wouldnâ€™t need to know that we assign an `i32` ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the [â€œEncapsulation that
Hides Implementation
Detailsâ€][encapsulation-that-hides-implementation-details]<!-- ignore -- >
section of Chapter 17.
-->
<p>Les newtypes peuvent aussi masquer des implÃ©mentations internes. Par exemple,
nous pouvons fournir un type <code>Personnes</code> pour embarquer un
<code>HashMap&lt;i32, String&gt;</code> qui stocke un identifiant d'une personne associÃ© Ã  son
nom. Le code qui utilisera <code>Personnes</code> ne pourra utiliser que l'API publique
que nous fournissons, comme une mÃ©thode pour ajouter une chaÃ®ne de caractÃ¨res
de caractÃ¨re qui est un nom Ã  la collection <code>Personnes</code>Â ; ce code n'aura pas
besoin de savoir que nous assignons en interne un identifiant <code>i32</code> aux noms.
Le motif newtype est une faÃ§on allÃ©gÃ©e de procÃ©der Ã  de l'encapsulation pour
masquer des dÃ©tails d'implÃ©mentation, comme nous l'avons vu dans <a href="ch17-01-what-is-oo.html">une partie du
chapitre 17</a><!-- ignore -->.</p>
<!--
### Creating Type Synonyms with Type Aliases
-->
<h3><a class="header" href="#crÃ©er-des-synonymes-de-noms-avec-les-alias-de-type" id="crÃ©er-des-synonymes-de-noms-avec-les-alias-de-type">CrÃ©er des synonymes de noms avec les alias de type</a></h3>
<!--
Along with the newtype pattern, Rust provides the ability to declare a *type
alias* to give an existing type another name. For this we use the `type`
keyword. For example, we can create the alias `Kilometers` to `i32` like so:
-->
<p>En plus du motif newtype, Rust fournit la possibilitÃ© de dÃ©clarer un <em>alias de
type</em> pour donner un autre nom Ã  un type dÃ©jÃ  existant. Pour faire cela, nous
utilisons le mot-clÃ© <code>type</code>. Par exemple, nous pouvons crÃ©er l'alias
<code>Kilometres</code> pour un <code>i32</code>, comme ceciÂ :</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;
# 
#     let x: i32 = 5;
#     let y: Kilometers = 5;
# 
#     println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometres = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters`
and `Meters` types we created in Listing 19-15, `Kilometers` is not a separate,
new type. Values that have the type `Kilometers` will be treated the same as
values of type `i32`:
-->
<p>DÃ©sormais, l'alias <code>Kilometres</code> est un <em>synonyme</em> de <code>i32</code>Â ; contrairement aux
types <code>Milimetres</code> et <code>Metres</code> que nous avons crÃ©Ã© dans l'encart 19-15,
<code>Kilometres</code> n'est pas un newtype sÃ©parÃ©. Les valeurs qui ont le type
<code>Kilometre</code> seront traitÃ©s comme si elles Ã©taient du type <code>i32</code>Â :</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;

    let x: i32 = 5;
    let y: Kilometres = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometres = i32;

let x: i32 = 5;
let y: Kilometres = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<!--
Because `Kilometers` and `i32` are the same type, we can add values of both
types and we can pass `Kilometers` values to functions that take `i32`
parameters. However, using this method, we donâ€™t get the type checking benefits
that we get from the newtype pattern discussed earlier.
-->
<p>Comme <code>Kilometres</code> et <code>i32</code> sont du mÃªme type, nous pouvons additionner les
valeurs des deux types et nous pouvons envoyer des valeurs <code>Kilometres</code> aux
fonctions qui prennent des paramÃ¨tres <code>i32</code>. Cependant, en utilisant cette
mÃ©thode, nous ne bÃ©nÃ©ficions pas des bienfaits de la vÃ©rification du type que
nous avions avec le motif newtype que nous avons vu prÃ©cÃ©demment.</p>
<!--
The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:
-->
<p>L'utilisation principale pour les synonymes de types est de rÃ©duire la
rÃ©pÃ©tition. Par exemple, nous pourrions avoir un type un peu long comme
celui-ciÂ :</p>
<!--
```rust,ignore
Box<dyn Fn() + Send + 'static>
```
-->
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<!--
Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.
-->
<p>L'Ã©criture de ce type un peu long dans des signatures de fonctions et comme
annotations de types tout au long du code peut Ãªtre fatigante et faciliter les
erreurs. Imaginez avoir un projet avec plein de code comme celui dans l'encart
19-24.</p>
<!--
```rust
# fn main() {
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
        // --snip--
    }

    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // -- partie masquÃ©e ici --
    }

    fn retourne_un_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-24: Using a long type in many places</span>
-->
<p><span class="caption">Encart 19-24Â : utilisation d'un long type dans de nombreux
endroits</span></p>
<!--
A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, weâ€™ve introduced an alias named `Thunk` for the verbose type and
can replace all uses of the type with the shorter alias `Thunk`.
-->
<p>Un alias de type simplifie ce code en rÃ©duisant la rÃ©pÃ©tition. Dans l'encart
19-25, nous avons ajoutÃ© un alias <code>Thunk</code> pour ce type verbeux et qui peut
remplacer tous ses cas d'emploi du type avec l'alias <code>Thunk</code>, plus court.</p>
<!--
```rust
# fn main() {
    type Thunk = Box<dyn Fn() + Send + 'static>;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -> Thunk {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Thunk) {
        // -- partie masquÃ©e ici --
    }

    fn retourne_un_long_type() -&gt; Thunk {
        // -- partie masquÃ©e ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-25: Introducing a type alias `Thunk` to reduce
repetition</span>
-->
<p><span class="caption">Encart 19-25Â : ajout et utilisation d'un alias <code>Thunk</code>
pour rÃ©duire les rÃ©pÃ©titions</span></p>
<!--
This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (*thunk* is a word for code
to be evaluated at a later time, so itâ€™s an appropriate name for a closure that
gets stored).
-->
<p>Ce code est plus facile Ã  lire et Ã©crireÂ ! Choisir un nom plus explicite pour
un alias peut aussi vous aider Ã  communiquer ce que vous voulez faire (<em>thunk</em>
est un terme dÃ©signant du code qui peut Ãªtre Ã©valuÃ© plus tard, donc c'est un nom
appropriÃ© pour une fermeture qui est stockÃ©e).</p>
<!--
Type aliases are also commonly used with the `Result<T, E>` type for reducing
repetition. Consider the `std::io` module in the standard library. I/O
operations often return a `Result<T, E>` to handle situations when operations
fail to work. This library has a `std::io::Error` struct that represents all
possible I/O errors. Many of the functions in `std::io` will be returning
`Result<T, E>` where the `E` is `std::io::Error`, such as these functions in
the `Write` trait:
-->
<p>Les alias de type sont couramment utilisÃ©s avec le type <code>Result&lt;T, E&gt;</code> pour
rÃ©duire la rÃ©pÃ©tition. Regardez le module <code>std::io</code> de la bibliothÃ¨que standard.
Les opÃ©rations d'entrÃ©e/sortie retournent parfois un <code>Result&lt;T, E&gt;</code> pour gÃ©rer
les situations lorsque les opÃ©rations Ã©chouent. Cette bibliothÃ¨que a une
structure <code>std::io::Error</code> qui reprÃ©sente toutes les erreurs possibles
d'entrÃ©e/sortie. De nombreuses fonctions dans <code>std::io</code> vont retourner un
<code>Result&lt;T, E&gt;</code> avec <code>E</code> qui est <code>std::io::Error</code>, ces fonctions sont dans le
trait <code>Write</code>Â :</p>
<!--
```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type of
alias declaration:
-->
<p>Le <code>Result&lt;..., Error&gt;</code> est rÃ©pÃ©tÃ© plein de fois. Ainsi, <code>std::io</code> a ce type de
dÃ©claration d'aliasÂ :</p>
<!--
```rust
# use std::fmt;
# 
type Result<T> = std::result::Result<T, std::io::Error>;
# 
# pub trait Write {
#     fn write(&mut self, buf: &[u8]) -> Result<usize>;
#     fn flush(&mut self) -> Result<()>;
# 
#     fn write_all(&mut self, buf: &[u8]) -> Result<()>;
#     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Because this declaration is in the `std::io` module, we can use the fully
qualified alias `std::io::Result<T>`â€”that is, a `Result<T, E>` with the `E`
filled in as `std::io::Error`. The `Write` trait function signatures end up
looking like this:
-->
<p>Comme cette dÃ©claration est dans le module <code>std::io</code>, nous pouvons utiliser
l'alias <code>std::io::Result&lt;T&gt;</code> â€” qui est un <code>Result&lt;T, E&gt;</code> avec le <code>E</code> qui est
dÃ©jÃ  renseignÃ© comme Ã©tant un <code>std::io::Error</code>. Les fonctions du trait <code>Write</code>
ressemblent finalement Ã  ceciÂ :</p>
<!--
```rust
# use std::fmt;
# 
# type Result<T> = std::result::Result<T, std::io::Error>;
# 
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
The type alias helps in two ways: it makes code easier to write *and* it gives
us a consistent interface across all of `std::io`. Because itâ€™s an alias, itâ€™s
just another `Result<T, E>`, which means we can use any methods that work on
`Result<T, E>` with it, as well as special syntax like the `?` operator.
-->
<p>L'alias de type nous aide sur deux domainesÂ : il permet de faciliter l'Ã©criture
du code <em>et</em> il nous donne une interface uniforme pour tout <code>std::io</code>. Comme
c'est un alias, c'est simplement un autre <code>Result&lt;T, E&gt;</code>, ce qui signifie que
nous pouvons utiliser n'importe quelle mÃ©thode qui fonctionne avec
<code>Result&lt;T, E&gt;</code>, ainsi que les syntaxes spÃ©ciales comme l'opÃ©rateur <code>?</code>.</p>
<!--
### The Never Type that Never Returns
-->
<h3><a class="header" href="#le-type-jamais-qui-ne-retourna-pas-de-valeur" id="le-type-jamais-qui-ne-retourna-pas-de-valeur">Le type &quot;jamais&quot;, qui ne retourna pas de valeur</a></h3>
<!--
Rust has a special type named `!` thatâ€™s known in type theory lingo as the
*empty type* because it has no values. We prefer to call it the *never type*
because it stands in the place of the return type when a function will never
return. Here is an example:
-->
<p>Rust a un type spÃ©cial qui s'appelle <code>!</code> qui est connu dans le vocabulaire de
la thÃ©orie des types comme Ã©tant le <em>type vide</em> car il n'a pas de valeur. Nous
prÃ©fÃ©rons appeler cela le <em>type jamais</em> car il remplace le type de retour
lorsqu'une fonction ne va jamais retourner quelque chose. Voici un exempleÂ :</p>
<!--
```rust
fn bar() -> ! {
    // --snip--
#     panic!();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn bar() -&gt; ! {
    // -- partie masquÃ©e ici --
<span class="boring">    panic!();
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
This code is read as â€œthe function `bar` returns never.â€ Functions that return
never are called *diverging functions*. We canâ€™t create values of the type `!`
so `bar` can never possibly return.
-->
<p>Ce code peut Ãªtre interprÃ©tÃ© comme â€œla fonction <code>bar</code> qui ne retourne pas de
valeurâ€. Les fonctions qui ne retournent pas de valeur s'appellent des
<em>fonctions divergentes</em>. Nous ne pouvons pas crÃ©er de valeurs de type <code>!</code> donc
<code>bar</code> afin que <code>bar</code> ne puisse jamais retourner de valeur.</p>
<!--
But what use is a type you can never create values for? Recall the code from
Listing 2-5; weâ€™ve reproduced part of it here in Listing 19-26.
-->
<p>Mais Ã  quoi sert un type dont on ne peut jamais crÃ©er de valeurs ?
Souvenez-vous du code de l'encart 2-5Â ; nous avons reproduit une partie de
celui-ci dans l'encart 19-26.</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         // --snip--
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
# 
#         println!("You guessed: {}", guess);
# 
#         // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        // -- partie masquÃ©e ici --
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span>        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">        // -- partie masquÃ©e ici --
</span><span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagnÃ©Â !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-26: A `match` with an arm that ends in
`continue`</span>
-->
<p><span class="caption">Encart 19-26Â : un <code>match</code> avec une branche qui finit par
un <code>continue</code></span></p>
<!--
At the time, we skipped over some details in this code. In Chapter 6 in [â€œThe
`match` Control Flow Operatorâ€][the-match-control-flow-operator]<!-- ignore
-- > section, we discussed that `match` arms must all return the same type. So,
for example, the following code doesnâ€™t work:
-->
<p>A l'Ã©poque, nous avions sautÃ© quelques dÃ©tails dans ce code. Dans la section
<a href="ch06-02-match.html#la-structure-de-contr%C3%B4le-match">â€œLa structure de contrÃ´le
<code>match</code>â€</a><!-- ignore --> du chapitre 6, nous
avons vu que les branches d'un <code>match</code> doivent toutes retourner le mÃªme type.
Donc, par exemple, le code suivant ne fonctionne pasÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let guess = "3";
    let guess = match guess.trim().parse() {
        Ok(_) => 5,
        Err(_) => "hello",
    };
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let supposition = &quot;3&quot;;
</span>    let supposition = match supposition.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;salut&quot;,
    };
<span class="boring">}
</span></code></pre>
<pre><code class="language-rust ignore does_not_compile">let supposition = match supposition.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;salut&quot;,
}
</code></pre>
<!--
The type of `guess` in this code would have to be an integer *and* a string,
and Rust requires that `guess` have only one type. So what does `continue`
return? How were we allowed to return a `u32` from one arm and have another arm
that ends with `continue` in Listing 19-26?
-->
<p>Le type de <code>supposition</code> dans ce code devrait Ãªtre un entier <em>et</em> une chaÃ®ne de
caractÃ¨res, et Rust nÃ©cessite que <code>supposition</code> n'ait qu'un seul type possible.
Donc que retourne <code>continue</code>Â ? Pourquoi pouvons-nous retourner un <code>u32</code> dans
une branche et avoir une autre branche qui finit avec un <code>continue</code> dans
l'encart 19-26Â ?</p>
<!--
As you might have guessed, `continue` has a `!` value. That is, when Rust
computes the type of `guess`, it looks at both match arms, the former with a
value of `u32` and the latter with a `!` value. Because `!` can never have a
value, Rust decides that the type of `guess` is `u32`.
-->
<p>Comme vous l'avez devinÃ©, <code>continue</code> a une valeur <code>!</code>. Ainsi, lorsque Rust
calcule le type de <code>supposition</code>, il regarde les deux branches, la premiÃ¨re
avec une valeur <code>u32</code> et la seconde avec une valeur <code>!</code>. Comme <code>!</code> ne peut
jamais retourner de valeur, Rust dÃ©cide alors que le type de <code>supposition</code> est
<code>u32</code>.</p>
<!--
The formal way of describing this behavior is that expressions of type `!` can
be coerced into any other type. Weâ€™re allowed to end this `match` arm with
`continue` because `continue` doesnâ€™t return a value; instead, it moves control
back to the top of the loop, so in the `Err` case, we never assign a value to
`guess`.
-->
<p>Une faÃ§on classique de dÃ©crire ce comportement est de dire que les expressions
du type <code>!</code> peuvent Ãªtre transformÃ©es dans n'importe quel type. Nous pouvons
finir cette branche de <code>match</code> avec <code>continue</code> car <code>continue</code> ne retourne pas
de valeurÂ ; Ã  la place, il retourne le contrÃ´le en haut de la boucle, donc dans
le cas d'un <code>Err</code>, nous n'assignons jamais de valeur Ã  <code>supposition</code>.</p>
<!--
The never type is useful with the `panic!` macro as well. Remember the `unwrap`
function that we call on `Option<T>` values to produce a value or panic? Here
is its definition:
-->
<p>Ce type &quot;jamais&quot; est aussi utile avec la macro <code>panic!</code>. Vous souvenez-vous que
la fonction <code>unwrap</code> que nous appelons sur les valeurs <code>Option&lt;T&gt;</code> fournissent
une valeur, ou paniquentÂ ? Voici sa dÃ©finitionÂ :</p>
<!--
```rust,ignore
# enum Option<T> {
#     Some(T),
#     None,
# }
# 
# use crate::Option::*;
# 
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<!--
In this code, the same thing happens as in the `match` in Listing 19-26: Rust
sees that `val` has the type `T` and `panic!` has the type `!`, so the result
of the overall `match` expression is `T`. This code works because `panic!`
doesnâ€™t produce a value; it ends the program. In the `None` case, we wonâ€™t be
returning a value from `unwrap`, so this code is valid.
-->
<p>Dans ce code, il se passe la mÃªme chose que l'encart 19-26Â : Rust constate que
<code>val</code> est du type <code>T</code> et que <code>panic!</code> est du type <code>!</code>, donc le rÃ©sultat de
l'ensemble de l'expression <code>match</code> est <code>T</code>. Ce code fonctionne car <code>panic!</code> ne
produit pas de valeurÂ ; il termine le programme. Dans le cas d'un <code>None</code>, nous
ne retournons pas une valeur de <code>unwrap</code>, donc ce code est valide.</p>
<!--
One final expression that has the type `!` is a `loop`:
-->
<p>Une des expressions qui sont du type <code>!</code> est le <code>loop</code>Â :</p>
<!--
```rust,ignore
# fn main() {
    print!("forever ");

    loop {
        print!("and ever ");
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;pour toujours &quot;);

    loop {
        print!(&quot;et toujours &quot;);
    }
<span class="boring">}
</span></code></pre>
<!--
Here, the loop never ends, so `!` is the value of the expression. However, this
wouldnâ€™t be true if we included a `break`, because the loop would terminate
when it got to the `break`.
-->
<p>Ici, la boucle ne se termine jamais, donc <code>!</code> est la valeur de cette
expression. En revanche, cela ne sera pas vrai si nous utilisons un <code>break</code>,
car la boucle va s'arrÃªter lorsqu'elle rencontrera le <code>break</code>.</p>
<!--
### Dynamically Sized Types and the `Sized` Trait
-->
<h3><a class="header" href="#les-types-Ã -taille-dynamique-et-le-trait-sized" id="les-types-Ã -taille-dynamique-et-le-trait-sized">Les types Ã  taille dynamique et le trait <code>Sized</code></a></h3>
<!--
Due to Rustâ€™s need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of *dynamically sized types*. Sometimes referred to
as *DSTs* or *unsized types*, these types let us write code using values whose
size we can know only at runtime.
-->
<p>Vu qu'il est nÃ©cessaire pour Rust de connaÃ®tre certains dÃ©tails, comme la
quantitÃ© d'espace Ã  allouer Ã  une valeur d'un type donnÃ©, il y a un aspect de
ce systÃ¨me de type qui peut Ãªtre dÃ©routantÂ : le concept des <em>types Ã  taille
dynamique</em>. Parfois appelÃ©s <em>DST</em> (Dynamically Sized Types) ou <em>types sans
taille</em>, ces types nous permettent d'Ã©crire du code qui utilisent des valeurs
qui ne peuvent Ãªtre connues uniquement Ã  l'exÃ©cution.</p>
<!--
Letâ€™s dig into the details of a dynamically sized type called `str`, which
weâ€™ve been using throughout the book. Thatâ€™s right, not `&str`, but `str` on
its own, is a DST. We canâ€™t know how long the string is until runtime, meaning
we canâ€™t create a variable of type `str`, nor can we take an argument of type
`str`. Consider the following code, which does not work:
-->
<p>Voyons les dÃ©tails d'un type Ã  taille dynamique qui s'appelle <code>str</code>, que nous
avons utilisÃ© dans ce livre. Plus prÃ©cisÃ©ment <code>&amp;str</code>, car <code>str</code> en lui-mÃªme est
un DST. Nous ne connaÃ®tre la longueur de la chaÃ®ne de caractÃ¨re qu'Ã 
l'exÃ©cution, ce qui signifie que nous ne pouvons pas ni crÃ©er une variable de
type <code>str</code>, ni prendre prendre en argument un type <code>str</code>. Imaginons le code
suivant, qui ne devrait pas fonctionnerÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Salut tout le mondeÂ !&quot;;
    let s2: str = &quot;Comment Ã§a vaÂ ?&quot;;
<span class="boring">}
</span></code></pre>
<!--
Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two `str` values would need to take up the
same amount of space. But they have different lengths: `s1` needs 12 bytes of
storage and `s2` needs 15. This is why itâ€™s not possible to create a variable
holding a dynamically sized type.
-->
<p>Rust a besoin de savoir combien de mÃ©moire allouer pour chaque valeur d'un type
donnÃ©, et toutes les valeurs de ce type doivent utiliser la mÃªme quantitÃ© de
mÃ©moire. Si Rust nous aurait autorisÃ© Ã  Ã©crire ce code, ces deux valeurs <code>str</code>
devraient occuper la mÃªme quantitÃ© de mÃ©moire. Mais elles ont deux longueurs
diffÃ©rentesÂ : <code>s1</code> prend 21 octets en mÃ©moire alors que <code>s2</code> en a besoin de 15.
C'est pourquoi il est impossible de crÃ©er une variable qui stocke un type Ã 
taille dynamique.</p>
<!--
So what do we do? In this case, you already know the answer: we make the types
of `s1` and `s2` a `&str` rather than a `str`. Recall that in the [â€œString
Slicesâ€][string-slices]<!-- ignore -- > section of Chapter 4, we said the slice
data structure stores the starting position and the length of the slice.
-->
<p>Donc qu'est-ce qu'on peut faireÂ ? Dans ce cas, vous connaissez dÃ©jÃ  la rÃ©ponseÂ :
nous faisons en sorte que le type de <code>s1</code> et <code>s2</code> soit <code>&amp;str</code> plutÃ´t que <code>str</code>.
Souvenez-vous que dans la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res">â€œLes slices de chaÃ®nes de caractÃ¨resâ€</a><!-- ignore -->
du chapitre 4, nous avions dit que la structure de donnÃ©es slice stockait
l'emplacement de dÃ©part et la longueur de la slice.</p>
<!--
So although a `&T` is a single value that stores the memory address of where
the `T` is located, a `&str` is *two* values: the address of the `str` and its
length. As such, we can know the size of a `&str` value at compile time: itâ€™s
twice the length of a `usize`. That is, we always know the size of a `&str`, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.
-->
<p>Aussi, bien qu'un <code>&amp;T</code> soit une seule valeur qui stocke l'adresse mÃ©moire d'oÃ¹
se trouve le <code>T</code>, un <code>&amp;str</code> reprÃ©sente <em>deux</em> valeursÂ : l'adresse du <code>str</code> et sa
longueur. Ainsi, nous pouvons connaÃ®tre la taille d'une valeur <code>&amp;str</code> Ã  la
compilationÂ : elle vaut deux fois la taille d'un <code>usize</code>. Ce faisant, nous
connaissons toujours la taille d'un <code>&amp;str</code>, peu importe la longueur de la chaÃ®ne
de caractÃ¨res sur laquelle cela pointe. GÃ©nÃ©ralement, c'est comme cela que les
types Ã  taille dynamique sont utilisÃ©s en RustÂ : ils ont des mÃ©tadonnÃ©es
supplÃ©mentaires qui stockent la taille des informations dynamiques. La rÃ¨gle
d'or des types Ã  taille dynamique est que nous devons toujours placer les
valeurs Ã  types Ã  taille dynamique dans une sorte de pointeur.</p>
<!--
We can combine `str` with all kinds of pointers: for example, `Box<str>` or
`Rc<str>`. In fact, youâ€™ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the [â€œUsing Trait Objects That
Allow for Values of Different
Typesâ€][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` (`Rc<dyn
Trait>` would work too).
-->
<p>Nous pouvons combiner <code>str</code> avec n'importe quel type de pointeurÂ : par exemple,
<code>Box&lt;str&gt;</code> ou <code>Rc&lt;str&gt;</code>. En fait, vous avez vu cela dÃ©jÃ  auparavant mais avec un
type Ã  taille dynamiqueÂ : les traits. Chaque trait est un type Ã  taille
dynamique auquel nous pouvons nous rÃ©fÃ©rer en utilisant le nom du trait. Dans
<a href="ch17-02-trait-objects.html">une section</a><!--
ignore --> du chapitre 17, nous avions mentionnÃ© que pour utiliser les traits
comme des objets traits, nous devions les utiliser avec un pointeur, comme le
<code>&amp;dyn Trait</code> ou <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> devrait aussi fonctionner).</p>
<!--
To work with DSTs, Rust has a particular trait called the `Sized` trait to
determine whether or not a typeâ€™s size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on `Sized` to every generic function.
That is, a generic function definition like this:
-->
<p>Pour pouvoir travailler avec les DST, Rust a un trait particulier <code>Sized</code> pour
dÃ©terminer si oui ou non la taille d'un type est connue Ã  la compilation. Ce
trait est automatiquement implÃ©mentÃ© sur tout ce qui a une taille connue Ã  la
compilation. De plus, Rust ajoute implicitement le trait liÃ© <code>Sized</code> sur chaque
fonction gÃ©nÃ©rique. Ainsi, la dÃ©finition d'une fonction gÃ©nÃ©rique comme
celle-ciÂ :</p>
<!--
```rust,ignore
fn generic<T>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T&gt;(t: T) {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
is actually treated as though we had written this:
-->
<p>... est en rÃ©alitÃ© traitÃ©e comme si nous avions Ã©cris ceciÂ :</p>
<!--
```rust,ignore
fn generic<T: Sized>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: Sized&gt;(t: T) {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:
-->
<p>Par dÃ©faut, les fonctions gÃ©nÃ©riques vont fonctionner uniquement sur les types
qui ont une taille connue Ã  la compilation. Cependant, vous pouvez utiliser la
syntaxe spÃ©ciale suivante pour Ã©viter cette restrictionÂ :</p>
<!--
```rust,ignore
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: ?Sized&gt;(t: &amp;T) {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
A trait bound on `?Sized` is the opposite of a trait bound on `Sized`: we would
read this as â€œ`T` may or may not be `Sized`.â€ This syntax is only available for
`Sized`, not any other traits.
-->
<p>Le trait liÃ© <code>?Sized</code> est l'opposÃ© du trait liÃ© <code>Sized</code>Â : nous pourrions lire
ceci comme Ã©tant â€œ<code>T</code> peut Ãªtre ou non un <code>Sized</code>â€. Cette syntaxe est disponible
uniquement pour <code>Sized</code>, et non pas pour les autres traits.</p>
<!--
Also note that we switched the type of the `t` parameter from `T` to `&T`.
Because the type might not be `Sized`, we need to use it behind some kind of
pointer. In this case, weâ€™ve chosen a reference.
-->
<p>Remarquez aussi que nous avons changÃ© le type du paramÃ¨tre <code>t</code> de <code>T</code> en <code>&amp;T</code>.
Comme ce type pourrait ne pas Ãªtre un <code>Sized</code>, nous devons l'utiliser avec
quelque chose qui sert de pointeur. Dans ce cas, nous avons choisi une
rÃ©fÃ©rence.</p>
<!--
Next, weâ€™ll talk about functions and closures!
-->
<p>Dans la partie suivante, nous allons parler des fonctions et des fermeturesÂ !</p>
<!--
[encapsulation-that-hides-implementation-details]:
ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details
[string-slices]: ch04-03-slices.html#string-slices
[the-match-control-flow-operator]:
ch06-02-match.html#the-match-control-flow-operator
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[using-the-newtype-pattern]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch19-03-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
