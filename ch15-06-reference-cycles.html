<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html" class="active"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/195">Pull Request</a>.</p>
</blockquote>
<!--
## Reference Cycles Can Leak Memory
-->
<h2 id="les-boucles-de-rÃ©fÃ©rences-qui-peuvent-provoquer-des-fuites-de-mÃ©moire"><a class="header" href="#les-boucles-de-rÃ©fÃ©rences-qui-peuvent-provoquer-des-fuites-de-mÃ©moire">Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></h2>
<!--
Rustâ€™s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a *memory leak*).
Preventing memory leaks entirely is not one of Rustâ€™s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using `Rc<T>`
and `RefCell<T>`: itâ€™s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.
-->
<p>Les garanties de sÃ©curitÃ© de la mÃ©moire de Rust rendent difficile, mais pas
impossible, la crÃ©ation accidentelle de mÃ©moire qui n'est jamais nettoyÃ©e
(aussi appelÃ©e <em>fuite de mÃ©moire</em>). Eviter absolument les fuites de mÃ©moire
n'est pas une des garanties de Rust comme c'est le cas pour l'accÃ¨s
concurrent Ã  la compilation, ce qui signifie que les fuites de mÃ©moire ne
sont dangereuses, pour Rust. Nous pouvons constater que Rust permet les fuites
de mÃ©moire en utilisant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code>Â : il est possible de crÃ©er des
rÃ©fÃ©rences oÃ¹ les Ã©lÃ©ments se rÃ©fÃ¨rent entre eux de maniÃ¨re cyclique. Cela
crÃ©e des fuites de mÃ©moire car le compteur de rÃ©fÃ©rences de chaque Ã©lÃ©ment
dans la boucle de rÃ©fÃ©rences ne vaudra jamais 0, et les valeurs ne seront
jamais libÃ©rÃ©es.</p>
<!--
### Creating a Reference Cycle
-->
<h3 id="crÃ©er-une-boucle-de-rÃ©fÃ©rences"><a class="header" href="#crÃ©er-une-boucle-de-rÃ©fÃ©rences">CrÃ©er une boucle de rÃ©fÃ©rences</a></h3>
<!--
Letâ€™s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the `List` enum and a `tail` method in Listing
15-25:
-->
<p>Voyons comment une boucle de rÃ©fÃ©rences peut exister et comment l'Ã©viter, en
commenÃ§ant par la dÃ©finition de l'Ã©numÃ©ration <code>List</code> et la mÃ©thode <code>parcourir</code>
de l'encart 15-25Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 15-25: A cons list definition that holds a
`RefCell<T>` so we can modify what a `Cons` variant is referring to</span>
-->
<p><span class="caption">Encart 15-25Â : une liste de construction qui stocke une
<code>RefCell&lt;T&gt;</code> pour que nous puissions modifier ce sur quoi une variante <code>Cons</code>
pointe</span></p>
<!--
Weâ€™re using another variation of the `List` definition from Listing 15-5. The
second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that
instead of having the ability to modify the `i32` value as we did in Listing
15-24, we want to modify which `List` value a `Cons` variant is pointing to.
Weâ€™re also adding a `tail` method to make it convenient for us to access the
second item if we have a `Cons` variant.
-->
<p>Nous utilisons une autre variation de la dÃ©finition de <code>List</code> de l'encart 15-5.
Le second Ã©lÃ©ment dans la variante <code>Cons</code> est maintenant un
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, ce qui signifie qu'au lieu de pouvoir modifier la valeur
<code>i32</code> comme nous l'avions fait dans l'encart 15-24, nous modifions ce sur quoi
une variante <code>Cons</code> pointe (qui reste une valeur <code>List</code>). Nous ajoutons
Ã©galement une mÃ©thode <code>parcourir</code> pour nous faciliter l'accÃ¨s au second Ã©lÃ©ment
si nous avons une variante <code>Cons</code>.</p>
<!--
In Listing 15-26, weâ€™re adding a `main` function that uses the definitions in
Listing 15-25. This code creates a list in `a` and a list in `b` that points to
the list in `a`. Then it modifies the list in `a` to point to `b`, creating a
reference cycle. There are `println!` statements along the way to show what the
reference counts are at various points in this process.
-->
<p>Dans l'encart 15-26, nous ajoutons une fonction <code>main</code> qui utilise les
dÃ©finitions de l'encart 15-25. Ce code crÃ©e une liste dans <code>a</code> et une liste
dans <code>b</code> qui pointe sur la liste de <code>a</code>. Ensuite, on modifie la liste de <code>a</code>
pour pointer sur <code>b</code>, ce qui crÃ©e une boucle de rÃ©fÃ©rences. Il y a aussi des
instructions <code>println!</code> tout du long pour montrer la valeur des compteurs de
rÃ©fÃ©rences Ã  diffÃ©rents endroits du processus.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use crate::List::{Cons, Nil};
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell<Rc<List>>),
#     Nil,
# }
# 
# impl List {
#     fn tail(&self) -> Option<&RefCell<Rc<List>>> {
#         match self {
#             Cons(_, item) => Some(item),
#             Nil => None,
#         }
#     }
# }
# 
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;compteur initial de a = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;prochain Ã©lÃ©ment de a = {:?}&quot;, a.parcourir());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;compteur de a aprÃ¨s crÃ©ation de b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;compteur initial de b = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;prochain Ã©lÃ©ment de b = {:?}&quot;, b.parcourir());

    if let Some(lien) = a.parcourir() {
        *lien.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;compteur de b aprÃ¨s avoir changÃ© a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;compteur de a aprÃ¨s avoir changÃ© a = {}&quot;, Rc::strong_count(&amp;a));

    // DÃ©commentez la ligne suivante pour constater que nous sommes dans
    // une boucle de rÃ©fÃ©rences, cela fera dÃ©border la pile
    // println!(&quot;prochain Ã©lÃ©ment de a = {:?}&quot;, a.parcourir());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-26: Creating a reference cycle of two `List`
values pointing to each other</span>
-->
<p><span class="caption">Encart 15-26Â : crÃ©ation d'une boucle de rÃ©fÃ©rences de
deux valeurs <code>List</code> qui se pointent mutuellement dessus</span></p>
<!--
We create an `Rc<List>` instance holding a `List` value in the variable `a`
with an initial list of `5, Nil`. We then create an `Rc<List>` instance
holding another `List` value in the variable `b` that contains the value 10 and
points to the list in `a`.
-->
<p>Nous crÃ©ons une instance <code>Rc&lt;List&gt;</code> qui stocke une valeur <code>List</code> dans la
variable <code>a</code> avec une valeur initiale de <code>5, Nil</code>. Nous crÃ©ons ensuite une
instance <code>Rc&lt;List&gt;</code> qui stocke une autre valeur <code>List</code> dans la variable <code>b</code>
qui contient la valeur 10 et pointe vers la liste dans <code>a</code>.</p>
<!--
We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We
do that by using the `tail` method to get a reference to the
`RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use
the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside
from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`.
-->
<p>Nous modifions <code>a</code> afin qu'elle pointe sur <code>b</code> au lieu de <code>Nil</code>, ce qui crÃ©e
une boucle. Nous faisons ceci en utilisant la mÃ©thode <code>parcourir</code> pour obtenir
une rÃ©fÃ©rence au <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> prÃ©sent dans <code>a</code>, que nous plaÃ§ons dans la
variable <code>link</code>. Ensuite nous utilisons la mÃ©thode <code>borrow_mut</code> sur le
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> pour changer la valeur prÃ©sente en son sein par une
<code>Rc&lt;List&gt;</code> qui stocke une valeur <code>Nil</code> vers le <code>Rc&lt;List&gt;</code> prÃ©sent dans <code>b</code>.</p>
<!--
When we run this code, keeping the last `println!` commented out for the
moment, weâ€™ll get this output:
-->
<p>Lorsque nous exÃ©cutons ce code, en gardant le dernier <code>println!</code> commentÃ©
pour le moment, nous obtenons ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
compteur initial de a = 1
prochain Ã©lÃ©ment de a = Some(RefCell { value: Nil })
compteur de a aprÃ¨s crÃ©ation de b = 2
compteur initial de b = 1
prochain Ã©lÃ©ment de b = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
compteur de b aprÃ¨s avoir changÃ© a = 2
compteur de a aprÃ¨s avoir changÃ© a = 2
</code></pre>
<!--
The reference count of the `Rc<List>` instances in both `a` and `b` are 2
after we change the list in `a` to point to `b`. At the end of `main`, Rust
will try to drop `b` first, which will decrease the count of the `Rc<List>`
instance in `b` by 1.
-->
<p>Les compteurs de rÃ©fÃ©rences des instances de <code>Rc&lt;List&gt;</code> valent tous les deux 2
pour <code>a</code> et <code>b</code> aprÃ¨s avoir modifiÃ© <code>a</code> pour qu'elle pointe sur <code>b</code>. A la fin
du <code>main</code>, Rust va nettoyer d'abord <code>b</code>, ce qui va rÃ©duire le compteur de
l'instance <code>Rc&lt;List&gt;</code> de <code>b</code> de 1.</p>
<!--
However, because `a` is still referencing the `Rc<List>` that was in `b`, that
`Rc<List>` has a count of 1 rather than 0, so the memory the `Rc<List>` has on
the heap wonâ€™t be dropped. The memory will just sit there with a count of 1,
forever. To visualize this reference cycle, weâ€™ve created a diagram in Figure
15-4.
-->
<p>Cependant, comme <code>a</code> pointe toujours sur le <code>Rc&lt;List&gt;</code> qui Ã©tait sur <code>b</code>, le
compteur de son <code>Rc&lt;List&gt;</code> vaudra toujours 1 au lieu de 0, donc la mÃ©moire de
sur le tas de ce <code>Rc&lt;List&gt;</code> ne sera pas nettoyÃ©. La mÃ©moire va juste rester ici
avec un compteur Ã  1, pour toujours. Pour reprÃ©senter la boucle de rÃ©fÃ©rences,
nous avons crÃ©Ã© un diagramme dans l'illustration 15-4.</p>
<!--
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
-->
<p><img
    alt="Une boucle de rÃ©fÃ©rences de listes"
    src="img/trpl15-04.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-4: A reference cycle of lists `a` and `b`
pointing to each other</span>
-->
<p><span class="caption">Illustration 15-4Â : une boucle de rÃ©fÃ©rences entre les
listes <code>a</code> et <code>b</code> qui se pointent mutuellement dessus</span></p>
<!--
If you uncomment the last `println!` and run the program, Rust will try to
print this cycle with `a` pointing to `b` pointing to `a` and so forth until it
overflows the stack.
-->
<p>Si vous dÃ©commentez le dernier <code>println!</code> et que vous exÃ©cutez le programme,
Rust va essayer d'afficher cette boucle avec <code>a</code> qui pointe sur <code>b</code> qui pointe
sur <code>a</code> ... et ainsi de suite jusqu'Ã  ce que cela fasse dÃ©border la pile.</p>
<!--
In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle arenâ€™t very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.
-->
<p>Dans ce cas, juste aprÃ¨s que nous ayons crÃ©Ã© la boucle de rÃ©fÃ©rences, le
programme se termine. Les consÃ©quences de cette boucle ne sont dÃ©sastreuses.
Cependant, si un programme plus complexe alloue beaucoup de mÃ©moire dans une
boucle de rÃ©fÃ©rences et la garde pendant longtemps, le programme va utiliser
bien plus de mÃ©moire qu'il a besoin et pourrait surcharger le systÃ¨me, qui
devrait Ã©puiser la mÃ©moire disponible.</p>
<!--
Creating reference cycles is not easily done, but itâ€™s not impossible either.
If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you donâ€™t create cycles; you canâ€™t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.
-->
<p>La crÃ©ation de boucles de rÃ©fÃ©rences n'est pas facile Ã  rÃ©aliser, mais n'est pas
non plus impossible. Si vous avez des valeurs <code>RefCell&lt;T&gt;</code> qui contiennent des
valeurs <code>Rc&lt;T&gt;</code> ou combinaisons similaires de types emboÃ®tÃ©es avec de la
mutabilitÃ© interne et du comptage de rÃ©fÃ©rences, vous devez vous assurer que
vous ne crÃ©ez pas de bouclesÂ ; vous ne pouvez pas compter sur Rust pour les
dÃ©tecter. La crÃ©ation de boucle de rÃ©fÃ©rences devrait Ãªtre un bogue de logique
de votre programme dont vous devriez rÃ©duire le risque en pratiquant des tests
automatisÃ©s, des revues de code, ainsi que d'autres pratiques de dÃ©veloppement.</p>
<!--
Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references donâ€™t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want `Cons`
variants to own their list, so reorganizing the data structure isnâ€™t possible.
Letâ€™s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.
-->
<p>Une autre solution pour Ã©viter les boucles de rÃ©fÃ©rences est de rÃ©organiser vos
structures de donnÃ©es afin que certaines rÃ©fÃ©rences prennent possession et
d'autres non. Par consÃ©quent, vous pouvez obtenir des boucles de certaines
rÃ©fÃ©rences qui prennent possession ou d'autres rÃ©fÃ©rences qui ne prennent pas
possession, et seules celles qui prennent possession dÃ©cident si oui ou non une
valeur peut Ãªtre libÃ©rÃ©e. Dans l'encart 15-25, nous voulons toujours que les
variantes <code>Cons</code> possÃ¨dent leur propre liste, donc il est impossible de
rÃ©organiser la structure des donnÃ©es. Voyons maintenant un exemple qui utilise
des branches constituÃ©es de nÅ“uds parents et enfants pour voir lorsque les
liens qui ne prennent pas possession sont appropriÃ©s pour Ã©viter les boucles de
rÃ©fÃ©rences.</p>
<!--
### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`
-->
<h3 id="eviter-les-boucles-de-rÃ©fÃ©rences--transformer-un-rct-en-weakt"><a class="header" href="#eviter-les-boucles-de-rÃ©fÃ©rences--transformer-un-rct-en-weakt">Eviter les boucles de rÃ©fÃ©rencesÂ : transformer un <code>Rc&lt;T&gt;</code> en <code>Weak&lt;T&gt;</code></a></h3>
<!--
So far, weâ€™ve demonstrated that calling `Rc::clone` increases the
`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned
up if its `strong_count` is 0. You can also create a *weak reference* to the
value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a
reference to the `Rc<T>`. When you call `Rc::downgrade`, you get a smart
pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the
`Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1.
The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>`
references exist, similar to `strong_count`. The difference is the `weak_count`
doesnâ€™t need to be 0 for the `Rc<T>` instance to be cleaned up.
-->
<p>PrÃ©cÃ©demment, nous avons dÃ©montrÃ© que l'appel Ã  <code>Rc::clone</code> augmente le
<code>strong_count</code> d'une instance de <code>Rc&lt;T&gt;</code>, et une instance <code>Rc&lt;T&gt;</code> est nettoyÃ©e
seulement si son <code>strong_count</code> est Ã  0. Vous pouvez aussi crÃ©er un <em>pointeur
faible</em> (NdTÂ : d'oÃ¹ le <code>weak</code>) vers la valeur prÃ©sente dans une instance <code>Rc&lt;T&gt;</code>
en appelant <code>Rc::downgrade</code> et en lui passant une rÃ©fÃ©rence vers le <code>Rc&lt;T&gt;</code>.
Lorsque vous faites appel Ã  <code>Rc::downgrade</code>, vous obtenez un pointeur
intelligent du type <code>Weak&lt;T&gt;</code>. PlutÃ´t que d'augmenter le <code>strong_count</code> de
l'instance de 1, l'appel Ã  <code>Rc::downgrade</code> augmente le <code>weak_count</code> de 1. Le
type <code>Rc&lt;T&gt;</code> utilise le <code>weak_count</code> pour compter combien de rÃ©fÃ©rences
<code>Weak&lt;T&gt;</code> existent, de la mÃªme maniÃ¨re que <code>strong_count</code>. La diffÃ©rence rÃ©side
dans le fait que <code>weak_count</code> n'a pas besoin d'Ãªtre 0 pour que l'instance
<code>Rc&lt;T&gt;</code> soit nettoyÃ©e.</p>
<!--
Strong references are how you can share ownership of an `Rc<T>` instance. Weak
references donâ€™t express an ownership relationship. They wonâ€™t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.
-->
<p>Les rÃ©fÃ©rences fortes dÃ©signent la maniÃ¨re de partager la propriÃ©tÃ© d'une
instance <code>Rc&lt;T&gt;</code>. Les pointeurs faibles ne dÃ©signent pas le lien qui prend
possession. Ils ne vont provoquer de boucle de rÃ©fÃ©rences car n'importe quelle
boucle qui implique des pointeurs faibles se terminera lorsque le compteur de
rÃ©fÃ©rences fortes liÃ© vaudra 0.</p>
<!--
Because the value that `Weak<T>` references might have been dropped, to do
anything with the value that a `Weak<T>` is pointing to, you must make sure the
value still exists. Do this by calling the `upgrade` method on a `Weak<T>`
instance, which will return an `Option<Rc<T>>`. Youâ€™ll get a result of `Some`
if the `Rc<T>` value has not been dropped yet and a result of `None` if the
`Rc<T>` value has been dropped. Because `upgrade` returns an `Option<Rc<T>>`,
Rust will ensure that the `Some` case and the `None` case are handled, and
there wonâ€™t be an invalid pointer.
-->
<p>Comme la valeur contenue dans une rÃ©fÃ©rence <code>Weak&lt;T&gt;</code> peut Ãªtre libÃ©rÃ©e, pour
pouvoir faire quelque chose avec cette valeur, vous devez vous assurer qu'elle
existe toujours. Vous pouvez faire ceci en appelant la mÃ©thode <code>upgrade</code> sur
une instance <code>Weak&lt;T&gt;</code>, qui va retourner une <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Ce rÃ©sultat
retournera <code>Some</code> si la valeur <code>Rc&lt;T&gt;</code> n'a pas encore Ã©tÃ© libÃ©rÃ©e, et un <code>None</code>
si la valeur <code>Rc&lt;T&gt;</code> a Ã©tÃ© libÃ©rÃ©e. Comme <code>upgrade</code> retourne une
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust va s'assurer que les cas de <code>Some</code> et de <code>None</code> sont bien
gÃ©rÃ©s, et qu'il n'existe pas de pointeur invalide.</p>
<!--
As an example, rather than using a list whose items know only about the next
item, weâ€™ll create a tree whose items know about their children items *and*
their parent items.
-->
<p>Par exemple, plutÃ´t que d'utiliser une liste dont les Ã©lÃ©ments ne connaissent
que les Ã©lÃ©ments suivants, nous allons crÃ©er un arbre dont les Ã©lÃ©ments
connaissent les Ã©lÃ©ments enfants <em>et</em> leurs Ã©lÃ©ments parents.</p>
<!--
#### Creating a Tree Data Structure: a `Node` with Child Nodes
-->
<h4 id="crÃ©er-une-structure-darbre-de-donnÃ©es--un-noeud-avec-des-nÅ“uds-enfants"><a class="header" href="#crÃ©er-une-structure-darbre-de-donnÃ©es--un-noeud-avec-des-nÅ“uds-enfants">CrÃ©er une structure d'arbre de donnÃ©esÂ : un <code>Noeud</code> avec des nÅ“uds enfants</a></h4>
<!--
To start, weâ€™ll build a tree with nodes that know about their child nodes.
Weâ€™ll create a struct named `Node` that holds its own `i32` value as well as
references to its children `Node` values:
-->
<p>Pour commencer, nous allons crÃ©er un arbre avec des nÅ“uds qui connaissent
leurs nÅ“uds enfants. Nous allons crÃ©er une structure <code>Noeud</code> qui contient sa
propre valeur ainsi que les rÃ©fÃ©rences vers ses <code>Noeud</code> enfantsÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         children: RefCell::new(vec![]),
#     });
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<!--
We want a `Node` to own its children, and we want to share that ownership with
variables so we can access each `Node` in the tree directly. To do this, we
define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to
modify which nodes are children of another node, so we have a `RefCell<T>` in
`children` around the `Vec<Rc<Node>>`.
-->
<p>Nous souhaitons qu'un <code>Noeud</code> prenne possession de ses enfants, et nous
souhaitons partager la possession avec des variables afin d'accÃ©der directement
Ã  chaque <code>Noeud</code> de l'arbre. Pour pouvoir faire ceci, nous dÃ©finissons les
Ã©lÃ©ments du <code>Vec&lt;T&gt;</code> pour Ãªtre des valeurs du type <code>Rc&lt;Noeud&gt;</code>. Nous souhaitons
Ã©galement modifier tel nÅ“ud est enfant de tel autre nÅ“ud, donc nous plaÃ§ons
un <code>RefCell&lt;T&gt;</code> dans <code>enfants</code> qui contient ce <code>Vec&lt;Rc&lt;Noeud&gt;&gt;</code>.</p>
<!--
Next, weâ€™ll use our struct definition and create one `Node` instance named
`leaf` with the value 3 and no children, and another instance named `branch`
with the value 5 and `leaf` as one of its children, as shown in Listing 15-27:
-->
<p>Ensuite, nous allons utiliser notre dÃ©finition de structure et crÃ©er une
instance de <code>Noeud</code> qui s'appellera <code>feuille</code> avec la valeur <code>3</code> et sans
enfant, comme dans l'encart 15-27Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FilenameÂ : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        enfants: RefCell::new(vec![]),
    });

    let branche = Rc::new(Noeud {
        valeur: 5,
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-27: Creating a `leaf` node with no children
and a `branch` node with `leaf` as one of its children</span>
-->
<p><span class="caption">Encart 15-27Â : crÃ©ation d'un nÅ“ud <code>feuille</code> sans aucun
enfant et un nÅ“ud <code>branche</code> avec <code>feuille</code> comme enfant</span></p>
<!--
We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the
`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from
`branch` to `leaf` through `branch.children`, but thereâ€™s no way to get from
`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and
doesnâ€™t know theyâ€™re related. We want `leaf` to know that `branch` is its
parent. Weâ€™ll do that next.
-->
<p>Nous crÃ©ons un clone du <code>Rc&lt;Noeud&gt;</code> dans <code>feuille</code> et nous le stockons dans
<code>branche</code>, ce qui signifie que le <code>Noeud</code> dans <code>feuille</code> a maintenant deux
propriÃ©tairesÂ : <code>feuille</code> et <code>branche</code>. Nous pouvons obtenir <code>feuille</code> Ã  partir
de <code>branche</code> en utilisant <code>branche.feuille</code>, mais il n'y a pas de moyen
d'obtenir <code>branche</code> Ã  partir de <code>feuille</code>. La raison est que <code>feuille</code> n'a pas
de rÃ©fÃ©rence vers <code>branche</code> et ne sait pas s'ils sont liÃ©s. Nous voulons que
<code>feuille</code> sache quelle <code>branche</code> est son parent. C'est ce que nous allons faire
dÃ¨s maintenant.</p>
<!--
#### Adding a Reference from a Child to Its Parent
-->
<h4 id="ajouter-une-rÃ©fÃ©rence-Ã -un-enfant-vers-son-parent"><a class="header" href="#ajouter-une-rÃ©fÃ©rence-Ã -un-enfant-vers-son-parent">Ajouter une rÃ©fÃ©rence Ã  un enfant vers son parent</a></h4>
<!--
To make the child node aware of its parent, we need to add a `parent` field to
our `Node` struct definition. The trouble is in deciding what the type of
`parent` should be. We know it canâ€™t contain an `Rc<T>`, because that would
create a reference cycle with `leaf.parent` pointing to `branch` and
`branch.children` pointing to `leaf`, which would cause their `strong_count`
values to never be 0.
-->
<p>Pour que le nÅ“ud enfant connaisse son parent, nous devons ajouter un champ
<code>parent</code> vers notre dÃ©finition de structure <code>Noeud</code>. La difficultÃ© ici est de
choisir quel sera le type de <code>parent</code>. Nous savons qu'il ne peut pas contenir
de <code>Rc&lt;T&gt;</code>, car cela crÃ©era une boucle de rÃ©fÃ©rence avec <code>feuille.parent</code> qui
pointe sur <code>branche</code> et <code>branche.enfant</code> qui pointe sur <code>feuille</code>, ce qui va
faire que leurs valeurs <code>strong_count</code> ne sera jamais Ã  0.</p>
<!--
Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!
-->
<p>En concevant le lien d'une autre maniÃ¨re, un nÅ“ud parent devrait prendre
possession de ses enfantsÂ : si un nÅ“ud parent est libÃ©rÃ©, ses nÅ“uds enfants
devraient aussi Ãªtre libÃ©rÃ©s. Cependant, un enfant ne devrait pas prendre
possession de son parentÂ : si nous libÃ©rons un nÅ“ud enfant, le parent doit
toujours exister. C'est donc un cas d'emploi pour les pointeurs faiblesÂ !</p>
<!--
So instead of `Rc<T>`, weâ€™ll make the type of `parent` use `Weak<T>`,
specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks
like this:
-->
<p>Donc, plutÃ´t qu'un <code>Rc&lt;T&gt;</code>, nous allons faire en sorte que le type de <code>parent</code>
soit un <code>Weak&lt;T&gt;</code>, plus prÃ©cisÃ©ment un <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code>. Maintenant,
la dÃ©finition de notre structure <code>Noeud</code> devrait ressembler Ã  ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![]),
#     });
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# 
#     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<!--
A node will be able to refer to its parent node but doesnâ€™t own its parent.
In Listing 15-28, we update `main` to use this new definition so the `leaf`
node will have a way to refer to its parent, `branch`:
-->
<p>Un nÅ“ud devrait pouvoir avoir une rÃ©fÃ©rence vers son nÅ“ud parent, mais il ne
devrait pas prendre possession de son parent. Dans l'encart 15-28, nous mettons
Ã  jour cette nouvelle dÃ©finition pour que le nÅ“ud <code>feuille</code> puisse avoir un
moyen de pointer vers son parent, <code>branche</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());

    let branche = Rc::new(Noeud {
        valeur: 5,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });

    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-28: A `leaf` node with a weak reference to its
parent node `branch`</span>
-->
<p><span class="caption">Encart 15-28Â : un nÅ“ud <code>feuille</code> avec un pointeur faible
vers son nÅ“ud parent, <code>branche</code></span></p>
<!--
Creating the `leaf` node looks similar to how creating the `leaf` node looked
in Listing 15-27 with the exception of the `parent` field: `leaf` starts out
without a parent, so we create a new, empty `Weak<Node>` reference instance.
-->
<p>La crÃ©ation du nÅ“ud <code>feuille</code> semble Ãªtre identique Ã  la crÃ©ation du nÅ“ud
<code>feuille</code> de l'encart 15-27, sauf pour le champ <code>parent</code>Â : <code>feuille</code> commence
sans parent, donc nous crÃ©ons une nouvelle instance de rÃ©fÃ©rence de type
<code>Weak&lt;Noeud&gt;</code>, qui est vide.</p>
<!--
At this point, when we try to get a reference to the parent of `leaf` by using
the `upgrade` method, we get a `None` value. We see this in the output from the
first `println!` statement:
-->
<p>A ce moment-lÃ , lorsque nous essayons d'obtenir une rÃ©fÃ©rence vers le parent de
<code>feuille</code> en utilisant la mÃ©thode <code>upgrade</code>, nous obtenons une valeur <code>None</code>.
Nous constatons cela dans la premiÃ¨re instruction <code>println!</code> sur la sortieÂ :</p>
<!--
```text
leaf parent = None
```
-->
<pre><code class="language-text">parent de la feuille = None
</code></pre>
<!--
When we create the `branch` node, it will also have a new `Weak<Node>`
reference in the `parent` field, because `branch` doesnâ€™t have a parent node.
We still have `leaf` as one of the children of `branch`. Once we have the
`Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>`
reference to its parent. We use the `borrow_mut` method on the
`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the
`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from
the `Rc<Node>` in `branch.`
-->
<p>Lorsque nous crÃ©ons le nÅ“ud <code>branche</code>, il va aussi avoir une nouvelle
rÃ©fÃ©rence <code>Weak&lt;Noeud&gt;</code> dans le champ <code>parent</code>, car <code>branche</code> n'a pas de nÅ“ud
parent. Nous avons nÃ©anmoins <code>feuille</code> dans <code>enfants</code> de <code>branche</code>. Une fois
que nous avons l'instance de <code>Noeud</code> dans <code>branche</code>, nous pouvons modifier
<code>feuille</code> pour lui donner une rÃ©fÃ©rence <code>Weak&lt;Noeud&gt;</code> vers son parent. Nous
utilisons la mÃ©thode <code>borrow_mut</code> sur la <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code> du champ
<code>parent</code> de <code>feuille</code>, et ensuite nous utilisons la fonction <code>Rc::downgrade</code>
pour crÃ©er une rÃ©fÃ©rence de type <code>Weak&lt;Node&gt;</code> vers <code>branche</code> Ã  partir du
<code>Rc&lt;Noeud&gt;</code> prÃ©sent dans <code>branche</code>.</p>
<!--
When we print the parent of `leaf` again, this time weâ€™ll get a `Some` variant
holding `branch`: now `leaf` can access its parent! When we print `leaf`, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:
-->
<p>Lorsque nous affichons Ã  nouveau le parent de <code>feuille</code>, cette fois nous
obtenons la variante <code>Some</code> qui contient <code>branche</code>Â : dÃ©sormais, <code>feuille</code> peut
accÃ©der Ã  son parentÂ ! Lorsque nous affichons <code>feuille</code>, nous avons aussi Ã©vitÃ©
la boucle qui aurait probablement fini en dÃ©bordement de pile comme nous
l'avions expÃ©rimentÃ© dans l'encart 15-26Â ; les rÃ©fÃ©rences <code>Weak&lt;Noeud&gt;</code>
s'Ã©crivent <code>(Weak)</code>Â :</p>
<!--
```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```
-->
<pre><code class="language-text">parent de la feuille = Some(Noeud { valeur: 5, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [Noeud { valeur: 3, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [] } }] } })
</code></pre>
<!--
The lack of infinite output indicates that this code didnâ€™t create a reference
cycle. We can also tell this by looking at the values we get from calling
`Rc::strong_count` and `Rc::weak_count`.
-->
<p>L'absence d'une sortie infinie nous confirme que ce code ne crÃ©e pas de boucle
de rÃ©fÃ©rences. Nous pouvons aussi le constater en affichant les valeurs que
nous pouvons obtenir en faisant appel Ã  <code>Rc::strong_count</code> et <code>Rc::weak_count</code>.</p>
<!--
#### Visualizing Changes to `strong_count` and `weak_count`
-->
<h4 id="visualiser-les-modifications-de-strong_count-et-weak_count"><a class="header" href="#visualiser-les-modifications-de-strong_count-et-weak_count">Visualiser les modifications de <code>strong_count</code> et <code>weak_count</code></a></h4>
<!--
Letâ€™s look at how the `strong_count` and `weak_count` values of the `Rc<Node>`
instances change by creating a new inner scope and moving the creation of
`branch` into that scope. By doing so, we can see what happens when `branch` is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:
-->
<p>Regardons comment changent les valeurs <code>strong_count</code> et <code>weak_count</code> des
instances de <code>Rc&lt;Noeud&gt;</code> en crÃ©ant une portÃ©e interne et en dÃ©plaÃ§ant la
crÃ©ation de <code>branche</code> dans cette portÃ©e. En faisant ceci, nous pourrons
constater ce qui se passe lorsque <code>branche</code> est crÃ©Ã©e et lorsqu'elle sera
libÃ©rÃ©e lorsqu'elle sortira de la portÃ©e. Ces modifications sont prÃ©sentÃ©es
dans l'encart 15-29Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );

    {
        let branche = Rc::new(Noeud {
            valeur: 5,
            parent: RefCell::new(Weak::new()),
            enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
        });

        *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

        println!(
            &quot;branche strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branche),
            Rc::weak_count(&amp;branche),
        );

        println!(
            &quot;feuille strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;feuille),
            Rc::weak_count(&amp;feuille),
        );
    }

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-29: Creating `branch` in an inner scope and
examining strong and weak reference counts</span>
-->
<p><span class="caption">Encart 15-29Â : crÃ©ation de <code>branche</code> dans une portÃ©e
interne et vÃ©rification des compteurs de rÃ©fÃ©rences strong et weak</span></p>
<!--
After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak
count of 0. In the inner scope, we create `branch` and associate it with
`leaf`, at which point when we print the counts, the `Rc<Node>` in `branch`
will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing
to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, weâ€™ll see
it will have a strong count of 2, because `branch` now has a clone of the
`Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak
count of 0.
-->
<p>AprÃ¨s la crÃ©ation de <code>feuille</code>, son <code>Rc&lt;Noeud&gt;</code> a le compteur strong Ã  1 et le
compteur weak Ã  0. Dans la portÃ©e interne, nous crÃ©ons <code>branche</code> et l'associons
Ã  <code>feuille</code>, et Ã  partir de lÃ , lorsque nous affichons les compteurs, le
<code>Rc&lt;Noeud&gt;</code> dans <code>branche</code> aura le compteur strong Ã  1 et le compteur weak Ã  1
(pour que <code>feuille.parent</code> pointe sur <code>branche</code> avec un <code>Weak&lt;Noeud&gt;</code>). Lorsque
nous affichons les compteurs dans <code>feuille</code> nous constatons qu'il a le compteur
strong Ã  2, car <code>branche</code> a maintenant un clone du <code>Rc&lt;Noeud&gt;</code> de <code>feuille</code>
stockÃ© dans <code>branche.enfants</code>, mais a toujours le compteur weak Ã  0.</p>
<!--
When the inner scope ends, `branch` goes out of scope and the strong count of
the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1
from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we
donâ€™t get any memory leaks!
-->
<p>Lorsque la portÃ©e interne se termine, <code>branche</code> sort de la portÃ©e et le
compteur strong de <code>Rc&lt;Noeud&gt;</code> dÃ©croÃ®t Ã  0, donc son <code>Noeud</code> est libÃ©rÃ©. Le
compteur weak Ã  1 de <code>feuille.parent</code> n'a aucune rÃ©percussion suite Ã  la
libÃ©ration ou non du <code>Noeud</code>, donc nous ne sommes pas dans une situation de
fuite de mÃ©moireÂ !</p>
<!--
If we try to access the parent of `leaf` after the end of the scope, weâ€™ll get
`None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong
count of 1 and a weak count of 0, because the variable `leaf` is now the only
reference to the `Rc<Node>` again.
-->
<p>Si nous essayons d'accÃ©der au parent de <code>feuille</code> aprÃ¨s la fin de la portÃ©e,
nous allons Ã  nouveau obtenir <code>None</code>. A la fin du programme, le <code>Rc&lt;Noeud&gt;</code>
dans <code>feuille</code> a son compteur strong Ã  1 et son compteur weak Ã  0, car la
variable <code>feuille</code> est Ã  nouveau la seule rÃ©fÃ©rence au <code>Rc&lt;Noeud&gt;</code>.</p>
<!--
All of the logic that manages the counts and value dropping is built into
`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By
specifying that the relationship from a child to its parent should be a
`Weak<T>` reference in the definition of `Node`, youâ€™re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.
-->
<p>Toute cette logique qui gÃ¨re les compteurs et les libÃ©rations des valeurs est
intÃ©grÃ©e dans <code>Rc&lt;T&gt;</code> et <code>Weak&lt;T&gt;</code> et leurs implÃ©mentations du trait <code>Drop</code>. En
prÃ©cisant dans la dÃ©finition de <code>Noeud</code> que le lien entre un enfant et son
parent doit Ãªtre une rÃ©fÃ©rence <code>Weak&lt;T&gt;</code>, vous pouvez avoir des nÅ“uds parents
qui pointent sur des nÅ“uds enfants et vice versa sans risquer de crÃ©er des
boucles de rÃ©fÃ©rences et des fuites de mÃ©moire.</p>
<!--
## Summary
-->
<h2 id="rÃ©sumÃ©"><a class="header" href="#rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
`Box<T>` type has a known size and points to data allocated on the heap. The
`Rc<T>` type keeps track of the number of references to data on the heap so
that data can have multiple owners. The `RefCell<T>` type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.
-->
<p>Ce chapitre a expliquÃ© l'utilisation des pointeurs intelligents pour appliquer
diffÃ©rentes garanties et compromis que celles qu'applique Rust par dÃ©faut avec
les rÃ©fÃ©rences classiques. Le type <code>Box&lt;T&gt;</code> a une taille connue et pointe sur
une donnÃ©e allouÃ©e sur le tas. Le type <code>Rc&lt;T&gt;</code> compte le nombre de rÃ©fÃ©rences
vers une donnÃ©e prÃ©sente sur le tas afin que cette donnÃ©e puisse avoir
plusieurs propriÃ©taires. Le type <code>RefCell&lt;T&gt;</code> nous permet de l'utiliser lorsque
nous avons besoin d'un type immuable mais que nous avons besoin de changer une
valeur interne Ã  ce type, grÃ¢ce Ã  sa fonctionnalitÃ© de mutabilitÃ© interneÂ ;
elle nous permet aussi d'appliquer les rÃ¨gles d'emprunt Ã  l'exÃ©cution plutÃ´t
qu'Ã  la compilation.</p>
<!--
Also discussed were the `Deref` and `Drop` traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using `Weak<T>`.
-->
<p>Nous avons aussi vu les traits <code>Deref</code> et <code>Drop</code>, qui offrent des
fonctionnalitÃ©s trÃ¨s importantes aux pointeurs intelligents. Nous avons
expÃ©rimentÃ© les boucles de rÃ©fÃ©rences qui peuvent causer des fuites de mÃ©moire
et nous avons vu comment les Ã©viter en utilisant <code>Weak&lt;T&gt;</code>.</p>
<!--
If this chapter has piqued your interest and you want to implement your own
smart pointers, check out [â€œThe Rustonomiconâ€][nomicon] for more useful
information.
-->
<p>Si ce chapitre a Ã©veillÃ© votre curiositÃ© et que vous souhaitez mettre en Å“uvre
vos propres pointeurs intelligents, visitez <a href="https://doc.rust-lang.org/nomicon/index.html">â€œThe Rustonomiconâ€</a> pour
en savoir plus.</p>
<!--
Next, weâ€™ll talk about concurrency in Rust. Youâ€™ll even learn about a few new
smart pointers.
-->
<p>Au chapitre suivant, nous allons parler de concurrence en Rust. Vous
dÃ©couvrirez peut-Ãªtre mÃªme quelques nouveaux pointeurs intelligents ...</p>
<!--
[nomicon]: ../nomicon/index.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
