<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html" class="active"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/205">Pull Request</a>.</p>
</blockquote>
<!--
## All the Places Patterns Can Be Used
-->
<h2 id="tous-les-endroits-oÃ¹-les-motifs-peuvent-Ãªtre-utilisÃ©s"><a class="header" href="#tous-les-endroits-oÃ¹-les-motifs-peuvent-Ãªtre-utilisÃ©s">Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></h2>
<!--
Patterns pop up in a number of places in Rust, and youâ€™ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.
-->
<p>Les motifs apparaissent dans de nombreux endroits en Rust, et vous en avez
utilisÃ© beaucoup sans vous en rendre compteÂ ! Cette section va prÃ©senter les
diffÃ©rentes situations oÃ¹ l'utilisation des motifs est appropriÃ©e.</p>
<!--
### `match` Arms
-->
<h3 id="les-branches-des-match"><a class="header" href="#les-branches-des-match">Les branches des <code>match</code></a></h3>
<!--
As discussed in Chapter 6, we use patterns in the arms of `match` expressions.
Formally, `match` expressions are defined as the keyword `match`, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that armâ€™s pattern, like this:
-->
<p>Comme nous l'avons vu au chapitre 6, nous utilisons les motifs dans les
branches des expressions <code>match</code>. Techniquement, les expressions <code>match</code> sont
dÃ©finies avec le mot-clÃ© <code>match</code>, une valeur sur laquelle procÃ©der, et une ou
plusieurs branches qui constituent un motif, ainsi qu'une expression Ã  exÃ©cuter
si la valeur correspond au motif de cette branche, comme ceciÂ :</p>
<!--
```text
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```
-->
<pre><code class="language-text">match VALEUR {
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
}
</code></pre>
<!--
One requirement for `match` expressions is that they need to be *exhaustive* in
the sense that all possibilities for the value in the `match` expression must
be accounted for. One way to ensure youâ€™ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.
-->
<p>L'une des conditions Ã  respecter pour les expressions <code>match</code> est qu'elle doit
Ãªtre <em>exhaustive</em> dans le sens oÃ¹ toutes les possibilitÃ©s pour la valeur dans
l'expression <code>match</code> doivent Ãªtre prises en compte. Une faÃ§on de s'assurer que
vous avez couvert toutes les possibilitÃ©s est d'avoir un motif passe-partout
pour la derniÃ¨re brancheÂ : par exemple, une valeur quelconque ne pourra jamais
Ã©chouer car la derniÃ¨re branche permet de couvrir tous les autres cas
possibles.</p>
<!--
A particular pattern `_` will match anything, but it never binds to a variable,
so itâ€™s often used in the last match arm. The `_` pattern can be useful when
you want to ignore any value not specified, for example. Weâ€™ll cover the `_`
pattern in more detail in the [â€œIgnoring Values in a
Patternâ€][ignoring-values-in-a-pattern]<!-- ignore -- > section later in this
chapter.
-->
<p>Le motif spÃ©cifique <code>_</code> va correspondre Ã  tout, mais il ne fournira jamais de
variable, donc il est souvent utilisÃ© dans la derniÃ¨re branche. Le motif <code>_</code>
peut Ãªtre utile lorsque vous souhaitez ignorer toutes les autres valeurs qui
n'ont pas Ã©tÃ© listÃ©es, par exemple. Nous allons voir plus en dÃ©tail le motif
<code>_</code> dans une section
<a href="ch18-03-pattern-syntax.html">plus tard dans ce chapitre</a><!-- ignore -->.</p>
<!--
### Conditional `if let` Expressions
-->
<h3 id="les-expressions-conditionnelles-if-let"><a class="header" href="#les-expressions-conditionnelles-if-let">Les expressions conditionnelles <code>if let</code></a></h3>
<!--
In Chapter 6 we discussed how to use `if let` expressions mainly as a shorter
way to write the equivalent of a `match` that only matches one case.
Optionally, `if let` can have a corresponding `else` containing code to run if
the pattern in the `if let` doesnâ€™t match.
-->
<p>Au chapitre 6, nous avons vu comment utiliser les expressions <code>if let</code>,
principalement pour pouvoir Ã©crire l'Ã©quivalent d'un <code>match</code> qui ne correspond
qu'Ã  un seul cas.
Accessoirement, <code>if let</code> peut avoir un <code>else</code> correspondant au code Ã  exÃ©cuter
si le motif du <code>if let</code> ne correspond pas au premier critÃ¨re.</p>
<!--
Listing 18-1 shows that itâ€™s also possible to mix and match `if let`, `else
if`, and `else if let` expressions. Doing so gives us more flexibility than a
`match` expression in which we can express only one value to compare with the
patterns. Also, the conditions in a series of `if let`, `else if`, `else if
let` arms arenâ€™t required to relate to each other.
-->
<p>L'encart 18-1 montre qu'il est aussi possible de conjuguer les expressions
<code>if let</code>, <code>else if</code>, et <code>else if let</code>. Faire ceci nous donne plus de
flexibilitÃ© qu'une expression <code>match</code> dans laquelle nous ne pouvons que
vÃ©rifier une seule valeur Ã  comparer avec les motifs. De plus, dans une sÃ©rie
de branches <code>if let</code>, <code>else if</code>, et <code>else if let</code>, les conditions n'ont pas
besoin d'avoir les mÃªmes conditions et contextes.</p>
<!--
The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, weâ€™ve created
variables with hardcoded values that a real program might receive from user
input.
-->
<p>Le code de l'encart 18-1 montre une sÃ©rie de vÃ©rifications pour quelques
conditions qui dÃ©cident quelle devrait Ãªtre la couleur de fond. Pour cet
exemple, nous avons crÃ©Ã© les variables avec des valeurs codÃ©es en dur qu'un
vrai programme devrait recevoir d'une saisie d'un utilisateur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let couleur_favorite: Option&lt;&amp;str&gt; = None;
    let on_est_mardi = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(couleur) = couleur_favorite {
        println!(&quot;Utilisation de votre couleur favorite, {}, comme couleur de fond&quot;, couleur);
    } else if on_est_mardi {
        println!(&quot;Mardi, c'est le jour du vertÂ !&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Utilisation du violet comme couleur de fond&quot;);
        } else {
            println!(&quot;Utilisation de l'orange comme couleur de fond&quot;);
        }
    } else {
        println!(&quot;Utilisation du bleu comme couleur de fond&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-1: Mixing `if let`, `else if`, `else if let`,
and `else`</span>
-->
<p><span class="caption">Encart 18-1Â : mÃ©lange de <code>if let</code>, <code>else if</code>,
<code>else if let</code>, et <code>else</code></span></p>
<!--
If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue.
-->
<p>Si l'utilisateur renseigne une couleur favorite, c'est cette couleur qui
devient la couleur de fond. Sinon, si nous sommes mardi, la couleur de fond
sera vert. Sinon, si l'utilisateur a renseignÃ© son age dans une chaÃ®ne de
caractÃ¨res et que nous pouvons l'interprÃ©ter comme un nombre avec succÃ¨s, la
couleur de fond sera soit violet, soit orange en fonction de la valeur de ce
nombre. Si aucune de ces conditions s'applique, la couleur de fond sera bleu.</p>
<!--
This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print `Using purple as the
background color`.
-->
<p>Cette structure conditionnelle nous permet de rÃ©pondre Ã  des conditions
complexes. Avec les valeurs codÃ©es en dur que nous avons ici, cet exemple
devrait afficher <code>Utilisation du violet comme couleur de fond</code>.</p>
<!--
You can see that `if let` can also introduce shadowed variables in the same way
that `match` arms can: the line `if let Ok(age) = age` introduces a new
shadowed `age` variable that contains the value inside the `Ok` variant. This
means we need to place the `if age > 30` condition within that block: we canâ€™t
combine these two conditions into `if let Ok(age) = age && age > 30`. The
shadowed `age` we want to compare to 30 isnâ€™t valid until the new scope starts
with the curly bracket.
-->
<p>Vous pouvez constater que le <code>if let</code> nous permet d'utiliser les variables
masquÃ©es de la mÃªme maniÃ¨re que le fait le font les branches <code>match</code>Â : la ligne
<code>if let Ok(age) = age</code> crÃ©e une nouvelle variable masquÃ©e <code>age</code> qui contient la
valeur prÃ©sente dans la variante <code>Ok</code>. Cela signifie que nous devons placer la
condition <code>if age &gt; 30</code> Ã  l'intÃ©rieur de ce blocÂ : nous ne pouvons pas combiner
ces deux conditions dans une seule <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. La
variable masquÃ©e <code>age</code> que nous souhaitons comparer Ã  30 n'est pas encore en
vigueur tant que la nouvelle portÃ©e entre les accolades n'a pas commencÃ©e.</p>
<!--
The downside of using `if let` expressions is that the compiler doesnâ€™t check
exhaustiveness, whereas with `match` expressions it does. If we omitted the
last `else` block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.
-->
<p>Le dÃ©savantage de l'utilisation des expressions <code>if let</code> est que le compilateur
ne vÃ©rifie pas l'exhaustivitÃ©, ce que fait l'expression <code>match</code>. Si nous avions
enlevÃ© le dernier bloc <code>else</code> et ainsi que nous oublions de gÃ©rer certains cas,
le compilateur ne pourrait pas nous prÃ©venir d'un possible bogue de logique.</p>
<!--
### `while let` Conditional Loops
-->
<h3 id="les-boucles-conditionelles-while-let"><a class="header" href="#les-boucles-conditionelles-while-let">les boucles conditionelles <code>while let</code></a></h3>
<!--
Similar in construction to `if let`, the `while let` conditional loop allows a
`while` loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a `while let` loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed.
-->
<p>Comme les constructions <code>if let</code>, les boucles conditionnelles <code>while let</code>
permettent Ã  une boucle <code>while</code> de s'exÃ©cuter aussi longtemps qu'un motif
continue Ã  correspondre. L'exemple dans l'encart 18-2 montre une boucle
<code>while let</code> qui utilise un vecteur comme une pile et affiche les valeurs du
vecteur dans l'ordre opposÃ© Ã  celui dans lequel elles ont Ã©tÃ© insÃ©rÃ©es.</p>
<!--
```rust
# fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut pile = Vec::new();

    pile.push(1);
    pile.push(2);
    pile.push(3);

    while let Some(donnee_du_haut) = pile.pop() {
        println!(&quot;{}&quot;, donnee_du_haut);
    }
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pile = Vec::new();

pile.push(1);
pile.push(2);
pile.push(3);

while let Some(donnee_du_haut) = pile.pop() {
    println!(&quot;{}&quot;, donnee_du_haut);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-2: Using a `while let` loop to print values
for as long as `stack.pop()` returns `Some`</span>
-->
<p><span class="caption">Encart 18-2Â : utilisation d'une boucle <code>while let</code> pour
afficher les valeurs aussi longtemps que <code>pile.pop()</code> retourne une <code>Some</code></span></p>
<!--
This example prints 3, 2, and then 1. The `pop` method takes the last element
out of the vector and returns `Some(value)`. If the vector is empty, `pop`
returns `None`. The `while` loop continues running the code in its block as
long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can
use `while let` to pop every element off our stack.
-->
<p>Cet exemple affiche 3, 2 puis ensuite 1. La mÃ©thode <code>pop</code> sort le dernier
Ã©lÃ©ment du vecteur et retourne <code>Some(valeur)</code>. Si le vecteur est vide, <code>pop</code>
retourne alors <code>None</code>. La boucle <code>while</code> continue Ã  exÃ©cuter le code de son bloc
aussi longtemps que <code>pop</code> retourne un <code>Some</code>. Lorsque <code>pop</code> retournera <code>None</code>,
la boucle s'arrÃªtera. Nous pouvons utiliser <code>while let</code> pour extraire tous les
Ã©lÃ©ments de la pile.</p>
<!--
### `for` Loops
-->
<h3 id="les-boucles-for"><a class="header" href="#les-boucles-for">Les boucles <code>for</code></a></h3>
<!--
In Chapter 3, we mentioned that the `for` loop is the most common loop
construction in Rust code, but we havenâ€™t yet discussed the pattern that `for`
takes. In a `for` loop, the pattern is the value that directly follows the
keyword `for`, so in `for x in y` the `x` is the pattern.
-->
<p>Au chapitre 3, nous avions mentionnÃ© que la boucle <code>for</code> Ã©tait la construction
de boucle la plus utilisÃ© dans du code Rust, mais nous n'avons pas encore abordÃ©
le motif que prend <code>for</code>. Dans une boucle <code>for</code>, le motif est la valeur qui suit
directement le mot-clÃ© <code>for</code>, de sorte que <code>x</code> est le motif dans <code>for x in y</code>.</p>
<!--
Listing 18-3 demonstrates how to use a pattern in a `for` loop to destructure,
or break apart, a tuple as part of the `for` loop.
-->
<p>L'encart 18-3 montre comment utiliser un motif dans une boucle <code>for</code> pour
dÃ©structurer, ou dÃ©composer, un tuple comme Ã©tant une partie de la boucle <code>for</code>.</p>
<!--
```rust
# fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (indice, valeur) in v.iter().enumerate() {
        println!(&quot;{} est Ã  l'indice {}&quot;, valeur, indice);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-3: Using a pattern in a `for` loop to
destructure a tuple</span>
-->
<p><span class="caption">Encart 18-3Â : utilisation d'un motif dans une boucle <code>for</code>
pour dÃ©structurer un tuple</span></p>
<!--
The code in Listing 18-3 will print the following:
-->
<p>Le code de l'encart 18-3 va afficher ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a est Ã  l'indice 0
b est Ã  l'indice 1
c est Ã  l'indice 2
</code></pre>
<!--
We use the `enumerate` method to adapt an iterator to produce a value and that
valueâ€™s index in the iterator, placed into a tuple. The first call to
`enumerate` produces the tuple `(0, 'a')`. When this value is matched to the
pattern `(index, value)`, `index` will be `0` and `value` will be `'a'`,
printing the first line of the output.
-->
<p>Nous avons utilisÃ© la mÃ©thode <code>enumerate</code> pour produire une valeur et son indice
Ã  partir d'un itÃ©rateur, que nous avons placÃ© dans un tuple. Le premier appel Ã 
<code>enumerate</code> va produire le tuple <code>(0, 'a')</code>. Lorsque cette valeur est adaptÃ©e au
motif <code>(indice, valeur)</code>, <code>indice</code> vaudra <code>0</code> et <code>valeur</code> vaudra <code>'a'</code>, et
affichera la premiÃ¨re ligne sur la sortie.</p>
<!--
### `let` Statements
-->
<h3 id="les-instructions-let"><a class="header" href="#les-instructions-let">Les instructions <code>let</code></a></h3>
<!--
Prior to this chapter, we had only explicitly discussed using patterns with
`match` and `if let`, but in fact, weâ€™ve used patterns in other places as well,
including in `let` statements. For example, consider this straightforward
variable assignment with `let`:
-->
<p>Avant d'arriver Ã  ce chapitre, nous n'avions abordÃ© explicitement l'utilisation
des motifs uniquement avec <code>match</code> et <code>if let</code>, mais en rÃ©alitÃ©, nous avons
utilisÃ© les motifs dans d'autres endroits, y compris les instructions <code>let</code>. Par
exemple, considÃ©rons l'assignation Ã  la variable suivante avec <code>let</code>Â :</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Throughout this book, weâ€™ve used `let` like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a `let` statement looks like this:
-->
<p>Tout au long de ce livre, nous avons utilisÃ© <code>let</code> de cette maniÃ¨re des
centaines de fois, et malgrÃ© tout vous ne vous Ãªtes probablement pas rendu
compte que vous utilisiez les motifsÂ ! Plus formellement, une instruction <code>let</code>
ressemble Ã  ceciÂ :</p>
<!--
```text
let PATTERN = EXPRESSION;
```
-->
<pre><code class="language-text">let MOTIF = EXPRESSION;
</code></pre>
<!--
In statements like `let x = 5;` with a variable name in the `PATTERN` slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
`let x = 5;` example, `x` is a pattern that means â€œbind what matches here to
the variable `x`.â€ Because the name `x` is the whole pattern, this pattern
effectively means â€œbind everything to the variable `x`, whatever the value is.â€
-->
<p>Dans des instructions comme <code>let x = 5;</code> avec un nom de variable dans
l'emplacement <code>MOTIF</code>, le nom de la variable est juste une forme simple de
motif. Rust compare l'expression avec le motif et assigne tous les noms qu'il
rencontre. Dans l'exemple <code>let x = 5;</code>, <code>x</code> est un motif qui signifie
â€œrelie ce qui suit Ã  la variable <code>x</code>â€.  Comme le nom <code>x</code> est un motif en entier,
ce motif demande exactement dans ce cas â€œrelie tout ce qui suit Ã  la variable
<code>x</code>, peu importe quelle valeur c'estâ€.</p>
<!--
To see the pattern matching aspect of `let` more clearly, consider Listing
18-4, which uses a pattern with `let` to destructure a tuple.
-->
<p>Pour comprendre plus clairement l'aspect filtrage par motif de <code>let</code>, admettons
l'encart 18-4, qui utilise un motif avec <code>let</code> pour destructurer un tuple.</p>
<!--
```rust
# fn main() {
    let (x, y, z) = (1, 2, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span>
-->
<p><span class="caption">Encart 18-4Â : utilisation d'un motif pour destructurer un
tuple et crÃ©er trois variables Ã  la fois</span></p>
<!--
Here, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)`
to the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust
binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple
pattern as nesting three individual variable patterns inside it.
-->
<p>Ici, nous avons fait correspondre un tuple Ã  un motif. Rust compare la valeur
<code>(1, 2, 3)</code> au motif <code>(x, y, z)</code> et constate que la valeur correspond au motif,
donc Rust relie <code>1</code> Ã  <code>x</code>, <code>2</code> Ã  <code>y</code>, et <code>3</code> Ã  <code>z</code>. Vous pouvez ainsi considÃ©rer
que ce motif de tuple contient trois variables individuelles en son sein.</p>
<!--
If the number of elements in the pattern doesnâ€™t match the number of elements
in the tuple, the overall type wonâ€™t match and weâ€™ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which wonâ€™t work.
-->
<p>Si le nombre d'Ã©lÃ©ments dans le motif ne correspondent pas au nombre d'Ã©lÃ©ments
dans le tuple, le type au complet ne va pas correspondre et nous allons obtenir
une erreur de compilation. Par exemple, l'encart 18-5 montre une tentative de
dÃ©structurer un tuple avec trois Ã©lÃ©ments dans deux variables, ce qui ne va pas
fonctionner.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let (x, y) = (1, 2, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables donâ€™t match the number of elements in the tuple</span>
-->
<p><span class="caption">Encart 18-5Â : construction incorrecte d'un motif dont les
variables ne vont pas correspondre au nombre d'Ã©lÃ©ments prÃ©sents dans le tuple
</span></p>
<!--
Attempting to compile this code results in this type error:
-->
<p>Si vous essayez de compiler ce code, vous obtiendrez cette erreur de typeÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 -- > src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
If we wanted to ignore one or more of the values in the tuple, we could use `_`
or `..`, as youâ€™ll see in the [â€œIgnoring Values in a
Patternâ€][ignoring-values-in-a-pattern]<!-- ignore -- > section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.
-->
<p>Si nous souhaitons ignorer une ou plusieurs valeurs dans un tuple, nous pouvons
utiliser <code>_</code> ou <code>..</code>, comme vous allez le voir Ã  la derniÃ¨re section de ce
chapitre. Si le problÃ¨me est que nous avons trop de variables dans le motif, la
solution faire correspondre les types en enlevant les variables afin que le
nombre de variables corresponde au nombre d'Ã©lÃ©ments prÃ©sents dans le tuple.</p>
<!--
### Function Parameters
-->
<h3 id="les-paramÃ¨tres-de-fonctions"><a class="header" href="#les-paramÃ¨tres-de-fonctions">Les paramÃ¨tres de fonctions</a></h3>
<!--
Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named `foo` that takes one parameter named `x` of type
`i32`, should by now look familiar.
-->
<p>Les paramÃ¨tres de fonctions peuvent aussi Ãªtre des motifs. Le code de l'encart
18-6 dÃ©clare une fonction <code>foo</code> qui prend un paramÃ¨tre <code>x</code> de type <code>i32</code>.</p>
<!--
```rust
fn foo(x: i32) {
    // code goes here
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(x: i32) {
    // le code se place ici
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span>
-->
<p><span class="caption">Encart 18-6Â : une signature de fonction qui utilise des
motifs dans ses paramÃ¨tres</span></p>
<!--
The `x` part is a pattern! As we did with `let`, we could match a tuple in a
functionâ€™s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.
-->
<p>La partie <code>x</code> est un motifÂ ! Comme nous l'avons dit pour <code>let</code>, nous pouvons
faire correspondre le motif avec un tuple dans les arguments de la fonction.
L'encart 18-7 dÃ©structure les valeurs d'un tuple que nous passons en argument
d'une fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn afficher_coordonnees(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;CoordonnÃ©es actuellesÂ : ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    afficher_coordonnees(&amp;point);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span>
-->
<p><span class="caption">Encart 18-7Â : une fonction avec des paramÃ¨tres qui
dÃ©structurent un tuple</span></p>
<!--
This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the
pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`.
-->
<p>Ce code affiche <code>CoordonÃ©es actuellesÂ : (3, 5)</code>. Les valeurs <code>&amp;(3, 5)</code>
correspondent au motif <code>&amp;(x, y)</code>, donc <code>x</code> a la valeur <code>3</code> et <code>y</code> a la valeur
<code>5</code>.</p>
<!--
We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.
-->
<p>Nous pouvons aussi utiliser les motifs dans la liste des paramÃ¨tres d'une
fermeture de la mÃªme maniÃ¨re que la liste des paramÃ¨tres d'une fonction, car les
fermetures sont similaires aux fonctions, comme nous l'avons dit au chapitre 13.</p>
<!--
At this point, youâ€™ve seen several ways of using patterns, but patterns donâ€™t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. Weâ€™ll discuss
these two concepts next.
-->
<p>A prÃ©sent, vous avez vu plusieurs faÃ§ons d'utiliser les motifs, mais les motifs
ne fonctionnent pas de la mÃªme maniÃ¨re dans toutes les situations oÃ¹ nous les
utilisons. Des fois, le motif sera irrÃ©futableÂ ; d'autres fois, il sera
rÃ©futable. C'est ce que nous allons voir tout de suite.</p>
<!--
[ignoring-values-in-a-pattern]:
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch18-00-patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch18-02-refutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch18-00-patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch18-02-refutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
