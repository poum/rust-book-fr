<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AmÃ©lioration de notre projet d&#x27;entrÃ©e/sortie - Le langage de programmation Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../ferris.css">
                <link rel="stylesheet" href="../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html" class="active"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Improving Our I/O Project
-->
<h2 id="amÃ©lioration-de-notre-projet-dentrÃ©esortie"><a class="header" href="#amÃ©lioration-de-notre-projet-dentrÃ©esortie">AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></h2>
<!--
With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Letâ€™s look at how iterators can improve our implementation of the
`Config::new` function and the `search` function.
-->
<p>GrÃ¢ce Ã  ces nouvelles connaissances sur les itÃ©rateurs, nous pouvons amÃ©liorer
le projet d'entrÃ©e/sortie du chapitre 12 en utilisant des itÃ©rateurs pour
rendre certains endroits du code plus clairs et plus concis. Voyons comment les
itÃ©rateurs peuvent amÃ©liorer notre implÃ©mentation de la fonction <code>Config::new</code>
et de la fonction <code>rechercher</code>.</p>
<!--
### Removing a `clone` Using an Iterator
-->
<h3 id="supprimer-lappel-Ã -clone-Ã -laide-dun-itÃ©rateur"><a class="header" href="#supprimer-lappel-Ã -clone-Ã -laide-dun-itÃ©rateur">Supprimer l'appel Ã  <code>clone</code> Ã  l'aide d'un itÃ©rateur</a></h3>
<!--
In Listing 12-6, we added code that took a slice of `String` values and created
an instance of the `Config` struct by indexing into the slice and cloning the
values, allowing the `Config` struct to own those values. In Listing 13-24,
weâ€™ve reproduced the implementation of the `Config::new` function as it was in
Listing 12-23:
-->
<p>Dans l'encart 12-6, nous avions ajoutÃ© du code qui prenait une <em>slice</em> de
<code>String</code> et qui crÃ©ait une instance de la structure <code>Config</code> en utilisant les
indices de la <em>slice</em> et en clonant les valeurs, permettant ainsi Ã  la
structure <code>Config</code> de possÃ©der ces valeurs. Dans l'encart 13-24, nous avions
reproduit l'implÃ©mentation de la fonction <code>Config::new</code> comme Ã©tait dans
l'encart 12-23 Ã  la fin du chapitre 12Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 13-24: Reproduction of the `Config::new` function
from Listing 12-23</span>
-->
<p><span class="caption">Encart 13-24Â : reproduction de la fonction <code>Config::new</code>
de la fin du chapitre 12</span></p>
<!--
At the time, we said not to worry about the inefficient `clone` calls because
we would remove them in the future. Well, that time is now!
-->
<p>Ã€ ce moment-lÃ , nous avions dit de ne pas s'inquiÃ©ter des appels inefficaces Ã 
<code>clone</code> parce que nous les supprimerions Ã  l'avenir. Et bien, ce moment est
venuÂ !</p>
<!--
We needed `clone` here because we have a slice with `String` elements in the
parameter `args`, but the `new` function doesnâ€™t own `args`. To return
ownership of a `Config` instance, we had to clone the values from the `query`
and `filename` fields of `Config` so the `Config` instance can own its values.
-->
<p>Nous avions besoin de <code>clone</code> ici parce que nous avons une slice d'Ã©lÃ©ments
<code>String</code> dans le paramÃ¨tre <code>args</code>, mais la fonction <code>new</code> ne possÃ¨de pas <code>args</code>.
Pour rendre la propriÃ©tÃ© d'une instance de <code>Config</code>, nous avons dÃ» cloner les
valeurs des champs <code>recherche</code> et <code>nom_fichier</code> de <code>Config</code> pour qu'elle puisse
prendre possession de ses valeurs.</p>
<!--
With our new knowledge about iterators, we can change the `new` function to
take ownership of an iterator as its argument instead of borrowing a slice.
Weâ€™ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
`Config::new` function is doing because the iterator will access the values.
-->
<p>Avec nos nouvelles connaissances sur les itÃ©rateurs, nous pouvons changer la
fonction <code>new</code> pour prendre possession d'un itÃ©rateur passÃ© en argument au lieu
d'emprunter une <em>slice</em>. Nous utiliserons les fonctionnalitÃ©s des itÃ©rateurs Ã 
la place du code qui vÃ©rifie la taille de la slice et qui utilise les indices
des Ã©lÃ©ments prÃ©cis. Cela clarifiera ce que la fonction <code>Config::new</code> fait car
l'itÃ©rateur accÃ©dera aux valeurs.</p>
<!--
Once `Config::new` takes ownership of the iterator and stops using indexing
operations that borrow, we can move the `String` values from the iterator into
`Config` rather than calling `clone` and making a new allocation.
-->
<p>Une fois que <code>Config::new</code> prend possession de l'itÃ©rateur et cesse d'utiliser
les opÃ©rations avec les indices et d'emprunter les donnÃ©es, nous pouvons
dÃ©placer les valeurs <code>String</code> de l'iterator dans <code>Config</code> plutÃ´t que de faire
appel Ã  <code>clone</code> et de crÃ©er par consÃ©quent de nouvelles allocations.</p>
<!--
#### Using the Returned Iterator Directly
-->
<h4 id="utiliser-directement-litÃ©rateur-retournÃ©"><a class="header" href="#utiliser-directement-litÃ©rateur-retournÃ©">Utiliser directement l'itÃ©rateur retournÃ©</a></h4>
<!--
Open your I/O projectâ€™s *src/main.rs* file, which should look like this:
-->
<p>Ouvrez le fichier <em>src/main.rs</em> de votre projet d'entrÃ©e/sortie, qui devrait
ressembler Ã  ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
Weâ€™ll change the start of the `main` function that we had in Listing 12-24 to
the code in Listing 13-25. This wonâ€™t compile until we update `Config::new` as
well.
-->
<p>Nous allons changer le dÃ©but de la fonction <code>main</code> que nous avions dans l'encart
12-24 pour le code dans l'encart 13-25. Ceci ne compilera pas encore jusqu'Ã  ce
que nous mettions Ã©galement Ã  jour <code>Config::new</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 13-25: Passing the return value of `env::args` to
`Config::new`</span>
-->
<p><span class="caption">Encart 13-25Â : on passe directement la valeur de retour de
<code>env::args</code> Ã  <code>Config::new</code>.</span></p>
<!--
The `env::args` function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to `Config::new`, now
weâ€™re passing ownership of the iterator returned from `env::args` to
`Config::new` directly.
-->
<p>La fonction <code>env::args</code> retourne un itÃ©rateurÂ ! PlutÃ´t que de collecter les
valeurs de l'itÃ©rateur dans un vecteur et de passer ensuite une <em>slice</em> Ã 
<code>Config::new</code>, nous passons maintenant la possession de l'itÃ©rateur de
<code>env::args</code> directement Ã  <code>Config::new</code>.</p>
<!--
Next, we need to update the definition of `Config::new`. In your I/O projectâ€™s
*src/lib.rs* file, letâ€™s change the signature of `Config::new` to look like
Listing 13-26. This still wonâ€™t compile because we need to update the function
body.
-->
<p>Ensuite, nous devons mettre Ã  jour la dÃ©finition de <code>Config::new</code>. Dans le
fichier <em>src/lib.rs</em> de votre projet d'entrÃ©e/sortie, modifions la signature de
<code>Config::new</code> pour qu'elle ressemble Ã  l'encart 13-26. Ceci ne compilera pas
encore car nous devons mettre Ã  jour le corps de la fonction.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        // -- partie masquÃ©e ici --
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-26: Updating the signature of `Config::new` to
expect an iterator</span>
-->
<p><span class="caption">Encart 13-26Â : mise Ã  jour de la signature de
<code>Config::new</code> pour recevoir un itÃ©rateur</span></p>
<!--
The standard library documentation for the `env::args` function shows that the
type of the iterator it returns is `std::env::Args`. Weâ€™ve updated the
signature of the `Config::new` function so the parameter `args` has the type
`std::env::Args` instead of `&[String]`. Because weâ€™re taking ownership of
`args` and weâ€™ll be mutating `args` by iterating over it, we can add the `mut`
keyword into the specification of the `args` parameter to make it mutable.
-->
<p>La documentation de la bibliothÃ¨que standard de la fonction <code>env::args</code>
indique que le type de l'itÃ©rateur qu'elle renvoie est <code>std::env::Args</code>. Nous
avons mis Ã  jour la signature de la fonction <code>Config::new</code> pour que le
paramÃ¨tre <code>args</code> ait le type <code>std::env::Args</code> au lieu de <code>&amp;[String]</code>. Etant
donnÃ© que nous prenons possession de <code>args</code> et que nous allons muter <code>args</code>
en itÃ©rant dessus, nous pouvons ajouter le mot-clÃ© <code>mut</code> dans la spÃ©cification
du paramÃ¨tre <code>args</code> pour le rendre mutable.</p>
<!--
#### Using `Iterator` Trait Methods Instead of Indexing
-->
<h4 id="utilisation-des-mÃ©thodes-du-trait-iterator-au-lieu-des-indices"><a class="header" href="#utilisation-des-mÃ©thodes-du-trait-iterator-au-lieu-des-indices">Utilisation des mÃ©thodes du trait <code>Iterator</code> au lieu des indices</a></h4>
<!--
Next, weâ€™ll fix the body of `Config::new`. The standard library documentation
also mentions that `std::env::Args` implements the `Iterator` trait, so we know
we can call the `next` method on it! Listing 13-27 updates the code from
Listing 12-23 to use the `next` method:
-->
<p>Ensuite corrigeons le corps de <code>Config::new</code>. La documentation de la bibliothÃ¨que
standard explique aussi que <code>std::env::Args</code> implÃ©mente le trait <code>Iterator</code>, donc
nous savons que nous pouvons appeler la mÃ©thode <code>next</code> dessusÂ ! L'encart 13-27
met Ã  jour le code de l'encart 12-23 afin d'utiliser la mÃ©thode <code>next</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        args.next();

        let recherche = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de chaÃ®ne de caractÃ¨res"),
        };

        let nom_fichier = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de nom de fichier"),
        };

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let recherche = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de chaÃ®ne de caractÃ¨res&quot;),
        };

        let nom_fichier = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
        };

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-27: Changing the body of `Config::new` to use
iterator methods</span>
-->
<p><span class="caption">Encart 13-27Â : changement du corps de <code>Config::new</code> afin
d'utiliser les mÃ©thodes d'itÃ©ration</span></p>
<!--
Remember that the first value in the return value of `env::args` is the name of
the program. We want to ignore that and get to the next value, so first we call
`next` and do nothing with the return value. Second, we call `next` to get the
value we want to put in the `query` field of `Config`. If `next` returns a
`Some`, we use a `match` to extract the value. If it returns `None`, it means
not enough arguments were given and we return early with an `Err` value. We do
the same thing for the `filename` value.
-->
<p>Rappelez-vous que la premiÃ¨re valeur de ce qui est retournÃ© par <code>env::args</code> est
le nom du programme. Nous voulons ignorer cette valeur et passer Ã  la suivante,
donc d'abord nous appelons une fois <code>next</code> et nous ne faisons rien avec sa
valeur de retour. Ensuite, nous appelons <code>next</code> pour obtenir la valeur que nous
voulons mettre dans le champ <code>recherche</code> de <code>Config</code>. Si <code>next</code> renvoie un
<code>Some</code>, nous utilisons un <code>match</code> pour extraire sa valeur. S'il retourne <code>None</code>,
cela signifie qu'il n'y a pas assez d'arguments donnÃ©s et nous revenons plus tÃ´t
avec une valeur <code>Err</code>. De mÃªme pour la valeur <code>nom_fichier</code>.</p>
<!--
### Making Code Clearer with Iterator Adaptors
-->
<h3 id="rendre-le-code-plus-clair-avec-des-adaptateurs-ditÃ©ration"><a class="header" href="#rendre-le-code-plus-clair-avec-des-adaptateurs-ditÃ©ration">Rendre le code plus clair avec des adaptateurs d'itÃ©ration</a></h3>
<!--
We can also take advantage of iterators in the `search` function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:
-->
<p>Nous pouvons Ã©galement tirer parti des itÃ©rateurs dans la fonction
<code>rechercher</code> de notre projet d'entrÃ©e/sortie, qui est reproduite ici dans
l'encart 13-28, comme elle l'Ã©tait dans l'encart 12-19 Ã  la fin du chapitre 12Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_resultat() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
# Obtenez les trois en mÃªme temps.";
# 
#         assert_eq!(vec!["sÃ©curitÃ©, rapiditÃ©, productivitÃ©."], rechercher(recherche, contenu));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-28: The implementation of the `search`
function from Listing 12-19</span>
-->
<p><span class="caption">Encart 13-28Â : La mise en oeuvre de la fonction
<code>rechercher</code> de l'encart 12-19</span></p>
<!--
We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate `results` vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldnâ€™t have to manage
concurrent access to the `results` vector. Listing 13-29 shows this change:
-->
<p>Nous pouvons Ã©crire ce code de faÃ§on plus concise en utilisant des mÃ©thodes
des adaptateurs d'itÃ©ration. Ce faisant, nous Ã©vitons ainsi d'avoir le vecteur
mutableÂ <code>resultats</code>. Le style de programmation fonctionnelle prÃ©fÃ¨re minimiser
la quantitÃ© d'Ã©tats modifiables pour rendre le code plus clair. Supprimer l'Ã©tat
mutable pourrait nous aider Ã  faire une amÃ©lioration future afin que la recherche
se fasse en parallÃ¨le, car nous n'aurions pas Ã  gÃ©rer l'accÃ¨s concurrent au
vecteur <code>resultats</code>. L'encart 13-29 montre ce changementÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
#         args.next();
# 
#         let recherche = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de chaÃ®ne de caractÃ¨res"),
#         };
# 
#         let nom_fichier = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de nom de fichier"),
#         };
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let recherche = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de chaÃ®ne de caractÃ¨res&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let nom_fichier = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the `search` function</span>
-->
<p><span class="caption">Encart 13-29Â : utilisation des mÃ©thodes des adaptateurs
d'itÃ©ration dans l'implÃ©mentation de la fonction <code>rechercher</code></span></p>
<!--
Recall that the purpose of the `search` function is to return all lines in
`contents` that contain the `query`. Similar to the `filter` example in Listing
13-19, this code uses the `filter` adaptor to keep only the lines that
`line.contains(query)` returns `true` for. We then collect the matching lines
into another vector with `collect`. Much simpler! Feel free to make the same
change to use iterator methods in the `search_case_insensitive` function as
well.
-->
<p>Souvenez-vous que le but de la fonction <code>rechercher</code> est de renvoyer toutes
les lignes dans <code>contenu</code> qui contiennent <code>recherche</code>. Comme dans l'exemple de
<code>filter</code> dans l'encart 13-19, nous pouvons utiliser l'adaptateur <code>filter</code>
pour garder uniquement les lignes pour lesquelles <code>ligne.contains(recherche)</code>
renvoie <code>true</code>. Nous collectons ensuite les lignes correspondantes dans un
autre vecteur avec <code>collect</code>. C'est bien plus simpleÂ ! N'hÃ©sitez pas Ã  faire
le mÃªme changement pour utiliser les mÃ©thodes d'itÃ©ration dans la fonction
<code>rechercher_insensible_casse</code>.</p>
<!--
The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. Itâ€™s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so itâ€™s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.
-->
<p>Logiquement la question suivante est de savoir quel style utiliser dans votre
propre code et pourquoiÂ : l'implÃ©mentation originale de l'encart 13-28 ou la
version utilisant l'itÃ©rateur dans l'encart 13-29. La plupart des dÃ©veloppeurs
Rust prÃ©fÃ¨rent utiliser le style avec l'itÃ©rateur. C'est un peu plus difficile
Ã  comprendre au dÃ©but, mais une fois que vous avez compris les diffÃ©rents
adaptateurs d'itÃ©ration et de ce qu'ils font, les itÃ©rateurs peuvent devenir
plus faciles Ã  comprendre. Au lieu de jongler avec diffÃ©rentes boucles et de
construire de nouveaux vecteurs, ce code se concentre sur l'objectif de haut
niveau de la boucle. Cette abstraction permet d'Ã©liminer une partie du code
trivial, de sorte qu'il soit plus facile de dÃ©gager les concepts propres Ã  ce
code, comme le filtrage de chaque Ã©lÃ©ment de l'itÃ©rateur qui est appliquÃ©.</p>
<!--
But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Letâ€™s talk about
performance.
-->
<p>Mais ces deux implÃ©mentations sont-elles rÃ©ellement Ã©quivalentesÂ ? L'hypothÃ¨se
intuitive pourrait Ãªtre que la boucle de plus bas niveau sera plus rapide.
IntÃ©ressons nous maintenant Ã  leurs performances.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch13-02-iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch13-04-performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch13-02-iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch13-04-performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../ferris.js"></script>
                <script type="text/javascript" src="github-button.js"></script>
        
        
    </body>
</html>
