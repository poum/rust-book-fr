<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Qu'est-ce que la possession ? - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## What Is Ownership?
-->
<h2><a class="header" href="#quest-ce-que-la-possession-" id="quest-ce-que-la-possession-">Qu'est-ce que la possessionÂ ?</a></h2>
<!--
Rustâ€™s central feature is *ownership*. Although the feature is straightforward
to explain, it has deep implications for the rest of the language.
-->
<p>La principale spÃ©cificitÃ© de Rust est <em>la possession</em>. Bien que cette
fonctionnalitÃ© soit simple Ã  expliquer, elle a de profondes consÃ©quences sur le
reste du langage.</p>
<!--
All programs have to manage the way they use a computerâ€™s memory while running.
Some languages have garbage collection that constantly looks for no longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks at
compile time. None of the ownership features slow down your program while itâ€™s
running.
-->
<p>Tous les programmes doivent gÃ©rer la faÃ§on dont ils utilisent la mÃ©moire
lorsqu'ils s'exÃ©cutent. Certains langages ont un ramasse-miettes qui scrute
constamment la mÃ©moire qui n'est plus utilisÃ©e pendant qu'il s'exÃ©cuteÂ ; dans
d'autres langages, le dÃ©veloppeur doit explicitement allouer et libÃ©rer la
mÃ©moire. Rust adopte une troisiÃ¨me approcheÂ : la mÃ©moire est gÃ©rÃ©e avec un
systÃ¨me de possession qui repose sur un jeu de rÃ¨gles que le compilateur vÃ©rifie
au moment de la compilation. Aucune des fonctionnalitÃ©s de possession ne
ralentit votre programme Ã  l'exÃ©cution.</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the more youâ€™ll be able to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>Comme la possession est un nouveau principe pour de nombreux dÃ©veloppeurs,
cela prend un certain temps pour s'y familiariser. La bonne nouvelle est que
plus vous devenez expÃ©rimentÃ© avec Rust et ses rÃ¨gles de possession, plus vous
dÃ©velopperez naturellement du code sÃ»r et efficace. Gardez bien cela Ã 
l'espritÂ !</p>
<!--
When you understand ownership, youâ€™ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, youâ€™ll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>Lorsque vous comprendrez la possession, vous aurez des bases solides pour
comprendre les fonctionnalitÃ©s qui font la particularitÃ© de Rust. Dans ce
chapitre, vous allez apprendre la possession en pratiquant avec plusieurs
exemples qui se concentrent sur une structure de donnÃ©es trÃ¨s couranteÂ : les
chaÃ®nes de caractÃ¨res.</p>
<!--
> ### The Stack and the Heap
>
> In many programming languages, you donâ€™t have to think about the stack and
> the heap very often. But in a systems programming language like Rust, whether
> a value is on the stack or the heap has more of an effect on how the language
> behaves and why you have to make certain decisions. Parts of ownership will
> be described in relation to the stack and the heap later in this chapter, so
> here is a brief explanation in preparation.
>
> Both the stack and the heap are parts of memory that are available to your
> code to use at runtime, but they are structured in different ways. The stack
> stores values in the order it gets them and removes the values in the
> opposite order. This is referred to as *last in, first out*. Think of a stack
> of plates: when you add more plates, you put them on top of the pile, and
> when you need a plate, you take one off the top. Adding or removing plates
> from the middle or bottom wouldnâ€™t work as well! Adding data is called
> *pushing onto the stack*, and removing data is called *popping off the stack*.
>
> All data stored on the stack must have a known, fixed size. Data with an
> unknown size at compile time or a size that might change must be stored on
> the heap instead. The heap is less organized: when you put data on the heap,
> you request a certain amount of space. The memory allocator finds an empty
> spot in the heap that is big enough, marks it as being in use, and returns a
> *pointer*, which is the address of that location. This process is called
> *allocating on the heap* and is sometimes abbreviated as just *allocating*.
> Pushing values onto the stack is not considered allocating. Because the
> pointer is a known, fixed size, you can store the pointer on the stack, but
> when you want the actual data, you must follow the pointer.
>
> Think of being seated at a restaurant. When you enter, you state the number of
> people in your group, and the staff finds an empty table that fits everyone
> and leads you there. If someone in your group comes late, they can ask where
> youâ€™ve been seated to find you.
>
> Pushing to the stack is faster than allocating on the heap because the
> allocator never has to search for a place to store new data; that
> location is always at the top of the stack. Comparatively, allocating space
> on the heap requires more work, because the allocator must first find
> a big enough space to hold the data and then perform bookkeeping to prepare
> for the next allocation.
>
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. Itâ€™s most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data thatâ€™s close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
>
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the functionâ€™s
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
>
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so you donâ€™t run out of space are all problems that ownership
> addresses. Once you understand ownership, you wonâ€™t need to think about the
> stack and the heap very often, but knowing that managing heap data is why
> ownership exists can help explain why it works the way it does.
-->
<blockquote>
<h3><a class="header" href="#la-pile-et-le-tas" id="la-pile-et-le-tas">La pile et le tas</a></h3>
<p>Dans de nombreux langages, il n'est pas nÃ©cessaire de se prÃ©occuper de la
pile (<em>stack</em>) et du tas (<em>heap</em>). Mais dans un langage de programmation
systÃ¨me comme Rust, qu'une donnÃ©e soit sur la pile ou sur le tas influe
sur le comportement du langage et explique pourquoi nous devons faire certains
choix. Nous dÃ©crirons plus loin dans ce chapitre comment la possession
fonctionne vis-Ã -vis de la pile et du tas, voici donc une brÃ¨ve explication au
prÃ©alable.</p>
<p>La pile et le tas sont tous les deux des emplacements de la mÃ©moire qui
sont Ã  disposition de votre code lors de son exÃ©cution, mais sont organisÃ©s de
faÃ§on diffÃ©rente. La pile enregistre les valeurs dans l'ordre qu'elle les
reÃ§oit et enlÃ¨ve les valeurs dans l'autre sens. C'est ce que l'on appelle le
principe de <em>dernier entrÃ©, premier sorti</em>. C'est comme une pile d'assiettesÂ :
quand vous ajoutez des nouvelles assiettes, vous les dÃ©posez sur le dessus de
la pile, et quand vous avez besoin d'une assiette, vous en prenez une sur le
dessus. Ajouter ou enlever des assiettes au milieu ou en bas ne serait pas
aussi efficaceÂ ! Ajouter une donnÃ©e sur la pile se dit <em>empiler</em> et en retirer
une se dit <em>dÃ©piler</em>.</p>
<p>Toutes les donnÃ©es stockÃ©es dans la pile doivent avoir une taille connue et
fixe. Les donnÃ©es avec une taille inconnue au moment de la compilation ou une
taille qui peut changer doivent plutÃ´t Ãªtre stockÃ©es sur le tas. Le tas est
moins bien organisÃ©Â : lorsque vous ajoutez des donnÃ©es sur le tas, vous
demandez une certaine quantitÃ© d'espace mÃ©moire. Le gestionnaire de mÃ©moire va
trouver un emplacement dans le tas qui est suffisamment grand, va le marquer
comme Ã©tant en cours d'utilisation, et va retourner un <em>pointeur</em>, qui est
l'adresse de cet emplacement. Cette procÃ©dure est appelÃ©e <em>allocation sur le
tas</em>, ce qu'on abrÃ¨ge parfois en <em>allocation</em> tout court. L'ajout de valeurs
sur la pile n'est pas considÃ©rÃ© comme une allocation. Comme le pointeur a une
taille connue et fixe, on peut stocker ce pointeur sur la pile, mais quand on
veut la vraie donnÃ©e, il faut suivre le pointeur.</p>
<p>C'est comme si vous vouliez manger au restaurant. Quand vous entrez, vous
indiquez le nombre de personnes dans votre groupe, et le personnel trouve une
table vide qui peut recevoir tout le monde, et vous y conduit. Si quelqu'un
dans votre groupe arrive en retard, il peut leur demander oÃ¹ vous Ãªtes assis
pour vous rejoindre.</p>
<p>Empiler sur la pile est plus rapide qu'allouer sur le tas car le gestionnaire
ne va jamais avoir besoin de chercher un emplacement pour y stocker les
nouvelles donnÃ©esÂ ; il le fait toujours au sommet de la pile. En comparaison,
allouer de la place sur le tas demande plus de travail, car le gestionnaire
doit d'abord trouver un espace assez grand pour stocker les donnÃ©es et mettre
Ã  jour son suivi pour prÃ©parer la prochaine allocation.</p>
<p>AccÃ©der Ã  des donnÃ©es dans le tas est plus lent que d'accÃ©der aux donnÃ©es sur
la pile car nous devons suivre un pointeur pour les obtenir. Les processeurs
modernes sont plus rapides s'ils se dÃ©placent moins dans la mÃ©moire. Pour
continuer avec notre analogie, imaginez un serveur dans un restaurant qui
prend les commandes de nombreuses tables. C'est plus efficace de rÃ©cupÃ©rer
toutes les commandes Ã  une seule table avant de passer Ã  la table suivante.
Prendre une commande Ã  la table A, puis prendre une commande Ã  la table B,
puis ensuite une autre Ã  la table A, puis une autre Ã  la table B serait un
processus bien plus lent. De la mÃªme maniÃ¨re, un processeur sera plus efficace
dans sa tÃ¢che s'il travaille sur des donnÃ©es qui sont proches les unes des
autres (comme c'est le cas sur la pile) plutÃ´t que si elles sont plus
Ã©loignÃ©es (comme cela peut Ãªtre le cas sur le tas). Allouer une grande
quantitÃ© de mÃ©moire sur le tas peut aussi prendre beaucoup de temps.</p>
<p>Quand notre code utilise une fonction, les valeurs passÃ©es Ã  la fonction
(incluant, potentiellement, des pointeurs de donnÃ©es sur le tas) et les
variables locales Ã  la fonction sont dÃ©posÃ©es sur la pile. Quand l'utilisation
de la fonction est terminÃ©e, ces donnÃ©es sont retirÃ©es de la pile.</p>
<p>La possession nous aide Ã  ne pas nous prÃ©occuper de faire attention Ã  quelles
parties du code utilisent quelles donnÃ©es sur le tas, de minimiser la
quantitÃ© de donnÃ©es en double sur le tas, ou encore de veiller Ã  libÃ©rer les
donnÃ©es inutilisÃ©es sur le tas pour que nous ne soyons pas Ã  court d'espace.
Quand vous aurez compris la possession, vous n'aurez plus besoin de vous
prÃ©occuper de la pile et du tas trÃ¨s souvent, mais savoir que la possession
existe pour gÃ©rer les donnÃ©es du tas peut vous aider Ã  comprendre pourquoi
elle fonctionne de cette maniÃ¨re.</p>
</blockquote>
<!--
### Ownership Rules
-->
<h3><a class="header" href="#les-rÃ¨gles-de-la-possession" id="les-rÃ¨gles-de-la-possession">Les rÃ¨gles de la possession</a></h3>
<!--
First, letâ€™s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>Tout d'abord, dÃ©finissons les rÃ¨gles de la possession. Gardez Ã  l'esprit ces
rÃ¨gles pendant que nous travaillons sur des exemples qui les illustrentÂ :</p>
<!--
* Each value in Rust has a variable thatâ€™s called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Chaque valeur en Rust a une variable qui s'appelle son <em>propriÃ©taire</em>.</li>
<li>Il ne peut y avoir qu'un seul propriÃ©taire Ã  la fois.</li>
<li>Quand le propriÃ©taire sortira de la portÃ©e, la valeur sera supprimÃ©e.</li>
</ul>
<!--
### Variable Scope
-->
<h3><a class="header" href="#portÃ©e-de-la-variable" id="portÃ©e-de-la-variable">PortÃ©e de la variable</a></h3>
<!--
Weâ€™ve walked through an example of a Rust program already in Chapter 2. Now
that weâ€™re past basic syntax, we wonâ€™t include all the `fn main() {` code in
examples, so if youâ€™re following along, youâ€™ll have to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>Nous avons dÃ©jÃ  vu un exemple de programme Rust au chapitre 2. Maintenant
que nous avons vu la syntaxe Rust de base, nous n'allons plus ajouter tout le
code du style <code>fn main() {</code> dans les exemples, donc si vous voulez reproduire
les exemples, vous devrez les mettre manuellement dans une fonction <code>main</code>. Par
consÃ©quent, nos exemples seront plus concis, nous permettant de nous concentrer
sur les dÃ©tails de la situation plutÃ´t que sur du code normalisÃ©.</p>
<!--
As a first example of ownership, weâ€™ll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Letâ€™s say we
have a variable that looks like this:
-->
<p>Pour le premier exemple de possession, nous allons analyser la <em>portÃ©e</em> de
certaines variables. Une portÃ©e est une zone dans un programme dans laquelle un
Ã©lÃ©ment est en vigueur. Imaginons que nous ayons la variable suivanteÂ :</p>
<!--
```rust
let s = "hello";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which itâ€™s declared until the end of the current *scope*. Listing 4-1 has
comments annotating where the variable `s` is valid.
-->
<p>La variable <code>s</code> fait rÃ©fÃ©rence Ã  un littÃ©ral de chaÃ®ne de caractÃ¨res, oÃ¹ la
valeur de la chaÃ®ne est codÃ©e en dur dans notre programme. La variable est en
vigueur Ã  partir du moment oÃ¹ elle est dÃ©clarÃ©e jusqu'Ã  la fin de la <em>portÃ©e</em>
actuelle. L'encart 4-1 a des commentaires pour indiquer quand la variable <code>s</code>
est en vigueurÂ :</p>
<!--
```rust
# fn main() {
    {                      // s is not valid here, itâ€™s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                    // s n'est pas en vigueur ici, elle n'est pas encore dÃ©clarÃ©e
        let s = &quot;hello&quot;; // s est en vigueur Ã  partir de ce point

        // on fait des choses avec s ici
    }                    // cette portÃ©e est maintenant terminÃ©e, et s n'est plus en vigueur
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span>
-->
<p><span class="caption">Encart 4-1Â : Une variable et la portÃ©e dans laquelle elle
est en vigueur.</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>Autrement dit, il y a ici deux Ã©tapes importantesÂ :</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li>Quand <code>s</code> rentre <em>dans la portÃ©e</em>, elle est en vigueur.</li>
<li>Cela reste ainsi jusqu'Ã  ce qu'elle <em>sort de la portÃ©e</em>.</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now weâ€™ll build on top of this
understanding by introducing the `String` type.
-->
<p>Pour le moment, la relation entre les portÃ©es et les conditions pour lesquelles
les variables sont en vigueur sont similaires Ã  d'autres langages de
programmation. Maintenant, nous allons aller plus loin en y ajoutant le type
<code>String</code>.</p>
<!--
### The `String` Type
-->
<h3><a class="header" href="#le-type-string" id="le-type-string">Le type <code>String</code></a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than the ones we covered in the [â€œData Typesâ€][data-types]<!-- ignore -- >
section of Chapter 3. The types covered previously are all stored on the stack
and popped off the stack when their scope is over, but we want to look at data
that is stored on the heap and explore how Rust knows when to clean up that
data.
-->
<p>Pour illustrer les rÃ¨gles de la possession, nous avons besoin d'un type de
donnÃ©e qui est plus complexe que ceux que nous avons rencontrÃ©s dans la section
<a href="ch03-02-data-types.html">â€œTypes de donnÃ©esâ€</a><!-- ignore --> du chapitre 3. Les types que
nous avons vus prÃ©cÃ©demment sont tous stockÃ©s sur la pile et sont retirÃ©s de la
pile quand ils sortent de la portÃ©e, mais nous voulons expÃ©rimenter le stockage
de donnÃ©es sur le tas et dÃ©couvrir comment Rust sait quand il doit nettoyer ces
donnÃ©es.</p>
<!--
Weâ€™ll use `String` as the example here and concentrate on the parts of `String`
that relate to ownership. These aspects also apply to other complex data types,
whether they are provided by the standard library or created by you. Weâ€™ll
discuss `String` in more depth in Chapter 8.
-->
<p>Nous allons utiliser ici <code>String</code> pour l'exemple et nous concentrer sur les
caractÃ©ristiques de <code>String</code> qui sont liÃ©es Ã  la possession. Ces aspects
s'appliquent Ã©galement Ã  d'autres types de donnÃ©es complexes, qu'ils soient
fournis par la bibliothÃ¨que standard ou qu'ils soient crÃ©Ã©s par vous. Nous
verrons <code>String</code> plus en dÃ©tail dans le chapitre 8.</p>
<!--
Weâ€™ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they arenâ€™t suitable for every
situation in which we may want to use text. One reason is that theyâ€™re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type is
allocated on the heap and as such is able to store an amount of text that is
unknown to us at compile time. You can create a `String` from a string literal
using the `from` function, like so:
-->
<p>Nous avons dÃ©jÃ  vu les littÃ©raux de chaÃ®nes de caractÃ¨res, quand une valeur de
chaÃ®ne est codÃ©e en dur dans notre programme. Les littÃ©raux de chaÃ®nes sont
pratiques, mais ils ne conviennent pas toujours Ã  tous les cas oÃ¹ on veut
utiliser du texte. Une des raisons est qu'ils sont immuables. Une autre raison
est qu'on ne connaÃ®t pas forcÃ©ment le contenu des chaÃ®nes de caractÃ¨res quand
nous Ã©crivons notre codeÂ : par exemple, comment faire si nous voulons rÃ©cupÃ©rer
du texte saisi par l'utilisateur et l'enregistrerÂ ? Pour ces cas-ci, Rust a un
second type de chaÃ®ne de caractÃ¨res, <code>String</code>. Ce type est allouÃ© sur le tas et
est ainsi capable de stocker une quantitÃ© de texte qui nous est inconnue au
moment de la compilation. Vous pouvez crÃ©er une <code>String</code> Ã  partir d'un littÃ©ral
de chaÃ®ne de caractÃ¨res en utilisant la fonction <code>from</code>, comme ceciÂ :</p>
<!--
```rust
let s = String::from("hello");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon (`::`) is an operator that allows us to namespace this
particular `from` function under the `String` type rather than using some sort
of name like `string_from`. Weâ€™ll discuss this syntax more in the [â€œMethod
Syntaxâ€][method-syntax]<!-- ignore -- > section of Chapter 5 and when we talk
about namespacing with modules in [â€œPaths for Referring to an Item in the
Module Treeâ€][paths-module-tree]<!-- ignore -- > in Chapter 7.
-->
<p>Le double deux-points (<code>::</code>) est un opÃ©rateur qui nous permet d'appeler cette
fonction spÃ©cifique dans l'espace de nom du type <code>String</code> plutÃ´t que d'utiliser
un nom comme <code>string_from</code>. Nous verrons cette syntaxe plus en dÃ©tail dans la
section <a href="ch05-03-method-syntax.html">â€œSyntaxe de mÃ©thodeâ€</a><!-- ignore --> du chapitre 5 et
lorsque nous aborderons les espaces de noms dans la section
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">â€œLes chemins pour dÃ©signer un Ã©lÃ©ment dans l'arborescence de
moduleâ€</a><!-- ignore --> du chapitre 7.</p>
<!--
This kind of string *can* be mutated:
-->
<p>Ce type de chaÃ®ne de caractÃ¨res <em>peut</em> Ãªtre mutableÂ :</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() ajoute un littÃ©ral de chaÃ®ne dans une String
    
    println!(&quot;{}&quot;, s); // Cela va afficher `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<!--
So, whatâ€™s the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>Donc, quelle est la diffÃ©rence iciÂ ? Pourquoi <code>String</code> peut Ãªtre mutable, mais
pourquoi les littÃ©raux de chaÃ®nes ne peuvent pas l'ÃªtreÂ ? La diffÃ©rence
se trouve dans la faÃ§on dont ces deux types travaillent avec la mÃ©moire.</p>
<!--
### Memory and Allocation
-->
<h3><a class="header" href="#mÃ©moire-et-allocation" id="mÃ©moire-et-allocation">MÃ©moire et allocation</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literalâ€™s immutability. Unfortunately, we canâ€™t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>Dans le cas d'un littÃ©ral de chaÃ®ne de caractÃ¨res, nous connaissons le contenu
au moment de la compilation donc le texte est codÃ© en dur directement dans
l'exÃ©cutable final. VoilÃ  pourquoi ces littÃ©raux de chaÃ®nes de caractÃ¨res sont
performants et rapides. Mais ces caractÃ©ristiques viennent de leur immuabilitÃ©.
Malheureusement, on ne peut pas accorder une grosse rÃ©gion de mÃ©moire dans le
binaire pour chaque morceau de texte qui n'a pas de taille connue au moment de
la compilation et dont la taille pourrait changer pendant l'exÃ©cution de ce
programme.</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p>Avec le type <code>String</code>, pour nous permettre d'avoir un texte mutable et qui peut
s'agrandir, nous devons allouer une quantitÃ© de mÃ©moire sur le tas, inconnue
au moment de la compilation, pour stocker le contenu. Cela signifie queÂ :</p>
<!--
* The memory must be requested from the memory allocator at runtime.
* We need a way of returning this memory to the allocator when weâ€™re
  done with our `String`.
-->
<ul>
<li>La mÃ©moire doit Ãªtre demandÃ©e auprÃ¨s du gestionnaire de mÃ©moire lors de
l'exÃ©cution.</li>
<li>Nous avons besoin d'un moyen de rendre cette mÃ©moire au gestionnaire lorsque
nous aurons fini d'utiliser notre <code>String</code>.</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>Nous nous occupons de ce premier pointÂ : quand nous appelons <code>String::from</code>, son
implÃ©mentation demande la mÃ©moire dont elle a besoin. C'est pratiquement
toujours ainsi dans la majoritÃ© des langages de programmation.</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track and cleans up memory that isnâ€™t being used anymore,
and we donâ€™t need to think about it. Without a GC, itâ€™s our responsibility to
identify when memory is no longer being used and call code to explicitly return
it, just as we did to request it. Doing this correctly has historically been a
difficult programming problem. If we forget, weâ€™ll waste memory. If we do it
too early, weâ€™ll have an invalid variable. If we do it twice, thatâ€™s a bug too.
We need to pair exactly one `allocate` with exactly one `free`.
-->
<p>Cependant, le deuxiÃ¨me point est diffÃ©rent. Dans des langages avec un
<em>ramasse-miettes</em>, le ramasse-miettes surveille et nettoie la mÃ©moire qui n'est
plus utilisÃ©e, sans que nous n'ayons Ã  nous en prÃ©occuper. Sans un
ramasse-miettes, c'est de notre responsabilitÃ© d'identifier quand cette mÃ©moire
n'est plus utilisÃ©e et d'appeler du code pour explicitement la libÃ©rer, comme
nous l'avons fait pour la demander auparavant. Historiquement, faire ceci
correctement a toujours Ã©tÃ© une difficultÃ© pour les dÃ©veloppeurs. Si nous
oublions de le faire, nous allons gaspiller de la mÃ©moire. Si nous le faisons
trop tÃ´t, nous allons avoir une variable invalide. Si nous le faisons deux fois,
cela produit aussi un bogue. Nous devons associer exactement un <code>allocate</code> avec
exactement un <code>free</code>.</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Hereâ€™s a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rust prend un chemin diffÃ©rentÂ : la mÃ©moire est automatiquement libÃ©rÃ©e dÃ¨s
que la variable qui la possÃ¨de sort de la portÃ©e. Voici une version de notre
exemple de portÃ©e de l'encart 4-1 qui utilise une <code>String</code> plutÃ´t qu'un littÃ©ral
de chaÃ®ne de caractÃ¨resÂ :</p>
<!--
```rust
# fn main() {
    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s est en vigueur Ã  partir de ce point
    
        // on fait des choses avec s ici
    }                                  // cette portÃ©e est dÃ©sormais terminÃ©e, et s
                                       // n'est plus en vigueur maintenant
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the allocator: when `s` goes out of scope. When a variable goes out
of scope, Rust calls a special function for us. This function is called `drop`,
and itâ€™s where the author of `String` can put the code to return the memory.
Rust calls `drop` automatically at the closing curly bracket.
-->
<p>Il y a un moment naturel oÃ¹ nous devons rendre la mÃ©moire de notre
<code>String</code> au gestionnaireÂ : quand <code>s</code> sort de la portÃ©e. Quand une variable sort
de la portÃ©e, Rust appelle une fonction spÃ©ciale pour nous. Cette fonction
s'appelle <code>drop</code>, et c'est dans celle-ci que l'auteur de <code>String</code> a pu mettre le
code pour libÃ©rer la mÃ©moire. Rust appelle automatiquement <code>drop</code> Ã  l'accolade
fermante <code>}</code>.</p>
<!--
> Note: In C++, this pattern of deallocating resources at the end of an itemâ€™s
> lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
> The `drop` function in Rust will be familiar to you if youâ€™ve used RAII
> patterns.
-->
<blockquote>
<p>RemarqueÂ : en C++, cette faÃ§on de libÃ©rer des ressources Ã  la fin de la
durÃ©e de vie d'un Ã©lÃ©ment est parfois appelÃ©e <em>l'acquisition d'une ressource
est une initialisation (RAII)</em>. La fonction <code>drop</code> de Rust vous sera familiÃ¨re
si vous avez dÃ©jÃ  utilisÃ© des techniques de RAII.</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
weâ€™ve allocated on the heap. Letâ€™s explore some of those situations now.
-->
<p>Cette faÃ§on de faire a un impact profond sur la faÃ§on dont le code Rust est
Ã©crit. Cela peut sembler simple dans notre cas, mais le comportement du code
peut Ãªtre surprenant dans des situations plus compliquÃ©es oÃ¹ nous voulons
avoir plusieurs variables utilisant des donnÃ©es que nous avons affectÃ©es sur le
tas. Examinons une de ces situations dÃ¨s Ã  prÃ©sent.</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4><a class="header" href="#les-interactions-entre-les-variables-et-les-donnÃ©es--le-dÃ©placement" id="les-interactions-entre-les-variables-et-les-donnÃ©es--le-dÃ©placement">Les interactions entre les variables et les donnÃ©esÂ : le dÃ©placement</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Letâ€™s look at an example using an integer in Listing 4-2.
-->
<p>Plusieurs variables peuvent interagir avec les mÃªmes donnÃ©es de diffÃ©rentes
maniÃ¨res en Rust. Regardons un exemple avec un entier dans l'encart 4-2Â :</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span>
-->
<p><span class="caption">Encart 4-2Â : Assigner l'entier de la variable <code>x</code> Ã  <code>y</code>
</span></p>
<!--
We can probably guess what this is doing: â€œbind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.â€ We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>Nous pouvons probablement deviner ce que ce code faitÂ : â€œAssigner la valeur <code>5</code>
Ã  <code>x</code>Â ; ensuite faire une copie de cette valeur de <code>x</code> et l'assigner Ã  <code>y</code>.â€
Nous avons maintenant deux variables, <code>x</code> et <code>y</code>, et chacune vaut <code>5</code>. C'est
effectivement ce qui se passe, car les entiers sont des valeurs simples avec une
taille connue et fixÃ©e, et ces deux valeurs <code>5</code> sont stockÃ©es sur la pile.</p>
<!--
Now letâ€™s look at the `String` version:
-->
<p>Maintenant, essayons une nouvelle version avec <code>String</code>Â :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar to the previous code, so we might assume that the way
it works would be the same: that is, the second line would make a copy of the
value in `s1` and bind it to `s2`. But this isnâ€™t quite what happens.
-->
<p>Cela ressemble beaucoup au code prÃ©cÃ©dent, donc nous allons supposer que cela
fonctionne pareil que prÃ©cÃ©demmentÂ : ainsi, la seconde ligne va faire une copie
de la valeur de <code>s1</code> et l'assigner Ã  <code>s2</code>. Mais ce n'est pas tout Ã  fait ce
qu'il se passe.</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>Regardons l'illustration 4-1 pour dÃ©couvrir ce qui arrive Ã  <code>String</code> sous le
capot. Une <code>String</code> est constituÃ©e de trois Ã©lÃ©ments, prÃ©sents sur la gaucheÂ :
un pointeur vers la mÃ©moire qui contient le contenu de la chaÃ®ne de caractÃ¨res,
une taille, et une capacitÃ©. Ce groupe de donnÃ©es est stockÃ© sur la pile. Ã€
droite, nous avons la mÃ©moire sur le tas qui contient les donnÃ©es.</p>
<!-- markdownlint-disable -->
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une string en mÃ©moire" src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>
-->
<p><span class="caption">Illustration 4-1Â : ReprÃ©sentation en mÃ©moire d'une
<code>String</code> qui contient la valeur <code>&quot;hello&quot;</code> assignÃ©e Ã  <code>s1</code>.</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the allocator. The difference between length
and capacity matters, but not in this context, so for now, itâ€™s fine to ignore
the capacity.
-->
<p>La taille est la quantitÃ© de mÃ©moire, en octets, que le contenu de la <code>String</code>
utilise actuellement. La capacitÃ© est la quantitÃ© totale de mÃ©moire, en octets,
que la <code>String</code> a reÃ§ue du gestionnaire. La diffÃ©rence entre la taille et la
capacitÃ© est importante, mais pas pour notre exemple, donc pour l'instant, ce
n'est pas grave d'ignorer la capacitÃ©.</p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p>Quand nous assignons <code>s1</code> Ã  <code>s2</code>, les donnÃ©es de la <code>String</code> sont copiÃ©es, ce
qui veut dire que nous copions le pointeur, la taille et la capacitÃ© qui sont
stockÃ©s sur la pile. Nous ne copions pas les donnÃ©es stockÃ©es sur le tas
auxquelles le pointeur se rÃ©fÃ¨re. Autrement dit, la reprÃ©sentation des donnÃ©es
dans la mÃ©moire ressemble Ã  l'illustration 4-2.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 qui pointent vers la mÃªme valeur" src="img/trpl04-02.svg"
class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>
-->
<p><span class="caption">Illustration 4-2Â : ReprÃ©sentation en mÃ©moire de la
variable <code>s2</code> qui a une copie du pointeur, de la taille et de la capacitÃ© de
<code>s1</code></span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>Cette reprÃ©sentation <em>n'est pas</em> comme l'illustration 4-3, qui reprÃ©senterait la
mÃ©moire si Rust avait aussi copiÃ© les donnÃ©es sur le tas. Si Rust faisait ceci,
l'opÃ©ration <code>s2 = s1</code> pourrait potentiellement Ãªtre trÃ¨s coÃ»teuse en termes de
performances d'exÃ©cution si les donnÃ©es sur le tas Ã©taient volumineuses.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 Ã  deux endroits" src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>
-->
<p><span class="caption">Illustration 4-3Â : Une autre possibilitÃ© de ce que
pourrait faire <code>s2 = s1</code> si Rust copiait aussi les donnÃ©es du tas</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>PrÃ©cÃ©demment, nous avons dit que quand une variable sortait de la portÃ©e, Rust
appelait automatiquement la fonction <code>drop</code> et nettoyait la mÃ©moire sur le tas
allouÃ©e pour cette variable. Mais l'illustration 4-2 montre que les deux
pointeurs de donnÃ©es pointeraient au mÃªme endroit. C'est un problÃ¨meÂ : quand
<code>s2</code> et <code>s1</code> sortent de la portÃ©e, elles vont essayer toutes les deux de
libÃ©rer la mÃªme mÃ©moire. C'est ce qu'on appelle une erreur de <em>double
libÃ©ration</em> et c'est un des bogues de sÃ©curitÃ© de mÃ©moire que nous avons
mentionnÃ©s prÃ©cÃ©demment. LibÃ©rer la mÃ©moire deux fois peut mener Ã  des
corruptions de mÃ©moire, ce qui peut potentiellement mener Ã  des vulnÃ©rabilitÃ©s
de sÃ©curitÃ©.</p>
<!--
To ensure memory safety, thereâ€™s one more detail to what happens in this
situation in Rust. Instead of trying to copy the allocated memory, Rust
considers `s1` to no longer be valid and, therefore, Rust doesnâ€™t need to free
anything when `s1` goes out of scope. Check out what happens when you try to
use `s1` after `s2` is created; it wonâ€™t work:
-->
<p>Pour garantir la sÃ©curitÃ© de la mÃ©moire, il y a un autre petit dÃ©tail qui se
produit dans cette situation avec Rust. PlutÃ´t qu'essayer de copier la mÃ©moire
allouÃ©e, Rust considÃ¨re que <code>s1</code> n'est plus en vigueur et donc, Rust n'a pas
besoin de libÃ©rer quoi que ce soit lorsque <code>s1</code> sort de la portÃ©e. Regardez ce
qu'il se passe quand vous essayez d'utiliser <code>s1</code> aprÃ¨s que <code>s2</code> est crÃ©Ã©,
cela ne va pas fonctionnerÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<!--
Youâ€™ll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>Vous allez avoir une erreur comme celle-ci, car Rust vous dÃ©fend d'utiliser la
rÃ©fÃ©rence qui n'est plus en vigueurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 -- > src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
If youâ€™ve heard the terms *shallow copy* and *deep copy* while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, itâ€™s known as a *move*. In this example, we would say that
`s1` was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>Si vous avez dÃ©jÃ  entendu parler de <em>copie superficielle</em> et de <em>copie
profonde</em> en utilisant d'autres langages, l'idÃ©e de copier le pointeur, la
taille et la capacitÃ© sans copier les donnÃ©es peut vous faire penser Ã  de la
copie superficielle. Mais comme Rust neutralise aussi la premiÃ¨re variable, au
lieu d'appeler cela une copie superficielle, on appelle cela un <em>dÃ©placement</em>.
Ici, nous pourrions dire que <code>s1</code> a Ã©tÃ© <em>dÃ©placÃ©</em> dans <code>s2</code>. Donc ce qui se
passe rÃ©ellement est dÃ©crit par l'illustration 4-4.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 dÃ©placÃ© dans s2" src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>
-->
<p><span class="caption">Illustration 4-4Â : ReprÃ©sentation de la mÃ©moire aprÃ¨s que
<code>s1</code> a Ã©tÃ© neutralisÃ©e</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and weâ€™re done.
-->
<p>Cela rÃ©sout notre problÃ¨meÂ ! Avec seulement <code>s2</code> en vigueur, quand elle
sortira de la portÃ©e, elle seule va libÃ©rer la mÃ©moire, et c'est tout.</p>
<!--
In addition, thereâ€™s a design choice thatâ€™s implied by this: Rust will never
automatically create â€œdeepâ€ copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>De plus, cela signifie qu'il y a eu un choix de conceptionÂ : Rust ne va jamais
crÃ©er automatiquement de copie â€œprofondeâ€ de vos donnÃ©es. Par consÃ©quent, toute
copie <em>automatique</em> peut Ãªtre considÃ©rÃ©e comme peu coÃ»teuse en termes de
performances d'exÃ©cution.</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4><a class="header" href="#les-interactions-entre-les-variables-et-les-donnÃ©es--le-clonage" id="les-interactions-entre-les-variables-et-les-donnÃ©es--le-clonage">Les interactions entre les variables et les donnÃ©esÂ : le clonage</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. Weâ€™ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, youâ€™ve probably seen them before.
-->
<p>Si nous <em>voulons</em> faire une copie profonde des donnÃ©es sur le tas d'une
<code>String</code>, et pas seulement des donnÃ©es sur la pile, nous pouvons utiliser une
mÃ©thode commune qui s'appelle <code>clone</code>. Nous aborderons la syntaxe des mÃ©thodes
au chapitre 5, mais comme les mÃ©thodes sont des outils courants dans de
nombreux langages, vous les avez probablement utilisÃ©es auparavant.</p>
<!--
Hereâ€™s an example of the `clone` method in action:
-->
<p>Voici un exemple d'utilisation de la mÃ©thode <code>clone</code>Â :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>Cela fonctionne trÃ¨s bien et c'est ainsi que vous pouvez reproduire le
comportement dÃ©crit dans l'illustration 4-3, oÃ¹ les donnÃ©es du tas sont copiÃ©es.</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. Itâ€™s a visual indicator that something
different is going on.
-->
<p>Quand vous voyez un appel Ã  <code>clone</code>, vous savez que du code arbitraire est
exÃ©cutÃ© et que ce code peut Ãªtre coÃ»teux. C'est un indicateur visuel qu'il se
passe quelque chose de diffÃ©rent.</p>
<!--
#### Stack-Only Data: Copy
-->
<h4><a class="header" href="#donnÃ©es-uniquement-sur-la-pile--la-copie" id="donnÃ©es-uniquement-sur-la-pile--la-copie">DonnÃ©es uniquement sur la pileÂ : la copie</a></h4>
<!--
Thereâ€™s another wrinkle we havenâ€™t talked about yet. This code using integers â€“ 
part of which was shown in Listing 4-2 â€“ works and is valid:
-->
<p>Il y a un autre dÃ©tail dont on n'a pas encore parlÃ©. Le code suivant utilise
des entiers - on en a vu une partie dans l'encart 4-2Â - il fonctionne et
est correctÂ :</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we donâ€™t have a call to
`clone`, but `x` is still valid and wasnâ€™t moved into `y`.
-->
<p>Mais ce code semble contredire ce que nous venons d'apprendreÂ : nous n'avons
pas appelÃ© <code>clone</code>, mais <code>x</code> est toujours en vigueur et n'a pas Ã©tÃ© dÃ©placÃ©
dans <code>y</code>.</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means thereâ€™s no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, thereâ€™s no difference
between deep and shallow copying here, so calling `clone` wouldnâ€™t do anything
different from the usual shallow copying and we can leave it out.
-->
<p>La raison est que les types comme les entiers ont une taille connue au moment de
la compilation et sont entiÃ¨rement stockÃ©s sur la pile, donc la copie des
vraies valeurs est rapide Ã  faire. Cela signifie qu'il n'y a pas de raison que
nous voudrions neutraliser <code>x</code> aprÃ¨s avoir crÃ©Ã© la variable <code>y</code>. En d'autres
termes, il n'y a pas ici de diffÃ©rence entre la copie superficielle et profonde,
donc appeler <code>clone</code> ne ferait rien d'autre qu'une copie superficielle classique
et on peut s'en passer.</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types like integers that are stored on the stack (weâ€™ll talk more about traits
in Chapter 10). If a type has the `Copy` trait, an older variable is still
usable after assignment. Rust wonâ€™t let us annotate a type with the `Copy`
trait if the type, or any of its parts, has implemented the `Drop` trait. If
the type needs something special to happen when the value goes out of scope and
we add the `Copy` annotation to that type, weâ€™ll get a compile-time error. To
learn about how to add the `Copy` annotation to your type, see [â€œDerivable
Traitsâ€][derivable-traits]<!-- ignore -- > in Appendix C.
-->
<p>Rust a une annotation spÃ©ciale appelÃ©e le trait <code>Copy</code> que nous pouvons utiliser
sur des types comme les entiers qui sont stockÃ©s sur la pile (nous verrons les
traits dans le chapitre 10). Si un type a le trait <code>Copy</code>, l'ancienne variable
sera toujours utilisable aprÃ¨s avoir Ã©tÃ© affectÃ©e. Rust ne nous autorisera pas Ã 
annoter un type avec le trait <code>Copy</code> si ce type, ou un de ses Ã©lÃ©ments, a
implÃ©mentÃ© le trait <code>Drop</code>. Si ce type a besoin que quelque chose de spÃ©cial se
produise quand la valeur sort de la portÃ©e et que nous ajoutons l'annotation
<code>Copy</code> sur ce type, nous aurons une erreur au moment de la compilation. Pour
savoir comment ajouter l'annotation <code>Copy</code> sur votre type, rÃ©fÃ©rez-vous Ã 
<a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore --> sur les traits dÃ©rivables.</p>
<!--
So what types are `Copy`? You can check the documentation for the given type to
be sure, but as a general rule, any group of simple scalar values can be
`Copy`, and nothing that requires allocation or is some form of resource is
`Copy`. Here are some of the types that are `Copy`:
-->
<p>Donc, quels sont les types qui sont <code>Copy</code>Â ? Vous pouvez regarder dans la
documentation pour un type donnÃ© pour vous en assurer, mais de maniÃ¨re gÃ©nÃ©rale,
tout groupe de valeur scalaire peut Ãªtre <code>Copy</code>, et tout ce qui ne nÃ©cessite pas
d'allocation de mÃ©moire ou tout autre forme de ressource est <code>Copy</code>.
Voici quelques types qui sont <code>Copy</code>Â :</p>
<!--
* All the integer types, such as `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, such as `f64`.
* The character type, `char`.
* Tuples, if they only contain types that are also `Copy`. For example,
  `(i32, i32)` is `Copy`, but `(i32, String)` is not.
-->
<ul>
<li>Tous les types d'entiers, comme <code>u32</code>.</li>
<li>Le type boolÃ©en, <code>bool</code>, avec les valeurs <code>true</code> et <code>false</code>.</li>
<li>Tous les types de flottants, comme <code>f64</code>.</li>
<li>Le type de caractÃ¨re, <code>char</code>.</li>
<li>Les tuples, mais uniquement s'ils contiennent des types qui sont aussi <code>Copy</code>.
Par exemple, le <code>(i32, i32)</code> est <code>Copy</code>, mais pas <code>(i32, String)</code>.</li>
</ul>
<!--
### Ownership and Functions
-->
<h3><a class="header" href="#la-possession-et-les-fonctions" id="la-possession-et-les-fonctions">La possession et les fonctions</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>La syntaxe pour passer une valeur Ã  une fonction est similaire Ã  celle pour
assigner une valeur Ã  une variable. Passer une variable Ã  une fonction va la
dÃ©placer ou la copier, comme l'assignation. L'encart 4-3 est un exemple avec
quelques commentaires qui montrent oÃ¹ les variables rentrent et sortent de la
portÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so itâ€™s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello&quot;);  // s rentre dans la portÃ©e.

  prendre_possession(s);  // La valeur de s est dÃ©placÃ©e dans la fonctionâ€¦
                          // â€¦ et n'est plus en vigueur Ã  partir d'ici

  let x = 5;              // x rentre dans la portÃ©e.

  creer_copie(x);         // x va Ãªtre dÃ©placÃ©e dans la fonction,
                          // mais i32 est Copy, donc on peut
                          // utiliser x ensuite.

} // Ici, x sort de la portÃ©e, puis ensuite s. Mais puisque la valeur de s a
// Ã©tÃ© dÃ©placÃ©e, il ne se passe rien de spÃ©cial.

fn prendre_possession(texte: String) { // texte rentre dans la portÃ©e.
  println!(&quot;{}&quot;, texte);
} // Ici, texte sort de la portÃ©e et `drop` est appelÃ©. La mÃ©moire est libÃ©rÃ©e.

fn creer_copie(entier: i32) { // entier rentre dans la portÃ©e.
  println!(&quot;{}&quot;, entier);
} // Ici, entier sort de la portÃ©e. Il ne se passe rien de spÃ©cial.
</code></pre></pre>
<!--
<span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span>
-->
<p><span class="caption">Encart 4-3Â : Les fonctions avec les possessions et les
portÃ©es qui sont commentÃ©es</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p>Si on essayait d'utiliser <code>s</code> aprÃ¨s l'appel Ã  <code>prendre_possession</code>, Rust
dÃ©clencherait une erreur Ã  la compilation. Ces vÃ©rifications statiques
nous protÃ¨gent des erreurs. Essayez d'ajouter du code au <code>main</code> qui utilise <code>s</code>
et <code>x</code> pour dÃ©couvrir lorsque vous pouvez les utiliser et lorsque les rÃ¨gles de
la possession vous empÃªchent de le faire.</p>
<!--
### Return Values and Scope
-->
<h3><a class="header" href="#les-valeurs-de-retour-et-les-portÃ©es" id="les-valeurs-de-retour-et-les-portÃ©es">Les valeurs de retour et les portÃ©es</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 is an example with
similar annotations to those in Listing 4-3.
-->
<p>Retourner des valeurs peut aussi transfÃ©rer leur possession. L'encart 4-4 est un
exemple avec des annotations similaires Ã  celles de l'encart 4-3Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s1 = donne_possession();     // donne_possession dÃ©place sa valeur de
                                   // retour dans s1

  let s2 = String::from(&quot;hello&quot;);  // s2 rentre dans la portÃ©e

  let s3 = prend_et_rend(s2);      // s2 est dÃ©placÃ©e dans
                                   // prend_et_rend, qui elle aussi
                                   // dÃ©place sa valeur de retour dans s3.
} // Ici, s3 sort de la portÃ©e et est Ã©liminÃ©e. s2 sort de la portÃ©e mais a Ã©tÃ©
  // dÃ©placÃ©e donc il ne se passe rien. s1 sort aussi de la portÃ©e et est
  // Ã©liminÃ©e.

fn donne_possession() -&gt; String {      // donne_possession va dÃ©placer sa
                                       // valeur de retour dans la
                                       // fonction qui l'appelle.

  let texte = String::from(&quot;hello&quot;);   // texte rentre dans la portÃ©e.

  texte                                // texte est retournÃ©e et
                                       // est dÃ©placÃ©e vers le code qui
                                       // l'appelle.
}

// prend_et_rend va prendre une String et en retourne aussi une.
fn prend_et_rend(texte: String) -&gt; String { // texte rentre dans la portÃ©e.

  texte  // texte est retournÃ©e et dÃ©placÃ©e vers le code qui l'appelle.
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">Encart 4-4Â : Transferts de possession des valeurs de
retour</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless the data
has been moved to be owned by another variable.
-->
<p>La possession d'une variable suit toujours le mÃªme schÃ©ma Ã  chaque foisÂ :
assigner une valeur Ã  une autre variable la dÃ©place. Quand une variable qui
contient des donnÃ©es sur le tas sort de la portÃ©e, la valeur sera nettoyÃ©e
avec <code>drop</code> Ã  moins que la donnÃ©e ait Ã©tÃ© dÃ©placÃ©e pour Ãªtre possÃ©dÃ©e par une
autre variable.</p>
<!--
Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
Itâ€™s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.
-->
<p>Il est un peu fastidieux de prendre la possession puis ensuite de retourner la
possession Ã  chaque fonction. Et qu'est-ce qu'il se passe si nous voulons
qu'une fonction utilise une valeur, mais n'en prenne pas possessionÂ ? C'est
assez pÃ©nible que tout ce que nous passons doit Ãªtre retournÃ© si nous voulons
l'utiliser Ã  nouveau, en plus de toutes les donnÃ©es qui dÃ©coulent du corps
de la fonction que nous voulons aussi rÃ©cupÃ©rer.</p>
<!--
Itâ€™s possible to return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>Il est possible de retourner plusieurs valeurs Ã  l'aide d'un tuple, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, taille) = calculer_taille(s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s2, taille);
}

fn calculer_taille(s: String) -&gt; (String, usize) {
    let taille = s.len(); // len() retourne la taille d'une String.

    (s, taille)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">Encart 4-5Â : Retourner la possession des paramÃ¨tres</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
*references*.
-->
<p>Mais c'est trop laborieux et beaucoup de travail pour un principe qui devrait
Ãªtre banal. Heureusement pour nous, Rust a une fonctionnalitÃ© pour ce principe,
c'est ce qu'on appelle les <em>rÃ©fÃ©rences</em>.</p>
<!-- markdownlint-disable -->
<!--
[data-types]: ch03-02-data-types.html#data-types
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->
<!-- markdownlint-restore -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
