<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html" class="active"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/120">Pull Request</a>.</p>
</blockquote>
<!--
## Validating References with Lifetimes
-->
<h2><a class="header" href="#la-conformitÃ©-des-rÃ©fÃ©rences-avec-les-durÃ©es-de-vies" id="la-conformitÃ©-des-rÃ©fÃ©rences-avec-les-durÃ©es-de-vies">La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></h2>
<!--
One detail we didnâ€™t discuss in the [â€œReferences and
Borrowingâ€][references-and-borrowing]<!-- ignore -- > section in Chapter 4 is
that every reference in Rust has a *lifetime*, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and
inferred, just like most of the time, types are inferred. We must annotate
types when multiple types are possible. In a similar way, we must annotate
lifetimes when the lifetimes of references could be related in a few different
ways. Rust requires us to annotate the relationships using generic lifetime
parameters to ensure the actual references used at runtime will definitely be
valid.
-->
<p>Il reste un dÃ©tail que nous n'avons pas abordÃ© dans la section <a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-et-lemprunt">â€œLes rÃ©fÃ©rences
et l'empruntâ€</a><!-- ignore --> du chapitre 4, c'est que
toutes les rÃ©fÃ©rences ont une <em>durÃ©e de vie</em> dans Rust, qui est la portÃ©e pour
laquelle cette rÃ©fÃ©rence est en vigueur. La plupart du temps, les durÃ©es de
vies sont implicites et sont dÃ©duit automatiquement, comme pour la plupart du
temps les types sont dÃ©duits. Nous devons renseigner le type lorsque plusieurs
types sont possibles. De la mÃªme maniÃ¨re, nous devons renseigner les durÃ©es de
vie lorsque les durÃ©es de vies des rÃ©fÃ©rences peuvent Ãªtre dÃ©duites de
diffÃ©rentes maniÃ¨res. Rust nÃ©cessite que nous renseignons ces relations en
utilisant des paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques pour s'assurer que les
rÃ©fÃ©rences utilisÃ©es au moment de la compilation restent bien en vigueur.</p>
<!--
The concept of lifetimes is somewhat different from tools in other programming
languages, arguably making lifetimes Rustâ€™s most distinctive feature. Although
we wonâ€™t cover lifetimes in their entirety in this chapter, weâ€™ll discuss
common ways you might encounter lifetime syntax so you can become familiar with
the concepts.
-->
<p>Le concept de la durÃ©e de vie est quelque chose de radicalement diffÃ©rent de ce
que l'on retrouve dans les outils des autres langages de programmation, Ã  un
tel point que la durÃ©e de vie est la fonctionnalitÃ© qui distingue Rust des
autres. Bien que nous ne puissions couvrir l'intÃ©gralitÃ© de la durÃ©e de vie dans
ce chapitre, nous allons voir les cas les plus courants oÃ¹ vous allez
rencontrer la syntaxe de la durÃ©e de vie, afin de vous familiariser avec ses
concepts.</p>
<!--
### Preventing Dangling References with Lifetimes
-->
<h3><a class="header" href="#eviter-les-rÃ©fÃ©rences-pendouillantes-avec-les-durÃ©es-de-vie" id="eviter-les-rÃ©fÃ©rences-pendouillantes-avec-les-durÃ©es-de-vie">Eviter les rÃ©fÃ©rences pendouillantes avec les durÃ©es de vie</a></h3>
<!--
The main aim of lifetimes is to prevent dangling references, which cause a
program to reference data other than the data itâ€™s intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.
-->
<p>L'objectif principal des durÃ©es de vies est d'Ã©viter les rÃ©fÃ©rences
pendouillantes qui font qu'un programme pointe des donnÃ©es autres que celles sur
lesquelles il Ã©tait censÃ© pointer. Admettons le programme de l'encart 10-17, qui
a une portÃ©e externe et une portÃ©e interne.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-17Â : tentative d'utiliser une rÃ©fÃ©rence vers
une valeur qui est sortie de la portÃ©e</span></p>
<!--
> Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
> without giving them an initial value, so the variable name exists in the
> outer scope. At first glance, this might appear to be in conflict with Rustâ€™s
> having no null values. However, if we try to use a variable before giving it
> a value, weâ€™ll get a compile-time error, which shows that Rust indeed does
> not allow null values.
-->
<blockquote>
<p>RemarqueÂ : Les exemples dans les encarts 10-17, 10-18 et 10-24 dÃ©clarent des
variables sans initialiser leur valeur, donc les noms de ces variables
existent dans la portÃ©e externe. A premiÃ¨re vue, cela semble Ãªtre en conflit
avec le fonctionnement de Rust qui n'utilise pas les valeurs nulles.
Cependant, si nous essayons d'utiliser une variable avant de lui donner une
valeur, nous aurons une erreur au moment de la compilation, qui confirme que
Rust ne fonctionne pas avec des valeurs nulles.</p>
</blockquote>
<!--
The outer scope declares a variable named `r` with no initial value, and the
inner scope declares a variable named `x` with the initial value of 5. Inside
the inner scope, we attempt to set the value of `r` as a reference to `x`. Then
the inner scope ends, and we attempt to print the value in `r`. This code wonâ€™t
compile because the value `r` is referring to has gone out of scope before we
try to use it. Here is the error message:
-->
<p>La portÃ©e externe dÃ©clare une variable <code>r</code> sans valeur initiale, et la portÃ©e
interne dÃ©clare une variable <code>x</code> avec la valeur initiale Ã  <code>5</code>. Au sein de la
portÃ©e interne, nous essayons d'assigner la valeur de <code>r</code> comme Ã©tant une
rÃ©fÃ©rence Ã  <code>x</code>. Puis la portÃ©e interne se ferme, et nous essayons d'afficher la
valeur dans <code>r</code>. Ce code ne va pas se compiler car la valeur <code>r</code> se rÃ©fÃ¨re Ã 
quelque chose qui est sortie de la portÃ©e avant que nous essayons de l'utiliser.
Voici le message d'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
<p>|
7  |             r = &amp;x;
|                 ^^ borrowed value does not live long enough
8  |         }
|         - <code>x</code> dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
|                           - borrow later used here</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0597</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The variable `x` doesnâ€™t â€œlive long enough.â€ The reason is that `x` will be out
of scope when the inner scope ends on line 7. But `r` is still valid for the
outer scope; because its scope is larger, we say that it â€œlives longer.â€ If
Rust allowed this code to work, `r` would be referencing memory that was
deallocated when `x` went out of scope, and anything we tried to do with `r`
wouldnâ€™t work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.
-->
<p>La variable <code>x</code> n'existe plus (â€œdoes not live long enoughâ€). La raison Ã  cela
est que <code>x</code> est sortie de la portÃ©e lorsque la portÃ©e interne s'est fermÃ©e Ã  la
ligne 7. Mais <code>r</code> reste en vigueur dans la portÃ©e externeÂ ; car sa portÃ©e est
plus grande, on dit qu'il â€œvit plus longtempsâ€. Si Rust avait permis Ã  ce code de
s'exÃ©cuter, <code>r</code> pointerait sur de la mÃ©moire dÃ©sallouÃ©e dÃ¨s que <code>x</code> est sortie
de la portÃ©e, ainsi tout ce que nous pourrions faire avec <code>r</code> ne fonctionnerait
pas correctement. Mais comment Rust dÃ©tecte que ce code est invalideÂ ? Il
utilise le vÃ©rificateur d'emprunt.</p>
<!--
### The Borrow Checker
-->
<h3><a class="header" href="#le-vÃ©rificateur-demprunt" id="le-vÃ©rificateur-demprunt">Le vÃ©rificateur d'emprunt</a></h3>
<!--
The Rust compiler has a *borrow checker* that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.
-->
<p>Le compilateur de Rust embarque un <em>vÃ©rificateur d'emprunt</em> (borrow checker) qui
compare les portÃ©es pour dÃ©terminer si les emprunts sont valides. L'encart 10-18
montre le mÃªme code que l'encart 10-17, mais avec des commentaires qui montrent
les durÃ©es de vies des variables.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-18: Annotations of the lifetimes of `r` and
`x`, named `'a` and `'b`, respectively</span>
-->
<p><span class="caption">Encart 10-18Â : commentaires pour montrer les durÃ©es de vie
de <code>r</code> et <code>x</code>, qui s'appellent respectivement <code>'a</code> et <code>'b</code></span></p>
<!--
Here, weâ€™ve annotated the lifetime of `r` with `'a` and the lifetime of `x`
with `'b`. As you can see, the inner `'b` block is much smaller than the outer
`'a` lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory
with a lifetime of `'b`. The program is rejected because `'b` is shorter than
`'a`: the subject of the reference doesnâ€™t live as long as the reference.
-->
<p>Ici, nous avons montrÃ© la durÃ©e de vie de <code>r</code> avec <code>'a</code> et la durÃ©e de vie de
<code>x</code> avec <code>'b</code>. Comme vous pouvez le constater, le bloc interne <code>'b</code> est bien
plus petit que le bloc externe <code>'a</code>. Au moment de la compilation, Rust compare
les tailles des deux durÃ©es de vies et constate que <code>r</code> a la durÃ©e de vie <code>'a</code>
mais fait rÃ©fÃ©rence Ã  de la mÃ©moire qui a une durÃ©e de vie de <code>'b</code>. Ce programme
est refusÃ© car <code>'b</code> est plus court que <code>'a</code>Â : l'Ã©lÃ©ment pointÃ© par la rÃ©fÃ©rence
n'existe pas aussi longtemps que la rÃ©fÃ©rence.</p>
<!--
Listing 10-19 fixes the code so it doesnâ€™t have a dangling reference and
compiles without any errors.
-->
<p>L'encart 10-19 rÃ©sout le code afin qu'il n'ai plus de rÃ©fÃ©rence pendouillante et
qu'il se compile sans erreur.</p>
<!--
```rust
# fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span>
-->
<p><span class="caption">Encart 10-19Â : la rÃ©fÃ©rence est valide puisque la donnÃ©e a
une durÃ©e de vie plus longue que la rÃ©fÃ©rence</span></p>
<!--
Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. This
means `r` can reference `x` because Rust knows that the reference in `r` will
always be valid while `x` is valid.
-->
<p>Ici, <code>x</code> a la durÃ©e de vie <code>'b</code>, qui est plus grand dans ce cas que <code>'a</code>. Cela
signifie que <code>r</code> peut rÃ©fÃ©rencer <code>x</code> car Rust sait que la rÃ©fÃ©rence prÃ©sente
dans <code>r</code> sera toujours valide du moment que <code>x</code> est en vigueur.</p>
<!--
Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, letâ€™s explore generic
lifetimes of parameters and return values in the context of functions.
-->
<p>Maintenant que vous savez oÃ¹ se situent les durÃ©es de vie des rÃ©fÃ©rences et
comment Rust analyse les durÃ©es de vies pour s'assurer que les rÃ©fÃ©rences soient
toujours en vigueur, dÃ©couvrons les durÃ©es de vies gÃ©nÃ©riques des paramÃ¨tres et
des valeurs de retour dans le cas des fonctions.</p>
<!--
### Generic Lifetimes in Functions
-->
<h3><a class="header" href="#les-durÃ©es-de-vies-gÃ©nÃ©riques-dans-les-fonctions" id="les-durÃ©es-de-vies-gÃ©nÃ©riques-dans-les-fonctions">Les durÃ©es de vies gÃ©nÃ©riques dans les fonctions</a></h3>
<!--
Letâ€™s write a function that returns the longer of two string slices. This
function will take two string slices and return a string slice. After weâ€™ve
implemented the `longest` function, the code in Listing 10-20 should print `The
longest string is abcd`.
-->
<p>Ecrivons une fonction qui retourne la plus longue des slice d'une chaÃ®ne de
caractÃ¨res. Cette fonction va prendre en argument deux slices de chaÃ®ne de
caractÃ¨res et retourner une slice d'une chaÃ®ne de caractÃ¨res. AprÃ¨s avoir
implÃ©mentÃ© la fonction <code>la_plus_longue</code>, le code de l'encart 10-20 devrait
afficher <code>La plus grande chaÃ®ne est abcd</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let resultat = la_plus_longue(string1.as_str(), string2);
    println!("La plus grande chaÃ®ne est {}", resultat);
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let resultat = la_plus_longue(string1.as_str(), string2);
    println!(&quot;La plus grande chaÃ®ne est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-20: A `main` function that calls the `longest`
function to find the longer of two string slices</span>
-->
<p><span class="caption">Encart 10-20Â : une fonction <code>main</code> qui appelle la
fonction <code>la_plus_longue</code> pour trouver la plus grande des deux slices de chaÃ®ne
de caractÃ¨res
</span></p>
<!--
Note that we want the function to take string slices, which are references,
because we donâ€™t want the `longest` function to take ownership of its
parameters. Refer to the [â€œString Slices as
Parametersâ€][string-slices-as-parameters]<!-- ignore -- > section in Chapter 4
for more discussion about why the parameters we use in Listing 10-20 are the
ones we want.
-->
<p>Remarquez que nous souhaitons que la fonction prenne deux slices de chaÃ®nes de
caractÃ¨res, qui sont des rÃ©fÃ©rences, car nous ne voulons pas que la fonction
<code>la_plus_longue</code> prenne possession de ses paramÃ¨tres. Rendez-vous Ã  la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res-en-param%C3%A8tres">â€œLes slices de chaÃ®nes de caractÃ¨res en
paramÃ¨tresâ€</a><!-- ignore --> du chapitre 4 pour
savoir pourquoi nous utilisons ce type de paramÃ¨tre dans l'encart 10-20.</p>
<!--
If we try to implement the `longest` function as shown in Listing 10-21, it
wonâ€™t compile.
-->
<p>Si nous essayons d'implÃ©menter la fonction <code>la_plus_longue</code> comme dans l'encart
10-21, cela ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La plus grande chaÃ®ne est {}", resultat);
# }
# 
fn la_plus_longue(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande chaÃ®ne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-21: An implementation of the `longest`
function that returns the longer of two string slices but does not yet
compile</span>
-->
<p><span class="caption">Encart 10-21Â : une implÃ©mentation de la fonction
<code>la_plus_longue</code> qui retourne la plus longue des deux slices de chaÃ®nes de
caractÃ¨res, mais ne se compile pas encore</span></p>
<!--
Instead, we get the following error that talks about lifetimes:
-->
<p>A la place, nous obtenons l'erreur suivante qui nous parle de durÃ©es de vieÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
<p>|
9 | fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
|                                        ^ expected lifetime parameter
|
= help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from <code>x</code> or <code>y</code></p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0106</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                        ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The help text reveals that the return type needs a generic lifetime parameter
on it because Rust canâ€™t tell whether the reference being returned refers to
`x` or `y`. Actually, we donâ€™t know either, because the `if` block in the body
of this function returns a reference to `x` and the `else` block returns a
reference to `y`!
-->
<p>La partie â€œhelpâ€ nous explique que le type de retour a besoin d'un paramÃ¨tre de
durÃ©e de vie gÃ©nÃ©rique car Rust ne sait pas si la rÃ©fÃ©rence retournÃ©e est liÃ©e Ã 
<code>x</code> ou Ã  <code>y</code>. Pour le moment, nous ne le savons pas nous non plus, car le bloc
<code>if</code> dans le corps de cette fonction retourne une rÃ©fÃ©rence Ã  <code>x</code> et le bloc
<code>else</code> retourne une rÃ©fÃ©rence Ã  <code>y</code>Â !</p>
<!--
When weâ€™re defining this function, we donâ€™t know the concrete values that will
be passed into this function, so we donâ€™t know whether the `if` case or the
`else` case will execute. We also donâ€™t know the concrete lifetimes of the
references that will be passed in, so we canâ€™t look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker canâ€™t determine this either, because it
doesnâ€™t know how the lifetimes of `x` and `y` relate to the lifetime of the
return value. To fix this error, weâ€™ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.
-->
<p>Lorsque nous dÃ©finissons cette fonction, nous ne connaissons pas les valeurs
concrÃ¨tes qui vont passer dans cette fonction, donc nous ne savons pas si nous
allons exÃ©cuter le cas du <code>if</code> ou du <code>else</code>. Nous ne connaissons pas non plus les
durÃ©es de vie des rÃ©fÃ©rences qui vont passer dans la fonction, donc nous ne
pouvons pas vÃ©rifier les portÃ©es comme nous l'avons fait dans les encarts 10-18
et 10-19 pour dÃ©terminer quelle rÃ©fÃ©rence que nous allons retourner sera
toujours en vigueur. Le vÃ©rificateur d'emprunt ne va pas pouvoir non plus
dÃ©terminer cela, car il ne sait comment les durÃ©es de vie de <code>x</code> et de <code>y</code> sont
reliÃ©es Ã  la durÃ©e de vie de la valeur de retour. Pour rÃ©soudre cette erreur,
nous allons ajouter des paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques qui dÃ©finissent
la relation entre les rÃ©fÃ©rences, afin que le vÃ©rificateur d'emprunt puisse
faire cette analyse.</p>
<!--
### Lifetime Annotation Syntax
-->
<h3><a class="header" href="#la-syntaxe-pour-annoter-les-durÃ©es-de-vies" id="la-syntaxe-pour-annoter-les-durÃ©es-de-vies">La syntaxe pour annoter les durÃ©es de vies</a></h3>
<!--
Lifetime annotations donâ€™t change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.
-->
<p>L'annotation des durÃ©es de vie ne change pas la longueur de leur durÃ©e de vie.
Comme une fonction accepte n'importe quel type lorsque la signature utilise un
paramÃ¨tre de type gÃ©nÃ©rique, les fonctions peuvent accepter des rÃ©fÃ©rences avec
n'importe quelle durÃ©e de vie en prÃ©cisant un paramÃ¨tre de durÃ©e de vie
gÃ©nÃ©rique. L'annotation des durÃ©es de vie dÃ©crit la relation des durÃ©es de vies
de plusieurs rÃ©fÃ©rences entre elles sans influencer les durÃ©es de vie.</p>
<!--
Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (`'`) and are usually all lowercase and
very short, like generic types. Most people use the name `'a`. We place
lifetime parameter annotations after the `&` of a reference, using a space to
separate the annotation from the referenceâ€™s type.
-->
<p>L'annotation des durÃ©es de vies a une syntaxe un peu inhabituelleÂ : le nom des
paramÃ¨tres de durÃ©es de vies doit commencer par une apostrophe (<code>'</code>) et sont
habituellement en minuscule et trÃ¨s court, comme les types gÃ©nÃ©riques. La
plupart des personnes utilisent le nom <code>'a</code>. Nous plaÃ§ons le paramÃ¨tre de type
aprÃ¨s le <code>&amp;</code> d'une rÃ©fÃ©rence, en utilisant un espace pour sÃ©parer l'annotation
du type de la rÃ©fÃ©rence.</p>
<!--
Here are some examples: a reference to an `i32` without a lifetime parameter, a
reference to an `i32` that has a lifetime parameter named `'a`, and a mutable
reference to an `i32` that also has the lifetime `'a`.
-->
<p>Voici quelques exemplesÂ : une rÃ©fÃ©rence Ã  un <code>i32</code> sans paramÃ¨tre de durÃ©e de
vie, une rÃ©fÃ©rence Ã  un <code>i32</code> qui a un paramÃ¨tre de durÃ©e de vie <code>'a</code>, et une
rÃ©fÃ©rence mutable Ã  un <code>i32</code> qui a aussi la durÃ©e de vie <code>'a</code>.</p>
<!--
```rust,ignore
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```
-->
<pre><code class="language-rust ignore">&amp;i32        // une rÃ©fÃ©rence
&amp;'a i32     // une rÃ©fÃ©rence avec une durÃ©e de vie explicite
&amp;'a mut i32 // une rÃ©fÃ©rence mutable avec une durÃ©e de vie explicite
</code></pre>
<!--
One lifetime annotation by itself doesnâ€™t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, letâ€™s say we have a function with
the parameter `first` that is a reference to an `i32` with lifetime `'a`. The
function also has another parameter named `second` that is another reference to
an `i32` that also has the lifetime `'a`. The lifetime annotations indicate
that the references `first` and `second` must both live as long as that generic
lifetime.
-->
<p>Une annotation de durÃ©e de vie toute seule n'a pas vraiment de sens, car les
annotations sont faites pour indiquer Ã  Rust quels paramÃ¨tres de durÃ©e de vie
gÃ©nÃ©riques de plusieurs rÃ©fÃ©rences sont liÃ©s aux autres. Par exemple, disons que
nous avons une fonction avec le paramÃ¨tre <code>premier</code> qui est une rÃ©fÃ©rence Ã  un
<code>i32</code> avec la durÃ©e de vie <code>'a</code>. La fonction a aussi un autre paramÃ¨tre <code>second</code>
qui est une autre rÃ©fÃ©rence Ã  un <code>i32</code> qui a aussi la durÃ©e de vie <code>'a</code>. Les
annotations de durÃ©e de vie indiquent que les rÃ©fÃ©rences <code>premier</code> et <code>second</code>
doivent tous les deux exister aussi longtemps que la durÃ©e de vie gÃ©nÃ©rique.</p>
<!--
### Lifetime Annotations in Function Signatures
-->
<h3><a class="header" href="#les-annotations-de-durÃ©e-de-vie-dans-les-signatures-des-fonctions" id="les-annotations-de-durÃ©e-de-vie-dans-les-signatures-des-fonctions">Les annotations de durÃ©e de vie dans les signatures des fonctions</a></h3>
<!--
Now letâ€™s examine lifetime annotations in the context of the `longest`
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. The constraint we want to express in this signature is that all the
references in the parameters and the return value must have the same lifetime.
Weâ€™ll name the lifetime `'a` and then add it to each reference, as shown in
Listing 10-22.
-->
<p>Maintenant, examinons les annotations de durÃ©e de vie dans contexte de la
fonction <code>la_plus_longue</code>. Comme avec les paramÃ¨tres de type gÃ©nÃ©riques, nous
devons dÃ©clarer les paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques dans des chevrons
entre le nom de la fonction et la liste des paramÃ¨tres. Nous souhaitons
contraindre toutes les rÃ©fÃ©rences dans les paramÃ¨tres de cette fonction ainsi
que sa valeur de retour aient tous la mÃªme durÃ©e de vie. Nous allons appeler la
durÃ©e de vie <code>'a</code> et ensuite l'ajouter Ã  chaque rÃ©fÃ©rence, comme nous le faisons
dans l'encart 10-22.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La plus grande chaÃ®ne est {}", resultat);
# }
# 
fn la_plus_longue<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande chaÃ®ne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-22: The `longest` function definition
specifying that all the references in the signature must have the same lifetime
`'a`</span>
-->
<p><span class="caption">Encart 10-22Â : dÃ©finition de la fonction <code>la_plus_longue</code>
qui indique que toutes les rÃ©fÃ©rences prÃ©sentes dans la signature doivent avoir
la mÃªme durÃ©e de vie <code>'a</code></span></p>
<!--
This code should compile and produce the result we want when we use it with the
`main` function in Listing 10-20.
-->
<p>Le code devrait se compiler et devrait produire le rÃ©sultat que nous souhaitions
lorsque nous l'utilisions dans la fonction <code>main</code> de l'encart 10-20.</p>
<!--
The function signature now tells Rust that for some lifetime `'a`, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime `'a`. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime `'a`.
In practice, it means that the lifetime of the reference returned by the
`longest` function is the same as the smaller of the lifetimes of the
references passed in. These constraints are what we want Rust to enforce.
Remember, when we specify the lifetime parameters in this function signature,
weâ€™re not changing the lifetimes of any values passed in or returned. Rather,
weâ€™re specifying that the borrow checker should reject any values that donâ€™t
adhere to these constraints. Note that the `longest` function doesnâ€™t need to
know exactly how long `x` and `y` will live, only that some scope can be
substituted for `'a` that will satisfy this signature.
-->
<p>La signature de la fonction indique maintenant Ã  Rust que pour la durÃ©e de vie
<code>'a</code>, la fonction prend deux paramÃ¨tres, les deux Ã©tant des slices de chaÃ®ne de
caractÃ¨re qui vivent aussi longtemps que la durÃ©e de vie <code>'a</code>. La signature de
la fonction indique Ã©galement Ã  Rust que la slice de chaÃ®ne de caractÃ¨re qui est
retournÃ©e par la fonction vivra au moins aussi longtemps que la durÃ©e de vie
<code>'a</code>. Dans la pratique, cela veut dire que durÃ©e de vie de la rÃ©fÃ©rence
retournÃ©e par la fonction <code>la_plus_longue</code> est la mÃªme que celle de la plus
petite des durÃ©es de vies des rÃ©fÃ©rences qu'on lui donne. Ces restrictions sont
celles que nous voulons que Rust fasse respecter. Souvenez-vous, lorsque nous
prÃ©cisons les paramÃ¨tres de durÃ©e de vie dans la signature de cette fonction,
nous ne changons pas les durÃ©es de vies des valeurs qui lui sont envoyÃ©es ou
qu'elle retourne. Ce que nous faisons, c'est plutÃ´t indiquer au vÃ©rificateur
d'emprunt qu'il doit rejeter toute valeur qui ne rÃ©pond pas Ã  ces conditions.
Notez que la fonction <code>la_plus_longue</code> n'a pas besoin de savoir exactement
combien de temps <code>x</code> et <code>y</code> vont exister, mais seulement que cette portÃ©e peut
Ãªtre substituÃ©e par <code>'a</code>, qui satisfera cette signature.</p>
<!--
When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help. However, when a function has references to or from
code outside that function, it becomes almost impossible for Rust to figure out
the lifetimes of the parameters or return values on its own. The lifetimes
might be different each time the function is called. This is why we need to
annotate the lifetimes manually.
-->
<p>Lorsqu'on prÃ©cise les durÃ©es de vie dans les fonctions, les annotations se
placent dans la signature de la fonction, pas dans le corps de la fonction. Rust
peut analyser le code Ã  l'intÃ©rieur du corps sans aucune aide. Cependant,
lorsqu'une fonction a des rÃ©fÃ©rences vers du code externe ou que ce code
rÃ©utilise une rÃ©fÃ©rence retournÃ©e par cette fonction, il devient presque
impossible pour Rust de dÃ©duire tout seul les durÃ©es de vie des paramÃ¨tres ou
des valeurs de retour. Les durÃ©es de vies peuvent Ãªtre diffÃ©rentes Ã  chaque fois
que la fonction est appelÃ©e. C'est pourquoi nous avons besoin d'indiquer les
durÃ©es de vie manuellement.</p>
<!--
When we pass concrete references to `longest`, the concrete lifetime that is
substituted for `'a` is the part of the scope of `x` that overlaps with the
scope of `y`. In other words, the generic lifetime `'a` will get the concrete
lifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because
weâ€™ve annotated the returned reference with the same lifetime parameter `'a`,
the returned reference will also be valid for the length of the smaller of the
lifetimes of `x` and `y`.
-->
<p>Lorsque nous donnons une rÃ©fÃ©rence concrÃ¨te Ã  <code>la_plus_longue</code>, la durÃ©e de vie
concrÃ¨te qui est modÃ©lisÃ©e par <code>'a</code> est la partie de la portÃ©e de <code>x</code> qui se
chevauche avec la portÃ©e de <code>y</code>. Autrement dit, la durÃ©e vie gÃ©nÃ©rique <code>'a</code> aura
la durÃ©e de vie concrÃ¨te qui est Ã©gale Ã  la plus petite des durÃ©es de vies entre
<code>x</code> et <code>y</code>. Comme nous avons marquÃ© la rÃ©fÃ©rence retournÃ©e avec le mÃªme
paramÃ¨tre de durÃ©e de vie <code>'a</code>, la rÃ©fÃ©rence retournÃ©e sera toujours en vigueur
pour la durÃ©e de la plus petite des durÃ©es de vies de <code>x</code> et de <code>y</code>.</p>
<!--
Letâ€™s look at how the lifetime annotations restrict the `longest` function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.
-->
<p>Regardons comment les annotations de durÃ©e de vie restreignent la fonction
<code>la_plus_longue</code> en y passant des rÃ©fÃ©rences qui ont des durÃ©es de vies
concrÃ¨tement diffÃ©rentes. L'encart 10-23 en est un exemple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let string1 = String::from("une longue chaÃ®ne est longue");

    {
        let string2 = String::from("xyz");
        let resultat = la_plus_longue(string1.as_str(), string2.as_str());
        println!("La chaÃ®ne la plus longue est {}", resultat);
    }
}
# 
# fn la_plus_longue<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;une longue chaÃ®ne est longue&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let resultat = la_plus_longue(string1.as_str(), string2.as_str());
        println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
    }
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-23: Using the `longest` function with
references to `String` values that have different concrete lifetimes</span>
-->
<p><span class="caption">Encart 10-23Â : utilisation de la fonction <code>la_plus_longue</code>
sur des rÃ©fÃ©rences Ã  des valeurs <code>String</code> qui ont concrÃ¨tement des durÃ©es de vie
diffÃ©rentes</span></p>
<!--
In this example, `string1` is valid until the end of the outer scope, `string2`
is valid until the end of the inner scope, and `result` references something
that is valid until the end of the inner scope. Run this code, and youâ€™ll see
that the borrow checker approves of this code; it will compile and print `The
longest string is long string is long`.
-->
<p>Dans cet exemple, <code>string1</code> est en vigueur jusqu'Ã  la fin de la portÃ©e externe,
<code>string2</code> n'est valide que jusqu'Ã  la fin de la portÃ©e interne, et <code>resultat</code>
est une rÃ©fÃ©rence vers quelque chose qui est en vigueur jusqu'Ã  la fin de la
portÃ©e interne. Lorsque vous lancez ce code, vous constaterez que le
vÃ©rificateur d'emprunt accepte ce codeÂ ; il va se compiler et afficher
<code>La chaÃ®ne la plus longue est une longue chaÃ®ne est longue</code>.</p>
<!--
Next, letâ€™s try an example that shows that the lifetime of the reference in
`result` must be the smaller lifetime of the two arguments. Weâ€™ll move the
declaration of the `result` variable outside the inner scope but leave the
assignment of the value to the `result` variable inside the scope with
`string2`. Then weâ€™ll move the `println!` that uses `result` outside the inner
scope, after the inner scope has ended. The code in Listing 10-24 will not
compile.
-->
<p>Maintenant, essayons un exemple qui fait en sorte que la durÃ©e de vie de la
rÃ©fÃ©rence dans <code>resultat</code> sera plus petite que celles des deux arguments. Nous
allons dÃ©placer la dÃ©claration de la variable <code>resultat</code> Ã  l'extÃ©rieur de la
portÃ©e interne mais on va laisser l'affectation de la valeur de la variable
<code>resultat</code> Ã  l'intÃ©rieur de la portÃ©e de <code>string2</code>. Nous allons ensuite dÃ©placer
le <code>println!</code>, qui utilise <code>resultat</code>, Ã  l'extÃ©rieur de la portÃ©e interne, aprÃ¨s
que la portÃ©e soit terminÃ©e. Le code de l'encart 10-24 ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let string1 = String::from("une longue chaÃ®ne est longue");
    let resultat;
    {
        let string2 = String::from("xyz");
        resultat = la_plus_longue(string1.as_str(), string2.as_str());
    }
    println!("La chaÃ®ne la plus longue est {}", resultat);
}
# 
# fn la_plus_longue<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;une longue chaÃ®ne est longue&quot;);
    let resultat;
    {
        let string2 = String::from(&quot;xyz&quot;);
        resultat = la_plus_longue(string1.as_str(), string2.as_str());
    }
    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-24: Attempting to use `result` after `string2`
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-24Â : tentative d'utilisation de <code>resultat</code> aprÃ¨s
<code>string2</code>, qui est sortie de la portÃ©e</span></p>
<!--
When we try to compile this code, weâ€™ll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous aurons cette erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
<p>|
6 |         result = la_plus_longue(string1.as_str(), string2.as_str());
|                                                   ^^^^^^^ borrowed value does not live long enough
7 |     }
|     - <code>string2</code> dropped here while still borrowed
8 |     println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
|                                                 -------- borrow later used here</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0597</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = la_plus_longue(string1.as_str(), string2.as_str());
  |                                                   ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
  |                                                 -------- borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error shows that for `result` to be valid for the `println!` statement,
`string2` would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter `'a`.
-->
<p>L'erreur explique que pour que <code>resultat</code> soit en vigueur pour l'instruction
<code>println!</code>, <code>string2</code> doit toujours Ãªtre valide jusqu'Ã  la fin de la portÃ©e
externe. Rust en a dÃ©duit cela car nous avons prÃ©cisÃ© les durÃ©es de vie des
paramÃ¨tres de la fonction et des valeurs de retour en utilisant le mÃªme
paramÃ¨tre de durÃ©e de vie <code>'a</code>.</p>
<!--
As humans, we can look at this code and see that `string1` is longer than
`string2` and therefore `result` will contain a reference to `string1`.
Because `string1` has not gone out of scope yet, a reference to `string1` will
still be valid for the `println!` statement. However, the compiler canâ€™t see
that the reference is valid in this case. Weâ€™ve told Rust that the lifetime of
the reference returned by the `longest` function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.
-->
<p>En tant qu'humain, nous pouvons lire ce code et constater que <code>string1</code> est plus
grand que <code>string2</code> et ainsi que <code>resultat</code> contiendra une rÃ©fÃ©rence vers
<code>string1</code>. Comme <code>string1</code> n'est pas encore sorti de portÃ©e, une rÃ©fÃ©rence vers
<code>string1</code> sera toujours valide pour l'instruction <code>println!</code>. Cependant, le
compilateur ne peut pas dÃ©duire que la rÃ©fÃ©rence est valide dans notre cas. Nous
avons dit Ã  Rust que la durÃ©e de vie de la rÃ©fÃ©rence qui est retournÃ©e par la
fonction <code>la_plus_longue</code> est la mÃªme que la plus petite des durÃ©es de vie des
rÃ©fÃ©rences qu'on lui passe en argument. C'est pourquoi le vÃ©rificateur d'emprunt
rejette le code de l'encart 10-24 car il a potentiellement une rÃ©fÃ©rence
invalide.</p>
<!--
Try designing more experiments that vary the values and lifetimes of the
references passed in to the `longest` function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if youâ€™re right!
-->
<p>Essayez d'expÃ©rimenter d'autres situations en variant les valeurs et durÃ©es de
vie des rÃ©fÃ©rences passÃ©es en argument de la fonction <code>la_plus_longue</code>, et
aussi comment on utilise la rÃ©fÃ©rence retournÃ©e. Faites des hypothÃ¨ses si ces
situations vont passer ou non le vÃ©rificateur d'emprunt avant que vous
compiliezÂ ; et vÃ©rifiez ensuite si vous avez raisonÂ !</p>
<!--
### Thinking in Terms of Lifetimes
-->
<h3><a class="header" href="#penser-en-termes-de-durÃ©es-de-vie" id="penser-en-termes-de-durÃ©es-de-vie">Penser en termes de durÃ©es de vie</a></h3>
<!--
The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
`longest` function to always return the first parameter rather than the longest
string slice, we wouldnâ€™t need to specify a lifetime on the `y` parameter. The
following code will compile:
-->
<p>La faÃ§on dont vous avez Ã  prÃ©ciser les paramÃ¨tres de durÃ©es de vie dÃ©pend de ce
que fait votre fonction. Par exemple, si nous changions l'implÃ©mentation de la
fonction <code>la_plus_longue</code> pour qu'elle retourne systÃ©matiquement le premier
paramÃ¨tre plutÃ´t que la slice de chaÃ®ne de caractÃ¨res la plus longue, nous
n'aurions pas besoin de renseigner une durÃ©e de vie sur le paramÃ¨tre <code>y</code>. Le
code suivant se compileÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "efghijklmnopqrstuvwxyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La chaÃ®ne la plus longue est {}", resultat);
# }
# 
fn la_plus_longue<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<!--
In this example, weâ€™ve specified a lifetime parameter `'a` for the parameter
`x` and the return type, but not for the parameter `y`, because the lifetime of
`y` does not have any relationship with the lifetime of `x` or the return value.
-->
<p>Dans cet exemple, nous avons prÃ©cisÃ© un paramÃ¨tre de durÃ©e de vie <code>'a</code> sur le
paramÃ¨tre <code>x</code> et sur le type de retour, mais pas sur le paramÃ¨tre <code>y</code>, car la
durÃ©e de vie de <code>y</code> n'a pas de lien avec la durÃ©e de vie de <code>x</code> ou de la valeur
de retour.</p>
<!--
When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does *not* refer to one of the parameters, it must refer
to a value created within this function, which would be a dangling reference
because the value will go out of scope at the end of the function. Consider
this attempted implementation of the `longest` function that wonâ€™t compile:
-->
<p>Lorsqu'on retourne une rÃ©fÃ©rence Ã  partir d'une fonction, le paramÃ¨tre de la
durÃ©e de vie pour le type de retour doit correspondre Ã  une des durÃ©es des
paramÃ¨tres. Si la rÃ©fÃ©rence retournÃ©e ne se rÃ©fÃ¨re <em>pas</em> Ã  un de ses paramÃ¨tres,
elle se rÃ©fÃ¨re probablement Ã  une valeur crÃ©e Ã  l'intÃ©rieur de cette fonction,
et elle deviendra une rÃ©fÃ©rence pendouillante car sa valeur va sortir de la
portÃ©e Ã  la fin de la fonction. Imaginons cette tentative d'implÃ©mentation de
la fonction <code>la_plus_longue</code> qui ne se compile pasÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La chaÃ®ne la plus longue est {}", resultat);
# }
# 
fn la_plus_longue<'a>(x: &str, y: &str) -> &'a str {
    let resultat = String::from("trÃ¨s longue chaÃ®ne");
    resultat.as_str()
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let resultat = String::from(&quot;trÃ¨s longue chaÃ®ne&quot;);
    resultat.as_str()
}
</code></pre>
<!--
Here, even though weâ€™ve specified a lifetime parameter `'a` for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:
-->
<p>Ici, mÃªme si nous avons prÃ©cisÃ© un paramÃ¨tre de durÃ©e de vie <code>'a</code> sur le type de
retour, cette implÃ©mentation va Ã©chouer Ã  la compilation car la durÃ©e de vie de
la valeur de retour n'est pas du tout liÃ©e Ã  la durÃ©e de vie des paramÃ¨tres.
Voici le message d'erreur que nous obtenonsÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `resultat`
  --> src/main.rs:11:5
<p>|
11 |     resultat.as_str()
|     --------^^^^^^^^^
|     |
|     returns a value referencing data owned by the current function
|     <code>resultat</code> is borrowed here</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0515</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `resultat`
  --&gt; src/main.rs:11:5
   |
11 |     resultat.as_str()
   |     --------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `resultat` is borrowed here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The problem is that `result` goes out of scope and gets cleaned up at the end
of the `longest` function. Weâ€™re also trying to return a reference to `result`
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust wonâ€™t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.
-->
<p>Le problÃ¨me est que <code>resultat</code> sort de la portÃ©e et est effacÃ©e Ã  la fin de la
fonction <code>la_plus_longue</code>. Nous avons aussi essayÃ© de retourner une rÃ©fÃ©rence
vers <code>resultat</code> Ã  partir de la fonction. Il n'existe aucune faÃ§on d'Ã©crire les
paramÃ¨tres de durÃ©e de vie de telle maniÃ¨re que cela changerait la rÃ©fÃ©rence
pendouillante, et Rust ne nous laissera pas crÃ©er une rÃ©fÃ©rence pendouillante.
Dans notre cas, la meilleure solution est de retourner un type de donnÃ©e dont on
va prendre possession plutÃ´t qu'une rÃ©fÃ©rence, ainsi le code appelant sera
responsable du nettoyage de la valeur.</p>
<!--
Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once theyâ€™re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.
-->
<p>Enfin, la syntaxe de la durÃ©e de vie sert Ã  interconnecter les durÃ©es de vie de
plusieurs paramÃ¨tres ainsi que les valeurs de retour des fonctions. Une fois
interconnectÃ©s, Rust a assez d'informations pour autoriser les opÃ©rations
sÃ©curisÃ©es dans la mÃ©moire et refuser les opÃ©rations qui pourraient crÃ©er des
pointeurs pendouillants ou alors enfreindre la sÃ©curitÃ© de la mÃ©moire.</p>
<!--
### Lifetime Annotations in Struct Definitions
-->
<h3><a class="header" href="#lajout-des-durÃ©es-de-vies-dans-les-dÃ©finitions-des-structures" id="lajout-des-durÃ©es-de-vies-dans-les-dÃ©finitions-des-structures">L'ajout des durÃ©es de vies dans les dÃ©finitions des structures</a></h3>
<!--
So far, weâ€™ve only defined structs to hold owned types. Itâ€™s possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the structâ€™s definition. Listing 10-25 has a
struct named `ImportantExcerpt` that holds a string slice.
-->
<p>Jusqu'Ã  prÃ©sent, nous avons dÃ©fini des structures pour contenir des types qui
sont possÃ©dÃ©s par elles-mÃªmes. Il est possible qu'une structure puisse contenir
des rÃ©fÃ©rences, mais dans ce cas nous devons prÃ©ciser une durÃ©e de vie sur
chaque rÃ©fÃ©rence dans la dÃ©finition de la structure. L'encart 10-25 montre une
structure <code>ExtraitImportant</code> qui stocke une slice de chaÃ®ne de caractÃ¨res.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct ExtraitImportant<'a> {
    partie: &'a str,
}

fn main() {
    let roman = String::from("Appelez-moi IsmaÃ«l. Il y a quelques annÃ©es ...");
    let premiere_phrase = roman.split('.')
        .next()
        .expect("Impossible de trouver un '.'");
    let i = ExtraitImportant { partie: premiere_phrase };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct ExtraitImportant&lt;'a&gt; {
    partie: &amp;'a str,
}

fn main() {
    let roman = String::from(&quot;Appelez-moi IsmaÃ«l. Il y a quelques annÃ©es ...&quot;);
    let premiere_phrase = roman.split('.')
        .next()
        .expect(&quot;Impossible de trouver un '.'&quot;);
    let i = ExtraitImportant { partie: premiere_phrase };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span>
-->
<p><span class="caption">Encart 10-25Â : une structure qui stocke une rÃ©fÃ©rence,
par consÃ©quent sa dÃ©finition a besoin d'une annotation de durÃ©e de vie</span></p>
<!--
This struct has one field, `part`, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of `ImportantExcerpt` canâ€™t outlive the reference
it holds in its `part` field.
-->
<p>Cette structure a un champ, <code>partie</code>, qui stocke une slice de chaÃ®ne de
caractÃ¨res, qui est une rÃ©fÃ©rence. Comme pour les types de donnÃ©es gÃ©nÃ©riques,
nous dÃ©clarons le nom du paramÃ¨tre de durÃ©e de vie gÃ©nÃ©rique entre des chevrons
aprÃ¨s le nom de la structure pour que nous puissions utiliser le paramÃ¨tre de
durÃ©e de vie dans le corps de la dÃ©finition de la structure. Cette annotation
signifie qu'une instance de <code>ExtraitImportant</code> ne peut pas vivre plus longtemps
que la rÃ©fÃ©rence qu'elle stocke dans son champ <code>partie</code>.</p>
<!--
The `main` function here creates an instance of the `ImportantExcerpt` struct
that holds a reference to the first sentence of the `String` owned by the
variable `novel`. The data in `novel` exists before the `ImportantExcerpt`
instance is created. In addition, `novel` doesnâ€™t go out of scope until after
the `ImportantExcerpt` goes out of scope, so the reference in the
`ImportantExcerpt` instance is valid.
-->
<p>La fonction <code>main</code> crÃ©e ici une instance de la structure <code>ExtraitImportant</code> qui
stocke une rÃ©fÃ©rence vers la premiÃ¨re phrase de la <code>String</code> possÃ©dÃ©e par la
variable <code>roman</code>. Les donnÃ©es dans <code>roman</code> existent avant que l'instance de
<code>ExtraitImportant</code> soit crÃ©e. De plus, <code>roman</code> ne sort pas de la portÃ©e avant
que l'instance de <code>ExtraitImportant</code> sorte de la portÃ©e, donc la rÃ©fÃ©rence dans
l'instance de <code>ExtraitImportant</code> est toujours valide.</p>
<!--
### Lifetime Elision
-->
<h3><a class="header" href="#lÃ©lision-des-durÃ©es-de-vie" id="lÃ©lision-des-durÃ©es-de-vie">L'Ã©lision des durÃ©es de vie</a></h3>
<!--
Youâ€™ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, which is shown again in Listing
10-26, that compiled without lifetime annotations.
-->
<p>Vous avez appris que toute rÃ©fÃ©rence a une durÃ©e de vie et que vous devez
renseigner des paramÃ¨tres de durÃ©e de vie sur des fonctions ou des structures
qui utilisent des rÃ©fÃ©rences. Cependant, dans le chapitre 4 nous avions une
fonction dans l'encart 4-9, qui est montrÃ©e Ã  nouveau dans l'encart 10-26, qui
compilait sans informations de durÃ©e de vie.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
fn premier_mot(s: &str) -> &str {
    let octets = s.as_bytes();

    for (i, &element) in octets.iter().enumerate() {
        if element == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // first_word works on slices of `String`s
#     let word = premier_mot(&my_string[..]);
# 
#     let my_string_literal = "hello world";
# 
#     // first_word works on slices of string literals
#     let word = premier_mot(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = premier_mot(my_string_literal);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;str) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = premier_mot(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = premier_mot(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = premier_mot(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span>
-->
<p><span class="caption">Encart 10-26Â : une fonction que nous avons dÃ©fini dans
l'encart 4-9 qui se compilait sans avoir d'indications sur la durÃ©e de vie, mÃªme
si les paramÃ¨tres et le type de retour sont des rÃ©fÃ©rences</span></p>
<!--
The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldnâ€™t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:
-->
<p>La raison pour laquelle cette fonction se compile sans annotation de durÃ©e de
vie est historiqueÂ : dans les premiÃ¨res versions de Rust (avant la 1.0), ce code
ne se serait pas compilÃ© parce que chaque rÃ©fÃ©rence devait avoir une durÃ©e de
vie explicite. A l'Ã©poque, la signature de la fonction devait Ãªtre Ã©crite
ainsiÂ :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compilerâ€™s code so
the borrow checker could infer the lifetimes in these situations and wouldnâ€™t
need explicit annotations.
-->
<p>AprÃ¨s avoir Ã©crit une grande quantitÃ© de code Rust, l'Ã©quipe de Rust s'est rendu
compte que les dÃ©veloppeurs Rust saisissaient toujours les mÃªmes durÃ©es de vie
encore et encore dans des situations spÃ©cifiques. Ces situations Ã©taient
prÃ©visibles et suivaient des schÃ©mas prÃ©dÃ©terminÃ©s. Les dÃ©veloppeurs ont
programmÃ© ces schÃ©mas dans le code du compilateur afin que le vÃ©rificateur
d'emprunt puisse deviner les durÃ©es de vie dans ces situations et n'auront plus
besoin d'annotations explicites.</p>
<!--
This piece of Rust history is relevant because itâ€™s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.
-->
<p>Cette partie de l'histoire de Rust est intÃ©ressante car il est possible que
d'autres modÃ¨les prÃ©dÃ©terminÃ©s Ã©mergent et soient ajoutÃ©s au compilateur. A
l'avenir, il est possible qu'encore moins d'annotations de durÃ©e de vie soient
nÃ©cessaires.</p>
<!--
The patterns programmed into Rustâ€™s analysis of references are called the
*lifetime elision rules*. These arenâ€™t rules for programmers to follow; theyâ€™re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you donâ€™t need to write the lifetimes explicitly.
-->
<p>Les schÃ©mas programmÃ©s dans l'analyse des rÃ©fÃ©rences de Rust s'appellent les
<em>rÃ¨gles d'Ã©lision des durÃ©es de vie</em>. Ce ne sont pas des rÃ¨gles que les
dÃ©veloppeurs doivent suivreÂ ; c'est un jeu de cas particuliers que le
compilateur va essayer de comparer Ã  votre code, et s'il y a une correspondance
alors vous n'aurez pas besoin d'Ã©crire explicitement les durÃ©es de vie.</p>
<!--
The elision rules donâ€™t provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler wonâ€™t guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.
-->
<p>Les rÃ¨gles d'Ã©lision ne permettent pas de faire des dÃ©ductions complÃ¨tes. Si
Rust applique les rÃ¨gles de faÃ§on stricte, mais qu'il existe toujours une
ambiguÃ¯tÃ© quant Ã  la durÃ©e de vie des rÃ©fÃ©rences, le compilateur ne devinera pas
quel devrait Ãªtre la durÃ©e de vie des autres rÃ©fÃ©rences. Dans ce cas, au lieu de
tenter de deviner, le compilateur va vous afficher une erreur que vous devrez
rÃ©soudre en prÃ©cisant les durÃ©es de vie qui clarifieront les liens entre chaque
rÃ©fÃ©rence.</p>
<!--
Lifetimes on function or method parameters are called *input lifetimes*, and
lifetimes on return values are called *output lifetimes*.
-->
<p>Les durÃ©es de vies sur les fonctions ou les paramÃ¨tres des fonctions sont
appelÃ©es les <em>durÃ©es de vie des entrÃ©es</em>, et les durÃ©es de vie sur les valeurs
de retour sont appelÃ©es les <em>durÃ©es de vie des sorties</em>.</p>
<!--
The compiler uses three rules to figure out what lifetimes references have when
there arenâ€™t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it canâ€™t
figure out lifetimes, the compiler will stop with an error. These rules apply
to `fn` definitions as well as `impl` blocks.
-->
<p>Le compilateur utilise trois rÃ¨gles pour dÃ©terminer quelles seraient les durÃ©es
de vie des rÃ©fÃ©rences si cela n'est pas indiquÃ© explicitement. La premiÃ¨re rÃ¨gle
s'applique sur les durÃ©es de vie des entrÃ©es, et la seconde et troisiÃ¨me rÃ¨gle
s'appliquent sur les durÃ©es de vie des sorties. Si le compilateur arrive Ã  la
fin des trois rÃ¨gles et qu'il y a encore des rÃ©fÃ©rences pour lesquelles il ne
peut pas savoir leur durÃ©e de vie, le compilateur s'arrÃªte avec une erreur. Ces
rÃ¨gles s'appliquent sur les dÃ©finitions des <code>fn</code> ainsi que sur celles des blocs
<code>impl</code>.</p>
<!--
The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two
separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so
on.
-->
<p>La premiÃ¨re rÃ¨gle dit que chaque paramÃ¨tre qui est une rÃ©fÃ©rence a sa propre
durÃ©e de vie. Autrement dit, une fonction avec un seul paramÃ¨tre va avoir un
seul paramÃ¨tre de durÃ©e de vieÂ : <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>Â ; une fonction avec
deux paramÃ¨tres va avoir deux paramÃ¨tres de durÃ©e de vie sÃ©parÃ©esÂ :
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>Â ; et ainsi de suite.</p>
<!--
The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32)
-> &'a i32`.
-->
<p>La seconde rÃ¨gle dit que s'il y a exactement un seul paramÃ¨tre de durÃ©e de vie
d'entrÃ©e, cette durÃ©e de vie est assignÃ©e Ã  tous les paramÃ¨tres de durÃ©e de vie
des sortiesÂ : <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<!--
The third rule is if there are multiple input lifetime parameters, but one of
them is `&self` or `&mut self` because this is a method, the lifetime of `self`
is assigned to all output lifetime parameters. This third rule makes methods
much nicer to read and write because fewer symbols are necessary.
-->
<p>La troisiÃ¨me rÃ¨gle est que lorsque nous avons plusieurs paramÃ¨tres de durÃ©e de
vie, mais qu'un d'entre eux est <code>&amp;self</code> ou <code>&amp;mut self</code> parce que c'est une
mÃ©thode, la durÃ©e de vie de <code>self</code> sera associÃ©e Ã  tous les paramÃ¨tres de durÃ©e
de vie des sorties. Cette troisiÃ¨me rÃ¨gle rend les mÃ©thodes plus faciles Ã  lire
et Ã  Ã©crire car il y a moins de caractÃ¨res nÃ©cessaires.</p>
<!--
Letâ€™s pretend weâ€™re the compiler. Weâ€™ll apply these rules to figure out what
the lifetimes of the references in the signature of the `first_word` function
in Listing 10-26 are. The signature starts without any lifetimes associated
with the references:
-->
<p>Imaginons que nous soyons le compilateur. Nous allons appliquer ces rÃ¨gles pour
dÃ©duire quelles seront les durÃ©es de vie des rÃ©fÃ©rences dans la signature de la
fonction <code>premier_mot</code> de l'encart 10-26.</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. Weâ€™ll call it `'a` as usual, so now the signature is
this:
-->
<p>Ensuite, le compilateur applique la premiÃ¨re rÃ¨gle, qui dit que chaque rÃ©fÃ©rence
a sa propre durÃ©e de vie. Appellons-la <code>'a</code> comme d'habitude, donc maintenant la
signature devient ceciÂ :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<!--
The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:
-->
<p>La seconde rÃ¨gle s'applique car il y a exactement une durÃ©e de vie d'entrÃ©e ici.
La seconde rÃ¨gle dit que la durÃ©e de vie du seul paramÃ¨tre d'entrÃ©e est affectÃ©e
Ã  la durÃ©e de vie des sorties, donc la signature est maintenant ceciÂ :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.
-->
<p>Maintenant, toutes les rÃ©fÃ©rences de cette signature de fonction ont des
durÃ©es de vie, et le compilateur peut continuer son analyse sans avoir besoin
que le dÃ©veloppeur renseigne les durÃ©es de vie dans les signatures de ces
fonctions.</p>
<!--
Letâ€™s look at another example, this time using the `longest` function that had
no lifetime parameters when we started working with it in Listing 10-21:
-->
<p>Voyons un autre exemple, qui utilise cette fois la fonction <code>la_plus_longue</code> qui
n'avait pas de paramÃ¨tres de durÃ©e de vie lorsque nous avons commencÃ© Ã 
l'utiliser dans l'encart 10-21Â :</p>
<!--
```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Letâ€™s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:
-->
<p>Appliquons la premiÃ¨re rÃ¨gleÂ : chaque rÃ©fÃ©rence a sa propre durÃ©e de vie. Cette
fois, nous avons avons deux rÃ©fÃ©rences au lieu d'une seule, donc nous avons deux
durÃ©es de vieÂ :</p>
<!--
```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<!--
You can see that the second rule doesnâ€™t apply because there is more than one
input lifetime. The third rule doesnâ€™t apply either, because `longest` is a
function rather than a method, so none of the parameters are `self`. After
working through all three rules, we still havenâ€™t figured out what the return
typeâ€™s lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldnâ€™t figure out all the lifetimes of the references in the signature.
-->
<p>Vous pouvez constater que la seconde rÃ¨gle ne s'applique pas car il y a plus
qu'une seule durÃ©e de vie. La troisiÃ¨me ne s'applique pas non plus, car
<code>la_plus_longue</code> est une fonction et non pas une mÃ©thode, donc aucun de ses
paramÃ¨tres ne sont <code>self</code>. AprÃ¨s avoir utilisÃ© ces trois rÃ¨gles, nous n'avons
pas pu en dÃ©duire la durÃ©e de vie de la valeur de retour. C'est pourquoi nous
obtenons une erreur en essayant de compiler le code dans l'encart 10-21Â : le
compilateur a utilisÃ© les rÃ¨gles d'Ã©lision des durÃ©es de vie mais n'est pas
capable d'en dÃ©duire toutes les durÃ©es de vie des rÃ©fÃ©rences prÃ©sentes dans la
signature.</p>
<!--
Because the third rule really only applies in method signatures, weâ€™ll look at
lifetimes in that context next to see why the third rule means we donâ€™t have to
annotate lifetimes in method signatures very often.
-->
<p>Comme la troisiÃ¨me rÃ¨gle ne s'applique que sur les signatures des mÃ©thodes, nous
allons examiner les durÃ©es de vie dans ce contexte pour comprendre pourquoi la
troisiÃ¨me rÃ¨gle signifie que nous n'avons pas souvent besoin d'annoter les
durÃ©es de vie dans les signatures des mÃ©thodes.</p>
<!--
### Lifetime Annotations in Method Definitions
-->
<h3><a class="header" href="#informations-de-durÃ©e-de-vie-dans-les-dÃ©finitions-des-mÃ©thodes" id="informations-de-durÃ©e-de-vie-dans-les-dÃ©finitions-des-mÃ©thodes">Informations de durÃ©e de vie dans les dÃ©finitions des mÃ©thodes</a></h3>
<!--
When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether theyâ€™re related to the struct
fields or the method parameters and return values.
-->
<p>Lorsque nous implÃ©mentons des mÃ©thodes sur une structure avec des durÃ©es de vie,
nous utilisons la mÃªme syntaxe que les paramÃ¨tres de type gÃ©nÃ©riques que nous
avons vu dans l'encart 10-11. L'endroit oÃ¹ nous dÃ©clarons et utilisons les
paramÃ¨tres de durÃ©e de vie dÃ©pend de s'ils sont reliÃ©s aux champs des structures
ou aux paramÃ¨tres de la mÃ©thode et les valeurs de retour.</p>
<!--
Lifetime names for struct fields always need to be declared after the `impl`
keyword and then used after the structâ€™s name, because those lifetimes are part
of the structâ€™s type.
-->
<p>Les noms des durÃ©es de vie pour les champs de structure ont toujours besoin
d'Ãªtre dÃ©clarÃ©s aprÃ¨s le mot-clÃ© <code>impl</code> et sont ensuite utilisÃ©s aprÃ¨s le nom de
la structure, car ces durÃ©es vie font partie du type de la structure.</p>
<!--
In method signatures inside the `impl` block, references might be tied to the
lifetime of references in the structâ€™s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
arenâ€™t necessary in method signatures. Letâ€™s look at some examples using the
struct named `ImportantExcerpt` that we defined in Listing 10-25.
-->
<p>Sur les signatures des mÃ©thodes Ã  l'intÃ©rieur du bloc <code>impl</code>, les rÃ©fÃ©rences
peuvent avoir la durÃ©e de vie des rÃ©fÃ©rences des champs de la structure, ou
elles peuvent Ãªtre indÃ©pendantes. De plus, les rÃ¨gles d'Ã©lision des durÃ©es de
vie le font parfois, ce qui fait que l'ajout des durÃ©es de vie n'est parfois pas
nÃ©cessaire dans les signatures des mÃ©thodes. Voyons quelques exemples en
utilisant la structure <code>ExtraitImportant</code> que nous avons dÃ©fini dans l'encart
10-25.</p>
<!--
First, weâ€™ll use a method named `level` whose only parameter is a reference to
`self` and whose return value is an `i32`, which is not a reference to anything:
-->
<p>PremiÃ¨rement, nous allons utiliser une mÃ©thode <code>niveau</code> dont le seul paramÃ¨tre
est une rÃ©fÃ©rence Ã  <code>self</code> et dont la valeur de retour sera un <code>i32</code>, qui n'est
pas une rÃ©fÃ©renceÂ :</p>
<!--
```rust
# struct ExtraitImportant<'a> {
#     partie: &'a str,
# }
# 
impl<'a> ExtraitImportant<'a> {
    fn niveau(&self) -> i32 {
        3
    }
}
# 
# impl<'a> ExtraitImportant<'a> {
#     fn annoncer_et_retourner_partie(&self, annonce: &str) -> &str {
#         println!("Votre attention s'il vous plaÃ®tÂ : {}", annonce);
#         self.partie
#     }
# }
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ExtraitImportant {
#         partie: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn niveau(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Votre attention s'il vous plaÃ®tÂ : {}&quot;, annonce);
</span><span class="boring">        self.partie
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
The lifetime parameter declaration after `impl` and its use after the type name
are required, but weâ€™re not required to annotate the lifetime of the reference
to `self` because of the first elision rule.
-->
<p>La dÃ©claration du paramÃ¨tre de durÃ©e de vie aprÃ¨s <code>impl</code> et son utilisation
aprÃ¨s le nom du type sont nÃ©cessaires, mais nous n'avons pas Ã  prÃ©ciser la durÃ©e
de vie de la rÃ©fÃ©rence Ã  <code>self</code> grÃ¢ce Ã  la premiÃ¨re rÃ¨gle d'Ã©lision.</p>
<!--
Here is an example where the third lifetime elision rule applies:
-->
<p>Voici un exemple oÃ¹ la troisiÃ¨me rÃ¨gle d'Ã©lision des durÃ©es de vie s'appliqueÂ :</p>
<!--
```rust
# struct ExtraitImportant<'a> {
#     partie: &'a str,
# }
# 
# impl<'a> ExtraitImportant<'a> {
#     fn niveau(&self) -> i32 {
#         3
#     }
# }
# 
impl<'a> ExtraitImportant<'a> {
    fn annoncer_et_retourner_partie(&self, annonce: &str) -> &str {
        println!("Votre attention s'il vous plaÃ®tÂ : {}", annonce);
        self.partie
    }
}
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ExtraitImportant {
#         partie: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn niveau(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
        println!(&quot;Votre attention s'il vous plaÃ®tÂ : {}&quot;, annonce);
        self.partie
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both `&self` and `announcement` their own lifetimes. Then, because
one of the parameters is `&self`, the return type gets the lifetime of `&self`,
and all lifetimes have been accounted for.
-->
<p>Il y a deux durÃ©es de vies des entrÃ©es, donc Rust applique la premiÃ¨re rÃ¨gle
d'Ã©lision des durÃ©es de vie et donne Ã  chacun de <code>&amp;self</code> et <code>annonce</code> leur
propre durÃ©e de vie. Ensuite, comme un des paramÃ¨tres est <code>&amp;self</code>, le type de
retour obtient la durÃ©e de vie de <code>&amp;self</code>, et ainsi toutes les durÃ©es de vie ont
Ã©tÃ© calculÃ©es.</p>
<!--
### The Static Lifetime
-->
<h3><a class="header" href="#la-durÃ©e-de-vie-statique" id="la-durÃ©e-de-vie-statique">La durÃ©e de vie statique</a></h3>
<!--
One special lifetime we need to discuss is `'static`, which means that this
reference *can* live for the entire duration of the program. All string
literals have the `'static` lifetime, which we can annotate as follows:
-->
<p>Une durÃ©e de vie particuliÃ¨re que nous devons aborder est <code>'static</code>, qui
signifie que cette rÃ©fÃ©rence <em>peut</em> vivre pendant la totalitÃ© de la durÃ©e du
programme. Tous les littÃ©raux de chaÃ®nes de caractÃ¨res ont la durÃ©e de vie
<code>'static</code>, que nous pouvons Ã©crire comme ceciÂ :</p>
<!--
```rust
let s: &'static str = "I have a static lifetime.";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;J'ai une durÃ©e de vie statique.&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The text of this string is stored directly in the programâ€™s binary, which
is always available. Therefore, the lifetime of all string literals is
`'static`.
-->
<p>Le texte de cette chaÃ®ne de caractÃ¨res est stockÃ© directement dans le binaire du
programme, qui est toujours disponible. C'est pourquoi la durÃ©e de vie de tous
les littÃ©raux de chaÃ®nes de caractÃ¨res est <code>'static</code>.</p>
<!--
You might see suggestions to use the `'static` lifetime in error messages. But
before specifying `'static` as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not. You might consider whether you want it to live that long, even
if it could. Most of the time, the problem results from attempting to create a
dangling reference or a mismatch of the available lifetimes. In such cases, the
solution is fixing those problems, not specifying the `'static` lifetime.
-->
<p>Il se peut que voyez des suggestions pour utiliser la durÃ©e de vie <code>'static</code>
dans les messages d'erreur. Mais avant d'utiliser <code>'static</code> comme durÃ©e de vie
pour une rÃ©fÃ©rence, demandez-vous si la rÃ©fÃ©rence en question vit bien pendant
toute la vie de votre programme, ou non. Vous devriez vous demander si vous
voulez qu'elle vive aussi longtemps, mÃªme si si c'Ã©tait possible. La plupart du
temps, le problÃ¨me rÃ©sulte d'une tentative de crÃ©ation d'une rÃ©fÃ©rence
pendouillante ou d'une inadÃ©quation des durÃ©es de vie disponibles. Dans de ces
cas-lÃ , la solution est de rÃ©soudre ces problÃ¨mes, et non pas de renseigner la
durÃ©e de vie comme Ã©tant <code>'static</code>.</p>
<!--
## Generic Type Parameters, Trait Bounds, and Lifetimes Together
-->
<h2><a class="header" href="#les-paramÃ¨tres-de-type-gÃ©nÃ©riques-les-traits-liÃ©s-et-les-durÃ©es-de-vies-ensemble" id="les-paramÃ¨tres-de-type-gÃ©nÃ©riques-les-traits-liÃ©s-et-les-durÃ©es-de-vies-ensemble">Les paramÃ¨tres de type gÃ©nÃ©riques, les traits liÃ©s, et les durÃ©es de vies ensemble</a></h2>
<!--
Letâ€™s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!
-->
<p>Regardons briÃ¨vement la syntaxe pour renseigner tous les paramÃ¨tres de type
gÃ©nÃ©riques, les traits liÃ©s, et les durÃ©es de vies sur une seule fonctionÂ !</p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue_avec_annonce(
#         string1.as_str(),
#         string2,
#         "Aujourd'hui, c'est l'anniversaire de quelqu'unÂ !",
#     );
#     println!("La chaÃ®ne la plus longue est {}", resultat);
# }
# 
use std::fmt::Display;

fn la_plus_longue_avec_annonce<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("AnnonceÂ ! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue_avec_annonce(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Aujourd'hui, c'est l'anniversaire de quelqu'unÂ !&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn la_plus_longue_avec_annonce&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;AnnonceÂ ! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
This is the `longest` function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named `ann` of the generic
type `T`, which can be filled in by any type that implements the `Display`
trait as specified by the `where` clause. This extra parameter will be printed
before the function compares the lengths of the string slices, which is why the
`Display` trait bound is necessary. Because lifetimes are a type of generic,
the declarations of the lifetime parameter `'a` and the generic type parameter
`T` go in the same list inside the angle brackets after the function name.
-->
<p>C'est la fonction <code>la_plus_longue</code> de l'encart 10-22 qui retourne la plus grande
de deux slices de chaÃ®nes de caractÃ¨res. Mais maintenant elle a un paramÃ¨tre
supplÃ©mentaire <code>ann</code> de type gÃ©nÃ©rique <code>T</code>, qui peut Ãªtre remplacÃ© par n'importe
quel type qui implÃ©mente le trait <code>Display</code> comme le prÃ©cise la clause <code>where</code>.
Ce paramÃ¨tre supplÃ©mentaire sera affichÃ© avant que la fonction compare les
longueurs des slices de chaÃ®nes de caractÃ¨res, c'est pourquoi le trait liÃ©
<code>Display</code> est nÃ©cessaire. Comme les durÃ©es de vie sont un type de gÃ©nÃ©riques,
les dÃ©clarations du paramÃ¨tre de durÃ©e de vie <code>'a</code> et le paramÃ¨tre de type
gÃ©nÃ©rique <code>T</code> vont dans la mÃªme liste Ã  l'intÃ©rieur des chevrons aprÃ¨s le nom de
la fonction.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©" id="rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, youâ€™re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, theyâ€™ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code wonâ€™t have any dangling references. And all of this
analysis happens at compile time, which doesnâ€™t affect runtime performance!
-->
<p>Nous avons vu beaucoup de choses dans ce chapitreÂ ! Maintenant que vous en savez
plus sur les paramÃ¨tres de type gÃ©nÃ©riques, les traits et les traits liÃ©s, et
les paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques, vous pouvez maintenant Ã©crire du code
en Ã©vitant les doublons qui va bien fonctionner dans de nombreuses situations.
Les paramÃ¨tres de type gÃ©nÃ©riques vous permet d'appliquer du code Ã  diffÃ©rents
types. Les traits et les traits liÃ©s s'assurent que bien que les types soient
gÃ©nÃ©riques, ils auront un comportement particulier sur lequel le code peut
compter. Vous avez appris comment utiliser les indications de durÃ©e de vie pour
s'assurer que ce code flexible n'aura pas de rÃ©fÃ©rences pendouillantes. Et
toutes ces vÃ©rifications se font au moment de la compilation, ce qui n'influe
pas sur les performances au moment de l'exÃ©cution du programmeÂ !</p>
<!--
Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the [Rust Reference][reference]. But next, youâ€™ll learn how to write tests in
Rust so you can make sure your code is working the way it should.
-->
<p>Croyez-le ou non, mais il y a encore des choses Ã  apprendre sur les sujets que
nous avons traitÃ©s dans ce chapitreÂ : le chapitre 17 expliquera les objets de
trait, qui est une faÃ§on d'utiliser les traits. Il existe aussi des scÃ©narios
plus complexes qui nÃ©cessitent des indications de durÃ©e de vie ainsi que
d'utiliser, uniquement pour ces ces scÃ©narios avancÃ©s, certaines fonctionnalitÃ©s
avancÃ©es du systÃ¨me de typeÂ ; pour ces cas-lÃ , vous devriez consulter la
<a href="https://doc.rust-lang.org/reference/index.html">RÃ©fÃ©rence de Rust</a>. Maintenant, nous allons voir au chapitre suivant
comment Ã©crire des tests en Rust afin que vous puissiez vous assurer que votre
code fonctionne comme il devrait le faire.</p>
<!--
[references-and-borrowing]:
ch04-02-references-and-borrowing.html#references-and-borrowing
[string-slices-as-parameters]:
ch04-03-slices.html#string-slices-as-parameters
[reference]: ../reference/index.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-02-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch11-00-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch10-02-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch11-00-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
