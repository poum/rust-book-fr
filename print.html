<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le langage de programmation Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1><a class="header" href="#le-langage-de-programmation-rust" id="le-langage-de-programmation-rust">Le langage de programmation Rust</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>par Steve Klabnik et Carol Nichols, avec la participation de la CommunautÃ©
Rust</em></p>
<!--
This version of the text assumes youâ€™re using Rust 1.41.0 or later with
`edition="2018"` in *Cargo.toml* of all projects to use Rust 2018 Edition
idioms. See the [â€œInstallationâ€ section of Chapter 1][install]<!-- ignore -- >
to install or update Rust, and see the new [Appendix E][editions]<!-- ignore
-- > for information on editions.
-->
<p>Cette version du document suppose que vous utilisez Rust 1.41.0 ou ultÃ©rieur
avec <code>edition=&quot;2018&quot;</code> dans <em>Cargo.toml</em> de tous les projets afin d'utiliser les
expressions idiomatiques de l'Ã©dition 2018 de Rust.
Voir la <a href="ch01-01-installation.html">section â€œInstallationâ€ du chapitre 1</a><!-- ignore -->
pour installer ou mettre Ã  jour Rust, et
voir la nouvelle <a href="appendix-05-editions.html">annexe E</a><!-- ignore --> pour plus d'informations
sur les Ã©ditions.</p>
<!--
The 2018 Edition of the Rust language includes a number of improvements that
make Rust more ergonomic and easier to learn. This iteration of the book
contains a number of changes to reflect those improvements:
-->
<p>L'Ã©dition 2018 du langage Rust apporte quelques amÃ©liorations qui rendent Rust
plus ergonomique et plus facile Ã  apprendre. Cette version du livre comprend un
certain nombre de changements pour reflÃ©ter ces amÃ©liorationsÂ :</p>
<!--
- Chapter 7, â€œManaging Growing Projects with Packages, Crates, and Modules,â€
  has been mostly rewritten. The module system and the way paths work in the
  2018 Edition were made more consistent.
- Chapter 10 has new sections titled â€œTraits as Parametersâ€ and â€œReturning
  Types that Implement Traitsâ€ that explain the new `impl Trait` syntax.
- Chapter 11 has a new section titled â€œUsing `Result<T, E>` in Testsâ€ that
  shows how to write tests that use the `?` operator.
- The â€œAdvanced Lifetimesâ€ section in Chapter 19 was removed because compiler
  improvements have made the constructs in that section even rarer.
- The previous Appendix D, â€œMacros,â€ has been expanded to include procedural
  macros and was moved to the â€œMacrosâ€ section in Chapter 19.
- Appendix A, â€œKeywords,â€ also explains the new raw identifiers feature that
  enables code written in the 2015 Edition and the 2018 Edition to interoperate.
- Appendix D is now titled â€œUseful Development Toolsâ€ and covers recently
  released tools that help you write Rust code.
- We fixed a number of small errors and imprecise wording throughout the book.
  Thank you to the readers who reported them!
-->
<ul>
<li>Le chapitre 7 a Ã©tÃ© rÃ©Ã©crit en grande partie. Le systÃ¨me de modules et le
fonctionnement des chemins dans l'Ã©dition 2018 ont Ã©tÃ© rendus plus cohÃ©rents.</li>
<li>Le chapitre 10 a deux nouvelles parties qui expliquent la nouvelle syntaxe
<code>impl Trait</code>.</li>
<li>Le chapitre 11 a une nouvelle partie qui montre comment Ã©crire des tests qui
utilisent l'opÃ©rateur <code>?</code>.</li>
<li>La partie &quot;DurÃ©e de vie avancÃ©e&quot; du chapitre 19 a Ã©tÃ© retirÃ©e, car les
amÃ©liorations du compilateur ont rendu encore plus rare les concepts de cette
section.</li>
<li>L'ancienne Annexe D a Ã©tÃ© complÃ©tÃ©e pour couvrir les macros procÃ©durales et a
Ã©tÃ© dÃ©placÃ©e dans la section &quot;Macros&quot; du chapitre 19.</li>
<li>L'annexe A explique aussi la nouvelle fonctionnalitÃ© d'identificateurs bruts
qui rend du code Ã©crit avec l'Ã©dition 2015 interopÃ©rable avec l'Ã©dition 2018.</li>
<li>L'annexe D a Ã©tÃ© renommÃ©e et couvre les nouveaux outils ajoutÃ©s rÃ©cemment
pour vous aider Ã  Ã©crire du code Rust.</li>
<li>Nous avons corrigÃ© quelques petites erreurs et certaines formulations floues
dans tout le livre. Merci aux lecteurs qui nous les ont signalÃ©esÂ !</li>
</ul>
<!--
Note that any code in earlier iterations of *The Rust Programming Language*
that compiled will continue to compile without `edition="2018"` in the
projectâ€™s *Cargo.toml*, even as you update the Rust compiler version youâ€™re
using. Thatâ€™s Rustâ€™s backward compatibility guarantees at work!
-->
<p>Veuillez noter que tout le code dans les versions prÃ©cÃ©dentes du livre
<em>Le langage de programmation Rust</em> qui se compilait va continuer Ã  compiler sans
<code>edition=&quot;2018&quot;</code> dans le <em>Cargo.toml</em> du projet, mÃªme si vous mettez Ã  jour le
compilateur Rust que vous utilisez. C'est la garantie de la rÃ©trocompatibilitÃ©
de Rust qui est Ã  l'Å“uvre iciÂ !</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>Le format HTML de la version anglaise est disponible en ligne Ã  l'adresse
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
et en hors-ligne avec l'installation de Rust qui a Ã©tÃ© effectuÃ©e avec <code>rustup</code>Â ;
vous pouvez lancer <code>rustup docs --book</code> pour l'ouvrir.</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>La version anglaise de ce livre est disponible
<a href="https://nostarch.com/rust">au format papier et e-book chez No Starch Press</a>.</p>
<!--
[install]: ch01-01-installation.html
[editions]: appendix-05-editions.html
[nsprust]: https://nostarch.com/rust
-->
<!--
# Foreword
-->
<h1><a class="header" href="#avant-propos" id="avant-propos">Avant-propos</a></h1>
<!--
It wasnâ€™t always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>Cela n'a pas toujours Ã©tÃ© aussi Ã©vident, mais le langage de programmation Rust
apporte avant tout plus de <em>puissance</em>Â : peu importe le type de code que vous
Ã©crivez en ce moment, Rust vous permet d'aller plus loin et de
programmer en toute confiance dans une plus grande diversitÃ© de domaines
qu'auparavant.</p>
<!--
Take, for example, â€œsystems-levelâ€ work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>Prenez par exemple la gestion des Ã©lÃ©ments au â€œniveau systÃ¨meâ€ qui traite de
dÃ©tails bas niveau de gestion de mÃ©moire, de modÃ¨les de donnÃ©es, et de
concurrence. Traditionnellement, ce domaine de la programmation est jugÃ©
Ã©sotÃ©rique, comprÃ©hensible uniquement par une poignÃ©e de personnes qui ont
consacrÃ© des annÃ©es d'apprentissage Ã  en dÃ©jouer les piÃ¨ges infÃ¢mes.
Et mÃªme ceux qui travaillent dans ce domaine le font avec beaucoup de prudence,
de crainte que leur code soit soumis Ã  des failles ou des plantages,
ou qu'il soit corrompu.</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to â€œdip downâ€ into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>Rust fait tomber ces obstacles en Ã©liminant les vieux piÃ¨ges et en apportant un
ensemble d'outils soignÃ©s et conviviaux pour vous aider sur votre chemin.
Les dÃ©veloppeurs qui ont besoin de &quot;se plonger&quot; dans le contrÃ´le de plus
bas niveau peuvent ainsi le faire avec Rust, sans prendre le risque habituel
de plantages ou de failles de sÃ©curitÃ©, et sans avoir Ã  apprendre les subtilitÃ©s
d'un enchevÃªtrement d'outils capricieux. Encore mieux, le langage est conÃ§u pour
vous guider naturellement vers un code fiable et efficace en termes de rapiditÃ©
d'exÃ©cution et d'utilisation de la mÃ©moire.</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you wonâ€™t accidentally introduce crashes or vulnerabilities.
-->
<p>Les dÃ©veloppeurs qui travaillent dÃ©jÃ  avec du code bas niveau peuvent utiliser
Rust pour accroÃ®tre leurs ambitions. Par exemple, introduire du parallÃ©lisme en
Rust est une opÃ©ration Ã  faible risqueÂ : le compilateur va dÃ©tecter les erreurs
classiques pour vous. Et vous pourrez vous lancer dans des amÃ©liorations plus
agressives de votre code avec la certitude que vous n'introduirez pas
accidentellement des causes de plantage ou des vulnÃ©rabilitÃ©s.</p>
<!--
But Rust isnâ€™t limited to low-level systems programming. Itâ€™s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write â€” youâ€™ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>Mais Rust n'est pas cantonnÃ© Ã  la programmation de bas niveau. C'est un langage
suffisamment expressif et ergonomique pour rendre les applications en ligne
de commande, les serveurs web et bien d'autres types de code agrÃ©ables Ã  Ã©crire
â€” vous trouverez plus tard des exemples simples de chacun dans ce livre.
Travailler avec Rust vous permet d'acquÃ©rir des compÃ©tences qui sont
transposables d'un domaine Ã  un autreÂ ; vous pouvez apprendre Rust en Ã©crivant
une application web, puis appliquer les mÃªmes notions pour les utiliser avec
votre Raspberry Pi.</p>
<!--
This book fully embraces the potential of Rust to empower its users. Itâ€™s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learnâ€”and welcome to the Rust community!
-->
<p>Ce livre exploite pleinement le potentiel de Rust pour permettre Ã  ses
utilisateurs de se dÃ©velopper. C'est une documentation conviviale et accessible
destinÃ©e Ã  amÃ©liorer vos connaissances en Rust, mais aussi Ã  amÃ©liorer vos
capacitÃ©s et votre assurance en tant que dÃ©veloppeur en gÃ©nÃ©ral. Alors foncez,
et prÃ©parez-vous Ã  apprendre â€” et bienvenue dans la communautÃ© RustÂ !</p>
<!--
â€” Nicholas Matsakis and Aaron Turon
-->
<p>â€” Nicholas Matsakis et Aaron Turon</p>
<!--
# Introduction
-->
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>Note : la version anglaise de ce livre est disponible au format papier et
ebook chez <a href="https://nostarch.com/">No Starch Press</a> Ã  cette adresse :
<a href="https://nostarch.com/rust">The Rust Programming Language</a></p>
</blockquote>
<!--
[nsprust]: https://nostarch.com/rust
[nsp]: https://nostarch.com/
-->
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Bienvenue sur <em>Le langage de programmation Rust</em>, un livre d'initiation Ã  Rust.
Le langage de programmation Rust vous aide Ã  Ã©crire plus rapidement des
logiciels plus fiables. L'ergonomie de haut-niveau et la maÃ®trise de bas-niveau
sont souvent en opposition dans la conception des langages de programmationÂ ;
Rust remet en cause ce conflit. GrÃ¢ce Ã  l'Ã©quilibre entre ses puissantes
capacitÃ©s techniques et une bonne ergonomie de dÃ©veloppement, Rust vous donne
la possibilitÃ© de contrÃ´ler les dÃ©tails de bas-niveau (comme l'utilisation de
la mÃ©moire) sans tous les soucis traditionnellement associÃ©s Ã  ce genre de
pratique.</p>
<!--
## Who Rust Is For
-->
<h2><a class="header" href="#Ã€-qui-sadresse-rust" id="Ã€-qui-sadresse-rust">Ã€ qui s'adresse Rust</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Letâ€™s look at a few of
the most important groups.
-->
<p>Rust est idÃ©al pour de nombreuses personnes pour diverses raisons. Analysons
quelques-uns des groupes les plus importants.</p>
<!--
### Teams of Developers
-->
<h3><a class="header" href="#Ã‰quipes-de-dÃ©veloppeurs" id="Ã‰quipes-de-dÃ©veloppeurs">Ã‰quipes de dÃ©veloppeurs</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the programâ€™s
logic rather than chasing down bugs.
-->
<p>Rust se rÃ©vÃ¨le Ãªtre un outil productif pour la collaboration entre de grandes
Ã©quipes de dÃ©veloppeurs ayant diffÃ©rents niveaux de connaissances en
programmation systÃ¨me. Le code de bas-niveau est sujet Ã  une multitude de bogues
subtils, qui, dans la plupart des autres langages, ne peuvent Ãªtre prÃ©venus
qu'au moyen de campagnes de test Ã©tendues et de minutieuses revues de
code menÃ©es par des dÃ©veloppeurs chevronnÃ©s. Avec Rust, le compilateur joue le
rÃ´le de gardien en refusant de compiler du code qui comprend ces bogues
discrets et vicieux, y compris les bogues de concurrence. En travaillant avec
le compilateur, l'Ã©quipe peut se concentrer sur la logique du programme plutÃ´t
que de traquer les bogues.</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rust offre aussi des outils de dÃ©veloppement modernes au monde de la
programmation systÃ¨me :</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargo, l'outil intÃ©grÃ© de gestion de dÃ©pendances et de compilation, qui
uniformise et facilite l'ajout, la compilation, et la gestion des dÃ©pendances
dans l'Ã©cosystÃ¨me Rust.</li>
<li>Rustfmt, qui assure une cohÃ©rence de style de codage pour tous les
dÃ©veloppeurs.</li>
<li>Le <em>Rust Langage Server</em> alimente les environnements de dÃ©veloppement
intÃ©grÃ©s (IDE) pour la complÃ©tion du code et l'affichage direct des messages
d'erreur.</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>En utilisant ces outils ainsi que d'autres dans l'Ã©cosystÃ¨me Rust, les
dÃ©veloppeurs peuvent Ãªtre plus productifs quand ils Ã©crivent du code systÃ¨me.</p>
<!--
### Students
-->
<h3><a class="header" href="#Ã‰tudiants" id="Ã‰tudiants">Ã‰tudiants</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rust est conÃ§u pour les Ã©tudiants et ceux qui s'intÃ©ressent Ã  l'apprentissage
des concepts systÃ¨me. En utilisant Rust, de nombreuses personnes ont appris
des domaines comme le dÃ©veloppement de systÃ¨mes d'exploitation. La communautÃ©
est trÃ¨s accueillante et rÃ©pond volontiers aux questions des Ã©tudiants. GrÃ¢ce Ã 
des initiatives comme ce livre, les Ã©quipes de Rust veulent rendre les notions
systÃ¨me accessibles au plus grand nombre, particuliÃ¨rement Ã  ceux qui dÃ©butent
dans la programmation.</p>
<!--
### Companies
-->
<h3><a class="header" href="#entreprises" id="entreprises">Entreprises</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>Des centaines d'entreprises, petites et grosses, utilisent Rust en production
pour diffÃ©rentes missions. Ils l'utilisent pour des outils en ligne de commande,
des services web, des outils DevOps, des systÃ¨mes embarquÃ©s, de l'analyse et de
la conversion audio et vidÃ©o, des cryptomonnaies, de la bio-informatique, des
moteurs de recherche, de l'internet des objets <em>(IoT)</em>, de l'apprentissage
automatique <em>(marchine learning)</em>, et mÃªme des parties importantes du navigateur
internet Firefox.</p>
<!--
### Open Source Developers
-->
<h3><a class="header" href="#dÃ©veloppeurs-de-logiciel-libre" id="dÃ©veloppeurs-de-logiciel-libre">DÃ©veloppeurs de logiciel libre</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. Weâ€™d love to have you contribute to the Rust
language.
-->
<p>Rust est ouvert aux personnes qui veulent dÃ©velopper le langage de programmation
Rust, la communautÃ©, les outils de dÃ©veloppement et les bibliothÃ¨ques. Nous
serions ravis que vous contribuiez au langage Rust.</p>
<!--
### People Who Value Speed and Stability
-->
<h3><a class="header" href="#les-personnes-qui-recherchent-la-rapiditÃ©-et-la-stabilitÃ©" id="les-personnes-qui-recherchent-la-rapiditÃ©-et-la-stabilitÃ©">Les personnes qui recherchent la rapiditÃ© et la stabilitÃ©</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compilerâ€™s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rust est une solution pour les personnes qui chÃ©rissent la rapiditÃ© et la
stabilitÃ© dans un langage. Par rapiditÃ©, nous entendons la vitesse des
programmes que vous pouvez crÃ©er avec Rust et la rapiditÃ© avec laquelle Rust
vous permet de les Ã©crire. Les vÃ©rifications du compilateur de Rust assurent la
stabilitÃ© durant l'ajout de fonctionnalitÃ©s ou le remaniement du code. Cela
le dÃ©marque des langages qui ne font pas ces contrÃ´les sur du code instable que
le programme a hÃ©ritÃ© avec le temps, et que bien souvent les dÃ©veloppeurs ont
peur de modifier. En s'efforÃ§ant de mettre en place des abstractions sans coÃ»t,
des fonctionnalitÃ©s de haut-niveau qui compilent vers du code bas-niveau aussi
rapide que s'il avait Ã©tÃ© Ã©crit Ã  la main, Rust fait en sorte que le
code sÃ»r soit aussi du code rapide.</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rustâ€™s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Le langage Rust espÃ¨re aider beaucoup d'autres utilisateursÂ ; ceux citÃ©s ici ne
font partie que d'un univers bien plus grand. Globalement, la plus grande
ambition de Rust est d'Ã©radiquer les compromis auxquels les dÃ©veloppeurs
se soumettaient depuis des dÃ©cennies en leur apportant sÃ©curitÃ© <em>et</em>
productivitÃ©, rapiditÃ© <em>et</em> ergonomie. Essayez Rust et vÃ©rifiez si ses dÃ©cisions
vous conviennent.</p>
<!--
## Who This Book Is For
-->
<h2><a class="header" href="#Ã€-qui-est-destinÃ©-ce-livre" id="Ã€-qui-est-destinÃ©-ce-livre">Ã€ qui est destinÃ© ce livre</a></h2>
<!--
This book assumes that youâ€™ve written code in another programming language but
doesnâ€™t make any assumptions about which one. Weâ€™ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
donâ€™t spend a lot of time talking about what programming *is* or how to think
about it. If youâ€™re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>Ce livre suppose que vous avez Ã©crit du code dans un autre langage de
programmation mais ne suppose pas lequel. Nous avons essayÃ© de rendre son
contenu le plus accessible au plus grand nombre d'expÃ©riences de programmation
possible. Nous ne nous Ã©vertuons pas Ã  nous questionner sur <em>ce qu'est</em> la
programmation ou comment l'envisager. Si vous Ãªtes dÃ©butant en programmation,
vous seriez mieux avisÃ© en lisant un livre qui vous initie Ã  la programmation.</p>
<!--
## How to Use This Book
-->
<h2><a class="header" href="#comment-utiliser-ce-livre" id="comment-utiliser-ce-livre">Comment utiliser ce livre</a></h2>
<!--
In general, this book assumes that youâ€™re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>Globalement, ce livre est prÃ©vu pour Ãªtre lu dans l'ordre. Les chapitres
suivants s'appuient sur les notions abordÃ©es dans les chapitres prÃ©cÃ©dents, et
lorsque les chapitres prÃ©cÃ©dents ne peuvent pas approfondir un sujet, ce sera
gÃ©nÃ©ralement fait dans un chapitre suivant.</p>
<!--
Youâ€™ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, youâ€™ll learn about an aspect of Rust. In project
chapters, weâ€™ll build small programs together, applying what youâ€™ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>Vous allez rencontrer deux diffÃ©rents types de chapitres dans ce livre : les
chapitres thÃ©oriques et les chapitres de projet. Dans les chapitres thÃ©oriques,
vous allez apprendre un sujet Ã  propos de Rust. Dans un chapitre de projet, nous
allons construire ensemble des petits programmes, pour appliquer ce que vous
avez appris prÃ©cÃ©demment. Les chapitres 2, 12 et 20 sont des chapitres de
projetÂ ; les autres sont des chapitres thÃ©oriques.</p>
<!--
Chapter 1 explains how to install Rust, how to write a â€œHello, world!â€ program,
and how to use Cargo, Rustâ€™s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rustâ€™s ownership system. However, if youâ€™re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
youâ€™d like to work on a project applying the details youâ€™ve learned.
-->
<p>Le chapitre 1 explique comment installer Rust, comment Ã©crire un programme
&quot;Hello, world!&quot; et comment utiliser Cargo, le gestionnaire de paquets et outil
de compilation. Le chapitre 2 est une initiation pratique au langage Rust. Nous
y aborderons des concepts de haut-niveau, et les chapitres suivants apporteront
plus de dÃ©tails. Si vous voulez vous <em>salir les mains</em> tout de suite,
le chapitre 2 est l'endroit pour cela. Au dÃ©but, vous pouvez mÃªme sauter le
chapitre 3, qui aborde les fonctionnalitÃ©s de Rust semblables aux autres
langages de programmation, et passer directement au chapitre 4 pour en savoir
plus sur le systÃ¨me de possession <em>(ownership)</em> de Rust. Toutefois, si vous Ãªtes
un apprenti particuliÃ¨rement minutieux qui prÃ©fÃ¨re apprendre chaque
particularitÃ© avant de passer Ã  la suivante, vous pouvez sauter le chapitre 2 et
passer directement au chapitre 3, puis revenir au chapitre 2 lorsque vous
souhaitez travailler sur un projet en appliquant les notions que vous avez
apprises.</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. Youâ€™ll use structs and
enums to make custom types in Rust.
-->
<p>Le chapitre 5 traite des structures et des mÃ©thodes, et le chapitre 6 couvre les
Ã©numÃ©rations, les expressions <code>match</code>, et la structure de contrÃ´le <code>if let</code>.
Vous emploierez les structures et les Ã©numÃ©rations pour crÃ©er des types
personnalisÃ©s avec Rust.</p>
<!--
In Chapter 7, youâ€™ll learn about Rustâ€™s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rustâ€™s error-handling philosophy and techniques.
-->
<p>Au chapitre 7, vous apprendrez le systÃ¨me de modules de Rust et les rÃ¨gles de
visibilitÃ©, afin d'organiser votre code et son interface de programmation
applicative (API) publique. Le chapitre 8 traitera des structures de collections
de donnÃ©es usuelles fournies par la bibliothÃ¨que standard, comme les vecteurs,
les chaÃ®nes de caractÃ¨res et les tables de hachage <em>(hash maps)</em>. Le chapitre 9
explorera la philosophie et les techniques de gestion d'erreurs de Rust.</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rustâ€™s safety guarantees is necessary to ensure your programâ€™s
logic is correct. In Chapter 12, weâ€™ll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, weâ€™ll use many of the concepts we discussed in the
previous chapters.
-->
<p>Le chapitre 10 nous plongera dans la gÃ©nÃ©ricitÃ©, les <em>traits</em> et
les durÃ©es de vie, qui vous donneront la capacitÃ© de crÃ©er du code qui s'adapte
Ã  diffÃ©rents types. Le chapitre 11 traitera des techniques de test, qui restent
nÃ©cessaires malgrÃ© les garanties de sÃ©curitÃ© de Rust, pour s'assurer que
la logique de votre programme est valide. Au chapitre 12, nous Ã©crirons
notre propre implÃ©mentation d'un sous-ensemble des fonctionnalitÃ©s du programme
en ligne de commande <code>grep</code>, qui recherche du texte dans des fichiers.
Pour ce faire, nous utiliserons de nombreuses notions abordÃ©es dans les
chapitres prÃ©cÃ©dents.</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, weâ€™ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>Le chapitre 13 explorera les fermetures <em>(closures)</em> et itÃ©rateurs : ce sont les
fonctionnalitÃ©s de Rust inspirÃ©es des langages de programmation fonctionnels.
Au chapitre 14, nous explorerons plus en profondeur Cargo et les bonnes
pratiques pour partager vos propres bibliothÃ¨ques avec les autres. Le chapitre
15 parlera de pointeurs intelligents qu'apporte la bibliothÃ¨que standard et des
<em>traits</em> qui activent leurs fonctionnalitÃ©s.</p>
<!--
In Chapter 16, weâ€™ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>Au chapitre 16, nous passerons en revue les diffÃ©rents modes de programmation
concurrente et comment Rust nous aide Ã  dÃ©velopper dans des tÃ¢ches parallÃ¨les
sans crainte. Le chapitre 17 comparera les fonctionnalitÃ©s de Rust aux
principes de programmation orientÃ©e objet, que vous connaissez peut-Ãªtre.</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>Le chapitre 18 est une rÃ©fÃ©rence sur les motifs et le filtrage de motif
<em>(pattern matching)</em>, qui sont des moyens puissants permettant de communiquer
des idÃ©es dans les programmes Rust. Le chapitre 19 contient une foultitude de
sujets avancÃ©s intÃ©ressants, comme le code Rust non sÃ©curisÃ© <em>(unsafe)</em>, les
macros et plus de dÃ©tails sur les durÃ©es de vie, les <em>traits</em>, les types, les
fonctions et les fermetures <em>(closures)</em>.</p>
<!--
In Chapter 20, weâ€™ll complete a project in which weâ€™ll implement a low-level
multithreaded web server!
-->
<p>Au chapitre 20, nous terminerons un projet dans lequel nous allons
implÃ©menter en bas-niveau un serveur web multitÃ¢chesÂ !</p>
<!--
Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rustâ€™s keywords, Appendix B
covers Rustâ€™s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>Et finalement, quelques annexes qui contiennent des informations utiles sur le
langage sous forme de rÃ©fÃ©rentiels qui renvoient Ã  d'autres documents. L'annexe
A liste les mots-clÃ©s de Rust, l'annexe B couvre les opÃ©rateurs et symboles de
Rust, l'annexe C parle des <em>traits</em> dÃ©rivables qu'apporte la bibliothÃ¨que
standard, l'annexe D rÃ©fÃ©rence certains outils de dÃ©veloppement utiles, et
l'annexe E explique les diffÃ©rentes Ã©ditions de Rust.</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>Il n'y a pas de mauvaise maniÃ¨re de lire ce livre : si vous voulez sauter des
Ã©tapes, allez-y !
Vous devrez alors peut-Ãªtre revenir sur les chapitres prÃ©cÃ©dents si vous
Ã©prouvez des difficultÃ©s. Mais faites comme bon vous semble.</p>
<!--
<span id="ferris"></span>
-->
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, weâ€™ll provide many examples that donâ€™t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example youâ€™re trying to run is meant to
error. Ferris will also help you distinguish code that isnâ€™t meant to work:
-->
<p>Une composante importante du processus d'apprentissage de Rust est de comprendre
comment lire les messages d'erreur qu'affiche le compilateur : ils vous
guideront vers du code correct.
Ainsi, nous citerons de nombreux exemples qui ne compilent pas, avec le message
d'erreur que le compilateur devrait vous afficher dans chaque cas. C'est donc
normal que dans certains cas, si vous copiez et exÃ©cutez un exemple au hasard,
il ne compile pas ! Assurez-vous d'avoir lu le texte autour pour savoir si
l'exemple que vous tentez de compiler doit Ã©chouer. Ferris va aussi vous aider
Ã  identifier du code qui ne devrait pas fonctionner :</p>
<!-- markdownlint-disable -->
<!--
| Ferris                                                                 | Meaning                                          |
|------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain"/>    | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain"/>              | This code panics!                                |
| <img src="img/ferris/unsafe.svg" class="ferris-explain"/>              | This code block contains unsafe code.            |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/>| This code does not produce the desired behavior. |
-->
<!-- markdownlint-restore -->
<table><thead><tr><th>Ferris</th><th>Signification</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Ce code ne compile pas !</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Ce code panique !</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Ce bloc de code contient du code non sÃ©curisÃ©.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Ce code ne se comporte pas comme voulu.</td></tr>
</tbody></table>
<!--
In most situations, weâ€™ll lead you to the correct version of any code that
doesnâ€™t compile.
-->
<p>Dans la plupart des cas, nous vous guiderons vers la version du code qui devrait
fonctionner.</p>
<!--
## Source Code
-->
<h2><a class="header" href="#code-source" id="code-source">Code source</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>Les fichiers du code source qui a gÃ©nÃ©rÃ© ce livre en anglais sont disponibles
sur <a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<p>La version franÃ§aise est aussi disponible sur <a href="https://github.com/Jimskapt/rust-book-fr">GitHub</a>.</p>
<!--
[book]: https://github.com/rust-lang/book/tree/master/src
-->
<h1><a class="header" href="#traduction-des-termes" id="traduction-des-termes">Traduction des termes</a></h1>
<p>Voici les principaux termes techniques qui ont Ã©tÃ© traduits de l'anglais vers le
franÃ§ais.</p>
<table><thead><tr><th>Anglais</th><th>FranÃ§ais</th><th>Remarques</th></tr></thead><tbody>
<tr><td>adaptor</td><td>adaptateur</td><td>-</td></tr>
<tr><td>ahead-of-time compilation</td><td>compilation anticipÃ©e</td><td>sigleÂ : AOT</td></tr>
<tr><td>alias</td><td>alias</td><td>-</td></tr>
<tr><td>allocated</td><td>allouÃ©</td><td>-</td></tr>
<tr><td>angle bracket</td><td>chevrons</td><td>-</td></tr>
<tr><td>annotate</td><td>indiquer</td><td>-</td></tr>
<tr><td>anti-pattern</td><td>anti-patron</td><td>-</td></tr>
<tr><td>append</td><td>ajouter</td><td>-</td></tr>
<tr><td>Appendix</td><td>annexe</td><td>tout en minuscule (sauf en dÃ©but de phrase)</td></tr>
<tr><td>append</td><td>ajouter</td><td>-</td></tr>
<tr><td>Application Programming Interface (API)</td><td>interface de programmation applicative (API)</td><td>-</td></tr>
<tr><td>assertion</td><td>vÃ©rification</td><td>-</td></tr>
<tr><td>assign</td><td>assigner</td><td>-</td></tr>
<tr><td>argument</td><td>argument / paramÃ¨tre</td><td>-</td></tr>
<tr><td>arm</td><td>branche</td><td>dans une expression <code>match</code></td></tr>
<tr><td>array</td><td>tableau</td><td>-</td></tr>
<tr><td>artifact</td><td>artÃ©fact</td><td>-</td></tr>
<tr><td>associated function</td><td>fonction associÃ©e</td><td>-</td></tr>
<tr><td>attribute</td><td>attribut</td><td>-</td></tr>
<tr><td>backend</td><td>application dorsale</td><td>-</td></tr>
<tr><td>backtrace</td><td>re-traÃ§age</td><td>-</td></tr>
<tr><td>benchmark</td><td>benchmark</td><td>-</td></tr>
<tr><td>binary crate</td><td>crate binaire</td><td>s'utilise au fÃ©minin</td></tr>
<tr><td><em>n</em>-bit number</td><td>nombre encodÃ© sur <em>n</em> bits</td><td>-</td></tr>
<tr><td>blanket implementation</td><td>implÃ©mentation gÃ©nÃ©rale</td><td>-</td></tr>
<tr><td>blob</td><td>blob</td><td>-</td></tr>
<tr><td>boilerplate code</td><td>code standard</td><td>-</td></tr>
<tr><td>boolean</td><td>boolÃ©en</td><td>-</td></tr>
<tr><td>borrow</td><td>emprunt(er)</td><td>-</td></tr>
<tr><td>borrow checker</td><td>vÃ©rificateur d'emprunt</td><td>-</td></tr>
<tr><td>box</td><td>boite</td><td>-</td></tr>
<tr><td>buffer overread</td><td>sur-lecture de tampon</td><td>-</td></tr>
<tr><td>bug</td><td>bogue</td><td>-</td></tr>
<tr><td>build</td><td>compilation</td><td>-</td></tr>
<tr><td>build system</td><td>systÃ¨me de compilation</td><td>-</td></tr>
<tr><td>byte</td><td>octet</td><td>-</td></tr>
<tr><td>Cargo</td><td>Cargo</td><td>-</td></tr>
<tr><td>catchall value</td><td>valeur passe-partout</td><td>-</td></tr>
<tr><td>channel</td><td>canal</td><td>-</td></tr>
<tr><td>Chapter</td><td>chapitre</td><td>tout en minuscule (sauf en dÃ©but de phrase)</td></tr>
<tr><td>CI system</td><td>systÃ¨me d'IntÃ©gration Continue</td><td>-</td></tr>
<tr><td>clause</td><td>clause</td><td>-</td></tr>
<tr><td>cleanup</td><td>nettoyage</td><td>-</td></tr>
<tr><td>closure</td><td>fermeture</td><td>-</td></tr>
<tr><td>code review</td><td>revue de code</td><td>-</td></tr>
<tr><td>coercion</td><td>extrapolation</td><td>-</td></tr>
<tr><td>collection</td><td>collection</td><td>-</td></tr>
<tr><td>command</td><td>commande</td><td>dans un terminal</td></tr>
<tr><td>commit</td><td>commit</td><td>-</td></tr>
<tr><td>compound</td><td>composÃ©</td><td>-</td></tr>
<tr><td>concept chapter</td><td>chapitre thÃ©orique</td><td>-</td></tr>
<tr><td>concurrency</td><td>concurrence</td><td>-</td></tr>
<tr><td>concurrent</td><td>concurrent</td><td>-</td></tr>
<tr><td>concurrent programming</td><td>programmation concurrente</td><td>-</td></tr>
<tr><td>conditional</td><td>structure conditionnelle</td><td>-</td></tr>
<tr><td>cons list</td><td>liste de construction</td><td>-</td></tr>
<tr><td>constant</td><td>constant / constante</td><td>-</td></tr>
<tr><td>construct</td><td>instruction</td><td>-</td></tr>
<tr><td>consuming adaptor</td><td>adaptateur de consommation</td><td>-</td></tr>
<tr><td>constructor</td><td>constructeur</td><td>-</td></tr>
<tr><td>control flow construct</td><td>structure de contrÃ´le</td><td>-</td></tr>
<tr><td>core of the error</td><td>message d'erreur</td><td>-</td></tr>
<tr><td>corruption</td><td>corruption / Ãªtre corrompu</td><td>-</td></tr>
<tr><td>CPU</td><td>processeur</td><td>-</td></tr>
<tr><td>crash</td><td>plantage</td><td>-</td></tr>
<tr><td>crate</td><td>crate</td><td>nom fÃ©minin (une <em>crate</em>)</td></tr>
<tr><td>curly bracket</td><td>accolade</td><td>-</td></tr>
<tr><td>dangling</td><td>pendouillant</td><td>-</td></tr>
<tr><td>data race</td><td>accÃ¨s concurrent</td><td>-</td></tr>
<tr><td>data representation</td><td>modÃ¨le de donnÃ©es</td><td>-</td></tr>
<tr><td>deadlock</td><td>interblocage</td><td>-</td></tr>
<tr><td>deallocate</td><td>dÃ©sallouÃ©</td><td>-</td></tr>
<tr><td>debug</td><td>dÃ©boguer</td><td>-</td></tr>
<tr><td>debugging</td><td>dÃ©bogage</td><td>-</td></tr>
<tr><td>deep copy</td><td>copie en profondeur</td><td>-</td></tr>
<tr><td>dependency</td><td>dÃ©pendance</td><td>-</td></tr>
<tr><td>deref coercion</td><td>extrapolation de dÃ©rÃ©ferencement</td><td>-</td></tr>
<tr><td>dereference operator</td><td>opÃ©rateur de dÃ©rÃ©fÃ©rencement</td><td>-</td></tr>
<tr><td>dereferencing</td><td>dÃ©rÃ©fÃ©rencement</td><td>-</td></tr>
<tr><td>design pattern</td><td>patron de conception</td><td>-</td></tr>
<tr><td>destructor</td><td>destructeur</td><td>-</td></tr>
<tr><td>destructure</td><td>dÃ©structurer</td><td>-</td></tr>
<tr><td>DevOps</td><td>DevOps</td><td>-</td></tr>
<tr><td>directory</td><td>dossier</td><td>-</td></tr>
<tr><td>dot notation</td><td>la notation avec un point</td><td>-</td></tr>
<tr><td>double free</td><td>double libÃ©ration</td><td>-</td></tr>
<tr><td>drop</td><td>libÃ©rÃ©r</td><td>-</td></tr>
<tr><td>elision</td><td>Ã©lision</td><td>-</td></tr>
<tr><td>enum</td><td>Ã©numÃ©ration</td><td>-</td></tr>
<tr><td>enumeration</td><td>Ã©numÃ©ration</td><td>-</td></tr>
<tr><td>enumâ€™s variant</td><td>variante d'Ã©numÃ©ration</td><td>-</td></tr>
<tr><td>exploit</td><td>faille</td><td>-</td></tr>
<tr><td>expression</td><td>expression</td><td>-</td></tr>
<tr><td>field</td><td>champ</td><td>d'une structure</td></tr>
<tr><td>Figure</td><td>Illustration</td><td>-</td></tr>
<tr><td>flag</td><td>drapeau</td><td>pour les programmes en ligne de commande</td></tr>
<tr><td>float</td><td>nombre Ã  virgule flottante</td><td>-</td></tr>
<tr><td>floating-point number</td><td>nombre Ã  virgule flottante</td><td>-</td></tr>
<tr><td>framework</td><td>environnement de dÃ©veloppement</td><td>-</td></tr>
<tr><td>frontend</td><td>application frontale</td><td>-</td></tr>
<tr><td>fully qualified syntax</td><td>syntaxe totalement dÃ©finie</td><td>-</td></tr>
<tr><td>function</td><td>fonction</td><td>-</td></tr>
<tr><td>functional programming</td><td>programmation fonctionnelle</td><td>-</td></tr>
<tr><td>garbage collector</td><td>ramasse-miettes</td><td>-</td></tr>
<tr><td>generics</td><td>gÃ©nÃ©riques / gÃ©nÃ©ricitÃ©</td><td>-</td></tr>
<tr><td>generic type parameter</td><td>paramÃ¨tre de type gÃ©nÃ©rique</td><td>-</td></tr>
<tr><td>getter</td><td>accesseur</td><td>-</td></tr>
<tr><td>grapheme cluster</td><td>groupe de graphÃ¨mes</td><td>-</td></tr>
<tr><td>glob</td><td>global</td><td>opÃ©rateur</td></tr>
<tr><td>global scope</td><td>portÃ©e globale</td><td>-</td></tr>
<tr><td>grapheme cluster</td><td>groupe de graphÃ¨mes</td><td>-</td></tr>
<tr><td>green thread</td><td>tÃ¢che virtuelle</td><td>-</td></tr>
<tr><td>guessing game</td><td>jeu de devinettes</td><td>-</td></tr>
<tr><td>handle</td><td>rÃ©fÃ©rence abstraite</td><td>-</td></tr>
<tr><td>hash</td><td>hash / relatif au hachage</td><td>-</td></tr>
<tr><td>hash map</td><td>table de hachage</td><td>-</td></tr>
<tr><td>heap</td><td>tas</td><td>-</td></tr>
<tr><td>Hello, world!</td><td>Hello, world!</td><td>-</td></tr>
<tr><td>high-level</td><td>haut niveau</td><td>-</td></tr>
<tr><td>identifier</td><td>identificateur</td><td>-</td></tr>
<tr><td>idiomatic</td><td>idÃ©al</td><td>-</td></tr>
<tr><td>immutability</td><td>immuabilitÃ©</td><td>-</td></tr>
<tr><td>immutable</td><td>immuable</td><td>-</td></tr>
<tr><td>index</td><td>indice</td><td>-</td></tr>
<tr><td>indexing</td><td>indexation</td><td>-</td></tr>
<tr><td>input/output</td><td>entrÃ©e/sortie</td><td>sigleÂ : IO</td></tr>
<tr><td>instance</td><td>instance</td><td>-</td></tr>
<tr><td>instantiate</td><td>instancier</td><td>crÃ©er une instance</td></tr>
<tr><td>integer literal</td><td>littÃ©ral d'entiers</td><td>-</td></tr>
<tr><td>integer overflow</td><td>dÃ©passement d'entier</td><td>-</td></tr>
<tr><td>Integrated Development Environment (IDE)</td><td>environnement de dÃ©veloppement intÃ©grÃ© (IDE)</td><td>-</td></tr>
<tr><td>interior mutability</td><td>mutabilitÃ© interne</td><td>-</td></tr>
<tr><td>interrupt signal</td><td>signal d'arrÃªt</td><td>-</td></tr>
<tr><td>invalidate</td><td>neutraliser</td><td>-</td></tr>
<tr><td>IOT</td><td>internet des objets (IOT)</td><td>-</td></tr>
<tr><td>iterator</td><td>itÃ©rateur</td><td>-</td></tr>
<tr><td>iterator adaptor</td><td>adaptateur d'itÃ©ration</td><td>-</td></tr>
<tr><td>job</td><td>mission</td><td>-</td></tr>
<tr><td>just-in-time compilation</td><td>compilation Ã  la volÃ©e</td><td>sigleÂ : JIT</td></tr>
<tr><td>keyword</td><td>mot-clÃ©</td><td>-</td></tr>
<tr><td>lazy</td><td>Ã©valuation paresseuse</td><td>comportement d'un itÃ©rateur</td></tr>
<tr><td>legacy code</td><td>code instable que le programme a hÃ©ritÃ© avec le temps</td><td>-</td></tr>
<tr><td>library</td><td>bibliothÃ¨que</td><td>-</td></tr>
<tr><td>library crate</td><td>crate de bibliothÃ¨que</td><td>s'utilise au fÃ©minin</td></tr>
<tr><td>lifetime</td><td>durÃ©e de vie</td><td>-</td></tr>
<tr><td>linker</td><td>linker</td><td>-</td></tr>
<tr><td>linter</td><td>analyse statique</td><td>-</td></tr>
<tr><td>literal value</td><td>valeur litÃ©rale</td><td>-</td></tr>
<tr><td>Listing</td><td>encart</td><td>tout en minuscule (sauf en dÃ©but de phrase)</td></tr>
<tr><td>loop</td><td>boucle</td><td>-</td></tr>
<tr><td>low-level</td><td>bas niveau</td><td>-</td></tr>
<tr><td>machine learning</td><td>apprentissage automatique</td><td>-</td></tr>
<tr><td>macro</td><td>macro</td><td>-</td></tr>
<tr><td>main</td><td>main</td><td>-</td></tr>
<tr><td>map</td><td>tableau associatif</td><td>-</td></tr>
<tr><td>match guard</td><td>contrÃ´le de correspondance</td><td>-</td></tr>
<tr><td>memory leak</td><td>fuite de mÃ©moire</td><td>-</td></tr>
<tr><td>memory management</td><td>gestion de mÃ©moire</td><td>-</td></tr>
<tr><td>message-passing</td><td>passage de messages</td><td>-</td></tr>
<tr><td>method</td><td>mÃ©thode</td><td>-</td></tr>
<tr><td>mock object</td><td>mock object</td><td>-</td></tr>
<tr><td>modern</td><td>rÃ©cent</td><td>-</td></tr>
<tr><td>module</td><td>module</td><td>-</td></tr>
<tr><td>module system</td><td>systÃ¨me de modules</td><td>-</td></tr>
<tr><td>monomorphization</td><td>monomorphisation</td><td>-</td></tr>
<tr><td>move</td><td>dÃ©placement</td><td>-</td></tr>
<tr><td>mutability</td><td>mutabilitÃ©</td><td>-</td></tr>
<tr><td>mutable</td><td>mutable</td><td>modifiable</td></tr>
<tr><td>mutate</td><td>muter</td><td>-</td></tr>
<tr><td>namespace</td><td>espace de nom</td><td>-</td></tr>
<tr><td>namespacing</td><td>l'espace de nom</td><td>-</td></tr>
<tr><td>nested (path)</td><td>(chemin) imbriquÃ©</td><td>-</td></tr>
<tr><td>nightly Rust</td><td>version expÃ©rimentale de Rust</td><td>-</td></tr>
<tr><td>Note</td><td>remarque</td><td>tout en minuscule (sauf en dÃ©but de phrase)</td></tr>
<tr><td>numerical characters</td><td>chiffres</td><td>-</td></tr>
<tr><td>object-oriented language</td><td>langage orientÃ© objet</td><td>-</td></tr>
<tr><td>operating system</td><td>systÃ¨me d'exploitation</td><td>-</td></tr>
<tr><td>output</td><td>sortie</td><td>-</td></tr>
<tr><td>overload</td><td>surcharge</td><td>-</td></tr>
<tr><td>owner</td><td>propriÃ©taire</td><td>-</td></tr>
<tr><td>ownership</td><td>possession</td><td>-</td></tr>
<tr><td>package manager</td><td>systÃ¨me de gestion de paquets</td><td>-</td></tr>
<tr><td>panic</td><td>panique(r)</td><td>-</td></tr>
<tr><td>parallelism</td><td>parallÃ©lisme</td><td>-</td></tr>
<tr><td>parallel programming</td><td>parallÃ©lisme</td><td>-</td></tr>
<tr><td>parameter</td><td>paramÃ¨tre</td><td>-</td></tr>
<tr><td>parse</td><td>interprÃªter</td><td>-</td></tr>
<tr><td>PATH</td><td>PATH</td><td>-</td></tr>
<tr><td>pattern</td><td>motif</td><td>-</td></tr>
<tr><td>pattern-matching</td><td>filtrage par motif</td><td>-</td></tr>
<tr><td>placeholder</td><td>espace rÃ©servÃ©</td><td><code>{}</code> pour <code>fmt</code></td></tr>
<tr><td>pointer</td><td>pointeur</td><td>-</td></tr>
<tr><td>popping off the stack</td><td>dÃ©piler</td><td>-</td></tr>
<tr><td>prelude</td><td>Ã©tape prÃ©liminaire</td><td>-</td></tr>
<tr><td>primitive obsession</td><td>obsession primitive</td><td>-</td></tr>
<tr><td>privacy</td><td>protection</td><td>explication de la protection des Ã©lÃ©ments d'un module</td></tr>
<tr><td>procedural macro</td><td>macro procÃ©durale</td><td>-</td></tr>
<tr><td>process</td><td>processus</td><td>-</td></tr>
<tr><td>project chapter</td><td>chapitre de projet</td><td>-</td></tr>
<tr><td>propagate</td><td>propager</td><td>-</td></tr>
<tr><td>race condition</td><td>situation de concurrence</td><td>-</td></tr>
<tr><td>pushing onto the stack</td><td>empiler</td><td>-</td></tr>
<tr><td>race condition</td><td>situation de concurrence</td><td>-</td></tr>
<tr><td>raw identifier</td><td>identificateur brut</td><td>-</td></tr>
<tr><td>README</td><td>README</td><td>-</td></tr>
<tr><td>recursive type</td><td>type rÃ©cursif</td><td>-</td></tr>
<tr><td>refactoring</td><td>remaniement</td><td>-</td></tr>
<tr><td>reference</td><td>rÃ©fÃ©rence</td><td>-</td></tr>
<tr><td>reference counting</td><td>compteur de rÃ©fÃ©rences</td><td>-</td></tr>
<tr><td>reference cycle</td><td>boucle de rÃ©fÃ©rences</td><td>-</td></tr>
<tr><td>release</td><td>publication</td><td>-</td></tr>
<tr><td>registry</td><td>registre</td><td>-</td></tr>
<tr><td>regression</td><td>rÃ©gression</td><td>-</td></tr>
<tr><td>remainder</td><td>modulo</td><td>opÃ©ration <code>%</code></td></tr>
<tr><td>reproducible build</td><td>compilation reproductible</td><td>-</td></tr>
<tr><td>Resource Acquisition Is Initialization (RAII)</td><td>l'acquisition d'une ressource est une initialisation (RAII)</td><td>-</td></tr>
<tr><td>return</td><td>retourner</td><td>-</td></tr>
<tr><td>run</td><td>exÃ©cuter</td><td>pour les programmes</td></tr>
<tr><td>Rustacean</td><td>RustacÃ©</td><td>-</td></tr>
<tr><td>section header</td><td>entÃªte de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sÃ©mantique</td><td>-</td></tr>
<tr><td>scalar</td><td>scalaire</td><td>-</td></tr>
<tr><td>scope</td><td>portÃ©e</td><td>-</td></tr>
<tr><td>script</td><td>script</td><td>-</td></tr>
<tr><td>secret</td><td>secret</td><td>-</td></tr>
<tr><td>section header</td><td>en-tÃªte de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sÃ©mantique</td><td>-</td></tr>
<tr><td>semantic versioning</td><td>versionnage sÃ©mantique</td><td>abrÃ©viationÂ : SemVer</td></tr>
<tr><td>shadow</td><td>masquer</td><td>remplacer une variable par une autre de mÃªme nom</td></tr>
<tr><td>shadowing</td><td>masquage</td><td>-</td></tr>
<tr><td>shallow copy</td><td>copie superficielle</td><td>-</td></tr>
<tr><td>shell</td><td>terminal / invite de commande</td><td>-</td></tr>
<tr><td>shorthand</td><td>abrÃ©viation</td><td>-</td></tr>
<tr><td>sidebar</td><td>volet latÃ©ral</td><td>-</td></tr>
<tr><td>signature</td><td>signature</td><td>d'une fonction</td></tr>
<tr><td>signed</td><td>signÃ©</td><td>-</td></tr>
<tr><td>slash</td><td>barre oblique</td><td>-</td></tr>
<tr><td>slice</td><td>slice</td><td>-</td></tr>
<tr><td>smart pointer</td><td>pointeur intelligent</td><td>-</td></tr>
<tr><td>snake case</td><td>snake case</td><td>-</td></tr>
<tr><td>snip</td><td>partie masquÃ©e ici</td><td>dans un encart</td></tr>
<tr><td>space</td><td>espace</td><td>ce mot est fÃ©minin quand on parle du caractÃ¨re typographique</td></tr>
<tr><td>square brackets</td><td>crochets</td><td>-</td></tr>
<tr><td>stack</td><td>pile</td><td>-</td></tr>
<tr><td>stack overflow</td><td>dÃ©bordement de pile</td><td>-</td></tr>
<tr><td>standard</td><td>standard <em>(adj. inv.)</em> / norme <em>(n.f.)</em></td><td>-</td></tr>
<tr><td>standard error</td><td>erreur standard</td><td>-</td></tr>
<tr><td>standard input</td><td>entrÃ©e standard</td><td>-</td></tr>
<tr><td>standard library</td><td>bibliothÃ¨que standard</td><td>-</td></tr>
<tr><td>standard output</td><td>sortie standard</td><td>-</td></tr>
<tr><td>statement</td><td>instruction</td><td>-</td></tr>
<tr><td>statically typed</td><td>statiquement typÃ©</td><td>-</td></tr>
<tr><td>string</td><td>chaÃ®ne de caractÃ¨res</td><td>-</td></tr>
<tr><td>string literal</td><td>un littÃ©ral de chaÃ®ne de caractÃ¨res</td><td>-</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>nom fÃ©minin (une <code>String</code>)</td></tr>
<tr><td>struct</td><td>structure</td><td>-</td></tr>
<tr><td>submodule</td><td>sous-module</td><td>-</td></tr>
<tr><td>supertrait</td><td>supertrait</td><td>-</td></tr>
<tr><td>syntax sugar</td><td>sucre syntaxique</td><td>-</td></tr>
<tr><td>systems concept</td><td>notion systÃ¨me</td><td>-</td></tr>
<tr><td>systems-level</td><td>niveau systÃ¨me</td><td>-</td></tr>
<tr><td>systems-level code</td><td>code systÃ¨me</td><td>-</td></tr>
<tr><td>terminal</td><td>terminal</td><td>-</td></tr>
<tr><td>thread</td><td>tÃ¢che</td><td>-</td></tr>
<tr><td>token</td><td>jeton</td><td>-</td></tr>
<tr><td>test double</td><td>double de test</td><td>-</td></tr>
<tr><td>thread pool</td><td>groupe de tÃ¢ches</td><td>-</td></tr>
<tr><td>trait</td><td>trait</td><td>-</td></tr>
<tr><td>trait bound</td><td>trait liÃ©</td><td>-</td></tr>
<tr><td>trait object</td><td>objet trait</td><td>-</td></tr>
<tr><td>tree</td><td>arborescence</td><td>-</td></tr>
<tr><td>troubleshooting</td><td>dÃ©pannage</td><td>-</td></tr>
<tr><td>tuple</td><td>tuple</td><td>-</td></tr>
<tr><td>tuple struct</td><td>structure tuple</td><td>-</td></tr>
<tr><td>tuple enum</td><td>Ã©numÃ©ration tuple</td><td>-</td></tr>
<tr><td>type</td><td>type</td><td>-</td></tr>
<tr><td>type annotation</td><td>annotation de type</td><td>-</td></tr>
<tr><td>type inference</td><td>infÃ©rence de types</td><td>-</td></tr>
<tr><td>twoâ€™s complement</td><td>complÃ©ment Ã  deux</td><td>-</td></tr>
<tr><td>twoâ€™s complement wrapping</td><td>rebouclage du complÃ©ment Ã  deux</td><td>-</td></tr>
<tr><td>underlying operating system</td><td>systÃ¨me d'exploitation sous-jacent</td><td>-</td></tr>
<tr><td>underscore</td><td>tiret bas</td><td>le caractÃ¨re <code>_</code></td></tr>
<tr><td>unit-like struct</td><td>structure unitÃ©</td><td>-</td></tr>
<tr><td>unit type</td><td>type unitÃ©</td><td>le <code>()</code></td></tr>
<tr><td>unit value</td><td>valeur unitÃ©</td><td>-</td></tr>
<tr><td>unrolling</td><td>dÃ©roulage</td><td>pour une boucle Ã  taille connue Ã  la compilation</td></tr>
<tr><td>unsafe</td><td>non sÃ©curisÃ©</td><td>-</td></tr>
<tr><td>unsigned</td><td>sans signe (toujours positif)</td><td>-</td></tr>
<tr><td>unsigned</td><td>non signÃ©</td><td>-</td></tr>
<tr><td>unwind</td><td>dÃ©rouler</td><td>(la pile)</td></tr>
<tr><td>user input</td><td>saisie utilisateur</td><td>-</td></tr>
<tr><td>variable</td><td>variable</td><td>-</td></tr>
<tr><td>variant</td><td>variante</td><td>d'une Ã©numÃ©ration</td></tr>
<tr><td>vector</td><td>vecteur</td><td>-</td></tr>
<tr><td>version control system (VCS)</td><td>systÃ¨me de gestion de versions (VCS)</td><td>-</td></tr>
<tr><td>vertical pipe</td><td>barre verticale</td><td>la barre `</td></tr>
<tr><td>warning</td><td>avertissement</td><td>-</td></tr>
<tr><td>weak reference</td><td>pointeur faible</td><td>-</td></tr>
<tr><td>wildcard</td><td>joker</td><td>-</td></tr>
<tr><td>worker</td><td>opÃ©rateur</td><td>-</td></tr>
<tr><td>workspace</td><td>espace de travail</td><td>-</td></tr>
<tr><td>yank</td><td>dÃ©prÃ©cier</td><td>-</td></tr>
<tr><td>zero-cost abstraction</td><td>abstraction sans coÃ»t</td><td>-</td></tr>
</tbody></table>
<!--
# Getting Started
-->
<h1><a class="header" href="#prise-en-main" id="prise-en-main">Prise en main</a></h1>
<!--
Letâ€™s start your Rust journey! Thereâ€™s a lot to learn, but every journey starts
somewhere. In this chapter, weâ€™ll discuss:
-->
<p>DÃ©marrons notre pÃ©riple avec Rust ! Il y a beaucoup Ã  apprendre, mais chaque
aventure doit commencer quelque part. Dans ce chapitre, nous allons aborder :</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rustâ€™s package manager and build system
-->
<ul>
<li>L'installation de Rust sur Linux, macOS et Windows</li>
<li>L'Ã©criture d'un programme qui affiche <code>Hello, world!</code></li>
<li>L'utilisation de <code>cargo</code>, le gestionnaire de paquets et systÃ¨me de compilation
de Rust</li>
</ul>
<!--
## Installation
-->
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<!--
The first step is to install Rust. Weâ€™ll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. Youâ€™ll need
an internet connection for the download.
-->
<p>La premiÃ¨re Ã©tape consiste Ã  installer Rust. Nous allons tÃ©lÃ©charger Rust via
<code>rustup</code>, un outil en ligne de commande conÃ§u pour gÃ©rer les versions de Rust et
les outils qui leur sont associÃ©s. Vous allez avoir besoin d'une connexion
Internet pour le tÃ©lÃ©chargement.</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see [the Rust
> installation page](https://www.rust-lang.org/tools/install) for other options.
-->
<blockquote>
<p>NoteÂ : si vous prÃ©fÃ©rez ne pas utiliser <code>rustup</code> pour une raison ou une autre,
vous pouvez vous rÃ©fÃ©rer Ã 
<a href="https://www.rust-lang.org/tools/install">la page d'installation de Rust</a>
pour d'autres mÃ©thodes d'installation.</p>
</blockquote>
<!--
The following steps install the latest stable version of the Rust compiler.
Rustâ€™s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>L'Ã©tape suivante est d'installer la derniÃ¨re version stable du compilateur Rust.
La garantie de stabilitÃ© de Rust assurera que tous les exemples dans le livre
qui se compilent bien vont continuer Ã  se compiler avec les nouvelles versions
de Rust. La sortie peut varier lÃ©gÃ¨rement d'une version Ã  une autre, car Rust
amÃ©liore souvent les messages d'erreur et les avertissements. En rÃ©sumÃ©, toute
nouvelle version stable de Rust que vous installez de cette maniÃ¨re devrait
fonctionner en cohÃ©rence avec le contenu de ce livre.</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, weâ€™ll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> donâ€™t need to type in the `$` character; it indicates the start of each
> command. Lines that donâ€™t start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3><a class="header" href="#la-notation-en-ligne-de-commande" id="la-notation-en-ligne-de-commande">La notation en ligne de commande</a></h3>
<p>Dans ce chapitre et les suivants dans le livre, nous allons montrer quelques
commandes tapÃ©es dans le terminal. Les lignes que vous devrez Ã©crire dans le
terminal commencent toutes par <code>$</code>. Vous n'avez pas besoin d'Ã©crire le
caractÃ¨re <code>$</code>; il marque le dÃ©but de chaque commande. Les lignes qui ne
commencent pas par <code>$</code> montrent gÃ©nÃ©ralement le rÃ©sultat de la commande
prÃ©cÃ©dente. De plus, les exemples propres Ã  PowerShell utiliseront
<code>&gt;</code> plutÃ´t que <code>$</code>.</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3><a class="header" href="#installer-rustup-sur-linux-ou-macos" id="installer-rustup-sur-linux-ou-macos">Installer <code>rustup</code> sur Linux ou macOS</a></h3>
<!--
If youâ€™re using Linux or macOS, open a terminal and enter the following command:
-->
<p>Si vous utilisez Linux ou macOS, ouvrez un terminal et Ã©crivez la commande
suivanteÂ :</p>
<!--
```console
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```
-->
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>Cette commande tÃ©lÃ©charge un script et lance l'installation de l'outil <code>rustup</code>,
qui va installer la derniÃ¨re version stable de Rust. Il est possible que l'on
vous demande votre mot de passe. Si l'installation se dÃ©roule bien, vous
devriez voir la ligne suivante s'afficherÂ :</p>
<!--
```text
Rust is installed now. Great!
```
-->
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
Additionally, youâ€™ll need a linker of some kind. Itâ€™s likely one is already
installed, but when you try to compile a Rust program and get errors indicating
that a linker could not execute, that means a linker isnâ€™t installed on your
system and youâ€™ll need to install one manually. C compilers usually come with
the correct linker. Check your platformâ€™s documentation for how to install a C
compiler. Also, some common Rust packages depend on C code and will need a C
compiler. Therefore, it might be worth installing one now.
-->
<p>De plus, vous aurez peut-Ãªtre besoin d'un <em>linker</em> quelconque. Il est probable
qu'il y en ait dÃ©jÃ  un d'installÃ©, mais si vous essayez de compiler un
programme Rust et que vous avez des erreurs qui disent que le <em>linker</em> ne peut
pas Ãªtre exÃ©cutÃ©, cela veut dire qu'il n'y a pas de <em>linker</em> d'installÃ© sur
votre systÃ¨me et que vous devrez en installer un manuellement. Les
compilateurs C sont gÃ©nÃ©ralement livrÃ©s avec un bon <em>linker</em>. RÃ©fÃ©rez-vous Ã  la
documentation de votre plateforme pour savoir comment installer un compilateur
C. De plus, certains paquets Rust communs nÃ©cessitent du code C et auront
besoin d'un compilateur C. C'est pourquoi cela vaut la peine d'en installer un
dÃ¨s maintenant.</p>
<!--
### Installing `rustup` on Windows
-->
<h3><a class="header" href="#installer-rustup-sous-windows" id="installer-rustup-sous-windows">Installer <code>rustup</code> sous Windows</a></h3>
<!-- markdownlint-disable -->
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, youâ€™ll
receive a message explaining that youâ€™ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. When asked which
workloads to install make sure "C++ build tools" is selected and that the Windows 10 SDK and the English language pack components are included.
-->
<!-- markdownlint-restore -->
<p>Sous Windows, il faut aller sur
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> et suivre les instructions
pour installer Rust. Ã€ un moment donnÃ© durant l'installation, vous aurez un
message vous expliquant qu'il va vous falloir l'outil de compilation C++
pour Visual Studio 2013 ou plus rÃ©cent. La mÃ©thode la plus facile pour obtenir
les outils de compilation est d'installer
<a href="https://visualstudio.microsoft.com/fr/visual-cpp-build-tools/">Build Tools pour Visual Studio 2019</a>. Lorsque vous aurez Ã 
sÃ©lectionner les composants Ã  installer, assurez-vous que les &quot;Outils de
compilation C++&quot; sont bien sÃ©lectionnÃ©s, et que le SDK Windows 10 et les paquets
de langage Anglais sont bien inclus.</p>
<!--
[install]: https://www.rust-lang.org/tools/install
[visualstudio]: https://visualstudio.microsoft.com/visual-cpp-build-tools/

FR translation: the website redirects to French version, we lose the "id" link.
Fix is directly below:
-->
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, weâ€™ll explain which to use.
-->
<p>La suite de ce livre utilisera des commandes qui fonctionnent Ã  la fois dans
<em>cmd.exe</em> et PowerShell. S'il y a des diffÃ©rences particuliÃ¨res, nous vous
expliquerons lesquelles utiliser.</p>
<!--
### Updating and Uninstalling
-->
<h3><a class="header" href="#mettre-Ã -jour-et-dÃ©sinstaller" id="mettre-Ã -jour-et-dÃ©sinstaller">Mettre Ã  jour et dÃ©sinstaller</a></h3>
<!--
After youâ€™ve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p>AprÃ¨s avoir installÃ© Rust avec <code>rustup</code>, la mise Ã  jour vers la derniÃ¨re version
est facile. Dans votre terminal, lancez le script de mise Ã  jour suivantÂ :</p>
<!--
```console
$ rustup update
```
-->
<pre><code class="language-console">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Pour dÃ©sinstaller Rust et <code>rustup</code>, exÃ©cutez le script de dÃ©sinstallation
suivant dans votre terminalÂ :</p>
<!--
```console
$ rustup self uninstall
```
-->
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3><a class="header" href="#dÃ©pannage" id="dÃ©pannage">DÃ©pannage</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Pour vÃ©rifier si Rust est correctement installÃ©, ouvrez un terminal et entrez
cette ligneÂ :</p>
<!--
```console
$ rustc --version
```
-->
<pre><code class="language-console">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>Vous devriez voir le numÃ©ro de version, le <em>hash</em> de <em>commit</em>,
et la date de <em>commit</em> de la derniÃ¨re version stable qui a Ã©tÃ© publiÃ©e,
au format suivantÂ :</p>
<!--
```text
rustc x.y.z (abcabcabc yyyy-mm-dd)
```
-->
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you donâ€™t
see this information and youâ€™re on Windows, check that Rust is in your `%PATH%`
system variable. If thatâ€™s all correct and Rust still isnâ€™t working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>Si vous voyez cette information, c'est que vous avez installÃ© Rust avec succÃ¨sÂ !
Si vous ne voyez pas cette information et que vous Ãªtes sous Windows, vÃ©rifiez
que Rust est prÃ©sent dans votre variable d'environnement systÃ¨me <code>%PATH%</code>. Si
tout est correct et que Rust ne fonctionne toujours pas, il y a quelques
endroits oÃ¹ vous pourrez trouver de l'aide. Le plus accessible est le
canal #beginners sur le <a href="https://discord.gg/rust-lang">Discord officiel de Rust</a>. LÃ -bas, vous pouvez
dialoguer en ligne avec d'autres <em>RustacÃ©s</em> (un surnom ridicule que nous nous
donnons entre nous) qui pourront vous aider. D'autres bonnes sources de donnÃ©es
sont <a href="https://users.rust-lang.org/">le forum d'utilisateurs</a> et <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<!--
[discord]: https://discord.gg/rust-lang
[users]: https://users.rust-lang.org/
[stackoverflow]: https://stackoverflow.com/questions/tagged/rust
-->
<!--
### Local Documentation
-->
<h3><a class="header" href="#documentation-en-local" id="documentation-en-local">Documentation en local</a></h3>
<!--
The installation of Rust also includes a copy of the documentation locally, so
you can read it offline. Run `rustup doc` to open the local documentation in
your browser.
-->
<p>L'installation de Rust embarque aussi une copie de la documentation en local
pour que vous puissiez la lire hors ligne. Lancez <code>rustup doc</code> afin d'ouvrir la
documentation locale dans votre navigateur.</p>
<!--
Any time a type or function is provided by the standard library and youâ€™re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>Ã€ chaque fois que vous n'Ãªtes pas sÃ»r de ce que fait un type ou une fonction
fournie par la bibliothÃ¨que standard ou que vous ne savez pas comment
l'utiliser, utilisez cette documentation de l'interface de programmation
applicative <em>(API)</em> pour le savoirÂ !</p>
<!--
## Hello, World!
-->
<h2><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h2>
<!--
Now that youâ€™ve installed Rust, letâ€™s write your first Rust program. Itâ€™s
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so weâ€™ll do the same here!
-->
<p>Maintenant que vous avez installÃ© Rust, Ã©crivons notre premier programme Rust.
Lorsqu'on apprend un nouveau langage, il est de tradition d'Ã©crire un petit
programme qui Ã©crit le texte &quot;Hello, world!&quot; Ã  l'Ã©cran, donc c'est ce que nous
allons faire !</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDEâ€™s documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>NoteÂ : ce livre part du principe que vous Ãªtes familier avec la ligne de
commande. Rust n'impose pas d'exigences sur votre Ã©diteur, vos outils ou
l'endroit oÃ¹ vous mettez votre code, donc si vous prÃ©fÃ©rez utiliser un
environnement de dÃ©veloppement intÃ©grÃ© (IDE) au lieu de la ligne de commande,
vous Ãªtes libre d'utiliser votre IDE favori. De nombreux IDE prennent en
charge Rust Ã  des degrÃ©s diversÂ ; consultez la documentation de
l'IDE pour plus d'informations. RÃ©cemment, l'Ã©quipe Rust s'est attelÃ©e Ã 
amÃ©liorer l'intÃ©gration dans les IDE et des progrÃ¨s ont rapidement Ã©tÃ© faits
dans ce domaine !</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3><a class="header" href="#crÃ©er-un-dossier-projet" id="crÃ©er-un-dossier-projet">CrÃ©er un dossier projet</a></h3>
<!--
Youâ€™ll start by making a directory to store your Rust code. It doesnâ€™t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Nous allons commencer par crÃ©er un dossier pour y ranger le code Rust. LÃ  oÃ¹
vous mettez votre code n'est pas important pour Rust, mais pour les exercices et
projets de ce livre, nous vous suggÃ©rons de crÃ©er un dossier <em>projects</em> dans
votre dossier utilisateur et de ranger tous vos projets lÃ -dedans.</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the â€œHello, world!â€ project within the *projects* directory.
-->
<p>Ouvrez un terminal et Ã©crivez les commandes suivantes pour crÃ©er un
dossier <em>projects</em> et un dossier pour le projet â€œHello, world!â€ Ã  l'intÃ©rieur
de ce dossier <em>projects</em>.</p>
<!--
For Linux, macOS, and PowerShell on Windows, enter this:
-->
<p>Sous Linux, macOS et PowerShell sous Windows, Ã©crivez ceciÂ :</p>
<!--
```console
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```
-->
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Avec CMD sous Windows, Ã©crivez ceciÂ :</p>
<!--
```cmd
> mkdir "%USERPROFILE%\projects"
> cd /d "%USERPROFILE%\projects"
> mkdir hello_world
> cd hello_world
```
-->
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3><a class="header" href="#Ã‰crire-et-exÃ©cuter-un-programme-rust" id="Ã‰crire-et-exÃ©cuter-un-programme-rust">Ã‰crire et exÃ©cuter un programme Rust</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If youâ€™re using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>Ensuite, crÃ©ez un nouveau fichier source et appelez-le <em>main.rs</em>. Les fichiers
Rust se terminent toujours par l'extension <em>.rs</em>. Si vous utilisez plusieurs
mots dans votre nom de fichier, utilisez un tiret bas (<code>_</code>) pour
les sÃ©parer. Par exemple, vous devriez utiliser <em>hello_world.rs</em> au lieu de
<em>helloworld.rs</em>.</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>Maintenant, ouvrez le fichier <em>main.rs</em> que vous venez de crÃ©er et entrez le
code de l'encart 1-1.</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">FichierÂ : main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">Encart 1-1Â : Un programme qui affiche <code>Hello, world!</code>
</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>Enregistrez le fichier et retournez dans votre terminal. Sur Linux
ou macOS, Ã©crivez les commandes suivantes pour compiler et exÃ©cuter le fichierÂ :</p>
<!--
```console
$ rustc main.rs
$ ./main
Hello, world!
```
-->
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Sur Windows, Ã©crivez la commande <code>.\main.exe</code> Ã  la place de <code>.\main</code>Â :</p>
<!--
```powershell
> rustc main.rs
> .\main.exe
Hello, world!
```
-->
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you donâ€™t see this output, refer back to the
[â€œTroubleshootingâ€][troubleshooting]<!-- ignore -- > part of the Installation
section for ways to get help.
-->
<p>Peu importe votre systÃ¨me d'exploitation, la chaÃ®ne de caractÃ¨res
<code>Hello, world!</code> devrait s'Ã©crire dans votre terminal. Si cela ne s'affiche pas,
rÃ©fÃ©rez-vous Ã  la partie <a href="ch01-01-installation.html#d%C3%A9pannage">&quot;DÃ©pannage&quot;</a><!-- ignore --> du
chapitre d'installation pour vous aider.</p>
<!--
If `Hello, world!` did print, congratulations! Youâ€™ve officially written a Rust
program. That makes you a Rust programmerâ€”welcome!
-->
<p>Si <code>Hello, world!</code> s'affiche, fÃ©licitations ! Vous avez officiellement Ã©crit un
programme Rust. Cela fait de vous un dÃ©veloppeur Rust â€” bienvenue !</p>
<!--
### Anatomy of a Rust Program
-->
<h3><a class="header" href="#structure-dun-programme-rust" id="structure-dun-programme-rust">Structure d'un programme Rust</a></h3>
<!--
Letâ€™s review in detail what just happened in your â€œHello, world!â€ program.
Hereâ€™s the first piece of the puzzle:
-->
<p>Regardons en dÃ©tail ce qui s'est passÃ© dans votre programme â€œHello, world!â€.
Voici le premier morceau du puzzleÂ :</p>
<!--
```rust
fn main() {

}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>Ces lignes dÃ©finissent une fonction dans Rust. La fonction <code>main</code> est spÃ©cialeÂ :
c'est toujours le premier code qui est exÃ©cutÃ© dans tous les programmes
en Rust. La premiÃ¨re ligne dÃ©clare une fonction qui s'appelle <code>main</code>, qui n'a
pas de paramÃ¨tre et qui ne retourne aucune valeur. S'il y avait des paramÃ¨tres,
ils seraient placÃ©s entre les parenthÃ¨ses <code>()</code>.</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. Itâ€™s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>Ã€ noter en outre que le corps de la fonction est placÃ© entre des accolades
<code>{}</code>. Rust en a besoin autour du corps de chaque fonction. C'est une
bonne pratique d'insÃ©rer l'accolade ouvrante sur la mÃªme ligne que la
dÃ©claration de la fonction, en ajoutant une espace entre les deux.</p>
<!--
At the time of this writing, an automatic formatter tool called `rustfmt` is
under development. If you want to stick to a standard style across Rust
projects, `rustfmt` will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
`rustc`. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.
-->
<p>Pendant que nous Ã©crivons ces lignes, un outil de formatage automatique de code
appelÃ© <code>rustfmt</code> est en cours de dÃ©veloppement.
Si vous voulez standardiser le style de votre code Rust dans vos projets,
<code>rustfmt</code> va formater votre code de maniÃ¨re bien dÃ©finie.
L'Ã©quipe Rust envisage d'intÃ©grer cet outil dans la distribution
standard de Rust, comme <code>rustc</code>. Donc, selon le moment oÃ¹ vous lirez ce livre,
il se peut qu'il soit dÃ©jÃ  installÃ© sur votre ordinateur ! Consultez la
documentation en ligne pour en savoir plus.</p>
<!--
Inside the `main` function is the following code:
-->
<p>Ã€ l'intÃ©rieur de la fonction <code>main</code>, nous avons le code suivantÂ :</p>
<!--
```rust
    println!("Hello, world!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here.
-->
<p>Cette ligne fait tout le travail dans ce petit programmeÂ : il Ã©crit le texte Ã 
l'Ã©cran. Il y a quatre dÃ©tails importants Ã  noter ici.</p>
<!--
First, Rust style is to indent with four spaces, not a tab.
-->
<p>PremiÃ¨rement, le style de Rust est d'indenter avec quatre espaces, et non pas
avec une tabulation.</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). Weâ€™ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a `!`
means that youâ€™re calling a macro instead of a normal function.
-->
<p>DeuxiÃ¨mement, <code>println!</code> fait appel Ã  une macro Rust. S'il appelait une
fonction Ã  la place, cela serait Ã©crit <code>println</code> (sans le <code>!</code>). Nous aborderons
les macros Rust plus en dÃ©tail dans le chapitre 19. Pour l'instant, vous avez
juste Ã  savoir qu'utiliser un <code>!</code> signifie que vous utilisez une macro plutÃ´t
qu'une fonction classique.</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>TroisiÃ¨mement, vous voyez la chaÃ®ne de caractÃ¨res <code>&quot;Hello, world!&quot;</code>. Nous
envoyons cette chaÃ®ne en argument Ã  <code>println!</code> et cette chaÃ®ne est affichÃ©e
Ã  l'Ã©cran.</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>QuatriÃ¨mement, nous terminons la ligne avec un point-virgule (<code>;</code>), qui indique
que cette expression est terminÃ©e et que la suivante est prÃªte Ã  commencer. La
plupart des lignes de Rust se terminent avec un point-virgule.</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3><a class="header" href="#la-compilation-et-lexÃ©cution-sont-des-Ã©tapes-sÃ©parÃ©es" id="la-compilation-et-lexÃ©cution-sont-des-Ã©tapes-sÃ©parÃ©es">La compilation et l'exÃ©cution sont des Ã©tapes sÃ©parÃ©es</a></h3>
<!--
Youâ€™ve just run a newly created program, so letâ€™s examine each step in the
process.
-->
<p>Vous venez de lancer un nouveau programme fraÃ®chement crÃ©Ã©, donc penchons-nous
sur chaque Ã©tape du processus.</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Avant de lancer un programme Rust, vous devez le compiler en utilisant le
compilateur Rust en entrant la commande <code>rustc</code> et en lui passant le nom de
votre fichier source, comme ceciÂ :</p>
<!--
```console
$ rustc main.rs
```
-->
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, youâ€™ll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>Si vous avez de l'expÃ©rience en C ou en C++, vous observerez des similaritÃ©s
avec <code>gcc</code> ou <code>clang</code>.
AprÃ¨s avoir compilÃ© avec succÃ¨s, Rust produit un binaire exÃ©cutable.</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell. On Linux and macOS, youâ€™ll see two
files. With PowerShell on Windows, youâ€™ll see the same three files that you
would see using CMD.
-->
<p>Avec Linux, macOS et PowerShell sous Windows, vous pouvez voir l'exÃ©cutable en
utilisant la commande <code>ls</code> dans votre terminal. Avec Linux et macOS,
vous devriez voir deux fichiers. Avec PowerShell sous Windows, vous devriez voir
les trois mÃªmes fichiers que vous verriez en utilisant CMD.</p>
<!--
```text
$ ls
main  main.rs
```
-->
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>Avec CMD sous Windows, vous devez saisir la commande suivanteÂ :</p>
<!--
```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```
-->
<pre><code class="language-cmd">&gt; dir /B %= l'option /B demande Ã  n'afficher que les noms de fichiers =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
Windows, a file containing debugging information with the *.pdb* extension.
From here, you run the *main* or *main.exe* file, like this:
-->
<p>Ceci affiche le fichier de code source avec l'extension <em>.rs</em>, le fichier
exÃ©cutable (<em>main.exe</em> sous Windows, mais <em>main</em> sur toutes les autres
plateformes) et, quand on utilise Windows, un fichier qui contient des
informations de dÃ©bogage avec l'extension <em>.pdb</em>. Dans ce dossier, vous pouvez
exÃ©cuter le fichier <em>main</em> ou <em>main.exe</em> comme ceciÂ :</p>
<!--
```console
$ ./main # or .\main.exe on Windows
```
-->
<pre><code class="language-console">$ ./main # ou .\main.exe sous Windows
</code></pre>
<!--
If *main.rs* was your â€œHello, world!â€ program, this line would print `Hello,
world!` to your terminal.
-->
<p>Si <em>main.rs</em> Ã©tait votre programme â€œHello, world!â€, cette ligne devrait afficher
<code>Hello, world!</code> dans votre terminal.</p>
<!--
If youâ€™re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>Si vous connaissez un langage dynamique, comme Ruby, Python, ou JavaScript, vous
n'avez peut-Ãªtre pas l'habitude de compiler puis lancer votre programme dans des
Ã©tapes sÃ©parÃ©es.
Rust est un langage Ã  <em>compilation anticipÃ©e</em>, ce qui veut dire que
vous pouvez compiler le programme et le donner Ã  quelqu'un d'autre, et il peut
l'exÃ©cuter sans avoir Rust d'installÃ©. Si vous donnez Ã  quelqu'un un fichier
<em>.rb</em>, <em>.py</em> ou <em>.js</em>, il a besoin d'avoir respectivement un interprÃ©teur Ruby,
Python, ou Javascript d'installÃ©. Cependant, avec ces langages, vous n'avez
besoin que d'une seule commande pour compiler et exÃ©cuter votre programme.
Dans la conception d'un langage, tout est une question de compromis.</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, youâ€™ll want to manage all the options and make it easy to share your
code. Next, weâ€™ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>Compiler avec <code>rustc</code> peut suffire pour de petits programmes, mais au fur et Ã 
mesure que votre programme grandit, vous allez avoir besoin de rÃ©gler plus
d'options et faciliter le partage de votre code. Ã€ la page suivante, nous allons
dÃ©couvrir l'outil Cargo, qui va vous aider Ã  Ã©crire des programmes Rust Ã 
l'Ã©preuve de la rÃ©alitÃ©.</p>
<!--
[troubleshooting]: ch01-01-installation.html#troubleshooting
-->
<!--
## Hello, Cargo!
-->
<h2><a class="header" href="#hello-cargo" id="hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rustâ€™s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call libraries your code needs *dependencies*.)
-->
<p>Cargo est le systÃ¨me de compilation et de gestion de paquets de Rust. La plupart
des RustacÃ©s utilisent cet outil pour gÃ©rer les projets Rust, car Cargo
s'occupe de nombreuses tÃ¢ches pour vous, comme compiler votre code, tÃ©lÃ©charger
les bibliothÃ¨ques dont votre code dÃ©pend, et compiler ces bibliothÃ¨ques. (On
appelle <em>dÃ©pendance</em> une bibliothÃ¨que nÃ©cessaire pour votre code.)</p>
<!--
The simplest Rust programs, like the one weâ€™ve written so far, donâ€™t have any
dependencies. So if we had built the â€œHello, world!â€ project with Cargo, it
would only use the part of Cargo that handles building your code. As you write
more complex Rust programs, youâ€™ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>Des programmes Rust trÃ¨s simples, comme le petit que nous avons Ã©crit prÃ©cÃ©demment,
n'ont pas de dÃ©pendance. Donc si nous avions compilÃ© le projet â€œHello, world!â€
avec Cargo, cela n'aurait fait appel qu'Ã  la fonctionnalitÃ© de Cargo qui
s'occupe de la compilation de votre code. Quand vous Ã©crirez des programmes Rust
plus complexes, vous ajouterez des dÃ©pendances, et si vous crÃ©ez un projet en
utilisant Cargo, l'ajout des dÃ©pendances sera plus facile Ã  faire.</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that youâ€™re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[â€œInstallationâ€][installation]<!-- ignore -- > section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Comme la large majoritÃ© des projets Rust utilisent Cargo, la suite de ce livre
va supposer que vous utilisez aussi Cargo. Cargo s'installe avec Rust si vous
avez utilisÃ© l'installateur officiel prÃ©sentÃ© dans la section
<a href="ch01-01-installation.html#installation">â€œInstallationâ€</a><!-- ignore -->. Si vous avez installÃ© Rust
autrement, vÃ©rifiez que Cargo est installÃ© en utilisant la commande suivante
dans votre terminalÂ :</p>
<!--
```console
$ cargo --version
```
-->
<pre><code class="language-console">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>Si vous voyez un numÃ©ro de version, c'est qu'il est installÃ©Â ! Si vous voyez une
erreur comme <code>Commande non trouvÃ©e</code> (ou <code>command not found</code>), alors consultez la
documentation de votre mÃ©thode d'installation pour savoir comment installer
sÃ©parÃ©ment Cargo.</p>
<!--
### Creating a Project with Cargo
-->
<h3><a class="header" href="#crÃ©er-un-projet-avec-cargo" id="crÃ©er-un-projet-avec-cargo">CrÃ©er un projet avec Cargo</a></h3>
<!--
Letâ€™s create a new project using Cargo and look at how it differs from our
original â€œHello, world!â€ project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>CrÃ©ons un nouveau projet en utilisant Cargo et analysons les diffÃ©rences avec
notre projet initial â€œHello, world!â€. Retournez dans votre dossier <em>projects</em>
(ou lÃ  oÃ¹ vous avez dÃ©cidÃ© d'enregistrer votre code). Ensuite, sur n'importe
quel systÃ¨me d'exploitation, lancez les commandes suivantesÂ :</p>
<!--
```console
$ cargo new hello_cargo
$ cd hello_cargo
```
-->
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command creates a new directory called *hello_cargo*. Weâ€™ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>La premiÃ¨re commande crÃ©e un nouveau dossier appelÃ© <em>hello_cargo</em>. Nous avons
appelÃ© notre projet <em>hello_cargo</em>, et Cargo crÃ©e ses fichiers dans un dossier
avec le mÃªme nom.</p>
<!--
Go into the *hello_cargo* directory and list the files. Youâ€™ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside.
-->
<p>Rendez-vous dans le dossier <em>hello_cargo</em> et afficher la liste des fichiers.
Vous constaterez que Cargo a gÃ©nÃ©rÃ© deux fichiers et un dossier pour nousÂ : un
fichier <em>Cargo.toml</em> et un dossier <em>src</em> avec un fichier <em>main.rs</em> Ã 
l'intÃ©rieur.</p>
<!--
It has also initialized a new Git repository along with a *.gitignore* file.
Git files wonâ€™t be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.
-->
<p>Il a aussi crÃ©Ã© un nouveau dÃ©pÃ´t Git ainsi qu'un fichier <em>.gitignore</em>. Les
fichiers de Git ne seront pas gÃ©nÃ©rÃ©s si vous lancez <code>cargo new</code> au sein d'un
dÃ©pÃ´t GitÂ ; vous pouvez dÃ©sactiver ce comportement temporairement en utilisant
<code>cargo new --vcs=git</code>.</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>NoteÂ : Git est un systÃ¨me de gestion de versions trÃ¨s rÃ©pandu. Vous pouvez
changer <code>cargo new</code> pour utiliser un autre systÃ¨me de gestion de versions
ou ne pas en utiliser du tout en Ã©crivant le drapeau <code>--vcs</code>.
Lancez <code>cargo new --help</code> pour en savoir plus sur les options disponibles.</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>Ouvrez <em>Cargo.toml</em> dans votre Ã©diteur de texte favori. Son contenu devrait
Ãªtre similaire au code dans l'encart 1-2.</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">Encart 1-2Â : Contenu de <em>Cargo.toml</em> gÃ©nÃ©rÃ© par <code>cargo new</code></span></p>
<!--
This file is in the [*TOML*](https://toml.io)<!-- ignore -- > (*Tomâ€™s Obvious,
Minimal Language*) format, which is Cargoâ€™s configuration format.
-->
<p>Ce fichier est au format <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tomâ€™s
Obvious, Minimal Language</em>), qui est le format de configuration de Cargo.</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, weâ€™ll add other sections.
-->
<p>La premiÃ¨re ligne, <code>[package]</code>, est un en-tÃªte de section qui indique que les
instructions suivantes configurent un paquet. Au fur et Ã  mesure que nous
ajouterons plus de dÃ©tails Ã  ce fichier, nous ajouterons des sections
supplÃ©mentaires.</p>
<!--
The next four lines set the configuration information Cargo needs to compile
your program: the name, the version, who wrote it, and the edition of Rust to
use. Cargo gets your name and email information from your environment, so if
that information is not correct, fix the information now and then save the
file. Weâ€™ll talk about the `edition` key in Appendix E.
-->
<p>Les quatre lignes suivantes dÃ©finissent les informations de configuration dont
Cargo a besoin pour compiler votre programmeÂ : le nom, la version, l'auteur et
l'Ã©dition de Rust Ã  utiliser. Cargo rÃ©cupÃ¨re votre nom et votre courriel Ã 
partir de votre environnement, donc si ces informations sont erronÃ©es, vous
pouvez les corriger dÃ¨s maintenant et ensuite enregistrer le fichier. Nous
aborderons la clÃ© <code>edition</code> dans l'annexe E.</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your projectâ€™s dependencies. In Rust, packages of code are referred to as
*crates*. We wonâ€™t need any other crates for this project, but we will in the
first project in Chapter 2, so weâ€™ll use this dependencies section then.
-->
<p>La derniÃ¨re ligne, <code>[dependencies]</code>, est le dÃ©but d'une section qui vous permet
de lister les dÃ©pendances de votre projet. Dans Rust, les paquets de code sont
dÃ©signÃ©s sous le nom de <em>crates</em>. Nous n'allons pas utiliser de <em>crate</em> pour ce
projet, mais nous le ferons pour le premier projet au chapitre 2Â ; nous
utiliserons alors cette section Ã  ce moment-lÃ .</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>Maintenant, ouvrez <em>src/main.rs</em> et jetez-y un coup d'Å“ilÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a â€œHello, world!â€ program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our previous project and
the project Cargo generates are that Cargo placed the code in the *src*
directory, and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargo a gÃ©nÃ©rÃ© un programme â€œHello, world!â€ pour vous, exactement comme celui
que nous avons Ã©crit dans l'encart 1-1Â ! Pour le moment, les seules diffÃ©rences
entre notre projet prÃ©cÃ©dent et le projet que Cargo a gÃ©nÃ©rÃ© sont que Cargo a
placÃ© le code dans le dossier <em>src</em>, et que nous avons un fichier de
configuration <em>Cargo.toml</em> Ã  la racine du dossier projet.</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. Thereâ€™s a place for everything, and
everything is in its place.
-->
<p>Cargo prÃ©voit de stocker vos fichiers sources dans le dossier <em>src</em>. Le dossier
parent est lÃ  uniquement pour les fichiers README, pour les informations Ã 
propos de la licence, pour les fichiers de configuration et tout ce qui n'est
pas directement reliÃ© Ã  votre code. Utiliser Cargo vous aide Ã  structurer vos
projets. Il y a un endroit pour tout, et tout est Ã  sa place.</p>
<!--
If you started a project that doesnâ€™t use Cargo, as we did with the â€œHello,
world!â€ project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>Si vous commencez un projet sans utiliser Cargo, comme nous l'avons fait avec
le projet â€œHello, world!â€, vous pouvez le transformer en projet qui
utilise Cargo. DÃ©placez le code de votre projet dans un dossier <em>src</em> et crÃ©ez
un fichier <em>Cargo.toml</em> adÃ©quat.</p>
<!--
### Building and Running a Cargo Project
-->
<h3><a class="header" href="#compiler-et-exÃ©cuter-un-projet-cargo" id="compiler-et-exÃ©cuter-un-projet-cargo">Compiler et exÃ©cuter un projet Cargo</a></h3>
<!--
Now letâ€™s look at whatâ€™s different when we build and run the â€œHello, world!â€
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>Maintenant, regardons ce qu'il y a de diffÃ©rent quand nous compilons et
exÃ©cutons le programme â€œHello, world!â€ avec CargoÂ ! Ã€ l'intÃ©rieur de votre
dossier <em>hello_cargo</em>, compilez votre projet en utilisant la commande suivanteÂ :</p>
<!--
```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```
-->
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>Cette commande crÃ©e un fichier exÃ©cutable dans <em>target/debug/hello_cargo</em> (ou
<em>target\debug\hello_cargo.exe</em> sous Windows) plutÃ´t que de le dÃ©poser dans votre
dossier courant. Vous pouvez lancer l'exÃ©cutable avec cette commandeÂ :</p>
<!--
```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
<pre><code class="language-console">$ ./target/debug/hello_cargo # ou .\target\debug\hello_cargo.exe sous Windows
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesnâ€™t have dependencies, so the
file is a bit sparse. You wonâ€™t ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>Si tout s'est bien passÃ©, <code>Hello, world!</code> devrait s'afficher dans le terminal.
Lancer <code>cargo build</code> pour la premiÃ¨re fois devrait aussi mener Cargo Ã  crÃ©er
un nouveau fichier Ã  la racine du dossier projetÂ : <em>Cargo.lock</em>. Ce fichier
garde une trace des versions exactes des dÃ©pendances de votre
projet. Ce projet n'a pas de dÃ©pendance, donc le fichier est un peu vide. Vous
n'aurez jamais besoin de changer ce fichier manuellementÂ ; Cargo va gÃ©rer son
contenu pour vous.</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>Nous venons de compiler un projet avec <code>cargo build</code> avant de l'exÃ©cuter avec
<code>./target/debug/hello_cargo</code>, mais nous pouvons aussi utiliser <code>cargo run</code> pour
compiler le code et ensuite lancer l'exÃ©cutable dans une seule et mÃªme
commandeÂ :</p>
<!--
```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didnâ€™t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadnâ€™t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>Notez que cette fois-ci, nous ne voyons pas de messages indiquant que Cargo a
compilÃ© <code>hello_cargo</code>. Cargo a dÃ©tectÃ© que les fichiers n'avaient pas changÃ©,
donc il a juste exÃ©cutÃ© le binaire. Si vous aviez modifiÃ© votre code source,
Cargo aurait recompilÃ© le projet avant de le lancer, et vous auriez eu les
messages suivantsÂ :</p>
<!--
```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesnâ€™t produce an executable:
-->
<p>Cargo fournit aussi une commande appelÃ©e <code>cargo check</code>. Elle vÃ©rifie rapidement
votre code pour s'assurer qu'il est compilable, mais ne produit pas
d'exÃ©cutableÂ :</p>
<!--
```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```
-->
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If youâ€™re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when theyâ€™re ready to use the executable.
-->
<p>Dans quel cas n'aurions-nous pas besoin d'un exÃ©cutable ? Parfois, <code>cargo check</code>
est bien plus rapide que <code>cargo build</code>, car il saute l'Ã©tape de crÃ©ation de
l'exÃ©cutable. Si vous vÃ©rifiez votre travail continuellement pendant que vous
Ã©crivez votre code, utiliser <code>cargo check</code> accÃ©lÃ¨rera le processusÂ ! C'est
pourquoi de nombreux RustacÃ©s utilisent pÃ©riodiquement <code>cargo check</code> quand ils
Ã©crivent leur programme afin de s'assurer qu'il compile. Ensuite, ils lancent
<code>cargo build</code> quand ils sont prÃªts Ã  utiliser l'exÃ©cutable.</p>
<!--
Letâ€™s recap what weâ€™ve learned so far about Cargo:
-->
<p>RÃ©capitulons ce que nous avons appris sur CargoÂ :</p>
<!-- markdownlint-disable -->
<!--
* We can build a project using `cargo build`.
* We can build and run a project in one step using `cargo run`.
* We can build a project without producing a binary to check for errors using `cargo check`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<!-- markdownlint-restore -->
<ul>
<li>Nous pouvons compiler un projet en utilisant <code>cargo build</code>.</li>
<li>Nous pouvons compiler puis exÃ©cuter un projet en une seule fois en utilisant
<code>cargo run</code>.</li>
<li>Nous pouvons compiler un projet sans produire de binaire afin de vÃ©rifier
l'existance d'erreurs en utilisant <code>cargo check</code>.</li>
<li>Au lieu d'enregistrer le rÃ©sultat de la compilation dans le mÃªme dossier que
votre code, Cargo l'enregistre dans le dossier <em>target/debug</em>.</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system youâ€™re working on. So, at this point, weâ€™ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Un autre avantage d'utiliser Cargo est que les commandes sont les mÃªmes peu
importe le systÃ¨me d'exploitation que vous utilisez.
Donc Ã  partir de maintenant, nous n'allons plus faire d'opÃ©rations spÃ©cifiques
Ã  Linux et macOS par rapport Ã  Windows.</p>
<!--
### Building for Release
-->
<h3><a class="header" href="#compiler-pour-diffuser" id="compiler-pour-diffuser">Compiler pour diffuser</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program youâ€™ll give to a user that wonâ€™t be rebuilt
repeatedly and that will run as fast as possible. If youâ€™re benchmarking your
codeâ€™s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>Quand votre projet est finalement prÃªt Ã  Ãªtre diffusÃ©, vous pouvez utiliser
<code>cargo build --release</code> pour le compiler en l'optimisant. Cette commande va
crÃ©er un exÃ©cutable dans <em>target/release</em> au lieu de <em>target/debug</em>. Ces
optimisations rendent votre code Rust plus rapide Ã  exÃ©cuter, mais l'utiliser
rallonge le temps de compilation de votre programme. C'est pourquoi il y a deux
diffÃ©rents profilsÂ : un pour le dÃ©veloppement, quand vous voulez recompiler
rapidement et souvent, et un autre pour compiler le programme final qui sera
livrÃ© Ã  un utilisateur, qui n'aura pas besoin d'Ãªtre recompilÃ© Ã  plusieurs
reprises et qui s'exÃ©cutera aussi vite que possible. Si vous Ã©valuez le temps
d'exÃ©cution de votre code, assurez-vous de lancer <code>cargo build --release</code> et
d'utiliser l'exÃ©cutable dans <em>target/release</em> pour vos bancs de test.</p>
<!--
### Cargo as Convention
-->
<h3><a class="header" href="#cargo-comme-convention" id="cargo-comme-convention">Cargo comme convention</a></h3>
<!--
With simple projects, Cargo doesnâ€™t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, itâ€™s much easier to let
Cargo coordinate the build.
-->
<p>Pour des projets simples, Cargo n'apporte pas grand-chose par rapport Ã  <code>rustc</code>,
mais il vous montrera son intÃ©rÃªt au fur et Ã  mesure
que vos programmes deviendront plus complexes. Avec des projets complexes
composÃ©s de plusieurs <em>crates</em>, il est plus facile de laisser Cargo prendre en
charge la coordination de la compilation.</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling youâ€™ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that projectâ€™s directory, and build:
-->
<p>MÃªme si le projet <code>hello_cargo</code> est simple, il utilise maintenant une grande
partie de l'outillage que vous rencontrerez dans votre carriÃ¨re avec Rust. En
effet, pour travailler sur n'importe quel projet Rust existant, vous n'avez
qu'Ã  saisir les commandes suivantes pour tÃ©lÃ©charger le code avec Git, vous
dÃ©placer dans le dossier projet et compilerÂ :</p>
<!--
```console
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```
-->
<pre><code class="language-console">$ git clone example.com/projet_quelconque
$ cd projet_quelconque
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].
-->
<p>Pour plus d'informations Ã  propos de Cargo, vous pouvez consulter <a href="https://doc.rust-lang.org/cargo/">sa
documentation</a>.</p>
<!--
[its documentation]: https://doc.rust-lang.org/cargo/
-->
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©" id="rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
Youâ€™re already off to a great start on your Rust journey! In this chapter,
youâ€™ve learned how to:
-->
<p>Vous Ãªtes dÃ©jÃ  bien lancÃ© dans votre pÃ©riple avec Rust ! Dans ce chapitre, vous
avez appris commentÂ :</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a â€œHello, world!â€ program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li>Installer la derniÃ¨re version stable de Rust en utilisant <code>rustup</code></li>
<li>Mettre Ã  jour Rust vers une nouvelle version</li>
<li>Ouvrir la documentation installÃ©e en local</li>
<li>Ã‰crire et exÃ©cuter un programme â€œHello, world!â€ en utilisant directement
<code>rustc</code></li>
<li>CrÃ©er et exÃ©cuter un nouveau projet en utilisant les conventions de Cargo</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, weâ€™ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>C'est le moment idÃ©al pour construire un programme plus ambitieux pour
s'habituer Ã  lire et Ã©crire du code Rust. Donc, au chapitre 2, nous allons
Ã©crire un programme de <em>jeu de devinettes</em>.
Si vous prÃ©fÃ©rez commencer par apprendre comment les principes de programmation
de base fonctionnent avec Rust, rendez-vous au chapitre 3, puis revenez au
chapitre 2.</p>
<!--
[installation]: ch01-01-installation.html#installation
-->
<!--
# Programming a Guessing Game
-->
<h1><a class="header" href="#programmer-le-jeu-du-plus-ou-du-moins" id="programmer-le-jeu-du-plus-ou-du-moins">Programmer le jeu du plus ou du moins</a></h1>
<!--
Letâ€™s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. Youâ€™ll learn about `let`, `match`, methods, associated
functions, using external crates, and more! The following chapters will explore
these ideas in more detail. In this chapter, youâ€™ll practice the fundamentals.
-->
<p>Entrons dans le vif du sujet en travaillant ensemble sur un projet concretÂ !
Ce chapitre prÃ©sente quelques concepts couramment utilisÃ©s en Rust en vous
montrant comment les utiliser dans un vÃ©ritable programme. Nous aborderons
notamment les instructions <code>let</code> et <code>match</code>, les mÃ©thodes et fonctions
associÃ©es, l'utilisation des <em>crates</em>, et bien plus encoreÂ ! Dans les chapitres
suivants, nous approfondirons ces notions. Dans ce chapitre, vous n'allez
exercer que les principes de base.</p>
<!--
Weâ€™ll implement a classic beginner programming problem: a guessing game. Hereâ€™s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>Nous allons coder un programme frÃ©quemment rÃ©alisÃ© par les dÃ©butants en
programmationÂ : <em>le jeu du plus ou du moins</em>. Le principe de ce jeu est le
suivantÂ : le programme va tirer au sort un nombre entre 1 et 100. Il invitera
ensuite le joueur Ã  saisir un nombre qu'il pense deviner. AprÃ¨s la saisie, le
programme indiquera si le nombre saisi par le joueur est trop grand ou trop
petit. Si le nombre saisi est le bon, le jeu affichera un message de
fÃ©licitations et se fermera.</p>
<!--
## Setting Up a New Project
-->
<h2><a class="header" href="#mise-en-place-dun-nouveau-projet" id="mise-en-place-dun-nouveau-projet">Mise en place d'un nouveau projet</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>Pour crÃ©er un nouveau projet, rendez-vous dans le dossier <em>projects</em> que
vous avez crÃ©Ã© au chapitre 1 et utilisez Cargo pour crÃ©er votre projet, comme
ceciÂ :</p>
<!--
```console
$ cargo new guessing_game
$ cd guessing_game
```
-->
<pre><code class="language-console">$ cargo new jeu_du_plus_ou_du_moins
$ cd jeu_du_plus_ou_du_moins
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The second command changes to the new projectâ€™s
directory.
-->
<p>La premiÃ¨re commande, <code>cargo new</code>, prend comme premier argument le nom de notre
projet (<code>jeu_du_plus_ou_du_moins</code>). La seconde commande nous dÃ©place dans le
dossier de notre nouveau projet crÃ©Ã© par Cargo.</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>Regardons le fichier <em>Cargo.toml</em> qui a Ã©tÃ© gÃ©nÃ©rÃ©Â :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Votre nom &lt;adresse@exemple.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<!--
If the author information that Cargo obtained from your environment is not
correct, fix that in the file and save it again.
-->
<p>Si le nom de l'auteur que Cargo a dÃ©duit de votre environnement est incorrect,
vous pouvez le changer dans ce fichier et le sauvegarder.</p>
<!--
As you saw in Chapter 1, `cargo new` generates a â€œHello, world!â€ program for
you. Check out the *src/main.rs* file:
-->
<p>Comme vous l'avez expÃ©rimentÃ© dans le chapitre 1, <code>cargo new</code> gÃ©nÃ¨re un
programme <em>â€œHello, world!â€</em> pour vous. Ouvrez le fichier <em>src/main.rs</em>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now letâ€™s compile this â€œHello, world!â€ program and run it in the same step
using the `cargo run` command:
-->
<p>Maintenant, lanÃ§ons la compilation de ce programme â€œHello, world!â€ et
son exÃ©cution en une seule commande avec <code>cargo run</code>Â :</p>
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as weâ€™ll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p>Cette commande <code>run</code> est trÃ¨s pratique lorsqu'on souhaite itÃ©rer rapidement
sur un projet, comme c'est le cas ici, pour tester rapidement chaque
modification avant de passer Ã  la suivante.</p>
<!--
Reopen the *src/main.rs* file. Youâ€™ll be writing all the code in this file.
-->
<p>Ouvrez Ã  nouveau le fichier <em>src/main.rs</em>. C'est dans ce fichier que nous
Ã©crirons la totalitÃ© de notre code.</p>
<!--
## Processing a Guess
-->
<h2><a class="header" href="#traitement-dun-nombre-saisi" id="traitement-dun-nombre-saisi">Traitement d'un nombre saisi</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, weâ€™ll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*.
-->
<p>La premiÃ¨re partie du programme consiste Ã  demander au joueur de saisir du
texte, Ã  traiter cette saisie, et Ã  vÃ©rifier que la saisie correspond au format
attendu.
CommenÃ§ons par permettre au joueur de saisir son nombre. Entrez le
code de l'encart 2-1 dans le fichier <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Devinez le nombreÂ !&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);

    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span>
-->
<p><span class="caption">Encart 2-1Â : Code permettant de rÃ©cupÃ©rer une saisie
utilisateur et de l'afficher</span></p>
<!--
This code contains a lot of information, so letâ€™s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` (input/output) library into scope. The `io` library comes from the
standard library (which is known as `std`):
-->
<p>Ce code contient beaucoup d'informations, nous allons donc l'analyser petit
Ã  petit. Pour obtenir la saisie utilisateur et ensuite l'afficher, nous avons
besoin d'importer la bibliothÃ¨que <code>io</code> (pour <em>input/output</em>, entrÃ©e/sortie) afin
de pouvoir l'utiliser. La bibliothÃ¨que <code>io</code> provient de la bibliothÃ¨que standard
(qui est aussi connue sous le nom de <code>std</code>).</p>
<!--
```rust,ignore
use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
By default, Rust brings only a few types into the scope of every program in
[the *prelude*][prelude]<!-- ignore -- >. If a type you want to use isnâ€™t in the
prelude, you have to bring that type into scope explicitly with a `use`
statement. Using the `std::io` library provides you with a number of useful
features, including the ability to accept user input.
-->
<p>Par dÃ©faut, Rust n'importe que trÃ¨s peu de types dans les programmes, qui sont
prÃ©sents dans <a href="https://doc.rust-lang.org/std/prelude/index.html"><em>l'Ã©tape prÃ©liminaire (the prelude)</em></a><!-- ignore -->. Si
vous voulez utiliser un type qui ne s'y trouve pas, vous devrez l'importer
explicitement avec l'instruction <code>use</code>. L'utilisation de la bibliothÃ¨que
<code>std::io</code> vous apporte de nombreuses fonctionnalitÃ©s utiles, comme ici la
possibilitÃ© de rÃ©cupÃ©rer une saisie utilisateur.</p>
<!--
[prelude]: ../std/prelude/index.html
-->
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>Comme vous l'avez vu au chapitre 1, la fonction <code>main</code> est le point d'entrÃ©e
du programmeÂ :</p>
<!--
```rust,ignore
# use std::io;
# 
fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`, indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p>Le mot clÃ© <code>fn</code> dÃ©clare une nouvelle fonction, les parenthÃ¨ses <code>()</code> indiquent
que cette fonction n'accepte aucun paramÃ¨tre, et l'accolade ouvrante <code>{</code> marque
le dÃ©but du corps de la fonction.</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>Comme vous l'avez Ã©galement appris au chapitre 1, <code>println!</code> est une macro qui
affiche une chaÃ®ne de caractÃ¨res Ã  l'Ã©cranÂ :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Devinez le nombreÂ !&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);
<span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
This code is printing a prompt stating what the game is and requesting input
from the user.
-->
<p>Ce code affiche du texte qui indique le titre de notre jeu, et un autre qui
demande au joueur d'entrer un nombre.</p>
<!--
### Storing Values with Variables
-->
<h3><a class="header" href="#enregistrer-des-donnÃ©es-dans-des-variables" id="enregistrer-des-donnÃ©es-dans-des-variables">Enregistrer des donnÃ©es dans des variables</a></h3>
<!--
Next, weâ€™ll create a place to store the user input, like this:
-->
<p>Ensuite, on crÃ©e un endroit oÃ¹ stocker la saisie de l'utilisateur, comme ceciÂ :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
    let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span>    let mut supposition = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
Now the program is getting interesting! Thereâ€™s a lot going on in this little
line. Notice that this is a `let` statement, which is used to create a
*variable*. Hereâ€™s another example:
-->
<p>Le programme commence Ã  devenir intÃ©ressantÂ ! Il se passe beaucoup de choses
dans cette petite ligne. Vous remarquerez qu'elle commence par le mot-clÃ© <code>let</code>,
qui sert Ã  crÃ©er une <em>variable</em>. Voici un autre exempleÂ :</p>
<!--
```rust,ignore
let foo = bar;
```
-->
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<!--
This line creates a new variable named `foo` and binds it to the value of the
`bar` variable. In Rust, variables are immutable by default. Weâ€™ll be
discussing this concept in detail in the [â€œVariables and
Mutabilityâ€][variables-and-mutability]<!-- ignore -- > section in Chapter 3.
The following example shows how to use `mut` before the variable name to make
a variable mutable:
-->
<p>Cette ligne permet de crÃ©er une nouvelle variable nommÃ©e <code>foo</code> et Ã  lui
assigner la valeur de <code>bar</code>. Par dÃ©faut en Rust, les variables sont immuables.
Nous aborderons plus en dÃ©tail cette notion dans la section <a href="ch03-01-variables-and-mutability.html">â€œVariables et
MutabilitÃ©â€</a><!-- ignore --> au chapitre 3. L'exemple
suivant montre comment utiliser le mot-clÃ© <code>mut</code> avant le nom de la variable
pour rendre une variable mutable <em>(c'est-Ã -dire modifiable)</em>Â :</p>
<!--
```rust,ignore
let foo = 5; // immutable
let mut bar = 5; // mutable
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = 5; // immuable
let mut bar = 5; // mutable, modifiable
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments, which are discussed in more detail
> in Chapter 3.
-->
<blockquote>
<p>RemarqueÂ : La syntaxe <code>//</code> permet de commencer un commentaire qui s'Ã©tend
jusqu'Ã  la fin de la ligne. Rust ignore tout ce qu'il y a dans un commentaire,
ceci sera dÃ©veloppÃ© plus en dÃ©tail dans le chapitre 3.</p>
</blockquote>
<!--
Letâ€™s return to the guessing game program. You now know that `let mut guess`
will introduce a mutable variable named `guess`. On the other side of the equal
sign (`=`) is the value that `guess` is bound to, which is the result of
calling `String::new`, a function that returns a new instance of a `String`.
[`String`][string]<!-- ignore -- > is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>Mais revenons Ã  notre jeu du plus ou du moins. Vous comprenez donc maintenant
que la ligne <code>let mut supposition</code> permet de crÃ©er une variable mutable nommÃ©e
<code>supposition</code>. De l'autre cÃ´tÃ© du signe Ã©gal (<code>=</code>) se trouve la valeur de cette
variable, et il s'agit ici du rÃ©sultat de l'utilisation de <code>String::new</code>, qui
est une fonction qui retourne une nouvelle instance de <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> est un type de chaÃ®ne de caractÃ¨res fourni
par la bibliothÃ¨que standard, qui est une portion de texte encodÃ©e en UTF-8 et
dont la longueur peut augmenter.</p>
<!--
[string]: ../std/string/struct.String.html
-->
<!--
The `::` syntax in the `::new` line indicates that `new` is an *associated
function* of the `String` type. An associated function is implemented on a type,
in this case `String`, rather than on a particular instance of a `String`. Some
languages call this a *static method*.
-->
<p>La syntaxe <code>::</code> dans <code>String::new()</code> indique que <code>new</code> est une
<em>fonction associÃ©e</em> au type <code>String</code>. Une fonction associÃ©e est implÃ©mentÃ©e sur
un type, ici <code>String</code>, plutÃ´t que sur une instance de <code>String</code>. Ce concept est
parfois appelÃ© une <em>mÃ©thode statique</em> dans d'autres langages.</p>
<!--
This `new` function creates a new, empty string. Youâ€™ll find a `new` function
on many types, because itâ€™s a common name for a function that makes a new value
of some kind.
-->
<p>Cette fonction <code>new</code> crÃ©e une nouvelle chaÃ®ne de caractÃ¨res vide, une nouvelle
<code>String</code>. Vous trouverez frÃ©quemment une fonction <code>new</code> sur d'autres types, car
c'est un nom souvent donnÃ© Ã  une fonction qui crÃ©e une nouvelle valeur ou
instance d'un type.</p>
<!--
To summarize, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>Pour rÃ©sumer, la ligne <code>let mut supposition = String::new();</code> crÃ©e une nouvelle
variable mutable qui contient une nouvelle chaÃ®ne de caractÃ¨res vide, une
instance de <code>String</code>. OufÂ !</p>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now weâ€™ll call
the `stdin` function from the `io` module:
-->
<p>Rappelez-vous que nous avons importÃ© les fonctionnalitÃ©s d'entrÃ©e/sortie de la
bibliothÃ¨que standard avec <code>use std::io;</code> Ã  la premiÃ¨re ligne de notre
programme. Nous allons maintenant appeler la fonction <code>stdin</code> du
module <code>io</code>Â :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
    io::stdin()
        .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut supposition)
<span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
If we hadnâ€™t put the `use std::io` line at the beginning of the program, we
could have written this function call as `std::io::stdin`. The `stdin` function
returns an instance of [`std::io::Stdin`][iostdin]<!-- ignore -- >, which is a
type that represents a handle to the standard input for your terminal.
-->
<p>Si la ligne <code>use std::io</code> n'Ã©tait pas prÃ©sente au dÃ©but du programme, on aurait
dÃ» Ã©crire l'appel Ã  la fonction de cette maniÃ¨reÂ : <code>std::io::stdin</code>. La fonction
<code>stdin</code> retourne une instance de <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, qui
est un type qui reprÃ©sente une rÃ©fÃ©rence abstraite <em>(handle)</em> vers l'entrÃ©e
standard du terminal dans lequel vous avez lancÃ© le programme.</p>
<!--
[iostdin]: ../std/io/struct.Stdin.html
-->
<!--
The next part of the code, `.read_line(&mut guess)`, calls the
[`read_line`][read_line]<!-- ignore -- > method on the standard input handle to
get input from the user. Weâ€™re also passing one argument to `read_line`: `&mut
guess`.
-->
<p>La partie suivante du code, <code>.read_line(&amp;mut supposition)</code>, appelle la mÃ©thode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> sur l'entrÃ©e standard afin d'obtenir
la saisie utilisateur. De plus, on passe Ã  cette mÃ©thode l'argument
<code>&amp;mut supposition</code>.</p>
<!--
[read_line]: ../std/io/struct.Stdin.html#method.read_line
-->
<!--
The job of `read_line` is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so the method can change the stringâ€™s
content by adding the user input.
-->
<p>Le rÃ´le de <code>read_line</code> est de rÃ©cupÃ©rer tout ce que l'utilisateur Ã©crit dans
l'entrÃ©e standard et de le stocker dans une chaÃ®ne de caractÃ¨resÂ ; c'est
pourquoi cette mÃ©thode prend une <code>String</code> comme argument. Cet argument doit Ãªtre
mutable pour que <code>read_line</code> puisse en modifier le contenu en y ajoutant
la saisie de l'utilisateur.</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rustâ€™s major advantages is how safe and easy it is to use
references. You donâ€™t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p>Le <code>&amp;</code> indique que cet argument est une <em>rÃ©fÃ©rence</em>, ce qui permet de laisser
plusieurs morceaux de votre code accÃ©der Ã  une mÃªme donnÃ©e sans avoir besoin
de copier ces donnÃ©es dans la mÃ©moire plusieurs fois. Les rÃ©fÃ©rences sont une
fonctionnalitÃ© complexe, et un des avantages majeurs de Rust est qu'il rend sÃ»r
et simple l'utilisation des rÃ©fÃ©rences. Il n'est pas nÃ©cessaire de trop
s'apesantir sur les rÃ©fÃ©rences pour terminer ce programme.
Pour l'instant, tout ce que vous devez savoir est que comme les variables, les
rÃ©fÃ©rences sont immuables par dÃ©faut.
D'oÃ¹ la nÃ©cessitÃ© d'Ã©crire <code>&amp;mut supposition</code> au lieu de <code>&amp;supposition</code> pour la
rendre mutable. (Le chapitre 4 expliquera plus en dÃ©tail les rÃ©fÃ©rences.)</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3><a class="header" href="#gÃ©rer-les-erreurs-potentielles-avec-le-type-result" id="gÃ©rer-les-erreurs-potentielles-avec-le-type-result">GÃ©rer les erreurs potentielles avec le type <code>Result</code></a></h3>
<!--
Weâ€™re still working on this line of code. Although weâ€™re now discussing a third
line of text, itâ€™s still part of a single logical line of code. The next part
is this method:
-->
<p>Nous avons encore du travail sur cette ligne de code. MÃªme si nous allons
rajouter une troisiÃ¨me ligne de code, elle ne fait partie que d'une seule ligne
de code. Cette nouvelle partie rajoute cette mÃ©thodeÂ :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
        .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span>        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
When you call a method with the `.foo()` syntax, itâ€™s often wise to introduce a
newline and other whitespace to help break up long lines. We could have
written this code as:
-->
<p>Lorsque l'on appelle une mÃ©thode avec la syntaxe <code>.foo()</code>, il est gÃ©nÃ©ralement
prÃ©fÃ©rable d'ajouter un retour Ã  la ligne puis d'indenter Ã  l'aide d'espaces
pour dÃ©composer les longues lignes de code.
Nous aurions pu Ã©crire ce code de cette maniÃ¨reÂ :</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition).expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so itâ€™s best to divide it. Now
letâ€™s discuss what this line does.
-->
<p>Cependant, une longue ligne de code n'est pas toujours facile Ã  lire, c'est donc
une bonne pratique de la diviser. Maintenant, voyons Ã  quoi sert cette ligne.</p>
<!--
As mentioned earlier, `read_line` puts what the user types into the string
weâ€™re passing it, but it also returns a valueâ€”in this case, an
[`io::Result`][ioresult]<!-- ignore -- >. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result]<!-- ignore -- >
as well as specific versions for submodules, such as `io::Result`.
-->
<p>Comme expliquÃ© prÃ©cÃ©demment, <code>read_line</code> stocke ce que l'utilisateur a saisi
dans la variable qu'on lui passe en argument, mais cette fonction retourne
aussi une valeur âˆ’ dans notre cas, de type
<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Il existe plusieurs types nommÃ©s
<code>Result</code> dans la bibliothÃ¨que standard de RustÂ : un type gÃ©nÃ©rique
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> ainsi que des dÃ©clinaisons spÃ©cifiques Ã 
des sous-modules, comme <code>io::Result</code>.</p>
<!--
[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html
-->
<!--
The `Result` types are [*enumerations*][enums]<!-- ignore -- >, often referred
to as *enums*. An enumeration is a type that can have a fixed set of values,
and those values are called the enumâ€™s *variants*. Chapter 6 will cover enums
in more detail.
-->
<p>Les types <code>Result</code> sont des <a href="ch06-00-enums.html"><em>Ã©numÃ©rations</em></a><!-- ignore -->, aussi
appelÃ©es <em>enums</em>. Une Ã©numÃ©ration est un type qui peut avoir un certain nombre
de valeurs prÃ©dÃ©finies, et ces valeurs sont appelÃ©es des <em>variantes</em>
d'Ã©numÃ©ration. Le chapitre 6 explorera les Ã©numÃ©rations plus en dÃ©tail.</p>
<!--
[enums]: ch06-00-enums.html
-->
<!--
For `Result`, the variants are `Ok` or `Err`. The `Ok` variant indicates the
operation was successful, and inside `Ok` is the successfully generated value.
The `Err` variant means the operation failed, and `Err` contains information
about how or why the operation failed.
-->
<p>Avec <code>Result</code>, les variantes sont <code>Ok</code> ou <code>Err</code>. La variante <code>Ok</code> signifie que
l'opÃ©ration a fonctionnÃ©, et Ã  l'intÃ©rieur de <code>Ok</code> se trouve la valeur gÃ©nÃ©rÃ©e
avec succÃ¨s. La variante <code>Err</code> signifie que l'opÃ©ration a Ã©chouÃ©, et <code>Err</code>
contient les informations dÃ©crivant comment ou pourquoi l'opÃ©ration a Ã©chouÃ©.</p>
<!--
The purpose of these `Result` types is to encode error-handling information.
Values of the `Result` type, like values of any type, have methods defined on
them. An instance of `io::Result` has an [`expect` method][expect]<!-- ignore
-- > that you can call. If this instance of `io::Result` is an `Err` value,
`expect` will cause the program to crash and display the message that you
passed as an argument to `expect`. If the `read_line` method returns an `Err`,
it would likely be the result of an error coming from the underlying operating
system. If this instance of `io::Result` is an `Ok` value, `expect` will take
the return value that `Ok` is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in what the user
entered into standard input.
-->
<p>L'objectif de ces types <code>Result</code> est d'encoder des informations utiles Ã  la
gestion des erreurs.
Les valeurs du type <code>Result</code>, comme pour tous les types, ont des mÃ©thodes
qui leur sont associÃ©es. Par exemple, une instance de <code>io::Result</code> a une
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">mÃ©thode <code>expect</code></a><!-- ignore --> que vous pouvez utiliser. Si cette
instance de <code>io::Result</code> a pour valeur la variante <code>Err</code>, l'appel Ã  <code>expect</code>
fera planter le programme et affichera le message que vous avez passÃ© en
argument de <code>expect</code>. Si l'appel Ã  <code>read_line</code> retourne une variante <code>Err</code>, ce
sera probablement dÃ» Ã  une erreur du systÃ¨me d'exploitation. Si en revanche
<code>read_line</code> a pour valeur la variante <code>Ok</code>, <code>expect</code> rÃ©cupÃ¨rera le
contenu du <code>Ok</code>, qui est le rÃ©sultat de l'opÃ©ration, et vous le retournera afin
que vous puissiez l'utiliser. Dans notre exemple, ce rÃ©sultat est le nombre
d'octets que l'utilisateur a saisi dans l'entrÃ©e standard.</p>
<!--
[expect]: ../std/result/enum.Result.html#method.expect
-->
<!--
If you donâ€™t call `expect`, the program will compile, but youâ€™ll get a warning:
-->
<p>Si on n'appelle pas <code>expect</code>, le programme compilera, mais avec un
avertissementÂ :</p>
<!--
```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` that must be used
  -- > src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut supposition);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
Rust warns that you havenâ€™t used the `Result` value returned from `read_line`,
indicating that the program hasnâ€™t handled a possible error.
-->
<p>Rust nous prÃ©vient que l'on ne fait rien du <code>Result</code> que nous fournit
<code>read_line</code>, et que par consÃ©quent notre programme ne gÃ¨re pas une erreur
potentielle.</p>
<!--
The right way to suppress the warning is to actually write error handling, but
because you just want to crash this program when a problem occurs, you can use
`expect`. Youâ€™ll learn about recovering from errors in Chapter 9.
-->
<p>La meilleure faÃ§on de masquer cet avertissement est de rÃ©ellement Ã©crire le
code permettant de gÃ©rer l'erreur, mais dans notre cas on a seulement besoin de
faire planter le programme si un problÃ¨me survient, on utilise donc <code>expect</code>.
Nous verrons dans le chapitre 9 comment gÃ©rer correctement les erreurs.</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3><a class="header" href="#afficher-des-valeurs-grÃ¢ce-aux-espaces-rÃ©servÃ©s-de-println" id="afficher-des-valeurs-grÃ¢ce-aux-espaces-rÃ©servÃ©s-de-println">Afficher des valeurs grÃ¢ce aux espaces rÃ©servÃ©s de <code>println!</code></a></h3>
<!--
Aside from the closing curly bracket, thereâ€™s only one more line to discuss in
the code added so far, which is the following:
-->
<p>Mis Ã  part l'accolade fermante, il ne nous reste plus qu'une seule ligne Ã 
Ã©tudier dans le code que nous avons pour l'instantÂ :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
    println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span>    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
<span class="boring">}
</span></code></pre>
<!--
This line prints the string we saved the userâ€™s input in. The set of curly
brackets, `{}`, is a placeholder: think of `{}` as little crab pincers that
hold a value in place. You can print more than one value using curly brackets:
the first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>Cette ligne affiche la chaÃ®ne de caractÃ¨res oÃ¹ est stockÃ© ce que l'utilisateur
a saisi. La paire d'accolades <code>{}</code> reprÃ©sente un espace rÃ©servÃ©Â : imaginez
qu'il s'agit de pinces de crabes qui gardent la place d'une valeur. Vous pouvez
afficher plusieurs valeurs en utilisant des accoladesÂ : la premiÃ¨re paire
d'accolades affichera la premiÃ¨re valeur listÃ©e aprÃ¨s la chaÃ®ne de formatage,
la deuxiÃ¨me paire d'accolades affichera la deuxiÃ¨me valeur, et ainsi de suite.
Pour afficher plusieurs valeurs en appelant <code>println!</code> une seule fois, on ferait
comme ceciÂ :</p>
<!--
```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} et y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>Ce code afficherait <code>x = 5 et y = 10</code>.</p>
<!--
### Testing the First Part
-->
<h3><a class="header" href="#test-de-la-premiÃ¨re-partie" id="test-de-la-premiÃ¨re-partie">Test de la premiÃ¨re partie</a></h3>
<!--
Letâ€™s test the first part of the guessing game. Run it using `cargo run`:
-->
<p>Pour tester notre dÃ©but de programme, lanÃ§ons-le Ã  l'aide de la commande
<code>cargo run</code>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombreÂ !
Veuillez entrer un nombre.
6
Votre nombreÂ : 6
</code></pre>
<!--
At this point, the first part of the game is done: weâ€™re getting input from the
keyboard and then printing it.
-->
<p>Ã€ ce stade, la premiÃ¨re partie de notre programme est terminÃ©eÂ : nous avons
rÃ©cupÃ©rÃ© la saisie du clavier et nous l'affichons Ã  l'Ã©cran.</p>
<!--
## Generating a Secret Number
-->
<h2><a class="header" href="#gÃ©nÃ©rer-le-nombre-secret" id="gÃ©nÃ©rer-le-nombre-secret">GÃ©nÃ©rer le nombre secret</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. Letâ€™s use a random number between 1 and 100 so the game isnâ€™t too
difficult. Rust doesnâ€™t yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate].
-->
<p>Maintenant, il nous faut gÃ©nÃ©rer un nombre secret que notre joueur va devoir
deviner. Ce nombre devra Ãªtre diffÃ©rent Ã  chaque fois pour qu'on puisse
s'amuser Ã  y jouer plusieurs fois. Tirons au sort un nombre compris entre
1 et 100 pour que le jeu ne soit pas trop difficile. Rust n'embarque pas pour
l'instant de fonctionnalitÃ© de gÃ©nÃ©ration de nombres alÃ©atoires dans sa
bibliothÃ¨que standard. Cependant, l'Ã©quipe de Rust propose une
<a href="https://crates.io/crates/rand"><em>crate</em> <code>rand</code></a>.</p>
<!--
[randcrate]: https://crates.io/crates/rand
-->
<!--
### Using a Crate to Get More Functionality
-->
<h3><a class="header" href="#Ã‰tendre-les-fonctionnalitÃ©s-de-rust-avec-une-crate" id="Ã‰tendre-les-fonctionnalitÃ©s-de-rust-avec-une-crate">Ã‰tendre les fonctionnalitÃ©s de Rust avec une <em>crate</em></a></h3>
<!--
Remember that a crate is a collection of Rust source code files.
The project weâ€™ve been building is a *binary crate*, which is an executable.
The `rand` crate is a *library crate*, which contains code intended to be
used in other programs.
-->
<p>Souvenez-vous, une <em>crate</em> est un ensemble de fichiers de code source Rust.
Le projet sur lequel nous travaillons est une <em>crate</em> binaire, qui est un
programme exÃ©cutable.
La <em>crate</em> <code>rand</code> est une <em>crate de bibliothÃ¨que</em>, qui contient du
code qui peut Ãªtre utilisÃ© dans d'autres programmes.</p>
<!--
Cargoâ€™s use of external crates is where it really shines. Before we can write
code that uses `rand`, we need to modify the *Cargo.toml* file to include the
`rand` crate as a dependency. Open that file now and add the following line to
the bottom beneath the `[dependencies]` section header that Cargo created for
you:
-->
<p>L'utilisation des <em>crates</em> externes est un domaine dans lequel Cargo excelle.
Avant d'Ã©crire le code qui utilisera <code>rand</code>, il nous faut Ã©diter le fichier
<em>Cargo.toml</em> pour y spÃ©cifier <code>rand</code> en tant que dÃ©pendance. Ouvrez donc
maintenant ce fichier et ajoutez la ligne suivante Ã  la fin, en dessous de
l'en-tÃªte de section <code>[dependencies]</code> que Cargo a crÃ©Ã© pour vousÂ :</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[dependencies]
rand = "0.5.5"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of a section
that continues until another section starts. The `[dependencies]` section is
where you tell Cargo which external crates your project depends on and which
versions of those crates you require. In this case, weâ€™ll specify the `rand`
crate with the semantic version specifier `0.5.5`. Cargo understands [Semantic
Versioning][semver]<!-- ignore -- > (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.5.5` is actually shorthand
for `^0.5.5`, which means â€œany version that has a public API compatible with
version 0.5.5.â€
-->
<p>Dans le fichier <em>Cargo.toml</em>, tout ce qui suit une en-tÃªte fait partie de cette
section, et ce jusqu'Ã  ce qu'une autre section dÃ©bute. La section
<code>[dependencies]</code> permet d'indiquer Ã  Cargo de quelles <em>crates</em> externes votre
projet dÃ©pend, et de quelle version de ces <em>crates</em> vous avez besoin.
Dans notre cas, on ajoute comme dÃ©pendance la crate <code>rand</code> avec la version
sÃ©mantique <code>0.5.5</code>. Cargo arrive Ã  interprÃ©ter le
<a href="http://semver.org">versionnage sÃ©mantique</a><!-- ignore --> (aussi appelÃ© <em>SemVer</em>), qui
est une convention d'Ã©criture de numÃ©ros de version. En rÃ©alitÃ©, <code>0.5.5</code> est
une abrÃ©viation pour <code>^0.5.5</code>, ce qui signifie â€œtoute version qui propose une
API publique compatible avec la version 0.5.5â€.</p>
<!--
[semver]: http://semver.org
-->
<!--
Now, without changing any of the code, letâ€™s build the project, as shown in
Listing 2-2.
-->
<p>Maintenant, sans apporter le moindre changement au code, lanÃ§ons une compilation
du projet, comme dans l'encart 2-2Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -- >
-->
<!--
```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">Encart 2-2Â : RÃ©sultat du lancement de <code>cargo build</code> aprÃ¨s
avoir ajoutÃ© la <em>crate</em> <code>rand</code> comme dÃ©pendance</span></p>
<!--
You may see different version numbers (but they will all be compatible with
the code, thanks to SemVer!), different lines (depending on the operating system), and the lines may be in a different order.
-->
<p>Il est possible que vous ne voyiez pas exactement les mÃªmes numÃ©ros de version,
(mais ils seront compatibles avec votre code, grÃ¢ce au <em>versionnage
sÃ©mantique</em>Â !), diffÃ©rentes lignes (en fonction de votre systÃ¨me
d'exploitation), et les lignes ne seront pas forcÃ©ment affichÃ©es dans le mÃªme
ordre.</p>
<!--
Now that we have an external dependency, Cargo fetches the latest versions of
everything from the *registry*, which is a copy of data from
[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem post
their open source Rust projects for others to use.
-->
<p>Maintenant que nous avons une dÃ©pendance externe, Cargo rÃ©cupÃ¨re la derniÃ¨re
version de tout ce qui nous faut depuis le <em>registre</em>, qui est une copie des
donnÃ©es de <a href="https://crates.io/">Crates.io</a>. Crates.io est lÃ  oÃ¹ les dÃ©veloppeurs de
l'Ã©cosystÃ¨me Rust publient leurs projets open source afin de les rendre
disponibles aux autres.</p>
<!--
[cratesio]: https://crates.io/
-->
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates you donâ€™t have yet. In this case, although we only listed
`rand` as a dependency, Cargo also grabbed `libc` and `rand_core`, because
`rand` depends on those to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.
-->
<p>Une fois le registre mis Ã  jour, Cargo lit la section <code>[dependencies]</code> et se
charge de tÃ©lÃ©charger les <em>crates</em> que vous n'avez pas encore. Dans notre cas,
bien que nous n'ayons spÃ©cifiÃ© qu'une seule dÃ©pendance, <code>rand</code>, Cargo a aussi
tÃ©lÃ©chargÃ© la <em>crate</em> <code>libc</code> et <code>rand_core</code>, car <code>rand</code> dÃ©pend d'elles pour
fonctionner. Une fois le tÃ©lÃ©chargement terminÃ© des <em>crates</em>, Rust les compile,
puis compile notre projet avec les dÃ©pendances disponibles.</p>
<!--
If you immediately run `cargo build` again without making any changes, you
wonâ€™t get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you havenâ€™t changed anything
about them in your *Cargo.toml* file. Cargo also knows that you havenâ€™t changed
anything about your code, so it doesnâ€™t recompile that either. With nothing to
do, it simply exits.
-->
<p>Si vous relancez tout de suite <code>cargo build</code> sans changer quoi que ce soit, vous
n'obtiendrez rien d'autre que la ligne <code>Finished</code>. Cargo sait qu'il a dÃ©jÃ 
tÃ©lÃ©chargÃ© et compilÃ© les dÃ©pendances, et que vous n'avez rien changÃ© dans votre
fichier <em>Cargo.toml</em>. Cargo sait aussi que vous n'avez rien changÃ© dans votre
code, donc il ne le recompile pas non plus. Ã‰tant donnÃ© qu'il n'a rien Ã  faire,
Cargo se termine tout simplement.</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, youâ€™ll only see two lines of output:
-->
<p>Si vous ouvrez le fichier <em>src/main.rs</em>, faites un changement trÃ¨s simple,
enregistrez le fichier, et relancez la compilation, vous verrez s'afficher
uniquement deux lignesÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -- >
-->
<!--
```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```
-->
<pre><code class="language-console">$ cargo build
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies havenâ€™t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those. It just rebuilds
your part of the code.
-->
<p>Ces lignes nous informent que Cargo a recompilÃ© uniquement Ã  cause de notre
petit changement dans le fichier <em>src/main.rs</em>. Les dÃ©pendances n'ayant pas
changÃ©, Cargo sait qu'il peut simplement rÃ©utiliser ce qu'il a dÃ©jÃ  tÃ©lÃ©chargÃ©
et compilÃ© prÃ©cÃ©demment. Il se contente donc de ne recompiler que notre partie
du code.</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4><a class="header" href="#assurer-la-reproductibilitÃ©-des-compilations-avec-le-fichier-cargolock" id="assurer-la-reproductibilitÃ©-des-compilations-avec-le-fichier-cargolock">Assurer la reproductibilitÃ© des compilations avec le fichier <em>Cargo.lock</em></a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, what
happens if next week version 0.5.6 of the `rand` crate comes out and
contains an important bug fix but also contains a regression that will break
your code?
-->
<p>Cargo embarque une fonctionnalitÃ© qui garantie que vous pouvez recompiler le
mÃªme artÃ©fact Ã  chaque fois que vous ou quelqu'un d'autre compile votre codeÂ :
Cargo va utiliser uniquement les versions de dÃ©pendances que vous avez
utilisÃ©es jusqu'Ã  ce que vous indiquiez le contraire.
Par exemple, que se passe-t-il si la semaine prochaine, la version 0.5.6 de la
<em>crate</em> <code>rand</code> est publiÃ©e et qu'elle apporte une correction importante, mais
aussi qu'elle produit une rÃ©gression qui va casser votre codeÂ ?</p>
<!--
The answer to this problem is the *Cargo.lock* file, which was created the
first time you ran `cargo build` and is now in your *guessing_game* directory.
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.5.5` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>La rÃ©ponse Ã  ce problÃ¨me est le fichier <em>Cargo.lock</em>, qui a Ã©tÃ© crÃ©Ã© la premiÃ¨re
fois que vous avez utilisÃ© <code>cargo build</code> et qui se trouve dÃ©sormais dans votre
dossier <em>jeu_du_plus_ou_du_moins</em>. Quand vous compilez un projet pour la
premiÃ¨re fois, Cargo dÃ©termine toutes les versions de dÃ©pendances qui
correspondent Ã  vos critÃ¨res et les Ã©crit dans le fichier <em>Cargo.lock</em>. Quand
vous recompilerez votre projet plus tard, Cargo verra que le fichier
<em>Cargo.lock</em> existe et utilisera les versions prÃ©cisÃ©es Ã  l'intÃ©rieur au lieu
de recommencer Ã  dÃ©terminer toutes les versions demandÃ©es.
Ceci vous permet d'avoir automatiquement des compilations reproductibles.
En d'autres termes, votre projet va rester sur la version <code>0.5.5</code> jusqu'Ã  ce
que vous le mettiez Ã  jour explicitement, grÃ¢ce au fichier <em>Cargo.lock</em>.</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4><a class="header" href="#mettre-Ã -jour-une-crate-vers-sa-nouvelle-version" id="mettre-Ã -jour-une-crate-vers-sa-nouvelle-version">Mettre Ã  jour une <em>crate</em> vers sa nouvelle version</a></h4>
<!--
When you *do* want to update a crate, Cargo provides another command, `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. If that works, Cargo will write
those versions to the *Cargo.lock* file.
-->
<p>Lorsque vous souhaitez rÃ©ellement mettre Ã  jour une <em>crate</em>, Cargo vous fournit
une autre commande, <code>update</code>, qui va ignorer le fichier <em>Cargo.lock</em> et va
rechercher toutes les versions qui correspondent Ã  vos critÃ¨res dans
<em>Cargo.toml</em>. Si cela se passe bien, Cargo va Ã©crire ces versions dans le
fichier <em>Cargo.lock</em>.</p>
<!--
But by default, Cargo will only look for versions greater than `0.5.5` and less
than `0.6.0`. If the `rand` crate has released two new versions, `0.5.6` and
`0.6.0`, you would see the following if you ran `cargo update`:
-->
<p>Mais par dÃ©faut, Cargo va rechercher uniquement les versions plus grandes que
<code>0.5.5</code> et infÃ©rieures Ã  <code>0.6.0</code>. Si la <em>crate</em> <code>rand</code> a Ã©tÃ© publiÃ©e en deux
nouvelles versions, <code>0.5.6</code> et <code>0.6.0</code>, alors vous verrez ceci si vous
lancez <code>cargo update</code>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.5.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -- >
-->
<!--
```console
$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -> v0.5.6
```
-->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -&gt; v0.5.6
</code></pre>
<!--
At this point, you would also notice a change in your *Cargo.lock* file noting
that the version of the `rand` crate you are now using is `0.5.6`.
-->
<p>Ã€ partir de ce moment, vous pouvez aussi constater un changement dans le fichier
<em>Cargo.lock</em> indiquant que la version de la <em>crate</em> <code>rand</code> que vous utilisez
maintenant est la <code>0.5.6</code>.</p>
<!--
If you wanted to use `rand` version `0.6.0` or any version in the `0.6.x`
series, youâ€™d have to update the *Cargo.toml* file to look like this instead:
-->
<p>Si vous vouliez utiliser <code>rand</code> en version <code>0.6.0</code> ou toute autre version dans
la sÃ©rie des <code>0.6.x</code>, il vous faut mettre Ã  jour le fichier <em>Cargo.toml</em> comme
ceciÂ :</p>
<!--
```toml
[dependencies]
rand = "0.6.0"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.6.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>La prochaine fois que vous lancerez <code>cargo build</code>, Cargo mettra Ã  jour son
registre de <em>crates</em> disponibles et rÃ©Ã©valuera vos exigences vis-Ã -vis de <code>rand</code>
selon la nouvelle version que vous avez spÃ©cifiÃ©e.</p>
<!--
Thereâ€™s a lot more to say about [Cargo][doccargo]<!-- ignore -- > and [its
ecosystem][doccratesio]<!-- ignore -- > which weâ€™ll discuss in Chapter 14, but
for now, thatâ€™s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p>Il y a encore plus Ã  dire Ã  propos de <a href="http://doc.crates.io">Cargo</a><!-- ignore --> et de
<a href="http://doc.crates.io/crates-io.html">son Ã©cosystÃ¨me</a><!-- ignore --> que nous aborderons au chapitre 14,
mais pour l'instant, c'est tout ce qu'il vous faut savoir. Cargo
facilite la rÃ©utilisation des bibliothÃ¨ques, pour que les RustacÃ©s soient
capables d'Ã©crire des petits projets issus d'un assemblage d'un certain
nombre de paquets.</p>
<!--
[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html
-->
<!--
### Generating a Random Number
-->
<h3><a class="header" href="#gÃ©nÃ©rer-un-nombre-alÃ©atoire" id="gÃ©nÃ©rer-un-nombre-alÃ©atoire">GÃ©nÃ©rer un nombre alÃ©atoire</a></h3>
<!--
Now that youâ€™ve added the `rand` crate to *Cargo.toml*, letâ€™s start using
`rand`. The next step is to update *src/main.rs*, as shown in Listing 2-3.
-->
<p>Maintenant que vous avez ajoutÃ© la <em>crate</em> <code>rand</code> dans <em>Cargo.toml</em>, commenÃ§ons
Ã  utiliser <code>rand</code>. La prochaine Ã©tape est de modifier <em>src/main.rs</em> comme dans
l'encart 2-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombreÂ !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);

        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a random
number</span>
-->
<p><span class="caption">Encart 2-3Â : Ajout du code pour gÃ©nÃ©rer un nombre
alÃ©atoire</span></p>
<!--
First, we add a `use` line: `use rand::Rng`. The `Rng` trait defines
methods that random number generators implement, and this trait must be in
scope for us to use those methods. Chapter 10 will cover traits in detail.
-->
<p>D'abord, nous avons ajoutÃ© une ligne <code>use</code>Â : <code>use rand::Rng</code>. Le <em>trait</em>
<code>Rng</code> dÃ©finit les mÃ©thodes implÃ©mentÃ©es par les gÃ©nÃ©rateurs de nombres
alÃ©atoires, et ce <em>trait</em> doit Ãªtre accessible Ã  notre code pour qu'on puisse
utiliser ces mÃ©thodes. Le chapitre 10 expliquera plus en dÃ©tail les <em>traits</em>.</p>
<!--
Next, weâ€™re adding two lines in the middle. The `rand::thread_rng` function
will give us the particular random number generator that weâ€™re going to use:
one that is local to the current thread of execution and seeded by the
operating system. Then we call the `gen_range` method on the random number
generator. This method is defined by the `Rng` trait that we brought into
scope with the `use rand::Rng` statement. The `gen_range` method takes two
numbers as arguments and generates a random number between them. Itâ€™s inclusive
on the lower bound but exclusive on the upper bound, so we need to specify `1`
and `101` to request a number between 1 and 100.
-->
<p>Ensuite, nous ajoutons deux lignes au milieu. La fonction <code>rand::thread_rng</code>
nous fournit le gÃ©nÃ©rateur de nombres alÃ©atoires particulier que nous allons
utiliserÂ : il est propre au fil d'exÃ©cution courant et gÃ©nÃ©rÃ© par le
systÃ¨me d'exploitation. Ensuite, nous appelons la mÃ©thode <code>gen_range</code> sur le
gÃ©nÃ©rateur de nombres alÃ©atoires. Cette mÃ©thode est dÃ©finie par le <em>trait</em> <code>Rng</code>
que nous avons importÃ© avec l'instruction <code>use rand::Rng</code>. La mÃ©thode
<code>gen_range</code> prend deux nombres en paramÃ¨tres et gÃ©nÃ¨re un nombre alÃ©atoire entre
ces deux bornes. Elle inclut la borne infÃ©rieure mais exclut la borne
supÃ©rieure, nous avons donc besoin de prÃ©ciser <code>1</code> et <code>101</code> pour demander un
nombre entre 1 et 100.</p>
<!--
> Note: You wonâ€™t just know which traits to use and which methods and functions
> to call from a crate. Instructions for using a crate are in each crateâ€™s
> documentation. Another neat feature of Cargo is that you can run the `cargo
> doc --open` command, which will build documentation provided by all of your
> dependencies locally and open it in your browser. If youâ€™re interested in
> other functionality in the `rand` crate, for example, run `cargo doc --open`
> and click `rand` in the sidebar on the left.
-->
<blockquote>
<p>RemarqueÂ : vous ne pourrez pas deviner quels <em>traits</em>, mÃ©thodes et
fonctions utiliser avec une <em>crate</em>. Les instructions pour l'utilisation
d'une <em>crate</em> se trouvent dans la documentation propre Ã  chaque <em>crate</em>. Une
autre fonctionnalitÃ© intÃ©ressante de Cargo est que vous pouvez utiliser la
commande <code>cargo doc --open</code>, qui va construire localement la documentation
intÃ©grÃ©e par toutes vos dÃ©pendances et va l'ouvrir dans votre navigateur.
Si vous vous intÃ©ressez Ã  d'autres fonctionnalitÃ©s de la <em>crate</em> <code>rand</code>,
par exemple, vous pouvez lancer <code>cargo doc --open</code> et cliquer sur <code>rand</code>
dans la barre latÃ©rale sur la gauche.</p>
</blockquote>
<!--
The second line that we added to the middle of the code prints the secret
number. This is useful while weâ€™re developing the program to be able to test
it, but weâ€™ll delete it from the final version. Itâ€™s not much of a game if the
program prints the answer as soon as it starts!
-->
<p>La seconde ligne que nous avons ajoutÃ©e au milieu du code affiche le nombre
secret. C'est pratique lors du dÃ©veloppement pour pouvoir le tester, mais nous
l'enlÃ¨verons dans la version finale. Ce n'est pas vraiment un jeu si le
programme affiche la rÃ©ponse dÃ¨s qu'il dÃ©marreÂ !</p>
<!--
Try running the program a few times:
-->
<p>Essayez de lancer le programme plusieurs foisÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombreÂ !
Le nombre secret estÂ : 7
Veuillez entrer un nombre.
4
Votre nombreÂ : 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombreÂ !
Le nombre secret estÂ : 83
Veuillez entrer un nombre.
5
Votre nombreÂ : 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>Vous devriez obtenir des nombres alÃ©atoires diffÃ©rents, et ils devraient Ãªtre
tous compris entre 1 et 100. Beau travailÂ !</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2><a class="header" href="#comparer-le-nombre-saisi-au-nombre-secret" id="comparer-le-nombre-saisi-au-nombre-secret">Comparer le nombre saisi au nombre secret</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code wonâ€™t compile quite yet, as we
will explain.
-->
<p>Maintenant que nous avons une saisie utilisateur et un nombre alÃ©atoire, nous
pouvons les comparer. Cette Ã©tape est Ã©crite dans l'encart 2-4. Sachez toutefois
que le code ne se compile pas encore, nous allons l'expliquer par la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // -- partie masquÃ©e ici --
<span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span>
    println!(&quot;Votre nombreÂ : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">Encart 2-4Â : Traitement des valeurs possibles saisies en
comparant les deux nombres</span></p>
<!--
The first new bit here is another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. Like `Result`,
`Ordering` is another enum, but the variants for `Ordering` are `Less`,
`Greater`, and `Equal`. These are the three outcomes that are possible when you
compare two values.
-->
<p>La premiÃ¨re nouveautÃ© ici est une nouvelle utilisation de l'instruction <code>use</code>,
qui importe <code>std::cmp::Ordering</code> Ã  portÃ©e de notre code depuis la
bibliothÃ¨que standard. Comme <code>Result</code>, <code>Ordering</code> est une autre Ã©numÃ©ration,
mais les variantes pour <code>Ordering</code> sont <code>Less</code> <em>(infÃ©rieur)</em>, <code>Greater</code>
<em>(supÃ©rieur)</em> et <code>Equal</code> <em>(Ã©gal)</em>.
Ce sont les trois issues possibles lorsqu'on compare deux valeurs.</p>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here itâ€™s
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match]<!-- ignore -- > expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>Ensuite, nous ajoutons cinq nouvelles lignes Ã  la fin qui utilisent le type
<code>Ordering</code>. La mÃ©thode <code>cmp</code> compare deux valeurs et peut Ãªtre appelÃ©e sur
tout ce qui peut Ãªtre comparÃ©. Elle prend en paramÃ¨tre une rÃ©fÃ©rence de ce qu'on
veut comparerÂ : ici, nous voulons comparer <code>supposition</code> et <code>nombre_secret</code>.
Ensuite, cela retourne une variante de l'Ã©numÃ©ration <code>Ordering</code> que nous avons
importÃ©e avec l'instruction <code>use</code>. Nous utilisons une expression
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> pour dÃ©cider quoi faire ensuite en fonction de
quelle variante de <code>Ordering</code> a Ã©tÃ© retournÃ©e Ã  l'appel de <code>cmp</code> avec
<code>supposition</code> et <code>nombre_secret</code>.</p>
<!--
[match]: ch06-02-match.html
-->
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* and
the code that should be run if the value given to the beginning of the `match`
expression fits that armâ€™s pattern. Rust takes the value given to `match` and
looks through each armâ€™s pattern in turn. The `match` construct and patterns
are powerful features in Rust that let you express a variety of situations your
code might encounter and make sure that you handle them all. These features
will be covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p>Une expression <code>match</code> est composÃ©e de <em>branches</em>. Une branche est constituÃ©e
d'un <em>motif (pattern)</em> et du code qui sera exÃ©cutÃ© si la valeur donnÃ©e
au dÃ©but de l'expression <code>match</code> correspond bien au motif de cette
branche. Rust prend la valeur donnÃ©e Ã  <code>match</code> et la compare au motif de
chaque branche Ã  tour de rÃ´le.
La structure de contrÃ´le <code>match</code> et les motifs sont des
fonctionnalitÃ©s puissantes de Rust qui vous permettent de dÃ©crire une multitude
de scÃ©narios que votre code peut rencontrer et de s'assurer que vous les gÃ©rez
toutes. Ces fonctionnalitÃ©s seront expliquÃ©es plus en dÃ©tail respectivement dans
le chapitre 6 et le chapitre 18.</p>
<!--
Letâ€™s walk through an example of what would happen with the `match` expression
used here. Say that the user has guessed 50 and the randomly generated secret
number this time is 38. When the code compares 50 to 38, the `cmp` method will
return `Ordering::Greater`, because 50 is greater than 38. The `match`
expression gets the `Ordering::Greater` value and starts checking each armâ€™s
pattern. It looks at the first armâ€™s pattern, `Ordering::Less`, and sees that
the value `Ordering::Greater` does not match `Ordering::Less`, so it ignores
the code in that arm and moves to the next arm. The next armâ€™s pattern,
`Ordering::Greater`, *does* match `Ordering::Greater`! The associated code in
that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>Voyons un exemple de ce qui se passerait avec l'expression <code>match</code> utilisÃ©e
ici. Disons que l'utilisateur a saisi le nombre 50 et que le nombre secret
gÃ©nÃ©rÃ© alÃ©atoirement a cette fois-ci comme valeur 38. Quand le code compare 50 Ã 
38, la mÃ©thode <code>cmp</code> va retourner <code>Ordering::Greater</code>, car 50 est plus grand
que 38. L'expression <code>match</code> obtient la valeur <code>Ordering::Greater</code> et commence Ã 
vÃ©rifier le motif de chaque branche.
Elle consulte le motif de la premiÃ¨re branche, <code>Ordering::Less</code> et remarque que
la valeur <code>Ordering::Greater</code> ne correspond pas au motif <code>Ordering::Less</code>Â ;
elle ignore donc le code de cette branche et passe Ã  la suivante.
Le motif de la branche suivante, <code>Ordering::Greater</code>, correspond Ã 
<code>Ordering::Greater</code>Â ! Le code associÃ© Ã  cette branche va Ãªtre exÃ©cutÃ© et va
afficher Ã  l'Ã©cran <code>C'est moinsÂ !</code>. L'expression <code>match</code> se termine ensuite, car
elle n'a pas besoin de consulter les autres branches de ce scÃ©nario.</p>
<!--
However, the code in Listing 2-4 wonâ€™t compile yet. Letâ€™s try it:
-->
<p>Cependant, notre code dans l'encart 2-4 ne compile pas encore. Essayons de le
faireÂ :</p>
<!--
```console
$ cargo build
   Compiling libc v0.2.51
   Compiling rand_core v0.4.0
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- > src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected reference `&std::string::String`
              found reference `&{integer}`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.51
   Compiling rand_core v0.4.0
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match supposition.cmp(&amp;nombre_secret) {
   |                           ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected reference `&amp;std::string::String`
              found reference `&amp;{integer}`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `jeu_du_plus_ou_du_moins`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let mut guess = String::new()`, Rust was able to infer that `guess` should be
a `String` and didnâ€™t make us write the type. The `secret_number`, on the other
hand, is a number type. A few number types can have a value between 1 and 100:
`i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a 64-bit
number; as well as others. Rust defaults to an `i32`, which is the type of
`secret_number` unless you add type information elsewhere that would cause Rust
to infer a different numerical type. The reason for the error is that Rust
cannot compare a string and a number type.
-->
<p>Le message d'erreur nous indique que nous sommes dans un cas de types non
compatibles <em>(mismatched types)</em>. Rust a un systÃ¨me de types fort et statique.
Cependant, il a aussi une fonctionnalitÃ© d'infÃ©rence de type. Quand nous avons
Ã©crit <code>let mut supposition = String::new()</code>, Rust a pu en dÃ©duire que
<code>supposition</code> devait Ãªtre une <code>String</code> et ne nous a pas demandÃ© d'Ã©crire le
type. D'autre part, <code>nombre_secret</code> est d'un type de nombre.
Quelques types de nombres peuvent avoir une valeur entre 1 et 100Â : <code>i32</code>, un
nombre entier encodÃ© sur 32 bitsÂ ; <code>u32</code>, un nombre entier de 32 bits non signÃ©
(positif ou nul)Â ; <code>i64</code>, un nombre entier encodÃ© sur 64 bitsÂ ; parmi
tant d'autres. Rust utilise par dÃ©faut un <code>i32</code>, qui est le type
de <code>nombre_secret</code>, Ã  moins que vous prÃ©cisiez quelque part une information de
type qui amÃ¨nerait Rust Ã  infÃ©rer un type de nombre diffÃ©rent. La raison de
cette erreur est que Rust ne peut pas comparer une chaÃ®ne de caractÃ¨res Ã  un
nombre.</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the secret number. We can
do that by adding another line to the `main` function body:
-->
<p>Au bout du compte, nous voulons convertir la <code>String</code> que le programme rÃ©cupÃ¨re
de la saisie utilisateur en un nombre, pour qu'on puisse la comparer
numÃ©riquement au nombre secret. Nous pouvons faire ceci en ajoutant une ligne
supplÃ©mentaire dans le corps de la fonction <code>main</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span>    // -- partie masquÃ©e ici --

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);

    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombreÂ !&quot;);

    println!(&quot;Votre nombreÂ : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
    }
}
</code></pre>
<!--
The line is:
-->
<p>La nouvelle ligne estÂ :</p>
<!--
```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```
-->
<pre><code class="language-rust ignore">let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombreÂ !&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesnâ€™t the program already have
a variable named `guess`? It does, but Rust allows us to *shadow* the previous
value of `guess` with a new one. This feature is often used in situations in
which you want to convert a value from one type to another type. Shadowing lets
us reuse the `guess` variable name rather than forcing us to create two unique
variables, such as `guess_str` and `guess` for example. (Chapter 3 covers
shadowing in more detail.)
-->
<p>Nous crÃ©ons une variable qui s'appelle <code>supposition</code>. Mais attendez, le
programme n'a-t-il pas dÃ©jÃ  une variable qui s'appelle <code>supposition</code>Â ?
C'est le cas, mais Rust nous permet de <em>masquer</em> la valeur prÃ©cÃ©dente de
<code>supposition</code> avec une nouvelle.
Cette fonctionnalitÃ© est souvent utilisÃ©e dans des
situations oÃ¹ on veut convertir une valeur d'un type Ã  un autre.
Le masquage <em>(shadowing)</em> nous permet de rÃ©utiliser le nom de variable
<code>supposition</code>, plutÃ´t que de nous forcer Ã  crÃ©er deux variables distinctes,
telles que <code>supposition_str</code> et <code>supposition</code> par exemple.
(Le chapitre 3 expliquera plus en dÃ©tail le masquage.)</p>
<!--
We bind `guess` to the expression `guess.trim().parse()`. The `guess` in the
expression refers to the original `guess` that was a `String` with the input in
it. The `trim` method on a `String` instance will eliminate any whitespace at
the beginning and end. Although `u32` can contain only numerical characters,
the user must press <span class="keystroke">enter</span> to satisfy
`read_line`. When the user presses <span class="keystroke">enter</span>, a
newline character is added to the string. For example, if the user types <span
class="keystroke">5</span> and presses <span class="keystroke">enter</span>,
`guess` looks like this: `5\n`. The `\n` represents â€œnewline,â€ the result of
pressing <span class="keystroke">enter</span>. The `trim` method eliminates
`\n`, resulting in just `5`.
-->
<p>Nous lions <code>supposition</code> Ã  l'expression <code>supposition.trim().parse()</code>. Le
<code>supposition</code> dans l'expression se rÃ©fÃ¨re au <code>supposition</code> initial qui Ã©tait une
<code>String</code> contenant la saisie utilisateur. La mÃ©thode <code>trim</code> sur une instance
de <code>String</code> va enlever les espaces et autres <em>whitespaces</em> au dÃ©but et Ã  la fin.
MÃªme si <code>u32</code> ne peut contenir que des chiffres, l'utilisateur doit
appuyer sur <span class="keystroke">entrÃ©e</span> pour mettre fin Ã  <code>read_line</code>.
Lorsque l'utilisateur appuie sur
<span class="keystroke">entrÃ©e</span>, un caractÃ¨re de fin de ligne
est ajoutÃ© Ã  la chaÃ®ne de caractÃ¨res. Par exemple, si l'utilisateur Ã©crit
<span class="keystroke">5</span> et appuie sur <span class="keystroke">
entrÃ©e</span>, <code>supposition</code> aura alors cette valeurÂ : <code>5\n</code>.
Le <code>\n</code> reprÃ©sente une fin de ligne, qui rÃ©sulte de l'appui sur
<span class="keystroke">entrÃ©e</span>. La mÃ©thode <code>trim</code> enlÃ¨ve <code>\n</code>, il ne
reste donc plus que <code>5</code>.</p>
<!--
The [`parse` method on strings][parse]<!-- ignore -- > parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust weâ€™ll annotate the variableâ€™s type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. Itâ€™s a good default choice for a small positive number. Youâ€™ll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p>La <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">mÃ©thode <code>parse</code> des chaÃ®nes de caractÃ¨res</a><!-- ignore --> interprÃ¨te
une chaÃ®ne de caractÃ¨res en une sorte de nombre. Comme cette mÃ©thode peut
interprÃ©ter plusieurs types de nombres, nous devons indiquer Ã  Rust le type
exact de nombre que nous voulons en utilisant <code>let supposition: u32</code>.
Le deux-points (<code>:</code>) aprÃ¨s <code>supposition</code> indique Ã  Rust que nous voulons
prÃ©ciser le type de la variable.
Rust embarque quelques types de nombresÂ ; le <code>u32</code> utilisÃ© ici est un
entier non signÃ© sur 32 bits.
C'est un bon choix par dÃ©faut pour un petit nombre positif.
Vous dÃ©couvrirez d'autres types de nombres dans le chapitre 3.
De plus, l'annotation <code>u32</code> dans ce programme d'exemple et la
comparaison avec <code>nombre_secret</code> permet Ã  Rust d'en dÃ©duire que <code>nombre_secret</code>
doit Ãªtre lui aussi un <code>u32</code>. Donc maintenant, la comparaison se fera
entre deux valeurs du mÃªme typeÂ !</p>
<!--
[parse]: ../std/primitive.str.html#method.parse
-->
<!--
The call to `parse` could easily cause an error. If, for example, the string
contained `AğŸ‘%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in [â€œHandling Potential Failure with the
`Result` Typeâ€](#handling-potential-failure-with-the-result-type)<!-- ignore
-- >). Weâ€™ll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldnâ€™t create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p>L'utilisation de <code>parse</code> peut facilement mener Ã  une erreur. Si par exemple,
le texte contient <code>AğŸ‘%</code>, il ne sera pas possible de le convertir en nombre.
Comme elle peut Ã©chouer, la mÃ©thode <code>parse</code> retourne un type <code>Result</code>, comme
celui que la mÃ©thode <code>read_line</code> retourne (comme nous l'avons vu plus tÃ´t dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">â€œGÃ©rer les erreurs potentielles avec le type
<code>Result</code>â€</a><!-- ignore-->).
Nous allons gÃ©rer ce <code>Result</code> de la mÃªme maniÃ¨re, avec Ã  nouveau la mÃ©thode
<code>expect</code>. Si <code>parse</code> retourne une variante <code>Err</code> de <code>Result</code> car elle ne peut
pas crÃ©er un nombre Ã  partir de la chaÃ®ne de caractÃ¨res, l'appel Ã 
<code>expect</code> va faire planter le jeu et va afficher le message que nous lui avons
passÃ© en paramÃ¨tre. Si <code>parse</code> arrive Ã  convertir la chaÃ®ne de caractÃ¨res en
nombre, alors elle retournera la variante <code>Ok</code> de <code>Result</code>, et <code>expect</code> va
retourner le nombre qu'il nous faut qui est stockÃ© dans la variante <code>Ok</code>.</p>
<!--
Letâ€™s run the program now!
-->
<p>ExÃ©cutons ce programme, maintenantÂ !</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombreÂ !
Le nombre secret estÂ : 58
Veuillez entrer un nombre.
  76
Votre nombreÂ : 76
C'est moinsÂ !
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>TrÃ¨s bienÂ !
MÃªme si des espaces ont Ã©tÃ© ajoutÃ©es avant la supposition, le programme a quand
mÃªme compris que l'utilisateur a saisi 76. Lancez le programme plusieurs
fois pour vÃ©rifier qu'il se comporte correctement avec diffÃ©rentes saisiesÂ :
devinez le nombre correctement, saisissez un nombre qui est trop grand, et
saisissez un nombre qui est trop petit.</p>
<!--
We have most of the game working now, but the user can make only one guess.
Letâ€™s change that by adding a loop!
-->
<p>La majeure partie du jeu fonctionne dÃ©sormais, mais l'utilisateur ne peut faire
qu'une seule supposition. Corrigeons cela en ajoutant une boucleÂ !</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2><a class="header" href="#permettre-plusieurs-suppositions-avec-les-boucles" id="permettre-plusieurs-suppositions-avec-les-boucles">Permettre plusieurs suppositions avec les boucles</a></h2>
<!--
The `loop` keyword creates an infinite loop. Weâ€™ll add that now to give users
more chances at guessing the number:
-->
<p>Le mot-clÃ© <code>loop</code> crÃ©e une boucle infinie. C'est ce que nous allons ajouter pour
donner aux utilisateurs plus de chances de deviner le nombreÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
    // --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

# 
#         let mut guess = String::new();
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
#         let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#         println!("You guessed: {}", guess);
# 
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    // -- partie masquÃ©e ici --

    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        // -- partie masquÃ©e ici --

<span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span>        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
            Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, weâ€™ve moved everything into a loop from the guess input prompt
onward. Be sure to indent the lines inside the loop another four spaces each
and run the program again. Notice that there is a new problem because the
program is doing exactly what we told it to do: ask for another guess forever!
It doesnâ€™t seem like the user can quit!
-->
<p>Comme vous pouvez le remarquer, nous avons dÃ©placÃ© dans une boucle tout le
code Ã  partir de l'invite Ã  entrer le nombre. Assurez-vous d'indenter
correctement les lignes dans la boucle avec quatre nouvelles espaces pour
chacune, et lancez Ã  nouveau le programme. Notez bien qu'il y a un nouveau
problÃ¨me, car le programme fait exactement ce que nous lui avons demandÃ© de
faireÂ : demander un nombre Ã  l'infiniÂ ! Il n'est pas possible pour l'utilisateur
de l'arrÃªterÂ !</p>
<!--
The user could always interrupt the program by using the keyboard shortcut <span
class="keystroke">ctrl-c</span>. But thereâ€™s another way to escape this
insatiable monster, as mentioned in the `parse` discussion in [â€œComparing the
Guess to the Secret Numberâ€](#comparing-the-guess-to-the-secret-number)<!--
ignore -- >: if the user enters a non-number answer, the program will crash. The
user can take advantage of that in order to quit, as shown here:
-->
<p>L'utilisateur pourrait quand mÃªme interrompre le programme en utilisant le
raccourci clavier <span class="keystroke">ctrl-c</span>.
Mais il y a une autre faÃ§on d'Ã©chapper Ã  ce monstre insatiable, comme nous
l'avons abordÃ© dans la partie <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">â€œComparer le nombre saisi au nombre
secretâ€</a><!-- ignore -->Â : si
l'utilisateur saisit quelque chose qui n'est pas un nombre, le programme va
planter. L'utilisateur peut procÃ©der ainsi pour le quitter, comme ci-dessousÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-- >
-->
<!-- markdownlint-disable -->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:999:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<!-- markdownlint-restore -->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombreÂ !
Le nombre secret estÂ : 59
Veuillez entrer un nombre.
45
Votre nombreÂ : 45
C'est plusÂ !
Veuillez entrer un nombre.
60
Votre nombreÂ : 60
C'est moinsÂ !
Veuillez entrer un nombre.
59
Votre nombreÂ : 59
Vous avez gagnÃ©Â !
Veuillez entrer un nombre.
quitter
thread 'main' panicked at 'Veuillez entrer un nombreÂ !: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
Typing `quit` actually quits the game, but so will any other non-number input.
However, this is suboptimal to say the least. We want the game to automatically
stop when the correct number is guessed.
-->
<p>Taper <code>quitter</code> ferme bien le jeu, mais toute autre saisie qui n'est pas un
nombre le ferait aussi.
Cependant, ce mÃ©canisme laisse franchement Ã  dÃ©sirer. Nous voudrions que le jeu
s'arrÃªte automatiquement lorsque le bon nombre est devinÃ©.</p>
<!--
### Quitting After a Correct Guess
-->
<h3><a class="header" href="#arrÃªter-le-programme-aprÃ¨s-avoir-gagnÃ©" id="arrÃªter-le-programme-aprÃ¨s-avoir-gagnÃ©">ArrÃªter le programme aprÃ¨s avoir gagnÃ©</a></h3>
<!--
Letâ€™s program the game to quit when the user wins by adding a `break` statement:
-->
<p>Faisons en sorte que le jeu s'arrÃªte quand le joueur gagne en ajoutant
l'instruction <code>break</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
#         let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#         println!("You guessed: {}", guess);
# 
        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span>        // -- partie masquÃ©e ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagnÃ©Â !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p>Ajouter la ligne <code>break</code> aprÃ¨s <code>Vous avez gagnÃ©Â !</code> fait sortir le programme de
la boucle quand le joueur a correctement devinÃ© le nombre secret. Et quitter la
boucle veut aussi dire terminer le programme, car ici la boucle est la derniÃ¨re
partie de <code>main</code>.</p>
<!--
### Handling Invalid Input
-->
<h3><a class="header" href="#gÃ©rer-les-saisies-invalides" id="gÃ©rer-les-saisies-invalides">GÃ©rer les saisies invalides</a></h3>
<!--
To further refine the gameâ€™s behavior, rather than crashing the program when
the user inputs a non-number, letâ€™s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as shown in Listing 2-5.
-->
<p>Pour amÃ©liorer le comportement du jeu, plutÃ´t que de faire planter le programme
quand l'utilisateur saisit quelque chose qui n'est pas un nombre, faisons en
sorte que le jeu ignore ce qui n'est pas un nombre afin que l'utilisateur puisse
continuer Ã  essayer de deviner. Nous pouvons faire ceci en modifiant la ligne oÃ¹
<code>supposition</code> est converti d'une <code>String</code> en un <code>u32</code>, comme dans l'encart 2-5Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span>        // -- partie masquÃ©e ici --

        io::stdin()
            .read_line(&amp;mut supposition)
            .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombreÂ : {}&quot;, supposition);

        // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagnÃ©Â !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">Encart 2-5Â : Ignorer une saisie qui n'est pas un nombre
et demander un nouveau nombre plutÃ´t que de faire planter le programme</span></p>
<!--
Switching from an `expect` call to a `match` expression is how you generally
move from crashing on an error to handling the error. Remember that `parse`
returns a `Result` type and `Result` is an enum that has the variants `Ok` or
`Err`. Weâ€™re using a `match` expression here, as we did with the `Ordering`
result of the `cmp` method.
-->
<p>Remplacer un appel Ã  <code>expect</code> par une expression <code>match</code> est la technique qu'on
utilise en gÃ©nÃ©ral pour passer d'une erreur qui fait planter le programme Ã  une
erreur proprement gÃ©rÃ©e. N'oubliez pas que
<code>parse</code> retourne un type <code>Result</code> et que <code>Result</code> est une Ã©numÃ©ration qui a pour
variantes <code>Ok</code> ou <code>Err</code>. Nous utilisons ici une expression <code>match</code> comme nous
l'avons dÃ©jÃ  fait avec le rÃ©sultat de type <code>Ordering</code> de la mÃ©thode <code>cmp</code>.</p>
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first armâ€™s pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable weâ€™re creating.
-->
<p>Si <code>parse</code> arrive Ã  convertir la chaÃ®ne de caractÃ¨res en nombre, cela va
retourner la variante <code>Ok</code> qui contient le nombre qui en rÃ©sulte. Cette variante
va correspondre au motif de la premiÃ¨re branche, et l'expression <code>match</code> va
simplement retourner la valeur de <code>nombre</code> que <code>parse</code> a trouvÃ©e et qu'elle a
mise dans la variante <code>Ok</code>.
Ce nombre va se retrouver lÃ  oÃ¹ nous en avons besoin,
dans la variable <code>supposition</code> que nous sommes en train de crÃ©er.</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does
match the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, weâ€™re saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second armâ€™s code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So, effectively, the
program ignores all errors that `parse` might encounter!
-->
<p>Si <code>parse</code> n'arrive <em>pas</em> Ã  convertir la chaÃ®ne de caractÃ¨res en nombre, elle
va retourner la variante <code>Err</code> qui contient plus d'informations sur l'erreur. La
variante <code>Err</code> ne correspond pas au motif <code>Ok(nombre)</code> de la premiÃ¨re branche,
mais elle correspond au motif <code>Err(_)</code> de la seconde branche. Le tiret bas,
<code>_</code>, est une valeur passe-partoutÂ ; dans notre exemple, nous disons
que nous voulons correspondre Ã  toutes les valeurs de <code>Err</code>, peu importe quelle
information elles ont Ã  l'intÃ©rieur d'elles-mÃªmes. Donc le programme va exÃ©cuter
le code de la seconde branche, <code>continue</code>, qui indique au programme de se rendre
Ã  la prochaine itÃ©ration de <code>loop</code> et de demander un nouveau nombre. Ainsi, le
programme ignore toutes les erreurs que <code>parse</code> pourrait rencontrerÂ !</p>
<!--
Now everything in the program should work as expected. Letâ€™s try it:
-->
<p>Maintenant, le programme devrait fonctionner correctement. Essayons-leÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombreÂ !
Le nombre secret estÂ : 61
Veuillez entrer un nombre.
10
Votre nombreÂ : 10
C'est plusÂ !
Veuillez entrer un nombre.
99
Votre nombreÂ : 99
C'est moinsÂ !
Veuillez entrer un nombre.
foo
Veuillez entrer un nombre.
61
Votre nombreÂ : 61
Vous avez gagnÃ©Â !
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Letâ€™s delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code.
-->
<p>SuperÂ ! Avec notre petite touche finale, nous avons fini notre jeu du plus ou du
moins. Rappelez-vous que le programme affiche toujours le nombre secret. C'Ã©tait
pratique pour les tests, mais cela gÃ¢che le jeu. Supprimons le <code>println!</code> qui
affiche le nombre secret. L'encart 2-6 reprÃ©sente le code final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Devinez le nombreÂ !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        let mut supposition = String::new();

        io::stdin()
            .read_line(&amp;mut supposition)
            .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombreÂ : {}&quot;, supposition);

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagnÃ©Â !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">Encart 2-6Â : Code complet du jeu du plus ou du moins
</span></p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-1" id="rÃ©sumÃ©-1">RÃ©sumÃ©</a></h2>
<!--
At this point, youâ€™ve successfully built the guessing game. Congratulations!
-->
<p>Si vous Ãªtes arrivÃ© jusqu'ici, c'est que vous avez construit avec succÃ¨s le jeu
du plus ou du moins. FÃ©licitationsÂ !</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, methods, associated functions, the use of external crates, and
more. In the next few chapters, youâ€™ll learn about these concepts in more
detail. Chapter 3 covers concepts that most programming languages have, such as
variables, data types, and functions, and shows how to use them in Rust.
Chapter 4 explores ownership, a feature that makes Rust different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
explains how enums work.
-->
<p>Ce projet Ã©tait une mise en pratique pour vous initier Ã  de nombreux concepts de
RustÂ : <code>let</code>, <code>match</code>, les mÃ©thodes, les fonctions associÃ©es, l'utilisation de
<em>crates</em> externes, et bien plus. Dans les prochains chapitres, vous allez en
apprendre plus sur ces concepts. Le chapitre 3 va traiter des concepts utilisÃ©s
par la plupart des langages de programmation, comme les variables, les types de
donnÃ©es, et les fonctions, et vous montrera comment les utiliser avec Rust. Le
chapitre 4 expliquera la possession <em>(ownership)</em>, qui est une fonctionnalitÃ©
qui distingue Rust des autres langages. Le chapitre 5 abordera les structures et
les syntaxes des mÃ©thodes, et le chapitre 6 expliquera comment les Ã©numÃ©rations
fonctionnent.</p>
<!--
[variables-and-mutability]:
ch03-01-variables-and-mutability.html#variables-and-mutability
-->
<!--
# Common Programming Concepts
-->
<h1><a class="header" href="#les-concepts-courants-de-programmation" id="les-concepts-courants-de-programmation">Les concepts courants de programmation</a></h1>
<!--
This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but weâ€™ll discuss them in the context of Rust and explain the conventions
around using these concepts.
-->
<p>Ce chapitre explique des concepts qui apparaissent dans presque tous les
langages de programmation, et la maniÃ¨re dont ils fonctionnent en Rust. De
nombreux langages sont basÃ©s sur des concepts communs. Les concepts prÃ©sentÃ©s
dans ce chapitre ne sont pas spÃ©cifiques Ã  Rust, mais nous les appliquerons
Ã  Rust et nous expliquerons les conventions qui leur sont liÃ©es.</p>
<!--
Specifically, youâ€™ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.
-->
<p>Plus prÃ©cisÃ©ment, vous allez apprendre les concepts de variables, les types de
base, les fonctions, les commentaires, et les structures de contrÃ´le. Ces
notions fondamentales seront prÃ©sentes dans tous les programmes Rust, et les
apprendre dÃ¨s le dÃ©but vous procurera de solides bases pour dÃ©buter.</p>
<!--
> #### Keywords
>
> The Rust language has a set of *keywords* that are reserved for use by
> the language only, much as in other languages. Keep in mind that you cannot
> use these words as names of variables or functions. Most of the keywords have
> special meanings, and youâ€™ll be using them to do various tasks in your Rust
> programs; a few have no current functionality associated with them but have
> been reserved for functionality that might be added to Rust in the future. You
> can find a list of the keywords in [Appendix A][appendix_a].
-->
<blockquote>
<h4><a class="header" href="#mots-clÃ©s" id="mots-clÃ©s">Mots-clÃ©s</a></h4>
<p>Le langage Rust possÃ¨de un ensemble de <em>mots-clÃ©s</em> qui ont Ã©tÃ© rÃ©servÃ©s pour
l'usage exclusif du langage, tout comme le font d'autres langages. Gardez Ã 
l'esprit que vous ne pouvez pas utiliser ces mots pour des noms de variables
ou de fonctions. La plupart des mots-clÃ©s ont une signification spÃ©ciale, et
vous les utiliserez pour rÃ©aliser de diffÃ©rentes tÃ¢ches dans vos programmes
RustÂ ; quelques-uns n'ont aucune fonctionnalitÃ© active pour le moment, mais
ont Ã©tÃ© rÃ©servÃ©s pour Ãªtre ajoutÃ©s plus tard Ã  Rust.
Vous pouvez trouver la liste de ces mots-clÃ©s dans <a href="appendix-01-keywords.html">l'annexe A</a>.</p>
</blockquote>
<!--
[appendix_a]: appendix-01-keywords.md
-->
<!--
## Variables and Mutability
-->
<h2><a class="header" href="#les-variables-et-la-mutabilitÃ©" id="les-variables-et-la-mutabilitÃ©">Les variables et la mutabilitÃ©</a></h2>
<!--
As mentioned in Chapter 2, by default variables are immutable. This is one of
many nudges Rust gives you to write your code in a way that takes advantage of
the safety and easy concurrency that Rust offers. However, you still have the
option to make your variables mutable. Letâ€™s explore how and why Rust
encourages you to favor immutability and why sometimes you might want to opt
out.
-->
<p>Tel qu'abordÃ© au chapitre 2, par dÃ©faut, les variables sont <em>immuables</em>. C'est
un des nombreux coups de pouce de Rust pour Ã©crire votre code de faÃ§on Ã 
garantir la sÃ©curitÃ© et la concurrence sans problÃ¨me. Cependant, vous avez quand
mÃªme la possibilitÃ© de rendre vos variables mutables <em>(modifiables)</em>. Explorons
comment et pourquoi Rust vous encourage Ã  favoriser l'immuabilitÃ©, et pourquoi
parfois vous pourriez choisir d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you canâ€™t change
that value. To illustrate this, letâ€™s generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
liÃ©e Ã  un nom, vous ne pouvez pas changer cette valeur. Ã€ titre d'illustration,
gÃ©nÃ©rons un nouveau projet appelÃ© <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code that wonâ€™t compile just yet:
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant qui ne compile pas pour le momentÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ciÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!(&quot;La valeur de x estÂ : {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Even though compiler errors can be frustrating, they only mean your program
isnâ€™t safely doing what you want it to do yet; they do *not* mean that youâ€™re
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide Ã  trouver les erreurs dans
vos programmes. MÃªme si les erreurs de compilation peuvent s'avÃ©rer frustrantes,
elles signifient uniquement que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute sÃ©curitÃ©Â ; elles ne
signifient <em>pas</em> que vous Ãªtes un mauvais dÃ©veloppeurÂ ! MÃªme les RustacÃ©s
expÃ©rimentÃ©s continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `cannot
assign twice to immutable variable x`, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du problÃ¨me est qu'il est <em>impossible
d'assigner Ã  deux reprises la variable immuable <code>x</code></em> (<code>cannot assign twice to immutable variable x</code>).</p>
<!--
Itâ€™s important that we get compile-time errors when we attempt to change a
value that we previously designated as immutable because this very situation
can lead to bugs. If one part of our code operates on the assumption that a
value will never change and another part of our code changes that value, itâ€™s
possible that the first part of the code wonâ€™t do what it was designed to do.
The cause of this kind of bug can be difficult to track down after the fact,
especially when the second piece of code changes the value only *sometimes*.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a prÃ©cÃ©demment Ã©tÃ© dÃ©clarÃ©e
comme immuable, car cette situation particuliÃ¨re peut donner lieu Ã  des bogues.
Si une partie de notre code part du principe qu'une valeur ne changera jamais et
qu'une autre partie de notre code modifie cette valeur, il est possible que la
premiÃ¨re partie du code ne fasse pas ce pour quoi elle a Ã©tÃ© conÃ§ue. La cause de
ce genre de bogue peut Ãªtre difficile Ã  localiser aprÃ¨s coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur.</p>
<!--
In Rust, the compiler guarantees that when you state that a value wonâ€™t change,
it really wonâ€™t change. That means that when youâ€™re reading and writing code,
you donâ€™t have to keep track of how and where a value might change. Your code
is thus easier to reason through.
-->
<p>Avec Rust, le compilateur garantit que lorsque nous dÃ©clarons qu'une variable ne
changera pas, elle ne changera vraiment pas. Cela signifie que lorsque vous
lisez et Ã©crivez du code, vous n'avez pas Ã  vous soucier d'oÃ¹ et comment la
valeur pourrait changer. Votre code est ainsi plus facile Ã  comprendre.</p>
<!--
But mutability can be very useful. Variables are immutable only by default; as
you did in Chapter 2, you can make them mutable by adding `mut` in front of the
variable name. In addition to allowing this value to change, `mut` conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variableâ€™s value.
-->
<p>Mais la mutabilitÃ© peut s'avÃ©rer trÃ¨s utile. Les variables sont immuables par
dÃ©fautÂ ; mais comme vous l'avez fait au chapitre 2, vous pouvez les rendre
mutables en ajoutant <code>mut</code> devant le nom de la variable. En plus de permettre Ã 
cette valeur de changer, <code>mut</code> va signaler l'intention aux futurs lecteurs de ce
code que d'autres parties du code vont modifier la valeur de cette variable.</p>
<!--
For example, letâ€™s change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsiÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous exÃ©cutons le programme, nous obtenonsÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
La valeur de x estÂ : 5
La valeur de x estÂ : 6
</code></pre>
<!--
Weâ€™re allowed to change the value that `x` binds to from `5` to `6` when `mut`
is used. In some cases, youâ€™ll want to make a variable mutable because it makes
the code more convenient to write than if it had only immutable variables.
-->
<p>En utilisant <code>mut</code>, nous avons permis Ã  la valeur de <code>x</code> de passer de <code>5</code> Ã  <code>6</code>.
Dans certains cas, on voudra rendre une variable mutable car cela
rendra le code plus pratique Ã  Ã©crire que s'il n'utilisait que des variables
immuables.</p>
<!--
There are multiple trade-offs to consider in addition to the prevention of
bugs. For example, in cases where youâ€™re using large data structures, mutating
an instance in place may be faster than copying and returning newly allocated
instances. With smaller data structures, creating new instances and writing in
a more functional programming style may be easier to think through, so lower
performance might be a worthwhile penalty for gaining that clarity.
-->
<p>Il y a d'autres compromis Ã  envisager, en plus de la prÃ©vention des bogues. Par
exemple, dans le cas oÃ¹ vous utiliseriez des grosses structures de donnÃ©es,
muter une instance dÃ©jÃ  existante peut Ãªtre plus rapide que copier et retourner
une instance nouvellement allouÃ©e. Avec des structures de donnÃ©es plus petites,
crÃ©er de nouvelles instances avec un style de programmation fonctionnelle peut
rendre le code plus facile Ã  comprendre, donc il peut valoir le coup de
sacrifier un peu de performance pour que le code gagne en clartÃ©.</p>
<!--
### Differences Between Variables and Constants
-->
<h3><a class="header" href="#diffÃ©rences-entre-les-variables-et-les-constantes" id="diffÃ©rences-entre-les-variables-et-les-constantes">DiffÃ©rences entre les variables et les constantes</a></h3>
<!--
Being unable to change the value of a variable might have reminded you of
another programming concept that most other languages have: *constants*. Like
immutable variables, constants are values that are bound to a name and are not
allowed to change, but there are a few differences between constants and
variables.
-->
<p>Rendre impossible de changer la valeur d'une variable peut vous avoir rappelÃ© un
autre concept de programmation que de nombreux autres langages possÃ¨dentÂ : les
<em>constantes</em>. Comme les variables immuables, les constantes sont des valeurs qui
sont liÃ©es Ã  un nom et qui ne peuvent Ãªtre modifiÃ©es, mais il y a quelques
diffÃ©rences entre les constantes et les variables.</p>
<!--
First, you arenâ€™t allowed to use `mut` with constants. Constants arenâ€™t just
immutable by defaultâ€”theyâ€™re always immutable.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par dÃ©faut âˆ’ elles sont toujours immuables.</p>
<!--
You declare constants using the `const` keyword instead of the `let` keyword,
and the type of the value *must* be annotated. Weâ€™re about to cover types and
type annotations in the next section, [â€œData Types,â€][data-types]<!-- ignore
-- > so donâ€™t worry about the details right now. Just know that you must always
annotate the type.
-->
<p>On dÃ©clare les constantes en utilisant le mot-clÃ© <code>const</code> Ã  la place du
mot-clÃ© <code>let</code>, et le type de la valeur <em>doit</em> Ãªtre indiquÃ©. Nous allons aborder
les types et les annotations de types dans la prochaine section,
<a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">â€œLes types de donnÃ©esâ€</a><!-- ignore -->, donc ne vous souciez pas
des dÃ©tails pour le moment. Sachez seulement que vous devez toujours indiquer le
type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent Ãªtre dÃ©clarÃ©es Ã  n'importe quel endroit du code, y
compris la portÃ©e globale, ce qui les rend trÃ¨s utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de connaÃ®tre.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a function call or any other value that could only be
computed at runtime.
-->
<p>La derniÃ¨re diffÃ©rence est que les constantes ne peuvent Ãªtre dÃ©finies que par
une expression constante, et non pas le rÃ©sultat d'un appel de fonction ou toute
autre valeur qui ne pourrait Ãªtre calculÃ©e qu'Ã  l'exÃ©cution.</p>
<!--
Hereâ€™s an example of a constant declaration where the constantâ€™s name is
`MAX_POINTS` and its value is set to 100,000. (Rustâ€™s naming convention for
constants is to use all uppercase with underscores between words, and
underscores can be inserted in numeric literals to improve readability):
-->
<p>Voici un exemple d'une dÃ©claration de constante oÃ¹ le nom de la constante est
<code>MAX_POINTS</code> et oÃ¹ sa valeur est dÃ©finie Ã  100Â 000. (En Rust, la convention de
nommage des constantes est de les Ã©crire tout en majuscule avec des tirets bas
entre les mots, et des tirets bas peuvent Ãªtre ajoutÃ©s entre les nombres pour
amÃ©liorer la lisibilitÃ©)Â :</p>
<!--
```rust
const MAX_POINTS: u32 = 100_000;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in, making them a useful choice for values in your application
domain that multiple parts of the program might need to know about, such as the
maximum number of points any player of a game is allowed to earn or the speed
of light.
-->
<p>Les constantes sont valables pendant toute la durÃ©e d'exÃ©cution du programme
au sein de la portÃ©e dans laquelle elles sont dÃ©clarÃ©es, ce qui en fait de
trÃ¨s bons choix lorsque plusieurs parties du programme doivent connaÃ®tre
certaines valeurs, comme par exemple le nombre maximum de points qu'un joueur
est autorisÃ© Ã  gagner ou encore la vitesse de la lumiÃ¨re.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>DÃ©clarer des valeurs codÃ©es en dur et utilisÃ©es tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs dÃ©veloppeurs. Cela permet Ã©galement de
n'avoir qu'un seul endroit de votre code Ã  modifier si cette valeur codÃ©e en dur
doit Ãªtre mise Ã  jour Ã  l'avenir.</p>
<!--
### Shadowing
-->
<h3><a class="header" href="#le-masquage" id="le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in the [â€œComparing the Guess to the
Secret Numberâ€][comparing-the-guess-to-the-secret-number]<!-- ignore -- >
section in Chapter 2, you can declare a new variable with the same name as a
previous variable, and the new variable shadows the previous variable.
Rustaceans say that the first variable is *shadowed* by the second, which means
that the second variableâ€™s value is what appears when the variable is used. We
can shadow a variable by using the same variableâ€™s name and repeating the use
of the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">â€œComparer le nombre saisi au nombre
secretâ€</a><!-- ignore -->
du jeu de devinettes au chapitre 2, on peut dÃ©clarer une nouvelle variable
avec le mÃªme nom qu'une variable prÃ©cÃ©dente, et la nouvelle variable
masquera la premiÃ¨re. Les RustacÃ©s disent que la premiÃ¨re variable est <em>masquÃ©e</em>
par la seconde, ce qui signifie que la valeur de la seconde variable sera ce que
nous obtiendrons lorsque nous utiliserons cette variable. Nous pouvons crÃ©er un
masque d'une variable en utilisant le mÃªme nom de variable et en rÃ©utilisant le
mot-clÃ© <code>let</code> comme ci-dessousÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. The third `let` statement also shadows `x`, multiplying the
previous value by `2` to give `x` a final value of `12`. When we run this
program, it will output the following:
-->
<p>Au dÃ©but, ce programme lie <code>x</code> Ã  la valeur <code>5</code>. Puis il crÃ©e un masque de <code>x</code>
en rÃ©pÃ©tant <code>let x =</code>, en rÃ©cupÃ©rant la valeur d'origine et lui ajoutant <code>1</code>Â :
la valeur de <code>x</code> est dÃ©sormais <code>6</code>. La troisiÃ¨me instruction <code>let</code> crÃ©e un autre
masque de <code>x</code>, en rÃ©cupÃ©rant la prÃ©cÃ©dente valeur et en la multipliant par <code>2</code>
pour donner Ã  <code>x</code> la valeur finale de <code>12</code>. Lorsque nous exÃ©cutons ce programme,
nous obtenons ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x is: 12
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
La valeur de x estÂ : 12
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because weâ€™ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>CrÃ©er un masque est diffÃ©rent que de marquer une variable comme Ã©tant <code>mut</code>,
car Ã  moins d'utiliser une nouvelle fois le mot-clÃ© <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de rÃ©assigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable aprÃ¨s que ces
transformations ont Ã©tÃ© appliquÃ©es.</p>
<!--
The other difference between `mut` and shadowing is that because weâ€™re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:
-->
<p>Comme nous crÃ©ons une nouvelle variable lorsque nous utilisons le mot-clÃ© <code>let</code>
une nouvelle fois, l'autre diffÃ©rence entre le <code>mut</code> et la crÃ©ation d'un masque
est que cela nous permet de changer le type de la valeur, mais en rÃ©utilisant
le mÃªme nom. Par exemple, imaginons un programme qui demande Ã  l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, mais que nous voulons plutÃ´t stocker cela sous forme de nombreÂ :</p>
<!--
```rust
# fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
This construct is allowed because the first `spaces` variable is a string type
and the second `spaces` variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, such as `spaces_str` and
`spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we
try to use `mut` for this, as shown here, weâ€™ll get a compile-time error:
-->
<p>Cette solution est autorisÃ©e car la premiÃ¨re variable <code>espaces</code> est du type
chaÃ®ne de caractÃ¨res <em>(string)</em>, alors que la seconde variable <code>espaces</code>, qui
est une toute nouvelle variable qui se trouve avoir le mÃªme nom que la premiÃ¨re,
est du type nombre. L'utilisation du masquage nous Ã©vite ainsi d'avoir Ã  trouver
des noms diffÃ©rents, comme <code>espaces_str</code> et <code>espaces_num</code>Â ; nous pouvons plutÃ´t
simplement rÃ©utiliser le nom <code>espaces</code>. Cependant, si nous essayons d'utiliser
<code>mut</code> pour faire ceci, comme ci-dessous, nous avons une erreur de compilationÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut espaces = &quot;   &quot;;
    espaces = espaces.len();
<span class="boring">}
</span></code></pre>
<!--
The error says weâ€™re not allowed to mutate a variableâ€™s type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variableÂ :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Now that weâ€™ve explored how variables work, letâ€™s look at more data types they
can have.
-->
<p>Maintenant que nous avons dÃ©couvert comment fonctionnent les variables, Ã©tudions
les types de donnÃ©es qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
-->
<!--
## Data Types
-->
<h2><a class="header" href="#les-types-de-donnÃ©es" id="les-types-de-donnÃ©es">Les types de donnÃ©es</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. Weâ€™ll look at
two data type subsets: scalar and compound.
-->
<p>Chaque valeur en Rust est d'un <em>type</em> bien dÃ©terminÃ©, qui indique Ã  Rust quel
genre de donnÃ©es il manipule pour qu'il sache comment traiter ces donnÃ©es.
Nous allons nous intÃ©resser Ã  deux catÃ©gories de types de donnÃ©esÂ : les
scalaires et les composÃ©s.</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the [â€œComparing the Guess to the Secret
Numberâ€][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Gardez Ã  l'esprit que Rust est langage <em>statiquement typÃ©</em>, ce qui signifie
qu'il doit connaÃ®tre les types de toutes les variables au moment de la
compilation. Le compilateur peut souvent dÃ©duire quel type utiliser en se basant
sur la valeur et sur la faÃ§on dont elle est utilisÃ©e. Dans les cas oÃ¹ plusieurs
types sont envisageables, comme lorsque nous avons converti une chaÃ®ne de
caractÃ¨res en un type numÃ©rique en utilisant <code>parse</code> dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">â€œComparer le nombre saisi au nombre
secretâ€</a><!-- ignore -->
du chapitre 2, nous devons ajouter une annotation de type, comme ceciÂ :</p>
<!--
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let supposition: u32 = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombreÂ !&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
If we donâ€™t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>Si nous n'ajoutons pas l'annotation de type ici, Rust affichera l'erreur
suivante, signifiant que le compilateur a besoin de plus d'informations pour
dÃ©terminer quel type nous souhaitons utiliserÂ :</p>
<!--
```console
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 -- > src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let supposition = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombreÂ !&quot;);
  |         ^^^^^^^^^^^ consider giving `supposition` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Youâ€™ll see different type annotations for other data types.
-->
<p>Vous dÃ©couvrirez diffÃ©rentes annotations de type au fur et Ã  mesure que nous
aborderons les autres types de donnÃ©es.</p>
<!--
### Scalar Types
-->
<h3><a class="header" href="#types-scalaires" id="types-scalaires">Types scalaires</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Letâ€™s jump into how they work in Rust.
-->
<p>Un type <em>scalaire</em> reprÃ©sente une seule valeur. Rust possÃ¨de quatre types
principaux de scalairesÂ : les entiers, les nombres Ã  virgule flottante, les
boolÃ©ens et les caractÃ¨res. Vous les connaissez sÃ»rement d'autres langages de
programmation. Regardons comment ils fonctionnent avec Rust.</p>
<!--
#### Integer Types
-->
<h4><a class="header" href="#types-de-nombres-entiers" id="types-de-nombres-entiers">Types de nombres entiers</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value itâ€™s associated with should be an unsigned integer (signed integer types
start with `i`, instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. Each variant in the Signed and Unsigned
columns (for example, `i16`) can be used to declare the type of an integer
value.
-->
<p>Un <em>entier</em> est un nombre sans partie dÃ©cimale. Nous avons utilisÃ© un entier
prÃ©cÃ©demment dans le chapitre 2, le type <code>u32</code>. Cette dÃ©claration de type
indique que la valeur Ã  laquelle elle est associÃ©e doit Ãªtre un entier non signÃ©
encodÃ© sur 32 bits dans la mÃ©moire (les entiers pouvant prendre des valeurs
nÃ©gatives commencent par un <code>i</code> (comme <em>integer</em>Â : â€œentierâ€), plutÃ´t que par un
<code>u</code> comme <em>unsigned</em>Â : â€œnon signÃ©â€). Le tableau 3-1 montre les types
d'entiers intÃ©grÃ©s au langage. Chaque variante dans les colonnes â€œSignÃ©â€ et
â€œNon signÃ©â€ (par exemple <code>i16</code>) peut Ãªtre utilisÃ©e pour dÃ©clarer le type d'une
valeur entiÃ¨re.</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">Tableau 3-1Â : les types d'entiers en Rust</span></p>
<!--
| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |
-->
<table><thead><tr><th>Taille</th><th>SignÃ©</th><th>Non signÃ©</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>archi</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!-- markdownlint-disable -->
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refer to whether itâ€™s possible for the number to be
negativeâ€”in other words, whether the number needs to have a sign
with it (signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). Itâ€™s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when itâ€™s safe to assume the number is positive, itâ€™s shown with no sign.
Signed numbers are stored using [twoâ€™s complement](https://en.wikipedia.org/wiki/Two%27s_complement) representation.
-->
<!-- markdownlint-restore -->
<p>Chaque variante peut-Ãªtre signÃ©e ou non signÃ©e et possÃ¨de une taille explicite.
<em>SignÃ©</em> et <em>non signÃ©</em> veut dire respectivement que le nombre peut prendre ou
non des valeurs nÃ©gatives â€” en d'autres termes, si l'on peut lui attribuer un
signe (signÃ©) ou s'il sera toujours positif et que l'on peut donc le reprÃ©senter
sans signe (non signÃ©). C'est comme Ã©crire des nombres sur du papierÂ : quand le
signe est important, le nombre est Ã©crit avec un signe plus ou un signe moinsÂ ;
en revanche, quand le nombre est forcÃ©ment positif, on peut l'Ã©crire sans son
signe. Les nombres signÃ©s sont stockÃ©s en utilisant le <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">complÃ©ment Ã 
deux</a>.</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>Chaque variante signÃ©e peut stocker des nombres allant de âˆ’(2<sup><em>n</em> âˆ’ 1</sup>)
Ã  2<sup><em>n</em> âˆ’ 1</sup> âˆ’ 1 inclus, oÃ¹ <em>n</em> est le nombre de bits que cette
variante utilise.
Un <code>i8</code> peut donc stocker des nombres allant de âˆ’(2<sup>7</sup>) Ã 
2<sup>7</sup> âˆ’ 1, c'est-Ã -dire de âˆ’128 Ã  127. Les variantes non signÃ©es peuvent
stocker des nombres de 0 Ã  2<sup><em>n</em></sup> âˆ’ 1, donc un <code>u8</code> peut stocker
des nombres allant de 0 Ã  2<sup>8</sup> âˆ’ 1, c'est-Ã -dire de 0 Ã  255.</p>
<!--
Additionally, the `isize` and `usize` types depend on the kind of computer your
program is running on: 64 bits if youâ€™re on a 64-bit architecture and 32 bits
if youâ€™re on a 32-bit architecture.
-->
<p>De plus, les types <code>isize</code> et <code>usize</code> dÃ©pendent du type d'ordinateur sur lequel
votre programme va s'exÃ©cuterÂ : 64 bits si vous utilisez une architecture
64 bits ou 32 bits si vous utilisez une architecture 32 bits.</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that all number literals except the byte literal allow a type suffix, such as
`57u8`, and `_` as a visual separator, such as `1_000`.
-->
<p>Vous pouvez Ã©crire des littÃ©raux d'entiers dans chacune des formes dÃ©crites dans
le tableau 3-2. Notez que chaque littÃ©ral numÃ©rique exceptÃ© l'octet accepte un
suffixe de type, comme <code>57u8</code>, et <code>_</code> comme sÃ©parateur visuel, comme par exemple
<code>1_000</code>.</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">Tableau 3-2Â : les littÃ©raux d'entiers en Rust</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>LittÃ©ral numÃ©rique</th><th>Exemple</th></tr></thead><tbody>
<tr><td>DÃ©cimal</td><td><code>98_222</code></td></tr>
<tr><td>HexadÃ©cimal</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binaire</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Octet (<code>u8</code> seulement)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If youâ€™re unsure, Rustâ€™s
defaults are generally good choices, and integer types default to `i32`: this
type is generally the fastest, even on 64-bit systems. The primary situation in
which youâ€™d use `isize` or `usize` is when indexing some sort of collection.
-->
<p>Comment pouvez-vous dÃ©terminer le type d'entier Ã  utiliserÂ ? Si vous n'Ãªtes pas
sÃ»r, les choix par dÃ©faut de Rust sont gÃ©nÃ©ralement de bons choix, et le type
d'entier par dÃ©faut est le <code>i32</code>Â : c'est souvent le plus rapide, mÃªme sur les
systÃ¨mes 64 bits. La principale utilisation d'un <code>isize</code> ou d'un <code>usize</code> est
lorsque l'on indexe une quelconque collection.</p>
<!--
> ##### Integer Overflow
>
> Letâ€™s say you have a variable of type `u8` that can hold values between 0 and 255.
> If you try to change the variable to a value outside of that range, such
> as 256, *integer overflow* will occur. Rust has some interesting rules
> involving this behavior. When youâ€™re compiling in debug mode, Rust includes
> checks for integer overflow that cause your program to *panic* at runtime if
> this behavior occurs. Rust uses the term panicking when a program exits with
> an error; weâ€™ll discuss panics in more depth in the [â€œUnrecoverable Errors
> with `panic!`â€][unrecoverable-errors-with-panic]<!-- ignore -- > section in
> Chapter 9.
>
> When youâ€™re compiling in release mode with the `--release` flag, Rust does
> *not* include checks for integer overflow that cause panics. Instead, if
> overflow occurs, Rust performs *twoâ€™s complement wrapping*. In short, values
> greater than the maximum value the type can hold â€œwrap aroundâ€ to the minimum
> of the values the type can hold. In the case of a `u8`, 256 becomes 0, 257
> becomes 1, and so on. The program wonâ€™t panic, but the variable will have a
> value that probably isnâ€™t what you were expecting it to have. Relying on
> integer overflowâ€™s wrapping behavior is considered an error. If you want to
> wrap explicitly, you can use the standard library type [`Wrapping`][wrapping].
-->
<blockquote>
<h5><a class="header" href="#dÃ©passement-dentier" id="dÃ©passement-dentier">DÃ©passement d'entier</a></h5>
<p>Imaginons que vous avez une variable de type <code>u8</code> qui peut stocker des
valeurs entre 0 et 255. Si vous essayez de changer la variable pour une valeur
en dehors de cet intervalle, comme 256, vous aurez un dÃ©passement
d'entier <em>(integer overflow)</em>. Rust possÃ¨de quelques rÃ¨gles intÃ©ressantes
concernant ce comportement. Quand vous compilez en mode dÃ©bogage, Rust
embarque des vÃ©rifications pour dÃ©tecter les cas de dÃ©passements d'entiers qui
pourraient faire <em>paniquer</em> votre programme Ã  l'exÃ©cution si ce phÃ©nomÃ¨ne se
produit. Rust utilise le terme <em>paniquer</em> quand un programme se termine
avec une erreurÂ ; nous verrons plus en dÃ©tail les <em>paniques</em> dans une section
du <a href="ch09-01-unrecoverable-errors-with-panic.html">chapitre 9</a><!-- ignore -->.</p>
<p>Lorsque vous compilez en mode publication <em>(release)</em> avec le drapeau
<code>--release</code>, Rust ne va <em>pas</em> vÃ©rifier les potentiels dÃ©passements d'entiers
qui peuvent faire paniquer le programme. En revanche, en cas de dÃ©passement,
Rust va effectuer un <em>rebouclage du complÃ©ment Ã  deux</em>. Pour faire simple, les
valeurs supÃ©rieures Ã  la valeur maximale du type seront â€œrebouclÃ©esâ€ depuis la
valeur minimale que le type peut stocker. Dans cas d'un <code>u8</code>, 256 devient 0,
257 devient 1, et ainsi de suite. Le programme ne va paniquer, mais
la variable va avoir une valeur qui n'est probablement pas ce que vous
attendez Ã  avoir. Se fier au comportement du rebouclage lors du
dÃ©passement d'entier est considÃ©rÃ© comme une faute. Si vous voulez reboucler
explicitement, vous pouvez utiliser le type <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a> de la
bibliothÃ¨que standard.</p>
</blockquote>
<!--
#### Floating-Point Types
-->
<h4><a class="header" href="#types-de-nombres-Ã -virgule-flottante" id="types-de-nombres-Ã -virgule-flottante">Types de nombres Ã  virgule flottante</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rustâ€™s floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs itâ€™s roughly the same speed as `f32` but is capable of
more precision.
-->
<p>Rust possÃ¨de Ã©galement deux types primitifs pour les <em>nombres Ã  virgule
flottante</em> (ou <em>flottants</em>), qui sont des nombres avec des dÃ©cimales. Les types
de flottants en Rust sont les <code>f32</code> et les <code>f64</code>, qui ont respectivement une
taille en mÃ©moire de 32 bits et 64 bits. Le type par dÃ©faut est le <code>f64</code> car sur
les processeurs rÃ©cents ce type est quasiment aussi rapide qu'un <code>f32</code> mais est
plus prÃ©cis.</p>
<!--
Hereâ€™s an example that shows floating-point numbers in action:
-->
<p>Voici un exemple montrant l'utilisation de nombres Ã  virgule flottanteÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FicherÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>Les nombres Ã  virgule flottante sont reprÃ©sentÃ©s selon la norme IEEE-754. Le
type <code>f32</code> est un flottant Ã  simple prÃ©cision, et le <code>f64</code> est Ã  double
prÃ©cision.</p>
<!--
#### Numeric Operations
-->
<h4><a class="header" href="#les-opÃ©rations-numÃ©riques" id="les-opÃ©rations-numÃ©riques">Les opÃ©rations numÃ©riques</a></h4>
<!--
Rust supports the basic mathematical operations youâ€™d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how youâ€™d use each one in a `let` statement:
-->
<p>Rust offre les opÃ©rations mathÃ©matiques de base dont vous auriez besoin pour
tous les types de nombresÂ : addition, soustraction, multiplication, division et
modulo. Le code suivant montre comment utiliser chacune d'elles avec une
instruction <code>let</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let somme = 5 + 10;

    // soustraction
    let difference = 95.5 - 4.3;

    // multiplication
    let produit = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // modulo
    let reste = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. Appendix B contains a
list of all operators that Rust provides.
-->
<p>Chaque expression de ces instructions utilise un opÃ©rateur mathÃ©matique et
calcule une valeur unique, qui est ensuite attribuÃ©e Ã  une variable. L'annexe B
prÃ©sente une liste de tous les opÃ©rateurs que Rust fournit.</p>
<!--
#### The Boolean Type
-->
<h4><a class="header" href="#le-type-boolÃ©en" id="le-type-boolÃ©en">Le type boolÃ©en</a></h4>
<!--
As in most other programming languages, a Boolean type in Rust has two possible
values: `true` and `false`. Booleans are one byte in size. The Boolean type in
Rust is specified using `bool`. For example:
-->
<p>Comme dans la plupart des langages de programmation, un type boolÃ©en a deux
valeurs possibles en RustÂ : <code>true</code> (vrai) et <code>false</code> (faux). Les boolÃ©ens
prennent un octet en mÃ©moire. Le type boolÃ©en est dÃ©signÃ© en utilisant <code>bool</code>.
Par exempleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // avec une annotation de type explicite
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. Weâ€™ll cover how `if` expressions work in Rust in the [â€œControl
Flowâ€][control-flow]<!-- ignore -- > section.
-->
<p>Les valeurs boolÃ©ennes sont principalement utilisÃ©es par les structures
conditionnelles, comme l'expression <code>if</code>. Nous aborderons le fonctionnement
de <code>if</code> en Rust dans la section
<a href="ch03-05-control-flow.html#les-structures-de-contr%C3%B4le">â€œLes structures de contrÃ´leâ€</a><!-- ignore -->.</p>
<!--
#### The Character Type
-->
<h4><a class="header" href="#le-type-caractÃ¨re" id="le-type-caractÃ¨re">Le type caractÃ¨re</a></h4>
<!--
So far weâ€™ve worked only with numbers, but Rust supports letters too. Rustâ€™s
`char` type is the languageâ€™s most primitive alphabetic type, and the following
code shows one way to use it. (Note that `char` literals are specified with
single quotes, as opposed to string literals, which use double quotes.)
-->
<p>Jusqu'Ã  prÃ©sent, nous avons utilisÃ© uniquement des nombres, mais Rust peut aussi
travailler avec des lettres. Le type <code>char</code> (comme <em>character</em>) est le type de
caractÃ¨re le plus rudimentaire, et le code suivant va vous montrer une faÃ§on de
l'utiliser. (A noter que les <code>char</code> sont Ã©crits avec des guillemets simples,
contrairement aux chaÃ®nes, qui utilisent des guillemets doubles.)</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'â„¤';
    let chat_aux_yeux_de_coeur = 'ğŸ˜»';
}
</code></pre></pre>
<!--
Rustâ€™s `char` type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII. Accented letters;
Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all
valid `char` values in Rust. Unicode Scalar Values range from `U+0000` to
`U+D7FF` and `U+E000` to `U+10FFFF` inclusive. However, a â€œcharacterâ€ isnâ€™t
really a concept in Unicode, so your human intuition for what a â€œcharacterâ€ is
may not match up with what a `char` is in Rust. Weâ€™ll discuss this topic in
detail in [â€œStoring UTF-8 Encoded Text with Stringsâ€][strings]<!-- ignore -- >
in Chapter 8.
-->
<p>Le type <code>char</code> de Rust prend quatre octets en mÃ©moire et reprÃ©sente une valeur
scalaire Unicode, ce qui veut dire que cela reprÃ©sente plus de caractÃ¨res que
l'ASCII. Les lettres accentuÃ©esÂ ; les caractÃ¨res chinois, japonais et corÃ©ensÂ ;
les emojiÂ ; les espaces de largeur nulle ont tous une valeur pour <code>char</code> avec
Rust. Les valeurs scalaires Unicode vont de <code>U+0000</code> Ã  <code>U+D7FF</code> et de <code>U+E000</code> Ã 
<code>U+10FFFF</code> inclus. Cependant, le concept de â€œcaractÃ¨reâ€ n'est pas clairement
dÃ©fini par Unicode, donc votre notion de â€œcaractÃ¨reâ€ peut ne pas correspondre
Ã  ce qu'est un <code>char</code> en Rust. Nous aborderons ce sujet plus en dÃ©tail au
<a href="ch08-02-strings.html">chapitre 8</a><!-- ignore -->.</p>
<!--
### Compound Types
-->
<h3><a class="header" href="#les-types-composÃ©s" id="les-types-composÃ©s">Les types composÃ©s</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p>Les <em>types composÃ©s</em> peuvent regrouper plusieurs valeurs dans un seul type. Rust
a deux types composÃ©s de baseÂ : les <em>tuples</em> et les tableaux <em>(arrays)</em>.</p>
<!--
#### The Tuple Type
-->
<h4><a class="header" href="#le-type-tuple" id="le-type-tuple">Le type <em>tuple</em></a></h4>
<!--
A tuple is a general way of grouping together a number of values with a variety
of types into one compound type. Tuples have a fixed length: once declared,
they cannot grow or shrink in size.
-->
<p>Un <em>tuple</em> est une maniÃ¨re gÃ©nÃ©rale de regrouper plusieurs valeurs
de types diffÃ©rents en un seul type composÃ©. Les tuples ont une taille fixÃ©eÂ :
Ã  partir du moment oÃ¹ ils ont Ã©tÃ© dÃ©clarÃ©s, on ne peut pas y ajouter ou enlever
des valeurs.</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple donâ€™t have to be the same. Weâ€™ve added optional
type annotations in this example:
-->
<p>Nous crÃ©ons un <em>tuple</em> en Ã©crivant une liste sÃ©parÃ©e par des virgules entre des
parenthÃ¨ses. Chaque emplacement dans le tuple a un type, et les types de chacune
des valeurs dans le tuple n'ont pas forcÃ©ment besoin d'Ãªtre les mÃªmes.
Nous avons ajoutÃ© des annotations de type dans cet exemple, mais c'est
optionnelÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>La variable <code>tup</code> est liÃ©e Ã  tout le tuple, car un tuple est considÃ©rÃ©
comme Ã©tant un unique Ã©lÃ©ment composÃ©. Pour obtenir un Ã©lÃ©ment prÃ©cis de ce
tuple, nous pouvons utiliser un filtrage par motif <em>(pattern matching)</em> pour
dÃ©structurer ce tuple, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;La valeur de y estÂ : {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>Le programme commence par crÃ©er un tuple et il l'assigne Ã  la variable <code>tup</code>.
Il utilise ensuite un motif avec <code>let</code> pour prendre <code>tup</code> et le scinder en
trois variables distinctesÂ : <code>x</code>, <code>y</code>, et <code>z</code>.
On appelle cela <em>dÃ©structurer</em>, car il divise le tuple en trois parties.
Puis finalement, le programme affiche la valeur de <code>y</code>, qui est <code>6.4</code>.</p>
<!--
In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (`.`) followed by the index of the value we
want to access. For example:
-->
<p>En plus de pouvoir dÃ©structurer avec un filtrage par motif, nous pouvons accÃ©der
directement Ã  chaque Ã©lÃ©ment du tuple en utilisant un point (<code>.</code>) suivi de
l'indice de la valeur que nous souhaitons obtenir. Par exempleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let cinq_cents = x.0;

    let six_virgule_quatre = x.1;

    let un = x.2;
}
</code></pre></pre>
<!--
This program creates a tuple, `x`, and then makes new variables for each
element by using their respective indices. As with most programming languages,
the first index in a tuple is 0.
-->
<p>Ce programme crÃ©e un tuple, <code>x</code>, puis crÃ©e une nouvelle variable pour
chaque Ã©lÃ©ment en utilisant leur indices respectifs. Comme dans de nombreux
langages de programmation, le premier indice d'un tuple est 0.</p>
<!--
#### The Array Type
-->
<h4><a class="header" href="#le-type-tableau" id="le-type-tableau">Le type tableau</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Arrays in Rust are
different from arrays in some other languages because arrays in Rust have a
fixed length, like tuples.
-->
<p>Un autre moyen d'avoir une collection de plusieurs valeurs est d'utiliser
un <em>tableau</em>. Contrairement aux tuples, chaque Ã©lÃ©ment d'un tableau doit Ãªtre du
mÃªme type. Les tableaux de Rust diffÃ¨rent de ceux de certains autres langages
car les tableaux de Rust ont une taille fixe, comme les tuples.</p>
<!--
In Rust, the values going into an array are written as a comma-separated list
inside square brackets:
-->
<p>Avec Rust, les valeurs stockÃ©es dans un tableau sont Ã©crites dans une
liste sÃ©parÃ©e par des virgules entre des crochetsÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isnâ€™t
as flexible as the vector type, though. A vector is a similar collection type
provided by the standard library that *is* allowed to grow or shrink in size.
If youâ€™re unsure whether to use an array or a vector, you should probably use a
vector. Chapter 8 discusses vectors in more detail.
-->
<p>Les tableaux sont utiles quand vous voulez que vos donnÃ©es soient allouÃ©es sur
la pile <em>(stack)</em> plutÃ´t que sur le tas <em>(heap)</em> (nous expliquerons la pile et
le tas au chapitre 4) ou lorsque vous voulez vous assurer que vous avez toujours
un nombre fixe d'Ã©lÃ©ments. Cependant, un tableau n'est pas aussi flexible qu'un
vecteur <em>(vector)</em>. Un vecteur est un type de collection de donnÃ©es
similaire qui est fourni par la bibliothÃ¨que standard qui, lui, peut
grandir ou rÃ©trÃ©cir en taille. Si vous ne savez pas si vous devez utiliser un
tableau ou un vecteur, vous devriez probablement utiliser un vecteur. Le
chapitre 8 expliquera les vecteurs.</p>
<!--
An example of when you might want to use an array rather than a vector is in a
program that needs to know the names of the months of the year. Itâ€™s very
unlikely that such a program will need to add or remove months, so you can use
an array because you know it will always contain 12 elements:
-->
<p>Un exemple de cas oÃ¹ vous pourriez avoir recours Ã  un tableau plutÃ´t qu'Ã  un
vecteur est un programme qui nÃ©cessite de connaÃ®tre les noms des mois de
l'annÃ©e.
Il est trÃ¨s improbable qu'un tel programme ait besoin d'ajouter ou de supprimer
des mois, donc vous pouvez utiliser un tableau car vous savez qu'il contiendra
toujours 12 Ã©lÃ©mentsÂ :</p>
<!--
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mois = [&quot;Janvier&quot;, &quot;FÃ©vrier&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;,
            &quot;AoÃ»t&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;DÃ©cembre&quot;];
<span class="boring">}
</span></code></pre></pre>
<!--
You would write an arrayâ€™s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:
-->
<p>Vous pouvez Ã©crire le type d'un tableau en utilisant des crochets, et entre ces
crochets y ajouter le type de chaque Ã©lÃ©ment, un point-virgule, et ensuite le
nombre d'Ã©lÃ©ments dans le tableau, comme ceciÂ :</p>
<!--
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the array contains five elements.
-->
<p>Ici, <code>i32</code> est le type de chaque Ã©lÃ©ment. AprÃ¨s le point-virgule, le nombre <code>5</code>
indique que le tableau contient cinq Ã©lÃ©ments.</p>
<!--
Writing an arrayâ€™s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:
-->
<p>L'Ã©criture d'un type de tableau de cette maniÃ¨re ressemble Ã  une autre syntaxe
pour initialiser un tableauÂ : si vous voulez crÃ©er un tableau qui contient la
mÃªme valeur pour chaque Ã©lÃ©ment, vous pouvez prÃ©ciser la valeur initiale, suivie
par un point-virgule, et ensuite la taille du tableau, le tout entre crochets,
comme ci-dessousÂ :</p>
<!--
```rust
let a = [3; 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>Le tableau <code>a</code> va contenir <code>5</code> Ã©lÃ©ments qui auront tous la valeur
initiale <code>3</code>. C'est la mÃªme chose que d'Ã©crire <code>let a = [3, 3, 3, 3, 3];</code> mais
de maniÃ¨re plus concise.</p>
<!--
##### Accessing Array Elements
-->
<h5><a class="header" href="#accÃ©der-aux-Ã©lÃ©ments-dun-tableau" id="accÃ©der-aux-Ã©lÃ©ments-dun-tableau">AccÃ©der aux Ã©lÃ©ments d'un tableau</a></h5>
<!--
An array is a single chunk of memory allocated on the stack. You can access
elements of an array using indexing, like this:
-->
<p>Un tableau est un simple bloc de mÃ©moire allouÃ© sur la pile. Vous pouvez accÃ©der
aux Ã©lÃ©ments d'un tableau en utilisant l'indexation, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let premier = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>Dans cet exemple, la variable qui s'appelle <code>premier</code> aura la valeur <code>1</code>, car
c'est la valeur Ã  l'indice <code>[0]</code> dans le tableau. La variable <code>second</code>
rÃ©cupÃ¨rera la valeur <code>2</code> depuis l'indice <code>[1]</code> du tableau.</p>
<!--
##### Invalid Array Element Access
-->
<h5><a class="header" href="#accÃ¨s-incorrect-Ã -un-Ã©lÃ©ment-dun-tableau" id="accÃ¨s-incorrect-Ã -un-Ã©lÃ©ment-dun-tableau">AccÃ¨s incorrect Ã  un Ã©lÃ©ment d'un tableau</a></h5>
<!--
What happens if you try to access an element of an array that is past the end
of the array? Say you change the example to the following code, which will
compile but exit with an error when it runs:
-->
<p>Que se passe-t-il quand vous essayez d'accÃ©der Ã  un Ã©lÃ©ment d'un tableau qui se
trouve aprÃ¨s la fin du tableauÂ ? Imaginons que vous changiez l'exemple par le
code suivant, qui va compiler mais qui va quitter avec une erreur quand il sera
exÃ©cutÃ©Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,panics
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```
-->
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let indice = 10;

    let element = a[indice];

    println!(&quot;La valeur de l'Ã©lÃ©ment estÂ : {}&quot;, element);
}
</code></pre>
<!--
Running this code using `cargo run` produces the following result:
-->
<p>ExÃ©cuter ce code en utilisant <code>cargo run</code> va donner le rÃ©sultat suivantÂ :</p>
<!--
```console
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
The compilation didnâ€™t produce any errors, but the program resulted in a
*runtime* error and didnâ€™t exit successfully. When you attempt to access an
element using indexing, Rust will check that the index youâ€™ve specified is less
than the array length. If the index is greater than or equal to the array
length, Rust will panic.
-->
<p>La compilation n'a pas produit d'erreur, mais le programme a rencontrÃ© une
erreur <em>Ã  l'exÃ©cution</em> et ne s'est pas terminÃ© avec succÃ¨s. Quand vous essayez
d'accÃ©der Ã  un Ã©lÃ©ment en utilisant l'indexation, Rust va vÃ©rifier que l'indice
que vous avez demandÃ© est plus petit que la taille du tableau. Si l'indice est
supÃ©rieur ou Ã©gal Ã  la taille du tableau, Rust va <em>paniquer</em>.</p>
<!--
This is the first example of Rustâ€™s safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rustâ€™s error handling.
-->
<p>C'est un premier exemple pratique des principes de sÃ©curitÃ© de Rust. Dans de
nombreux langages de bas niveau, ce genre de vÃ©rification n'est pas effectuÃ©e,
et quand vous utilisez un indice incorrect, de la mÃ©moire invalide peut Ãªtre
rÃ©cupÃ©rÃ©e. Rust vous protÃ¨ge de ce genre d'erreur en quittant immÃ©diatement
l'exÃ©cution au lieu de permettre l'accÃ¨s en mÃ©moire et
continuer son dÃ©roulement. Le chapitre 9 expliquera la gestion d'erreurs de
Rust.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[wrapping]: ../std/num/struct.Wrapping.html
-->
<!--
## Functions
-->
<h2><a class="header" href="#les-fonctions" id="les-fonctions">Les fonctions</a></h2>
<!--
Functions are pervasive in Rust code. Youâ€™ve already seen one of the most
important functions in the language: the `main` function, which is the entry
point of many programs. Youâ€™ve also seen the `fn` keyword, which allows you to
declare new functions.
-->
<p>Les fonctions sont omniprÃ©sentes dans le code Rust. Vous avez dÃ©jÃ  vu l'une des
fonctions les plus importantes du langageÂ : la fonction <code>main</code>, qui est le point
d'entrÃ©e de beaucoup de programmes. Vous avez aussi vu le mot-clÃ© <code>fn</code>, qui vous
permet de dÃ©clarer des nouvelles fonctions.</p>
<!--
Rust code uses *snake case* as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Hereâ€™s a program that contains an example function definition:
-->
<p>Le code Rust utilise le <em>snake case</em> comme convention de style de nom des
fonctions et des variables. Avec le <em>snake case</em>, toutes les lettres sont en
minuscule et on utilise des tirets bas pour sÃ©parer les mots. Voici un programme
qui est un exemple de dÃ©finition de fonctionÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    une_autre_fonction();
}

fn une_autre_fonction() {
    println!(&quot;Une autre fonction.&quot;);
}
</code></pre></pre>
<!--
Function definitions in Rust start with `fn` and have a set of parentheses
after the function name. The curly brackets tell the compiler where the
function body begins and ends.
-->
<p>La dÃ©finition d'une fonction avec Rust commence par <code>fn</code> et a une paire de
parenthÃ¨ses aprÃ¨s le nom de la fonction. Les accolades indiquent au compilateur
oÃ¹ le corps de la fonction commence et oÃ¹ il se termine.</p>
<!--
We can call any function weâ€™ve defined by entering its name followed by a set
of parentheses. Because `another_function` is defined in the program, it can be
called from inside the `main` function. Note that we defined `another_function`
*after* the `main` function in the source code; we could have defined it before
as well. Rust doesnâ€™t care where you define your functions, only that theyâ€™re
defined somewhere.
-->
<p>Nous pouvons appeler n'importe quelle fonction que nous avons dÃ©finie en
utilisant son nom, suivi d'une paire de parenthÃ¨ses. Comme <code>une_autre_fonction</code>
est dÃ©finie dans le programme, elle peut Ãªtre appelÃ©e Ã  l'intÃ©rieur de la
fonction <code>main</code>. Remarquez que nous avons dÃ©fini <code>une_autre_fonction</code> <em>aprÃ¨s</em>
la fonction <code>main</code> dans le code sourceÂ ; nous aurions aussi pu la dÃ©finir avant.
Rust ne se soucie pas de l'endroit oÃ¹ vous dÃ©finissez vos fonctions, du moment
qu'elles sont bien dÃ©finies quelque part.</p>
<!--
Letâ€™s start a new binary project named *functions* to explore functions
further. Place the `another_function` example in *src/main.rs* and run it. You
should see the following output:
-->
<p>CrÃ©ons un nouveau projet de binaire qui s'appellera <em>functions</em> afin d'en
apprendre plus sur les fonctions. Ajoutez l'exemple <code>une_autre_fonction</code> dans le
<em>src/main.rs</em> et exÃ©cutez-le. Vous devriez avoir ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Une autre fonction.
</code></pre>
<!--
The lines execute in the order in which they appear in the `main` function.
First, the â€œHello, world!â€ message prints, and then `another_function` is
called and its message is printed.
-->
<p>Les lignes s'exÃ©cutent dans l'ordre dans lequel elles apparaissent dans la
fonction <code>main</code>. D'abord, le message <code>Hello, world!</code> est Ã©crit, et ensuite
<code>une_autre_fonction</code> est appelÃ©e et son message est affichÃ©.</p>
<!--
### Function Parameters
-->
<h3><a class="header" href="#les-paramÃ¨tres-de-fonctions" id="les-paramÃ¨tres-de-fonctions">Les paramÃ¨tres de fonctions</a></h3>
<!--
Functions can also be defined to have *parameters*, which are special variables
that are part of a functionâ€™s signature. When a function has parameters, you
can provide it with concrete values for those parameters. Technically, the
concrete values are called *arguments*, but in casual conversation, people tend
to use the words *parameter* and *argument* interchangeably for either the
variables in a functionâ€™s definition or the concrete values passed in when you
call a function.
-->
<p>Les fonctions peuvent aussi Ãªtre dÃ©finies avec des <em>paramÃ¨tres</em>, qui sont des
variables spÃ©ciales qui font partie de la signature de la fonction. Quand une
fonction a des paramÃ¨tres, vous pouvez lui fournir des valeurs concrÃ¨tes avec
ces paramÃ¨tres. Techniquement, ces valeurs concrÃ¨tes sont appelÃ©es des
<em>arguments</em>, mais dans une conversation courante, on a tendance Ã 
confondre les termes <em>paramÃ¨tres</em> et <em>arguments</em> pour dÃ©signer soit les
variables dans la dÃ©finition d'une fonction, soit les valeurs concrÃ¨tes passÃ©es
quand on appelle une fonction.</p>
<!--
The following rewritten version of `another_function` shows what parameters
look like in Rust:
-->
<p>La version rÃ©Ã©crite de <code>une_autre_fonction</code> montre comment utiliser un paramÃ¨tre
avec RustÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    une_autre_fonction(5);
}

fn une_autre_fonction(x: i32) {
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre></pre>
<!--
Try running this program; you should get the following output:
-->
<p>En exÃ©cutant ce programme, vous devriez obtenir ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
La valeur de x estÂ : 5
</code></pre>
<!--
The declaration of `another_function` has one parameter named `x`. The type of
`x` is specified as `i32`. When `5` is passed to `another_function`, the
`println!` macro puts `5` where the pair of curly brackets were in the format
string.
-->
<p>La dÃ©claration de <code>une_autre_fonction</code> a un paramÃ¨tre nommÃ© <code>x</code>. Le type de
<code>x</code> a Ã©tÃ© dÃ©clarÃ© comme <code>i32</code>. Quand <code>5</code> est passÃ© Ã  <code>une_autre_fonction</code>, la
macro <code>println!</code> place <code>5</code> lÃ  oÃ¹ la paire d'accolades <code>{}</code> a Ã©tÃ© placÃ©e dans la
chaÃ®ne de formatage.</p>
<!--
In function signatures, you *must* declare the type of each parameter. This is
a deliberate decision in Rustâ€™s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what you mean.
-->
<p>Dans la signature d'une fonction, vous <em>devez</em> dÃ©clarer le type de chaque
paramÃ¨tre. C'est un choix dÃ©libÃ©rÃ© de conception de RustÂ : exiger l'annotation
de type dans la dÃ©finition d'une fonction fait en sorte que le compilateur n'a
presque plus besoin que vous les utilisiez autre part pour qu'il comprenne ce
que vous voulez faire.</p>
<!--
When you want a function to have multiple parameters, separate the parameter
declarations with commas, like this:
-->
<p>Lorsque vous souhaitez qu'une fonction ait plusieurs paramÃ¨tres, sÃ©parez les
paramÃ¨tres avec des virgules, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    une_autre_fonction(5, 6);
}

fn une_autre_fonction(x: i32, y: i32) {
    println!(&quot;La valeur de x estÂ : {}&quot;, x);
    println!(&quot;La valeur de y estÂ : {}&quot;, y);
}
</code></pre></pre>
<!--
This example creates a function with two parameters, both of which are `i32`
types. The function then prints the values in both of its parameters. Note that
function parameters donâ€™t all need to be the same type, they just happen to be
in this example.
-->
<p>Cet exemple crÃ©e une fonction avec deux paramÃ¨tres, chacun d'eux sont du type
<code>i32</code>. La fonction affiche ensuite les valeurs de ses deux paramÃ¨tres.
Notez que les paramÃ¨tres des fonctions n'ont pas besoin d'Ãªtre du mÃªme type,
nous sommes dans cette situation uniquement pour les besoins de notre exemple.</p>
<!--
Letâ€™s try running this code. Replace the program currently in your *functions*
projectâ€™s *src/main.rs* file with the preceding example and run it using `cargo
run`:
-->
<p>Essayons d'exÃ©cuter ce code. Remplacez le programme prÃ©sent actuellement dans
votre fichier <em>src/main.rs</em> de votre projet <em>functions</em> par l'exemple prÃ©cÃ©dent
et lancez-le en utilisant <code>cargo run</code>Â :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
La valeur de x estÂ : 5
La valeur de x estÂ : 6
</code></pre>
<!--
Because we called the function with `5` as the value for  `x` and `6` is passed
as the value for `y`, the two strings are printed with these values.
-->
<p>Comme nous avons appelÃ© la fonction avec la valeur <code>5</code> pour <code>x</code> et <code>6</code> pour
<code>y</code>, deux lignes sont affichÃ©es avec ces valeurs.</p>
<!--
### Function Bodies Contain Statements and Expressions
-->
<h3><a class="header" href="#corps-de-fonction-avec-des-instructions-et-des-expressions" id="corps-de-fonction-avec-des-instructions-et-des-expressions">Corps de fonction avec des instructions et des expressions</a></h3>
<!--
Function bodies are made up of a series of statements optionally ending in an
expression. So far, weâ€™ve only covered functions without an ending expression,
but you have seen an expression as part of a statement. Because Rust is an
expression-based language, this is an important distinction to understand.
Other languages donâ€™t have the same distinctions, so letâ€™s look at what
statements and expressions are and how their differences affect the bodies of
functions.
-->
<p>Les corps de fonctions sont constituÃ©s d'une sÃ©rie d'instructions qui se
termine Ã©ventuellement par une expression. Jusqu'Ã  prÃ©sent, nous avons vu des
fonctions sans expression Ã  la fin, mais vous avez dÃ©jÃ  vu une expression faire
partie d'une instruction. Comme Rust est un langage basÃ© sur des expressions,
il est important de faire la distinction. D'autres langages ne font pas de
telles distinctions, donc penchons-nous sur ce que sont les instructions et les
expressions et comment leurs diffÃ©rences influent sur le corps des fonctions.</p>
<!--
Weâ€™ve actually already used statements and expressions. *Statements* are
instructions that perform some action and do not return a value. *Expressions*
evaluate to a resulting value. Letâ€™s look at some examples.
-->
<p>Nous avons dÃ©jÃ  utilisÃ© des instructions et des expressions. Les <em>instructions</em>
effectuent des actions et ne retournent aucune valeur.
Les <em>expressions</em> sont Ã©valuÃ©es pour retourner une valeur comme rÃ©sultat.
Voyons quelques exemples.</p>
<!--
Creating a variable and assigning a value to it with the `let` keyword is a
statement. In Listing 3-1, `let y = 6;` is a statement.
-->
<p>CrÃ©er une variable en lui assignant une valeur avec le mot-clÃ© <code>let</code> constitue
une instruction. Dans l'encart 3-1, <code>let y = 6;</code> est une instruction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let y = 6;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<!-- markdownlint-disable -->
<!--
<span class="caption">Listing 3-1: A `main` function declaration containing one statement</span>
-->
<!-- markdownlint-restore -->
<p><span class="caption">Encart 3-1Â : une fonction <code>main</code> qui contient une
instruction</span></p>
<!--
Function definitions are also statements; the entire preceding example is a
statement in itself.
-->
<p>La dÃ©finition d'une fonction est aussi une instructionÂ ; l'intÃ©gralitÃ© de
l'exemple prÃ©cÃ©dent est une instruction Ã  elle toute seule.</p>
<!--
Statements do not return values. Therefore, you canâ€™t assign a `let` statement
to another variable, as the following code tries to do; youâ€™ll get an error:
-->
<p>Une instruction ne retourne pas de valeur. Ainsi, vous ne pouvez pas assigner
le rÃ©sultat d'une instruction <code>let</code> Ã  une autre variable, comme le code suivant
essaye de le faire, car vous obtiendrez une erreurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = (let y = 6);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<!--
When you run this program, the error youâ€™ll get looks like this:
-->
<p>Quand vous exÃ©cutez ce programme, l'erreur que vous obtenez devrait ressembler Ã 
ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 -- > src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<!--
The `let y = 6` statement does not return a value, so there isnâ€™t anything for
`x` to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write `x = y = 6` and have both `x` and `y` have the value
`6`; that is not the case in Rust.
-->
<p>L'instruction <code>let y = 6</code> ne retourne pas de valeur, donc cela ne peut pas
devenir une valeur de <code>x</code>. Ceci est diffÃ©rent d'autres langages, comme le C ou
Ruby, oÃ¹ l'assignation retourne la valeur de l'assignation. Dans ces
langages, vous pouvez Ã©crire <code>x = y = 6</code> et avoir ainsi <code>x</code> et <code>y</code> qui ont
chacun la valeur <code>6</code>Â ; cela n'est pas possible avec Rust.</p>
<!--
Expressions evaluate to something and make up most of the rest of the code that
youâ€™ll write in Rust. Consider a simple math operation, such as `5 + 6`, which
is an expression that evaluates to the value `11`. Expressions can be part of
statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an
expression that evaluates to the value `6`. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, `{}`, is an expression, for example:
-->
<p>Les expressions sont Ã©valuÃ©es et seront ce que vous Ã©crirez le plus en Rust
(hormis les instructions). Prenez une simple opÃ©ration mathÃ©matique, comme
<code>5 + 6</code>, qui est une expression qui s'Ã©value Ã  la valeur <code>11</code>. Les expressions
peuvent faire partie d'une instructionÂ : dans l'encart 3-1, le <code>6</code> dans
l'instruction <code>let y = 6;</code> est une expression qui s'Ã©value Ã  la valeur <code>6</code>.
L'appel de fonction est aussi une expression. L'appel de macro est une
expression. Le bloc que nous utilisons pour crÃ©er une nouvelle portÃ©e, <code>{}</code>,
est une expression, par exempleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;La valeur de y estÂ : {}&quot;, y);
}
</code></pre></pre>
<!--
This expression:
-->
<p>L'expression suivanteâ€¦</p>
<!--
```rust,ignore
{
    let x = 3;
    x + 1
}
```
-->
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<!--
is a block that, in this case, evaluates to `4`. That value gets bound to `y`
as part of the `let` statement. Note the `x + 1` line without a semicolon at
the end, which is unlike most of the lines youâ€™ve seen so far. Expressions do
not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, which will then not return a value.
Keep this in mind as you explore function return values and expressions next.
-->
<p>â€¦ est un bloc qui, dans ce cas, s'Ã©value Ã  <code>4</code>. Cette valeur est assignÃ©e Ã  <code>y</code>
dans le cadre de l'instruction <code>let</code>. Remarquez la ligne <code>x + 1</code> qui ne se
termine pas par un point-virgule, ce qui est diffÃ©rent de la plupart
des lignes que vous avez vues jusque lÃ . Les expressions n'ont pas de
point-virgule de fin de ligne. Si vous ajoutez un point-virgule Ã  la fin de
l'expression, vous la transformez en instruction, qui ne va donc pas retourner
de valeur. Gardez ceci Ã  l'esprit quand nous aborderons prochainement les
valeurs de retour des fonctions ainsi que les expressions.</p>
<!--
### Functions with Return Values
-->
<h3><a class="header" href="#les-fonctions-qui-retournent-des-valeurs" id="les-fonctions-qui-retournent-des-valeurs">Les fonctions qui retournent des valeurs</a></h3>
<!--
Functions can return values to the code that calls them. We donâ€™t name return
values, but we do declare their type after an arrow (`->`). In Rust, the return
value of the function is synonymous with the value of the final expression in
the block of the body of a function. You can return early from a function by
using the `return` keyword and specifying a value, but most functions return
the last expression implicitly. Hereâ€™s an example of a function that returns a
value:
-->
<p>Les fonctions peuvent retourner des valeurs au code qui les appelle.
Nous ne nommons pas les valeurs de retour, mais nous devons dÃ©clarer
leur type aprÃ¨s une flÃ¨che (<code>-&gt;</code>). En Rust, la valeur de retour de la fonction
est la mÃªme que la valeur de l'expression finale dans le corps de la fonction.
Vous pouvez sortir prÃ©maturÃ©ment d'une fonction en utilisant le mot-clÃ© <code>return</code>
et en prÃ©cisant la valeur de retour, mais la plupart des fonctions vont
retourner implicitement la derniÃ¨re expression.
Voici un exemple d'une fonction qui retourne une valeurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn cinq() -&gt; i32 {
    5
}

fn main() {
    let x = cinq();

    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}
</code></pre></pre>
<!--
There are no function calls, macros, or even `let` statements in the `five`
functionâ€”just the number `5` by itself. Thatâ€™s a perfectly valid function in
Rust. Note that the functionâ€™s return type is specified too, as `-> i32`. Try
running this code; the output should look like this:
-->
<p>Il n'y a pas d'appel de fonction, de macro, ni mÃªme d'instruction <code>let</code> dans la
fonction <code>cinq</code> â€” uniquement le nombre <code>5</code> tout seul. C'est une fonction
parfaitement valide avec Rust. Remarquez que le type de retour de la fonction a
Ã©tÃ© prÃ©cisÃ© aussi, avec <code>-&gt; i32</code>. Essayez d'exÃ©cuter ce codeÂ ; le rÃ©sultat
devrait ressembler Ã  ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
La valeur de x estÂ : 5
</code></pre>
<!--
The `5` in `five` is the functionâ€™s return value, which is why the return type
is `i32`. Letâ€™s examine this in more detail. There are two important bits:
first, the line `let x = five();` shows that weâ€™re using the return value of a
function to initialize a variable. Because the function `five` returns a `5`,
that line is the same as the following:
-->
<p>Le <code>5</code> dans <code>cinq</code> est la valeur de retour de la fonction, ce qui explique le
type de retour de <code>i32</code>. Regardons cela plus en dÃ©tail. Il y a deux Ã©lÃ©ments
importantsÂ : premiÃ¨rement, la ligne <code>let x = cinq();</code> dit que nous utilisons
la valeur de retour de la fonction pour initialiser la variable. Comme la
fonction <code>cinq</code> retourne un <code>5</code>, cette ligne revient Ã  faire ceciÂ :</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Second, the `five` function has no parameters and defines the type of the
return value, but the body of the function is a lonely `5` with no semicolon
because itâ€™s an expression whose value we want to return.
-->
<p>DeuxiÃ¨mement, la fonction <code>cinq</code> n'a pas de paramÃ¨tre et dÃ©clare le type de
valeur de retour, mais le corps de la fonction est un simple <code>5</code> sans
point-virgule car c'est une expression dont nous voulons retourner la valeur.</p>
<!--
Letâ€™s look at another example:
-->
<p>Regardons un autre exempleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<!--
Running this code will print `The value of x is: 6`. But if we place a
semicolon at the end of the line containing `x + 1`, changing it from an
expression to a statement, weâ€™ll get an error.
-->
<p>ExÃ©cuter ce code va afficher <code>La valeur de x estÂ : 6</code>. Mais si nous ajoutons un
point-virgule Ã  la fin de la ligne qui contient <code>x + 1</code>, ce qui la transforme
d'une expression Ã  une instruction, nous obtenons une erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x estÂ : {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<!--
Compiling this code produces an error, as follows:
-->
<p>Compiler ce code va produire une erreur, comme ci-dessousÂ :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 -- > src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_un(x: i32) -&gt; i32 {
  |    -------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The main error message, â€œmismatched types,â€ reveals the core issue with this
code. The definition of the function `plus_one` says that it will return an
`i32`, but statements donâ€™t evaluate to a value, which is expressed by `()`,
an empty tuple. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.
-->
<p>Le message d'erreur principal, â€œmismatched typesâ€ <em>(types inadÃ©quats)</em> donne le
cÅ“ur du problÃ¨me de ce code. La dÃ©finition de la fonction <code>plus_un</code> dit qu'elle
va retourner un <code>i32</code>, mais les instructions ne retournent pas de valeur, ceci
est donc reprÃ©sentÃ© par <code>()</code>, un <em>tuple</em> vide. Par consÃ©quent, rien n'est
retournÃ©, ce qui contredit la dÃ©finition de la fonction et provoque une erreur.
Rust affiche un message qui peut aider Ã  corriger ce problÃ¨meÂ : il suggÃ¨re
d'enlever le point-virgule, ce qui va rÃ©soudre notre problÃ¨me.</p>
<!--
## Comments
-->
<h2><a class="header" href="#les-commentaires" id="les-commentaires">Les commentaires</a></h2>
<!--
All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave notes, or
*comments*, in their source code that the compiler will ignore but people
reading the source code may find useful.
-->
<p>Tous les dÃ©veloppeurs s'efforcent de rendre leur code facile Ã  comprendre, mais
parfois il est nÃ©cessaire d'Ã©crire des explications supplÃ©mentaires.
Dans ce cas, les dÃ©veloppeurs laissent des notes, appelÃ©es <em>commentaires</em>, dans
leur code source que le compilateur va ignorer mais qui peuvent Ãªtre utiles
pour les personnes qui lisent le code source.</p>
<!--
Hereâ€™s a simple comment:
-->
<p>Voici un simple commentaireÂ :</p>
<!--
```rust
// hello, world
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust, the idiomatic comment style starts a comment with two slashes, and the
comment continues until the end of the line. For comments that extend beyond a
single line, youâ€™ll need to include `//` on each line, like this:
-->
<p>Avec Rust, les commentaires classiques commencent avec deux barres obliques et
continuent jusqu'Ã  la fin de la ligne. Pour les commentaires qui font plus
d'une seule ligne, vous aurez besoin d'ajouter <code>//</code> sur chaque ligne, comme
ceciÂ :</p>
<!--
```rust
// So weâ€™re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain whatâ€™s going on.
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Donc ici on fait quelque chose de compliquÃ©, tellement long que nous avons
// besoin de plusieurs lignes de commentaires pour le faireÂ ! Heureusement,
// ce commentaire va expliquer ce qui se passe.
<span class="boring">}
</span></code></pre></pre>
<!--
Comments can also be placed at the end of lines containing code:
-->
<p>Les commentaires peuvent aussi Ãªtre aussi ajoutÃ©s Ã  la fin d'une ligne qui
contient du codeÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let lucky_number = 7; // Iâ€™m feeling lucky today
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_chanceux = 7; // Je me sens chanceux aujourd'hui
}
</code></pre></pre>
<!--
But youâ€™ll more often see them used in this format, with the comment on a
separate line above the code itâ€™s annotating:
-->
<p>Mais parfois, vous pourrez les voir utilisÃ©s de cette maniÃ¨re, avec le
commentaire sur une ligne sÃ©parÃ©e au-dessus du code qu'il annoteÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    // Iâ€™m feeling lucky today
    let lucky_number = 7;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Je me sens chanceux aujourd'hui
    let nombre_chanceux = 7;
}
</code></pre></pre>
<!--
Rust also has another kind of comment, documentation comments, which weâ€™ll
discuss in the â€œPublishing a Crate to Crates.ioâ€ section of Chapter 14.
-->
<p>Rust a aussi un autre type de commentaire, les commentaires de documentation,
que nous aborderons au chapitre 14.</p>
<!--
## Control Flow
-->
<h2><a class="header" href="#les-structures-de-contrÃ´le" id="les-structures-de-contrÃ´le">Les structures de contrÃ´le</a></h2>
<!--
Deciding whether or not to run some code depending on if a condition is true
and deciding to run some code repeatedly while a condition is true are basic
building blocks in most programming languages. The most common constructs that
let you control the flow of execution of Rust code are `if` expressions and
loops.
-->
<p>Choisir d'exÃ©cuter ou non du code selon qu'une condition est vÃ©rifiÃ©e et
choisir d'exÃ©cuter du code de faÃ§on rÃ©pÃ©tÃ©e tant qu'une condition est vÃ©rifiÃ©e
sont des constructions Ã©lÃ©mentaires dans la plupart des langages de
programmation. Les structures de contrÃ´le les plus courantes en Rust sont les
expressions <code>if</code> et les boucles.</p>
<!--
### `if` Expressions
-->
<h3><a class="header" href="#les-expressions-if" id="les-expressions-if">Les expressions <code>if</code></a></h3>
<!--
An `if` expression allows you to branch your code depending on conditions. You
provide a condition and then state, â€œIf this condition is met, run this block
of code. If the condition is not met, do not run this block of code.â€
-->
<p>Une expression <code>if</code> vous permet de diviser votre code en fonction de conditions.
Vous prÃ©cisez une condition et vous choisissez ensuiteÂ : â€œSi cette condition est
remplie, alors exÃ©cuter ce bloc de code. Si la condition n'est pas remplie,
ne pas exÃ©cuter ce bloc de code.â€</p>
<!--
Create a new project called *branches* in your *projects* directory to explore
the `if` expression. In the *src/main.rs* file, input the following:
-->
<p>CrÃ©ez un nouveau projet appelÃ© <em>branches</em> dans votre dossier <em>projects</em> pour
dÃ©couvrir les expressions <code>if</code>. Dans le fichier <em>src/main.rs</em>, Ã©crivez ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre &lt; 5 {
        println!(&quot;La condition est vÃ©rifiÃ©e&quot;);
    } else {
        println!(&quot;La condition n'est pas vÃ©rifiÃ©e&quot;);
    }
}
</code></pre></pre>
<!--
All `if` expressions start with the keyword `if`, which is followed by a
condition. In this case, the condition checks whether or not the variable
`number` has a value less than 5. The block of code we want to execute if the
condition is true is placed immediately after the condition inside curly
brackets. Blocks of code associated with the conditions in `if` expressions are
sometimes called *arms*, just like the arms in `match` expressions that we
discussed in the [â€œComparing the Guess to the Secret
Numberâ€][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section of
Chapter 2.
-->
<p>Une expression <code>if</code> commence par le mot-clÃ© <code>if</code>, suivi d'une condition.
Dans notre cas, la condition vÃ©rifie si oui ou non la variable <code>nombre</code> a une
valeur infÃ©rieure Ã  5. Le bloc de code que nous voulons exÃ©cuter si la condition
est vÃ©rifiÃ©e est placÃ© immÃ©diatement aprÃ¨s la condition entre des accolades.
Les blocs de code associÃ©s Ã  une condition dans une expression <code>if</code> sont parfois
appelÃ©s des <em>branches</em>, exactement comme les branches dans les expressions
<code>match</code> que nous avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">â€œComparer le nombre saisi au
nombre secretâ€</a><!-- ignore --> du
chapitre 2.</p>
<!--
Optionally, we can also include an `else` expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you donâ€™t provide an `else` expression and
the condition is false, the program will just skip the `if` block and move on
to the next bit of code.
-->
<p>Ã‰ventuellement, vous pouvez aussi ajouter une expression <code>else</code>, ce que nous
avons fait ici, pour prÃ©ciser un bloc alternatif de code qui sera exÃ©cutÃ© dans
le cas oÃ¹ la condition est fausse (elle n'est pas vÃ©rifiÃ©e). Si
vous ne renseignez pas d'expression <code>else</code> et que la condition n'est pas
vÃ©rifiÃ©e, le programme va simplement sauter le bloc de <code>if</code> et passer au
prochain morceau de code.</p>
<!--
Try running this code; you should see the following output:
-->
<p>Essayez d'exÃ©cuter ce codeÂ ; vous verrez ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition est vÃ©rifiÃ©e
</code></pre>
<!--
Letâ€™s try changing the value of `number` to a value that makes the condition
`false` to see what happens:
-->
<p>Essayons de changer la valeur de <code>nombre</code> pour une valeur qui rend la condition
non vÃ©rifiÃ©e pour voir ce qui se passeÂ :</p>
<!--
```rust,ignore
# fn main() {
    let number = 7;
# 
#     if number < 5 {
#         println!("condition was true");
#     } else {
#         println!("condition was false");
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let nombre = 7;
<span class="boring">
</span><span class="boring">    if nombre &lt; 5 {
</span><span class="boring">        println!(&quot;La condition est vÃ©rifiÃ©e&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;La condition n'est pas vÃ©rifiÃ©e&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the program again, and look at the output:
-->
<p>ExÃ©cutez Ã  nouveau le programme, et regardez le rÃ©sultatÂ :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition n'est pas vÃ©rifiÃ©e
</code></pre>
<!--
Itâ€™s also worth noting that the condition in this code *must* be a `bool`. If
the condition isnâ€™t a `bool`, weâ€™ll get an error. For example, try running the
following code:
-->
<p>Il est aussi intÃ©ressant de noter que la condition dans ce code <em>doit</em> Ãªtre un
<code>bool</code>. Si la condition n'est pas un <code>bool</code>, nous aurons une erreur. Par
exemple, essayez d'exÃ©cuter le code suivantÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombre = 3;

    if nombre {
        println!(&quot;Le nombre Ã©tait trois&quot;);
    }
}
</code></pre>
<!--
The `if` condition evaluates to a value of `3` this time, and Rust throws an
error:
-->
<p>La condition <code>if</code> vaut <code>3</code> cette fois, et Rust lÃ¨ve une erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 -- > src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if nombre {
  |        ^^^^^^ expected bool, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error indicates that Rust expected a `bool` but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
`if` with a Boolean as its condition. If we want the `if` code block to run
only when a number is not equal to `0`, for example, we can change the `if`
expression to the following:
-->
<p>Cette erreur explique que Rust attendait un <code>bool</code> mais a obtenu un entier
<em>(integer)</em>. Contrairement Ã  des langages comme Ruby et JavaScript, Rust
ne va pas essayer de convertir automatiquement les types non boolÃ©ens en
boolÃ©ens. Vous devez Ãªtre prÃ©cis et toujours fournir un boolÃ©en Ã  la condition
d'un <code>if</code>. Si nous voulons que le bloc de code du <code>if</code> soit exÃ©cutÃ© quand le
nombre est diffÃ©rent de <code>0</code>, par exemple, nous pouvons changer l'expression <code>if</code>
par la suivanteÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre != 0 {
        println!(&quot;Le nombre valait autre chose que zÃ©ro&quot;);
    }
}
</code></pre></pre>
<!--
Running this code will print `number was something other than zero`.
-->
<p>ExÃ©cuter ce code va bien afficher <code>Le nombre valait autre chose que zÃ©ro</code>.</p>
<!--
#### Handling Multiple Conditions with `else if`
-->
<h4><a class="header" href="#gÃ©rer-plusieurs-conditions-avec-else-if" id="gÃ©rer-plusieurs-conditions-avec-else-if">GÃ©rer plusieurs conditions avec <code>else if</code></a></h4>
<!--
You can have multiple conditions by combining `if` and `else` in an `else if`
expression. For example:
-->
<p>Vous pouvez utiliser plusieurs conditions en combinant <code>if</code> et <code>else</code> dans une
expression <code>else if</code>. Par exempleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 6;

    if nombre % 4 == 0 {
        println!(&quot;Le nombre est divisible par 4&quot;);
    } else if nombre % 3 == 0 {
        println!(&quot;Le nombre est divisible par 3&quot;);
    } else if nombre % 2 == 0 {
        println!(&quot;Le nombre est divisible par 2&quot;);
    } else {
        println!(&quot;Le nombre n'est pas divisible par 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<!--
This program has four possible paths it can take. After running it, you should
see the following output:
-->
<p>Ce programme peut choisir entre quatre chemins diffÃ©rents. AprÃ¨s l'avoir
exÃ©cutÃ©, vous devriez voir le rÃ©sultat suivantÂ :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Le nombre est divisible par 3
</code></pre>
<!--
When this program executes, it checks each `if` expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we donâ€™t see the output `number is divisible by 2`, nor do we
see the `number is not divisible by 4, 3, or 2` text from the `else` block.
Thatâ€™s because Rust only executes the block for the first true condition, and
once it finds one, it doesnâ€™t even check the rest.
-->
<p>Quand ce programme s'exÃ©cute, il vÃ©rifie chaque expression <code>if</code> Ã  tour de rÃ´le
et exÃ©cute le premier bloc dont la condition est vÃ©rifiÃ©e. Notez que mÃªme si 6
est divisible par 2, nous ne voyons pas le message <code>Le nombre est divisible par 2</code>, ni le message <code>Le nombre n'est pas divisible par 4, 3 ou 2</code> du bloc <code>else</code>.
C'est parce que Rust n'exÃ©cute que le bloc de la premiÃ¨re condition vÃ©rifiÃ©e,
et dÃ¨s lors qu'il en a trouvÃ© une, il ne va pas chercher Ã  vÃ©rifier les
suivantes.</p>
<!--
Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.
-->
<p>Utiliser trop d'expressions <code>else if</code> peut encombrer votre code, donc si vous
en avez plus d'une, vous devriez envisager de remanier votre code. Le chapitre 6
prÃ©sente une construction puissante appelÃ©e <code>match</code> pour de tels cas.</p>
<!--
#### Using `if` in a `let` Statement
-->
<h4><a class="header" href="#utiliser-if-dans-une-instruction-let" id="utiliser-if-dans-une-instruction-let">Utiliser <code>if</code> dans une instruction <code>let</code></a></h4>
<!--
Because `if` is an expression, we can use it on the right side of a `let`
statement, as in Listing 3-2.
-->
<p>Comme <code>if</code> est une expression, nous pouvons l'utiliser Ã  droite d'une
instruction <code>let</code>, comme dans l'encart 3-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let nombre = if condition { 5 } else { 6 };

    println!(&quot;La valeur du nombre estÂ : {}&quot;, nombre);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span>
-->
<p><span class="caption">Encart 3-2Â : assigner le rÃ©sultat d'une expression <code>if</code> Ã 
une variable</span></p>
<!--
The `number` variable will be bound to a value based on the outcome of the `if`
expression. Run this code to see what happens:
-->
<p>La variable <code>nombre</code> va avoir la valeur du rÃ©sultat de l'expression <code>if</code>.
ExÃ©cutez ce code pour dÃ©couvrir ce qui va se passerÂ :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
La valeur du nombre estÂ : 5
</code></pre>
<!--
Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole `if` expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the `if` must be
the same type; in Listing 3-2, the results of both the `if` arm and the `else`
arm were `i32` integers. If the types are mismatched, as in the following
example, weâ€™ll get an error:
-->
<p>Souvenez-vous que les blocs de code s'exÃ©cutent jusqu'Ã  la derniÃ¨re expression
qu'ils contiennent, et que les nombres tout seuls sont aussi des expressions.
Dans notre cas, la valeur de toute l'expression <code>if</code> dÃ©pend de quel bloc de code
elle va exÃ©cuter. Cela veut dire que chaque valeur qui peut Ãªtre le rÃ©sultat de
chaque branche du <code>if</code> doivent Ãªtre du mÃªme typeÂ ; dans l'encart 3-2, les
rÃ©sultats des branches <code>if</code> et <code>else</code> sont tous deux des entiers <code>i32</code>. Si
les types ne sont pas identiques, comme dans l'exemple suivant, nous allons
obtenir une erreurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let nombre = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;La valeur du nombre estÂ : {}&quot;, nombre);
}
</code></pre>
<!--
When we try to compile this code, weâ€™ll get an error. The `if` and `else` arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons une erreur. Les
branches <code>if</code> et <code>else</code> ont des types de valeurs qui ne sont pas compatibles, et
Rust indique exactement oÃ¹ trouver le problÃ¨me dans le programmeÂ :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: if and else have incompatible types
 -- > src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let nombre = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The expression in the `if` block evaluates to an integer, and the expression in
the `else` block evaluates to a string. This wonâ€™t work because variables must
have a single type. Rust needs to know at compile time what type the `number`
variable is, definitively, so it can verify at compile time that its type is
valid everywhere we use `number`. Rust wouldnâ€™t be able to do that if the type
of `number` was only determined at runtime; the compiler would be more complex
and would make fewer guarantees about the code if it had to keep track of
multiple hypothetical types for any variable.
-->
<p>L'expression dans le bloc <code>if</code> donne un entier, et l'expression dans le bloc
<code>else</code> donne une chaÃ®ne de caractÃ¨res. Ceci ne fonctionne pas car les variables
doivent avoir un seul type. Rust a besoin de savoir de quel type est la variable
<code>nombre</code> au moment de la compilation, assurÃ©ment, afin de vÃ©rifier au moment
de la compilation que son type est valable n'importe oÃ¹ nous utilisons <code>nombre</code>.
Rust ne serait pas capable de faire cela si le type de <code>nombre</code> Ã©tait dÃ©terminÃ©
uniquement Ã  l'exÃ©cutionÂ ; car le compilateur deviendrait plus complexe et nous
donnerait moins de garanties sur le code s'il devait prendre en compte tous les
types hypothÃ©tiques pour une variable.</p>
<!--
### Repetition with Loops
-->
<h3><a class="header" href="#les-rÃ©pÃ©titions-avec-les-boucles" id="les-rÃ©pÃ©titions-avec-les-boucles">Les rÃ©pÃ©titions avec les boucles</a></h3>
<!--
Itâ€™s often useful to execute a block of code more than once. For this task,
Rust provides several *loops*. A loop runs through the code inside the loop
body to the end and then starts immediately back at the beginning. To
experiment with loops, letâ€™s make a new project called *loops*.
-->
<p>Il est parfois utile d'exÃ©cuter un bloc de code plus d'une seule fois. Dans ce
but, Rust propose plusieurs types de <em>boucles</em>. Une boucle parcourt le code Ã 
l'intÃ©rieur du corps de la boucle jusqu'Ã  la fin et recommence immÃ©diatement du
dÃ©but. Pour tester les boucles, crÃ©ons un nouveau projet appelÃ© <em>loops</em>.</p>
<!--
Rust has three kinds of loops: `loop`, `while`, and `for`. Letâ€™s try each one.
-->
<p>Rust a trois types de bouclesÂ : <code>loop</code>, <code>while</code>, et <code>for</code>. Essayons chacune
d'elles.</p>
<!--
#### Repeating Code with `loop`
-->
<h4><a class="header" href="#rÃ©pÃ©ter-du-code-avec-loop" id="rÃ©pÃ©ter-du-code-avec-loop">RÃ©pÃ©ter du code avec <code>loop</code></a></h4>
<!--
The `loop` keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.
-->
<p>Le mot-clÃ© <code>loop</code> demande Ã  Rust d'exÃ©cuter un bloc de code encore et encore
jusqu'Ã  l'infini ou jusqu'Ã  ce que vous lui demandiez explicitement de
s'arrÃªter.</p>
<!--
As an example, change the *src/main.rs* file in your *loops* directory to look
like this:
-->
<p>Par exemple, changez le fichier <em>src/main.rs</em> dans votre dossier <em>loops</em> comme
ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;Ã€ nouveauÂ !&quot;);
    }
}
</code></pre>
<!--
When we run this program, weâ€™ll see `again!` printed over and over continuously
until we stop the program manually. Most terminals support a keyboard shortcut,
<span class="keystroke">ctrl-c</span>, to interrupt a program that is stuck in
a continual loop. Give it a try:
-->
<p>Quand nous exÃ©cutons ce programme, nous voyons <code>Ã€ nouveauÂ !</code> s'afficher encore
et encore en continu jusqu'Ã  ce qu'on arrÃªte le programme manuellement. La
plupart des terminaux utilisent un raccourci clavier, <span class="keystroke">
ctrl-c</span>, pour arrÃªter un programme qui est bloquÃ© dans une boucle infinie.
Essayons celaÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-- >
-->
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
Ã€ nouveauÂ !
Ã€ nouveauÂ !
Ã€ nouveauÂ !
Ã€ nouveauÂ !
^CÃ€ nouveauÂ !
</code></pre>
<!--
The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word `again!` printed after the `^C`,
depending on where the code was in the loop when it received the interrupt
signal.
-->
<p>Le symbole <code>^C</code> reprÃ©sente le moment oÃ¹ vous avez appuyÃ© sur
<span class="keystroke">ctrl-c</span>. Vous devriez voir ou non le texte
<code>Ã€ nouveauÂ !</code> aprÃ¨s le <code>^C</code>, en fonction de lÃ  oÃ¹ la boucle en Ã©tait dans votre
code quand elle a reÃ§u le signal d'arrÃªt.</p>
<!--
Fortunately, Rust provides another, more reliable way to break out of a loop.
You can place the `break` keyword within the loop to tell the program when to
stop executing the loop. Recall that we did this in the guessing game in the
[â€œQuitting After a Correct Guessâ€][quitting-after-a-correct-guess]<!-- ignore
-- > section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.
-->
<p>Heureusement, Rust fournit un autre moyen, plus fiable, de sortir d'une boucle.
Vous pouvez ajouter le mot-clÃ© <code>break</code> Ã  l'intÃ©rieur de la boucle pour demander
au programme d'arrÃªter la boucle. Souvenez-vous que nous avions fait ceci dans
le jeu de devinettes, dans la section <a href="ch02-00-guessing-game-tutorial.html#arr%C3%AAter-le-programme-apr%C3%A8s-avoir-gagn%C3%A9">â€œArrÃªter le programme aprÃ¨s avoir
gagnÃ©â€</a><!-- ignore --> du chapitre 2 afin de
quitter le programme quand l'utilisateur gagne le jeu en devinant le bon nombre.</p>
<!--
#### Returning Values from Loops
-->
<h4><a class="header" href="#retourner-des-valeurs-dune-boucle" id="retourner-des-valeurs-dune-boucle">Retourner des valeurs d'une boucle</a></h4>
<!--
One of the uses of a `loop` is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the `break` expression you use to stop
the loop; that value will be returned out of the loop so you can use it, as
shown here:
-->
<p>L'une des utilisations d'une boucle <code>loop</code> est de rÃ©essayer une opÃ©ration qui
peut Ã©chouer, comme vÃ©rifier si une tÃ¢che a terminÃ© son travail. Cependant, vous
aurez peut-Ãªtre besoin de passer le rÃ©sultat de l'opÃ©ration au reste de votre
code. Pour ce faire, vous pouvez ajouter la valeur que vous voulez retourner
aprÃ¨s l'expression <code>break</code> que vous utilisez pour stopper la boucleÂ ; cette
valeur sera retournÃ©e de la boucle pour que vous puissiez l'utiliser, comme
ci-dessousÂ :</p>
<!--
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;

    let resultat = loop {
        compteur += 1;

        if compteur == 10 {
            break compteur * 2;
        }
    };

    println!(&quot;Le rÃ©sultat est {}&quot;, resultat);
}
</code></pre></pre>
<!--
Before the loop, we declare a variable named `counter` and initialize it to
`0`. Then we declare a variable named `result` to hold the value returned from
the loop. On every iteration of the loop, we add `1` to the `counter` variable,
and then check whether the counter is equal to `10`. When it is, we use the
`break` keyword with the value `counter * 2`. After the loop, we use a
semicolon to end the statement that assigns the value to `result`. Finally, we
print the value in `result`, which in this case is 20.
-->
<p>Avant la boucle, nous dÃ©clarons une variable avec le nom <code>compteur</code> et nous
l'initialisons Ã  <code>0</code>. Ensuite, nous dÃ©clarons une variable <code>resultat</code> pour
stocker la valeur retournÃ©e de la boucle. Ã€ chaque itÃ©ration de la boucle, nous
ajoutons <code>1</code> Ã  la variable <code>compteur</code>, et ensuite nous vÃ©rifions si le compteur
est Ã©gal Ã  <code>10</code>. Lorsque c'est le cas, nous utilisons le mot-clÃ© <code>break</code> avec la
valeur <code>compteur * 2</code>. AprÃ¨s la boucle, nous utilisons un point-virgule pour
terminer l'instruction qui assigne la valeur Ã  <code>resultat</code>. Enfin, nous
affichons la valeur de <code>resultat</code>, qui est 20 dans ce cas-ci.</p>
<!--
#### Conditional Loops with `while`
-->
<h4><a class="header" href="#les-boucles-conditionnelles-avec-while" id="les-boucles-conditionnelles-avec-while">Les boucles conditionnelles avec <code>while</code></a></h4>
<!--
Itâ€™s often useful for a program to evaluate a condition within a loop. While
the condition is true, the loop runs. When the condition ceases to be true, the
program calls `break`, stopping the loop. This loop type could be implemented
using a combination of `loop`, `if`, `else`, and `break`; you could try that
now in a program, if youâ€™d like.
-->
<p>Il est souvent utile pour un programme d'Ã©valuer une condition dans une boucle.
Tant que la condition est vraie, la boucle tourne. Quand la condition arrÃªte
d'Ãªtre vraie, le programme appelle <code>break</code>, ce qui arrÃªte la boucle. Ce type de
boucle peut Ãªtre implÃ©mentÃ© en combinant <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code>Â ; vous
pouvez essayer de le faire, si vous voulez.</p>
<!--
However, this pattern is so common that Rust has a built-in language construct
for it, called a `while` loop. Listing 3-3 uses `while`: the program loops
three times, counting down each time, and then, after the loop, it prints
another message and exits.
-->
<p>Cependant, cette utilisation est si frÃ©quente que Rust a une construction pour
cela, intÃ©grÃ©e dans le langage, qui s'appelle une boucle <code>while</code>. L'encart 3-3
utilise <code>while</code>Â : le programme va boucler trois fois, en dÃ©crÃ©mentant Ã  chaque
fois, et ensuite, aprÃ¨s la boucle, il va afficher un message et se fermer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut nombre = 3;

    while nombre != 0 {
        println!(&quot;{}Â !&quot;, nombre);

        nombre -= 1;
    }

    println!(&quot;DÃ‰COLLAGEÂ !!!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-3: Using a `while` loop to run code while a
condition holds true</span>
-->
<p><span class="caption">Encart 3-3: utiliser une boucle <code>while</code> pour exÃ©cuter du
code tant qu'une condition est vraie</span></p>
<!--
This construct eliminates a lot of nesting that would be necessary if you used
`loop`, `if`, `else`, and `break`, and itâ€™s clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.
-->
<p>Cette construction Ã©limine beaucoup d'imbrications qui seraient nÃ©cessaires si
vous utilisiez <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code>, et c'est aussi plus clair. Tant
que la condition est vraie, le code est exÃ©cutÃ©Â ; sinon, il quitte la boucle.</p>
<!--
#### Looping Through a Collection with `for`
-->
<h4><a class="header" href="#boucler-dans-une-collection-avec-for" id="boucler-dans-une-collection-avec-for">Boucler dans une collection avec <code>for</code></a></h4>
<!--
You could use the `while` construct to loop over the elements of a collection,
such as an array. For example, letâ€™s look at Listing 3-4.
-->
<p>Vous pouvez utiliser la construction <code>while</code> pour itÃ©rer sur les
Ã©lÃ©ments d'une collection, comme les tableaux. Par exemple, analysons l'encart
3-4.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;La valeur estÂ : {}&quot;, a[indice]);

        indice += 1;
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-4: Looping through each element of a collection
using a `while` loop</span>
-->
<p><span class="caption">Encart 3-4Â : itÃ©ration sur les Ã©lÃ©ments d'une collection
en utilisant une boucle <code>while</code></span></p>
<!--
Here, the code counts up through the elements in the array. It starts at index
`0`, and then loops until it reaches the final index in the array (that is,
when `index < 5` is no longer true). Running this code will print every element
in the array:
-->
<p>Ici, le code parcourt le tableau Ã©lÃ©ment par Ã©lÃ©ment.
Il commence Ã  l'indice <code>0</code>, et ensuite boucle jusqu'Ã  ce qu'il atteigne l'indice
final du tableau (ce qui correspond au moment oÃ¹ la condition <code>index &lt; 5</code> n'est
plus vraie). ExÃ©cuter ce code va afficher chaque Ã©lÃ©ment du tableauÂ :</p>
<!--
```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```
-->
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
La valeur estÂ : 10
La valeur estÂ : 20
La valeur estÂ : 30
La valeur estÂ : 40
La valeur estÂ : 50
</code></pre>
<!--
All five array values appear in the terminal, as expected. Even though `index`
will reach a value of `5` at some point, the loop stops executing before trying
to fetch a sixth value from the array.
-->
<p>Les cinq valeurs du tableau s'affichent toutes dans le terminal, comme attendu.
MÃªme si <code>indice</code> va atteindre la valeur <code>5</code> Ã  un moment, la boucle arrÃªtera de
s'exÃ©cuter avant d'essayer de rÃ©cupÃ©rer une sixiÃ¨me valeur du tableau.</p>
<!--
But this approach is error prone; we could cause the program to panic if the
index length is incorrect. Itâ€™s also slow, because the compiler adds runtime
code to perform the conditional check on every element on every iteration
through the loop.
-->
<p>Mais cette approche pousse Ã  l'erreurÂ ; nous pourrions faire paniquer le
programme si l'indice est trop grand. De plus, c'est lent, car le compilateur
ajoute du code Ã  l'exÃ©cution pour effectuer des vÃ©rifications sur chaque Ã©lÃ©ment
Ã  chaque itÃ©ration de la boucle.</p>
<!--
As a more concise alternative, you can use a `for` loop and execute some code
for each item in a collection. A `for` loop looks like the code in Listing 3-5.
-->
<p>Pour une alternative plus concise, vous pouvez utiliser une boucle <code>for</code> et
exÃ©cuter du code pour chaque Ã©lÃ©ment dans une collection. Une boucle <code>for</code>
s'utilise comme dans le code de l'encart 3-5.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;La valeur estÂ : {}&quot;, element);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-5: Looping through each element of a collection
using a `for` loop</span>
-->
<p><span class="caption">Encart 3-5Â : itÃ©rer sur chaque Ã©lÃ©ment d'une collection
en utilisant une boucle <code>for</code></span></p>
<!--
When we run this code, weâ€™ll see the same output as in Listing 3-4. More
importantly, weâ€™ve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.
-->
<p>Lorsque nous exÃ©cutons ce code, nous obtenons les mÃªmes messages que dans
l'encart 3-4. Mais ce qui est plus important, c'est que nous avons amÃ©liorÃ© la
sÃ©curitÃ© de notre code et Ã©liminÃ© le risque de bogues qui pourraient survenir
si on dÃ©passait la fin du tableau, ou si on n'allait pas jusqu'au bout
et qu'on ratait quelques Ã©lÃ©ments.</p>
<!--
For example, in the code in Listing 3-4, if you changed the definition of the
`a` array to have four elements but forgot to update the condition to `while
index < 4`, the code would panic. Using the `for` loop, you wouldnâ€™t need to
remember to change any other code if you changed the number of values in the
array.
-->
<p>Par exemple, dans le code de l'encart 3-4, si vous changez la dÃ©finition du
tableau <code>a</code> pour qu'il stocle quatre Ã©lÃ©ments mais que vous oubliez de mettre Ã 
jour la condition tel que <code>while indice &lt; 4</code>, le code va paniquer. En utilisant
la boucle <code>for</code>, vous n'aurez pas Ã  vous rappeler de changer le code si vous
changez le nombre de valeurs dans le tableau.</p>
<!--
The safety and conciseness of `for` loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a `while` loop
in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that
would be to use a `Range`, which is a type provided by the standard library
that generates all numbers in sequence starting from one number and ending
before another number.
-->
<p>La sÃ©curitÃ© et la concision de la boucle <code>for</code> en font la construction de boucle
la plus utilisÃ©e avec Rust. MÃªme dans des situations dans lesquelles vous
voudriez exÃ©cuter du code plusieurs fois, comme l'exemple du dÃ©compte qui
utilisait une boucle <code>while</code> dans l'encart 3-3, la plupart des RustacÃ©s
utiliseraient une boucle <code>for</code>. Il faut pour cela utiliser un intervalle
<code>Range</code>, qui est un type fourni par la bibliothÃ¨que standard qui gÃ©nÃ¨re dans
l'ordre tous les nombres compris entre un certain nombre et un autre nombre.</p>
<!--
Hereâ€™s what the countdown would look like using a `for` loop and another method
weâ€™ve not yet talked about, `rev`, to reverse the range:
-->
<p>Voici ce que le dÃ©compte aurait donnÃ© en utilisant une boucle <code>for</code> et une autre
mÃ©thode que nous n'avons pas encore vue, <code>rev</code>, qui inverse l'intervalleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    for nombre in (1..4).rev() {
        println!(&quot;{}Â !&quot;, nombre);
    }
    println!(&quot;DÃ‰COLLAGEÂ !!!&quot;);
}
</code></pre></pre>
<!--
This code is a bit nicer, isnâ€™t it?
-->
<p>Ce code est un peu plus sympa, nonÂ ?</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-2" id="rÃ©sumÃ©-2">RÃ©sumÃ©</a></h2>
<!--
You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, `if` expressions, and loops! If
you want to practice with the concepts discussed in this chapter, try building
programs to do the following:
-->
<p>Vous y Ãªtes arrivÃ©Â ! C'Ã©tait un chapitre importantÂ : vous avez appris les
variables, les types scalaires et composÃ©s, les fonctions, les commentaires, les
expressions <code>if</code>, et les bouclesÂ ! Si vous voulez pratiquer un peu les concepts
abordÃ©s dans ce chapitre, voici quelques programmes que vous pouvez essayer de
crÃ©erÂ :</p>
<!--
* Convert temperatures between Fahrenheit and Celsius.
* Generate the nth Fibonacci number.
* Print the lyrics to the Christmas carol â€œThe Twelve Days of Christmas,â€
  taking advantage of the repetition in the song.
-->
<ul>
<li>Convertir des tempÃ©ratures entre les degrÃ©s Fahrenheit et Celsius.</li>
<li>GÃ©nÃ©rer le <em>n</em>-iÃ¨me nombre de Fibonacci.</li>
<li>Afficher les paroles de la chanson de NoÃ«l <em>The Twelve Days of Christmas</em> en
profitant de l'aspect rÃ©pÃ©titif de la chanson.</li>
</ul>
<!--
When youâ€™re ready to move on, weâ€™ll talk about a concept in Rust that *doesnâ€™t*
commonly exist in other programming languages: ownership.
-->
<p>Quand vous serez prÃªt Ã  aller plus loin, nous aborderons une notion de Rust
qui n'existe <em>pas</em> dans les autres langages de programmationÂ : la possession
<em>(ownership)</em>.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[quitting-after-a-correct-guess]:
ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess
-->
<!--
# Understanding Ownership
-->
<h1><a class="header" href="#comprendre-la-possession" id="comprendre-la-possession">Comprendre la possession</a></h1>
<!--
Ownership is Rustâ€™s most unique feature, and it enables Rust to make memory
safety guarantees without needing a garbage collector. Therefore, itâ€™s
important to understand how ownership works in Rust. In this chapter, weâ€™ll
talk about ownership as well as several related features: borrowing, slices,
and how Rust lays data out in memory.
-->
<p>La possession (<em>ownership</em>) est la fonctionnalitÃ© la plus remarquable de Rust,
et elle permet Ã  Rust de garantir la sÃ©curitÃ© de la mÃ©moire sans avoir besoin
d'un ramasse-miettes (<em>garbage collector</em>). Par consÃ©quent, il est important de
comprendre comment la possession fonctionne en Rust. Dans ce chapitre, nous
aborderons la possession, ainsi que d'autres fonctionnalitÃ©s associÃ©esÂ :
l'emprunt, les <em>slices</em> et la faÃ§on dont Rust agence les donnÃ©es en mÃ©moire.</p>
<!--
## What Is Ownership?
-->
<h2><a class="header" href="#quest-ce-que-la-possession-" id="quest-ce-que-la-possession-">Qu'est-ce que la possessionÂ ?</a></h2>
<!--
Rustâ€™s central feature is *ownership*. Although the feature is straightforward
to explain, it has deep implications for the rest of the language.
-->
<p>La principale spÃ©cificitÃ© de Rust est <em>la possession</em>. Bien que cette
fonctionnalitÃ© soit simple Ã  expliquer, elle a de profondes consÃ©quences sur le
reste du langage.</p>
<!--
All programs have to manage the way they use a computerâ€™s memory while running.
Some languages have garbage collection that constantly looks for no longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks at
compile time. None of the ownership features slow down your program while itâ€™s
running.
-->
<p>Tous les programmes doivent gÃ©rer la faÃ§on dont ils utilisent la mÃ©moire
lorsqu'ils s'exÃ©cutent. Certains langages ont un ramasse-miettes qui scrute
constamment la mÃ©moire qui n'est plus utilisÃ©e pendant qu'il s'exÃ©cuteÂ ; dans
d'autres langages, le dÃ©veloppeur doit explicitement allouer et libÃ©rer la
mÃ©moire. Rust adopte une troisiÃ¨me approcheÂ : la mÃ©moire est gÃ©rÃ©e avec un
systÃ¨me de possession qui repose sur un jeu de rÃ¨gles que le compilateur vÃ©rifie
au moment de la compilation. Aucune des fonctionnalitÃ©s de possession ne
ralentit votre programme Ã  l'exÃ©cution.</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the more youâ€™ll be able to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>Comme la possession est un nouveau principe pour de nombreux dÃ©veloppeurs,
cela prend un certain temps pour s'y familiariser. La bonne nouvelle est que
plus vous devenez expÃ©rimentÃ© avec Rust et ses rÃ¨gles de possession, plus vous
dÃ©velopperez naturellement du code sÃ»r et efficace. Gardez bien cela Ã 
l'espritÂ !</p>
<!--
When you understand ownership, youâ€™ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, youâ€™ll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>Lorsque vous comprendrez la possession, vous aurez des bases solides pour
comprendre les fonctionnalitÃ©s qui font la particularitÃ© de Rust. Dans ce
chapitre, vous allez apprendre la possession en pratiquant avec plusieurs
exemples qui se concentrent sur une structure de donnÃ©es trÃ¨s couranteÂ : les
chaÃ®nes de caractÃ¨res.</p>
<!--
> ### The Stack and the Heap
>
> In many programming languages, you donâ€™t have to think about the stack and
> the heap very often. But in a systems programming language like Rust, whether
> a value is on the stack or the heap has more of an effect on how the language
> behaves and why you have to make certain decisions. Parts of ownership will
> be described in relation to the stack and the heap later in this chapter, so
> here is a brief explanation in preparation.
>
> Both the stack and the heap are parts of memory that are available to your
> code to use at runtime, but they are structured in different ways. The stack
> stores values in the order it gets them and removes the values in the
> opposite order. This is referred to as *last in, first out*. Think of a stack
> of plates: when you add more plates, you put them on top of the pile, and
> when you need a plate, you take one off the top. Adding or removing plates
> from the middle or bottom wouldnâ€™t work as well! Adding data is called
> *pushing onto the stack*, and removing data is called *popping off the stack*.
>
> All data stored on the stack must have a known, fixed size. Data with an
> unknown size at compile time or a size that might change must be stored on
> the heap instead. The heap is less organized: when you put data on the heap,
> you request a certain amount of space. The memory allocator finds an empty
> spot in the heap that is big enough, marks it as being in use, and returns a
> *pointer*, which is the address of that location. This process is called
> *allocating on the heap* and is sometimes abbreviated as just *allocating*.
> Pushing values onto the stack is not considered allocating. Because the
> pointer is a known, fixed size, you can store the pointer on the stack, but
> when you want the actual data, you must follow the pointer.
>
> Think of being seated at a restaurant. When you enter, you state the number of
> people in your group, and the staff finds an empty table that fits everyone
> and leads you there. If someone in your group comes late, they can ask where
> youâ€™ve been seated to find you.
>
> Pushing to the stack is faster than allocating on the heap because the
> allocator never has to search for a place to store new data; that
> location is always at the top of the stack. Comparatively, allocating space
> on the heap requires more work, because the allocator must first find
> a big enough space to hold the data and then perform bookkeeping to prepare
> for the next allocation.
>
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. Itâ€™s most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data thatâ€™s close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
>
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the functionâ€™s
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
>
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so you donâ€™t run out of space are all problems that ownership
> addresses. Once you understand ownership, you wonâ€™t need to think about the
> stack and the heap very often, but knowing that managing heap data is why
> ownership exists can help explain why it works the way it does.
-->
<blockquote>
<h3><a class="header" href="#la-pile-et-le-tas" id="la-pile-et-le-tas">La pile et le tas</a></h3>
<p>Dans de nombreux langages, il n'est pas nÃ©cessaire de se prÃ©occuper de la
pile (<em>stack</em>) et du tas (<em>heap</em>). Mais dans un langage de programmation
systÃ¨me comme Rust, qu'une donnÃ©e soit sur la pile ou sur le tas influe
sur le comportement du langage et explique pourquoi nous devons faire certains
choix. Nous dÃ©crirons plus loin dans ce chapitre comment la possession
fonctionne vis-Ã -vis de la pile et du tas, voici donc une brÃ¨ve explication au
prÃ©alable.</p>
<p>La pile et le tas sont tous les deux des emplacements de la mÃ©moire qui
sont Ã  disposition de votre code lors de son exÃ©cution, mais sont organisÃ©s de
faÃ§on diffÃ©rente. La pile enregistre les valeurs dans l'ordre qu'elle les
reÃ§oit et enlÃ¨ve les valeurs dans l'autre sens. C'est ce que l'on appelle le
principe de <em>dernier entrÃ©, premier sorti</em>. C'est comme une pile d'assiettesÂ :
quand vous ajoutez des nouvelles assiettes, vous les dÃ©posez sur le dessus de
la pile, et quand vous avez besoin d'une assiette, vous en prenez une sur le
dessus. Ajouter ou enlever des assiettes au milieu ou en bas ne serait pas
aussi efficaceÂ ! Ajouter une donnÃ©e sur la pile se dit <em>empiler</em> et en retirer
une se dit <em>dÃ©piler</em>.</p>
<p>Toutes les donnÃ©es stockÃ©es dans la pile doivent avoir une taille connue et
fixe. Les donnÃ©es avec une taille inconnue au moment de la compilation ou une
taille qui peut changer doivent plutÃ´t Ãªtre stockÃ©es sur le tas. Le tas est
moins bien organisÃ©Â : lorsque vous ajoutez des donnÃ©es sur le tas, vous
demandez une certaine quantitÃ© d'espace mÃ©moire. Le gestionnaire de mÃ©moire va
trouver un emplacement dans le tas qui est suffisamment grand, va le marquer
comme Ã©tant en cours d'utilisation, et va retourner un <em>pointeur</em>, qui est
l'adresse de cet emplacement. Cette procÃ©dure est appelÃ©e <em>allocation sur le
tas</em>, ce qu'on abrÃ¨ge parfois en <em>allocation</em> tout court. L'ajout de valeurs
sur la pile n'est pas considÃ©rÃ© comme une allocation. Comme le pointeur a une
taille connue et fixe, on peut stocker ce pointeur sur la pile, mais quand on
veut la vraie donnÃ©e, il faut suivre le pointeur.</p>
<p>C'est comme si vous vouliez manger au restaurant. Quand vous entrez, vous
indiquez le nombre de personnes dans votre groupe, et le personnel trouve une
table vide qui peut recevoir tout le monde, et vous y conduit. Si quelqu'un
dans votre groupe arrive en retard, il peut leur demander oÃ¹ vous Ãªtes assis
pour vous rejoindre.</p>
<p>Empiler sur la pile est plus rapide qu'allouer sur le tas car le gestionnaire
ne va jamais avoir besoin de chercher un emplacement pour y stocker les
nouvelles donnÃ©esÂ ; il le fait toujours au sommet de la pile. En comparaison,
allouer de la place sur le tas demande plus de travail, car le gestionnaire
doit d'abord trouver un espace assez grand pour stocker les donnÃ©es et mettre
Ã  jour son suivi pour prÃ©parer la prochaine allocation.</p>
<p>AccÃ©der Ã  des donnÃ©es dans le tas est plus lent que d'accÃ©der aux donnÃ©es sur
la pile car nous devons suivre un pointeur pour les obtenir. Les processeurs
modernes sont plus rapides s'ils se dÃ©placent moins dans la mÃ©moire. Pour
continuer avec notre analogie, imaginez un serveur dans un restaurant qui
prend les commandes de nombreuses tables. C'est plus efficace de rÃ©cupÃ©rer
toutes les commandes Ã  une seule table avant de passer Ã  la table suivante.
Prendre une commande Ã  la table A, puis prendre une commande Ã  la table B,
puis ensuite une autre Ã  la table A, puis une autre Ã  la table B serait un
processus bien plus lent. De la mÃªme maniÃ¨re, un processeur sera plus efficace
dans sa tÃ¢che s'il travaille sur des donnÃ©es qui sont proches les unes des
autres (comme c'est le cas sur la pile) plutÃ´t que si elles sont plus
Ã©loignÃ©es (comme cela peut Ãªtre le cas sur le tas). Allouer une grande
quantitÃ© de mÃ©moire sur le tas peut aussi prendre beaucoup de temps.</p>
<p>Quand notre code utilise une fonction, les valeurs passÃ©es Ã  la fonction
(incluant, potentiellement, des pointeurs de donnÃ©es sur le tas) et les
variables locales Ã  la fonction sont dÃ©posÃ©es sur la pile. Quand l'utilisation
de la fonction est terminÃ©e, ces donnÃ©es sont retirÃ©es de la pile.</p>
<p>La possession nous aide Ã  ne pas nous prÃ©occuper de faire attention Ã  quelles
parties du code utilisent quelles donnÃ©es sur le tas, de minimiser la
quantitÃ© de donnÃ©es en double sur le tas, ou encore de veiller Ã  libÃ©rer les
donnÃ©es inutilisÃ©es sur le tas pour que nous ne soyons pas Ã  court d'espace.
Quand vous aurez compris la possession, vous n'aurez plus besoin de vous
prÃ©occuper de la pile et du tas trÃ¨s souvent, mais savoir que la possession
existe pour gÃ©rer les donnÃ©es du tas peut vous aider Ã  comprendre pourquoi
elle fonctionne de cette maniÃ¨re.</p>
</blockquote>
<!--
### Ownership Rules
-->
<h3><a class="header" href="#les-rÃ¨gles-de-la-possession" id="les-rÃ¨gles-de-la-possession">Les rÃ¨gles de la possession</a></h3>
<!--
First, letâ€™s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>Tout d'abord, dÃ©finissons les rÃ¨gles de la possession. Gardez Ã  l'esprit ces
rÃ¨gles pendant que nous travaillons sur des exemples qui les illustrentÂ :</p>
<!--
* Each value in Rust has a variable thatâ€™s called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Chaque valeur en Rust a une variable qui s'appelle son <em>propriÃ©taire</em>.</li>
<li>Il ne peut y avoir qu'un seul propriÃ©taire Ã  la fois.</li>
<li>Quand le propriÃ©taire sortira de la portÃ©e, la valeur sera supprimÃ©e.</li>
</ul>
<!--
### Variable Scope
-->
<h3><a class="header" href="#portÃ©e-de-la-variable" id="portÃ©e-de-la-variable">PortÃ©e de la variable</a></h3>
<!--
Weâ€™ve walked through an example of a Rust program already in Chapter 2. Now
that weâ€™re past basic syntax, we wonâ€™t include all the `fn main() {` code in
examples, so if youâ€™re following along, youâ€™ll have to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>Nous avons dÃ©jÃ  vu un exemple de programme Rust au chapitre 2. Maintenant
que nous avons vu la syntaxe Rust de base, nous n'allons plus ajouter tout le
code du style <code>fn main() {</code> dans les exemples, donc si vous voulez reproduire
les exemples, vous devrez les mettre manuellement dans une fonction <code>main</code>. Par
consÃ©quent, nos exemples seront plus concis, nous permettant de nous concentrer
sur les dÃ©tails de la situation plutÃ´t que sur du code normalisÃ©.</p>
<!--
As a first example of ownership, weâ€™ll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Letâ€™s say we
have a variable that looks like this:
-->
<p>Pour le premier exemple de possession, nous allons analyser la <em>portÃ©e</em> de
certaines variables. Une portÃ©e est une zone dans un programme dans laquelle un
Ã©lÃ©ment est en vigueur. Imaginons que nous ayons la variable suivanteÂ :</p>
<!--
```rust
let s = "hello";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which itâ€™s declared until the end of the current *scope*. Listing 4-1 has
comments annotating where the variable `s` is valid.
-->
<p>La variable <code>s</code> fait rÃ©fÃ©rence Ã  un littÃ©ral de chaÃ®ne de caractÃ¨res, oÃ¹ la
valeur de la chaÃ®ne est codÃ©e en dur dans notre programme. La variable est en
vigueur Ã  partir du moment oÃ¹ elle est dÃ©clarÃ©e jusqu'Ã  la fin de la <em>portÃ©e</em>
actuelle. L'encart 4-1 a des commentaires pour indiquer quand la variable <code>s</code>
est en vigueurÂ :</p>
<!--
```rust
# fn main() {
    {                      // s is not valid here, itâ€™s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                    // s n'est pas en vigueur ici, elle n'est pas encore dÃ©clarÃ©e
        let s = &quot;hello&quot;; // s est en vigueur Ã  partir de ce point

        // on fait des choses avec s ici
    }                    // cette portÃ©e est maintenant terminÃ©e, et s n'est plus en vigueur
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span>
-->
<p><span class="caption">Encart 4-1Â : Une variable et la portÃ©e dans laquelle elle
est en vigueur.</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>Autrement dit, il y a ici deux Ã©tapes importantesÂ :</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li>Quand <code>s</code> rentre <em>dans la portÃ©e</em>, elle est en vigueur.</li>
<li>Cela reste ainsi jusqu'Ã  ce qu'elle <em>sort de la portÃ©e</em>.</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now weâ€™ll build on top of this
understanding by introducing the `String` type.
-->
<p>Pour le moment, la relation entre les portÃ©es et les conditions pour lesquelles
les variables sont en vigueur sont similaires Ã  d'autres langages de
programmation. Maintenant, nous allons aller plus loin en y ajoutant le type
<code>String</code>.</p>
<!--
### The `String` Type
-->
<h3><a class="header" href="#le-type-string" id="le-type-string">Le type <code>String</code></a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than the ones we covered in the [â€œData Typesâ€][data-types]<!-- ignore -- >
section of Chapter 3. The types covered previously are all stored on the stack
and popped off the stack when their scope is over, but we want to look at data
that is stored on the heap and explore how Rust knows when to clean up that
data.
-->
<p>Pour illustrer les rÃ¨gles de la possession, nous avons besoin d'un type de
donnÃ©e qui est plus complexe que ceux que nous avons rencontrÃ©s dans la section
<a href="ch03-02-data-types.html">â€œTypes de donnÃ©esâ€</a><!-- ignore --> du chapitre 3. Les types que
nous avons vus prÃ©cÃ©demment sont tous stockÃ©s sur la pile et sont retirÃ©s de la
pile quand ils sortent de la portÃ©e, mais nous voulons expÃ©rimenter le stockage
de donnÃ©es sur le tas et dÃ©couvrir comment Rust sait quand il doit nettoyer ces
donnÃ©es.</p>
<!--
Weâ€™ll use `String` as the example here and concentrate on the parts of `String`
that relate to ownership. These aspects also apply to other complex data types,
whether they are provided by the standard library or created by you. Weâ€™ll
discuss `String` in more depth in Chapter 8.
-->
<p>Nous allons utiliser ici <code>String</code> pour l'exemple et nous concentrer sur les
caractÃ©ristiques de <code>String</code> qui sont liÃ©es Ã  la possession. Ces aspects
s'appliquent Ã©galement Ã  d'autres types de donnÃ©es complexes, qu'ils soient
fournis par la bibliothÃ¨que standard ou qu'ils soient crÃ©Ã©s par vous. Nous
verrons <code>String</code> plus en dÃ©tail dans le chapitre 8.</p>
<!--
Weâ€™ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they arenâ€™t suitable for every
situation in which we may want to use text. One reason is that theyâ€™re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type is
allocated on the heap and as such is able to store an amount of text that is
unknown to us at compile time. You can create a `String` from a string literal
using the `from` function, like so:
-->
<p>Nous avons dÃ©jÃ  vu les littÃ©raux de chaÃ®nes de caractÃ¨res, quand une valeur de
chaÃ®ne est codÃ©e en dur dans notre programme. Les littÃ©raux de chaÃ®nes sont
pratiques, mais ils ne conviennent pas toujours Ã  tous les cas oÃ¹ on veut
utiliser du texte. Une des raisons est qu'ils sont immuables. Une autre raison
est qu'on ne connaÃ®t pas forcÃ©ment le contenu des chaÃ®nes de caractÃ¨res quand
nous Ã©crivons notre codeÂ : par exemple, comment faire si nous voulons rÃ©cupÃ©rer
du texte saisi par l'utilisateur et l'enregistrerÂ ? Pour ces cas-ci, Rust a un
second type de chaÃ®ne de caractÃ¨res, <code>String</code>. Ce type est allouÃ© sur le tas et
est ainsi capable de stocker une quantitÃ© de texte qui nous est inconnue au
moment de la compilation. Vous pouvez crÃ©er une <code>String</code> Ã  partir d'un littÃ©ral
de chaÃ®ne de caractÃ¨res en utilisant la fonction <code>from</code>, comme ceciÂ :</p>
<!--
```rust
let s = String::from("hello");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon (`::`) is an operator that allows us to namespace this
particular `from` function under the `String` type rather than using some sort
of name like `string_from`. Weâ€™ll discuss this syntax more in the [â€œMethod
Syntaxâ€][method-syntax]<!-- ignore -- > section of Chapter 5 and when we talk
about namespacing with modules in [â€œPaths for Referring to an Item in the
Module Treeâ€][paths-module-tree]<!-- ignore -- > in Chapter 7.
-->
<p>Le double deux-points (<code>::</code>) est un opÃ©rateur qui nous permet d'appeler cette
fonction spÃ©cifique dans l'espace de nom du type <code>String</code> plutÃ´t que d'utiliser
un nom comme <code>string_from</code>. Nous verrons cette syntaxe plus en dÃ©tail dans la
section <a href="ch05-03-method-syntax.html">â€œSyntaxe de mÃ©thodeâ€</a><!-- ignore --> du chapitre 5 et
lorsque nous aborderons les espaces de noms dans la section
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">â€œLes chemins pour dÃ©signer un Ã©lÃ©ment dans l'arborescence de
moduleâ€</a><!-- ignore --> du chapitre 7.</p>
<!--
This kind of string *can* be mutated:
-->
<p>Ce type de chaÃ®ne de caractÃ¨res <em>peut</em> Ãªtre mutableÂ :</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() ajoute un littÃ©ral de chaÃ®ne dans une String
    
    println!(&quot;{}&quot;, s); // Cela va afficher `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<!--
So, whatâ€™s the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>Donc, quelle est la diffÃ©rence iciÂ ? Pourquoi <code>String</code> peut Ãªtre mutable, mais
pourquoi les littÃ©raux de chaÃ®nes ne peuvent pas l'ÃªtreÂ ? La diffÃ©rence
se trouve dans la faÃ§on dont ces deux types travaillent avec la mÃ©moire.</p>
<!--
### Memory and Allocation
-->
<h3><a class="header" href="#mÃ©moire-et-allocation" id="mÃ©moire-et-allocation">MÃ©moire et allocation</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literalâ€™s immutability. Unfortunately, we canâ€™t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>Dans le cas d'un littÃ©ral de chaÃ®ne de caractÃ¨res, nous connaissons le contenu
au moment de la compilation donc le texte est codÃ© en dur directement dans
l'exÃ©cutable final. VoilÃ  pourquoi ces littÃ©raux de chaÃ®nes de caractÃ¨res sont
performants et rapides. Mais ces caractÃ©ristiques viennent de leur immuabilitÃ©.
Malheureusement, on ne peut pas accorder une grosse rÃ©gion de mÃ©moire dans le
binaire pour chaque morceau de texte qui n'a pas de taille connue au moment de
la compilation et dont la taille pourrait changer pendant l'exÃ©cution de ce
programme.</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p>Avec le type <code>String</code>, pour nous permettre d'avoir un texte mutable et qui peut
s'agrandir, nous devons allouer une quantitÃ© de mÃ©moire sur le tas, inconnue
au moment de la compilation, pour stocker le contenu. Cela signifie queÂ :</p>
<!--
* The memory must be requested from the memory allocator at runtime.
* We need a way of returning this memory to the allocator when weâ€™re
  done with our `String`.
-->
<ul>
<li>La mÃ©moire doit Ãªtre demandÃ©e auprÃ¨s du gestionnaire de mÃ©moire lors de
l'exÃ©cution.</li>
<li>Nous avons besoin d'un moyen de rendre cette mÃ©moire au gestionnaire lorsque
nous aurons fini d'utiliser notre <code>String</code>.</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>Nous nous occupons de ce premier pointÂ : quand nous appelons <code>String::from</code>, son
implÃ©mentation demande la mÃ©moire dont elle a besoin. C'est pratiquement
toujours ainsi dans la majoritÃ© des langages de programmation.</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track and cleans up memory that isnâ€™t being used anymore,
and we donâ€™t need to think about it. Without a GC, itâ€™s our responsibility to
identify when memory is no longer being used and call code to explicitly return
it, just as we did to request it. Doing this correctly has historically been a
difficult programming problem. If we forget, weâ€™ll waste memory. If we do it
too early, weâ€™ll have an invalid variable. If we do it twice, thatâ€™s a bug too.
We need to pair exactly one `allocate` with exactly one `free`.
-->
<p>Cependant, le deuxiÃ¨me point est diffÃ©rent. Dans des langages avec un
<em>ramasse-miettes</em>, le ramasse-miettes surveille et nettoie la mÃ©moire qui n'est
plus utilisÃ©e, sans que nous n'ayons Ã  nous en prÃ©occuper. Sans un
ramasse-miettes, c'est de notre responsabilitÃ© d'identifier quand cette mÃ©moire
n'est plus utilisÃ©e et d'appeler du code pour explicitement la libÃ©rer, comme
nous l'avons fait pour la demander auparavant. Historiquement, faire ceci
correctement a toujours Ã©tÃ© une difficultÃ© pour les dÃ©veloppeurs. Si nous
oublions de le faire, nous allons gaspiller de la mÃ©moire. Si nous le faisons
trop tÃ´t, nous allons avoir une variable invalide. Si nous le faisons deux fois,
cela produit aussi un bogue. Nous devons associer exactement un <code>allocate</code> avec
exactement un <code>free</code>.</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Hereâ€™s a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rust prend un chemin diffÃ©rentÂ : la mÃ©moire est automatiquement libÃ©rÃ©e dÃ¨s
que la variable qui la possÃ¨de sort de la portÃ©e. Voici une version de notre
exemple de portÃ©e de l'encart 4-1 qui utilise une <code>String</code> plutÃ´t qu'un littÃ©ral
de chaÃ®ne de caractÃ¨resÂ :</p>
<!--
```rust
# fn main() {
    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s est en vigueur Ã  partir de ce point
    
        // on fait des choses avec s ici
    }                                  // cette portÃ©e est dÃ©sormais terminÃ©e, et s
                                       // n'est plus en vigueur maintenant
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the allocator: when `s` goes out of scope. When a variable goes out
of scope, Rust calls a special function for us. This function is called `drop`,
and itâ€™s where the author of `String` can put the code to return the memory.
Rust calls `drop` automatically at the closing curly bracket.
-->
<p>Il y a un moment naturel oÃ¹ nous devons rendre la mÃ©moire de notre
<code>String</code> au gestionnaireÂ : quand <code>s</code> sort de la portÃ©e. Quand une variable sort
de la portÃ©e, Rust appelle une fonction spÃ©ciale pour nous. Cette fonction
s'appelle <code>drop</code>, et c'est dans celle-ci que l'auteur de <code>String</code> a pu mettre le
code pour libÃ©rer la mÃ©moire. Rust appelle automatiquement <code>drop</code> Ã  l'accolade
fermante <code>}</code>.</p>
<!--
> Note: In C++, this pattern of deallocating resources at the end of an itemâ€™s
> lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
> The `drop` function in Rust will be familiar to you if youâ€™ve used RAII
> patterns.
-->
<blockquote>
<p>RemarqueÂ : en C++, cette faÃ§on de libÃ©rer des ressources Ã  la fin de la
durÃ©e de vie d'un Ã©lÃ©ment est parfois appelÃ©e <em>l'acquisition d'une ressource
est une initialisation (RAII)</em>. La fonction <code>drop</code> de Rust vous sera familiÃ¨re
si vous avez dÃ©jÃ  utilisÃ© des techniques de RAII.</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
weâ€™ve allocated on the heap. Letâ€™s explore some of those situations now.
-->
<p>Cette faÃ§on de faire a un impact profond sur la faÃ§on dont le code Rust est
Ã©crit. Cela peut sembler simple dans notre cas, mais le comportement du code
peut Ãªtre surprenant dans des situations plus compliquÃ©es oÃ¹ nous voulons
avoir plusieurs variables utilisant des donnÃ©es que nous avons affectÃ©es sur le
tas. Examinons une de ces situations dÃ¨s Ã  prÃ©sent.</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4><a class="header" href="#les-interactions-entre-les-variables-et-les-donnÃ©es--le-dÃ©placement" id="les-interactions-entre-les-variables-et-les-donnÃ©es--le-dÃ©placement">Les interactions entre les variables et les donnÃ©esÂ : le dÃ©placement</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Letâ€™s look at an example using an integer in Listing 4-2.
-->
<p>Plusieurs variables peuvent interagir avec les mÃªmes donnÃ©es de diffÃ©rentes
maniÃ¨res en Rust. Regardons un exemple avec un entier dans l'encart 4-2Â :</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span>
-->
<p><span class="caption">Encart 4-2Â : Assigner l'entier de la variable <code>x</code> Ã  <code>y</code>
</span></p>
<!--
We can probably guess what this is doing: â€œbind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.â€ We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>Nous pouvons probablement deviner ce que ce code faitÂ : â€œAssigner la valeur <code>5</code>
Ã  <code>x</code>Â ; ensuite faire une copie de cette valeur de <code>x</code> et l'assigner Ã  <code>y</code>.â€
Nous avons maintenant deux variables, <code>x</code> et <code>y</code>, et chacune vaut <code>5</code>. C'est
effectivement ce qui se passe, car les entiers sont des valeurs simples avec une
taille connue et fixÃ©e, et ces deux valeurs <code>5</code> sont stockÃ©es sur la pile.</p>
<!--
Now letâ€™s look at the `String` version:
-->
<p>Maintenant, essayons une nouvelle version avec <code>String</code>Â :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar to the previous code, so we might assume that the way
it works would be the same: that is, the second line would make a copy of the
value in `s1` and bind it to `s2`. But this isnâ€™t quite what happens.
-->
<p>Cela ressemble beaucoup au code prÃ©cÃ©dent, donc nous allons supposer que cela
fonctionne pareil que prÃ©cÃ©demmentÂ : ainsi, la seconde ligne va faire une copie
de la valeur de <code>s1</code> et l'assigner Ã  <code>s2</code>. Mais ce n'est pas tout Ã  fait ce
qu'il se passe.</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>Regardons l'illustration 4-1 pour dÃ©couvrir ce qui arrive Ã  <code>String</code> sous le
capot. Une <code>String</code> est constituÃ©e de trois Ã©lÃ©ments, prÃ©sents sur la gaucheÂ :
un pointeur vers la mÃ©moire qui contient le contenu de la chaÃ®ne de caractÃ¨res,
une taille, et une capacitÃ©. Ce groupe de donnÃ©es est stockÃ© sur la pile. Ã€
droite, nous avons la mÃ©moire sur le tas qui contient les donnÃ©es.</p>
<!-- markdownlint-disable -->
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une string en mÃ©moire" src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>
-->
<p><span class="caption">Illustration 4-1Â : ReprÃ©sentation en mÃ©moire d'une
<code>String</code> qui contient la valeur <code>&quot;hello&quot;</code> assignÃ©e Ã  <code>s1</code>.</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the allocator. The difference between length
and capacity matters, but not in this context, so for now, itâ€™s fine to ignore
the capacity.
-->
<p>La taille est la quantitÃ© de mÃ©moire, en octets, que le contenu de la <code>String</code>
utilise actuellement. La capacitÃ© est la quantitÃ© totale de mÃ©moire, en octets,
que la <code>String</code> a reÃ§ue du gestionnaire. La diffÃ©rence entre la taille et la
capacitÃ© est importante, mais pas pour notre exemple, donc pour l'instant, ce
n'est pas grave d'ignorer la capacitÃ©.</p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p>Quand nous assignons <code>s1</code> Ã  <code>s2</code>, les donnÃ©es de la <code>String</code> sont copiÃ©es, ce
qui veut dire que nous copions le pointeur, la taille et la capacitÃ© qui sont
stockÃ©s sur la pile. Nous ne copions pas les donnÃ©es stockÃ©es sur le tas
auxquelles le pointeur se rÃ©fÃ¨re. Autrement dit, la reprÃ©sentation des donnÃ©es
dans la mÃ©moire ressemble Ã  l'illustration 4-2.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 qui pointent vers la mÃªme valeur" src="img/trpl04-02.svg"
class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>
-->
<p><span class="caption">Illustration 4-2Â : ReprÃ©sentation en mÃ©moire de la
variable <code>s2</code> qui a une copie du pointeur, de la taille et de la capacitÃ© de
<code>s1</code></span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>Cette reprÃ©sentation <em>n'est pas</em> comme l'illustration 4-3, qui reprÃ©senterait la
mÃ©moire si Rust avait aussi copiÃ© les donnÃ©es sur le tas. Si Rust faisait ceci,
l'opÃ©ration <code>s2 = s1</code> pourrait potentiellement Ãªtre trÃ¨s coÃ»teuse en termes de
performances d'exÃ©cution si les donnÃ©es sur le tas Ã©taient volumineuses.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 Ã  deux endroits" src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>
-->
<p><span class="caption">Illustration 4-3Â : Une autre possibilitÃ© de ce que
pourrait faire <code>s2 = s1</code> si Rust copiait aussi les donnÃ©es du tas</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>PrÃ©cÃ©demment, nous avons dit que quand une variable sortait de la portÃ©e, Rust
appelait automatiquement la fonction <code>drop</code> et nettoyait la mÃ©moire sur le tas
allouÃ©e pour cette variable. Mais l'illustration 4-2 montre que les deux
pointeurs de donnÃ©es pointeraient au mÃªme endroit. C'est un problÃ¨meÂ : quand
<code>s2</code> et <code>s1</code> sortent de la portÃ©e, elles vont essayer toutes les deux de
libÃ©rer la mÃªme mÃ©moire. C'est ce qu'on appelle une erreur de <em>double
libÃ©ration</em> et c'est un des bogues de sÃ©curitÃ© de mÃ©moire que nous avons
mentionnÃ©s prÃ©cÃ©demment. LibÃ©rer la mÃ©moire deux fois peut mener Ã  des
corruptions de mÃ©moire, ce qui peut potentiellement mener Ã  des vulnÃ©rabilitÃ©s
de sÃ©curitÃ©.</p>
<!--
To ensure memory safety, thereâ€™s one more detail to what happens in this
situation in Rust. Instead of trying to copy the allocated memory, Rust
considers `s1` to no longer be valid and, therefore, Rust doesnâ€™t need to free
anything when `s1` goes out of scope. Check out what happens when you try to
use `s1` after `s2` is created; it wonâ€™t work:
-->
<p>Pour garantir la sÃ©curitÃ© de la mÃ©moire, il y a un autre petit dÃ©tail qui se
produit dans cette situation avec Rust. PlutÃ´t qu'essayer de copier la mÃ©moire
allouÃ©e, Rust considÃ¨re que <code>s1</code> n'est plus en vigueur et donc, Rust n'a pas
besoin de libÃ©rer quoi que ce soit lorsque <code>s1</code> sort de la portÃ©e. Regardez ce
qu'il se passe quand vous essayez d'utiliser <code>s1</code> aprÃ¨s que <code>s2</code> est crÃ©Ã©,
cela ne va pas fonctionnerÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<!--
Youâ€™ll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>Vous allez avoir une erreur comme celle-ci, car Rust vous dÃ©fend d'utiliser la
rÃ©fÃ©rence qui n'est plus en vigueurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 -- > src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
If youâ€™ve heard the terms *shallow copy* and *deep copy* while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, itâ€™s known as a *move*. In this example, we would say that
`s1` was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>Si vous avez dÃ©jÃ  entendu parler de <em>copie superficielle</em> et de <em>copie
profonde</em> en utilisant d'autres langages, l'idÃ©e de copier le pointeur, la
taille et la capacitÃ© sans copier les donnÃ©es peut vous faire penser Ã  de la
copie superficielle. Mais comme Rust neutralise aussi la premiÃ¨re variable, au
lieu d'appeler cela une copie superficielle, on appelle cela un <em>dÃ©placement</em>.
Ici, nous pourrions dire que <code>s1</code> a Ã©tÃ© <em>dÃ©placÃ©</em> dans <code>s2</code>. Donc ce qui se
passe rÃ©ellement est dÃ©crit par l'illustration 4-4.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 dÃ©placÃ© dans s2" src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>
-->
<p><span class="caption">Illustration 4-4Â : ReprÃ©sentation de la mÃ©moire aprÃ¨s que
<code>s1</code> a Ã©tÃ© neutralisÃ©e</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and weâ€™re done.
-->
<p>Cela rÃ©sout notre problÃ¨meÂ ! Avec seulement <code>s2</code> en vigueur, quand elle
sortira de la portÃ©e, elle seule va libÃ©rer la mÃ©moire, et c'est tout.</p>
<!--
In addition, thereâ€™s a design choice thatâ€™s implied by this: Rust will never
automatically create â€œdeepâ€ copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>De plus, cela signifie qu'il y a eu un choix de conceptionÂ : Rust ne va jamais
crÃ©er automatiquement de copie â€œprofondeâ€ de vos donnÃ©es. Par consÃ©quent, toute
copie <em>automatique</em> peut Ãªtre considÃ©rÃ©e comme peu coÃ»teuse en termes de
performances d'exÃ©cution.</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4><a class="header" href="#les-interactions-entre-les-variables-et-les-donnÃ©es--le-clonage" id="les-interactions-entre-les-variables-et-les-donnÃ©es--le-clonage">Les interactions entre les variables et les donnÃ©esÂ : le clonage</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. Weâ€™ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, youâ€™ve probably seen them before.
-->
<p>Si nous <em>voulons</em> faire une copie profonde des donnÃ©es sur le tas d'une
<code>String</code>, et pas seulement des donnÃ©es sur la pile, nous pouvons utiliser une
mÃ©thode commune qui s'appelle <code>clone</code>. Nous aborderons la syntaxe des mÃ©thodes
au chapitre 5, mais comme les mÃ©thodes sont des outils courants dans de
nombreux langages, vous les avez probablement utilisÃ©es auparavant.</p>
<!--
Hereâ€™s an example of the `clone` method in action:
-->
<p>Voici un exemple d'utilisation de la mÃ©thode <code>clone</code>Â :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>Cela fonctionne trÃ¨s bien et c'est ainsi que vous pouvez reproduire le
comportement dÃ©crit dans l'illustration 4-3, oÃ¹ les donnÃ©es du tas sont copiÃ©es.</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. Itâ€™s a visual indicator that something
different is going on.
-->
<p>Quand vous voyez un appel Ã  <code>clone</code>, vous savez que du code arbitraire est
exÃ©cutÃ© et que ce code peut Ãªtre coÃ»teux. C'est un indicateur visuel qu'il se
passe quelque chose de diffÃ©rent.</p>
<!--
#### Stack-Only Data: Copy
-->
<h4><a class="header" href="#donnÃ©es-uniquement-sur-la-pile--la-copie" id="donnÃ©es-uniquement-sur-la-pile--la-copie">DonnÃ©es uniquement sur la pileÂ : la copie</a></h4>
<!--
Thereâ€™s another wrinkle we havenâ€™t talked about yet. This code using integers,
part of which was shown in Listing 4-2, works and is valid:
-->
<p>Il y a un autre dÃ©tail dont on n'a pas encore parlÃ©. Le code suivant utilise
des entiers, et on en a vu une partie dans l'encart 4-2Â ; il fonctionne et
est correctÂ :</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we donâ€™t have a call to
`clone`, but `x` is still valid and wasnâ€™t moved into `y`.
-->
<p>Mais ce code semble contredire ce que nous venons d'apprendreÂ : nous n'avons
pas appelÃ© <code>clone</code>, mais <code>x</code> est toujours en vigueur et n'a pas Ã©tÃ© dÃ©placÃ©
dans <code>y</code>.</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means thereâ€™s no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, thereâ€™s no difference
between deep and shallow copying here, so calling `clone` wouldnâ€™t do anything
different from the usual shallow copying and we can leave it out.
-->
<p>La raison est que les types comme les entiers ont une taille connue au moment de
la compilation et sont entiÃ¨rement stockÃ©s sur la pile, donc la copie des
vraies valeurs est rapide Ã  faire. Cela signifie qu'il n'y a pas de raison que
nous voudrions neutraliser <code>x</code> aprÃ¨s avoir crÃ©Ã© la variable <code>y</code>. En d'autres
termes, il n'y a pas ici de diffÃ©rence entre la copie superficielle et profonde,
donc appeler <code>clone</code> ne ferait rien d'autre qu'une copie superficielle classique
et on peut s'en passer.</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types like integers that are stored on the stack (weâ€™ll talk more about traits
in Chapter 10). If a type has the `Copy` trait, an older variable is still
usable after assignment. Rust wonâ€™t let us annotate a type with the `Copy`
trait if the type, or any of its parts, has implemented the `Drop` trait. If
the type needs something special to happen when the value goes out of scope and
we add the `Copy` annotation to that type, weâ€™ll get a compile-time error. To
learn about how to add the `Copy` annotation to your type, see [â€œDerivable
Traitsâ€][derivable-traits]<!-- ignore -- > in Appendix C.
-->
<p>Rust a une annotation spÃ©ciale appelÃ©e le trait <code>Copy</code> que nous pouvons utiliser
sur des types comme les entiers qui sont stockÃ©s sur la pile (nous verrons les
traits dans le chapitre 10). Si un type a le trait <code>Copy</code>, l'ancienne variable
sera toujours utilisable aprÃ¨s avoir Ã©tÃ© affectÃ©e. Rust ne nous autorisera pas Ã 
annoter un type avec le trait <code>Copy</code> si ce type, ou un de ses Ã©lÃ©ments, a
implÃ©mentÃ© le trait <code>Drop</code>. Si ce type a besoin que quelque chose de spÃ©cial se
produise quand la valeur sort de la portÃ©e et que nous ajoutons l'annotation
<code>Copy</code> sur ce type, nous aurons une erreur au moment de la compilation. Pour
savoir comment ajouter l'annotation <code>Copy</code> sur votre type, rÃ©fÃ©rez-vous Ã 
<a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore --> sur les traits dÃ©rivables.</p>
<!--
So what types are `Copy`? You can check the documentation for the given type to
be sure, but as a general rule, any group of simple scalar values can be
`Copy`, and nothing that requires allocation or is some form of resource is
`Copy`. Here are some of the types that are `Copy`:
-->
<p>Donc, quels sont les types qui sont <code>Copy</code>Â ? Vous pouvez regarder dans la
documentation pour un type donnÃ© pour vous en assurer, mais de maniÃ¨re gÃ©nÃ©rale,
tout groupe de valeur scalaire peut Ãªtre <code>Copy</code>, et tout ce qui ne nÃ©cessite pas
d'allocation de mÃ©moire ou tout autre forme de ressource est <code>Copy</code>.
Voici quelques types qui sont <code>Copy</code>Â :</p>
<!--
* All the integer types, such as `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, such as `f64`.
* The character type, `char`.
* Tuples, if they only contain types that are also `Copy`. For example,
  `(i32, i32)` is `Copy`, but `(i32, String)` is not.
-->
<ul>
<li>Tous les types d'entiers, comme <code>u32</code>.</li>
<li>Le type boolÃ©en, <code>bool</code>, avec les valeurs <code>true</code> et <code>false</code>.</li>
<li>Tous les types de flottants, comme <code>f64</code>.</li>
<li>Le type de caractÃ¨re, <code>char</code>.</li>
<li>Les tuples, mais uniquement s'ils contiennent des types qui sont aussi <code>Copy</code>.
Par exemple, le <code>(i32, i32)</code> est <code>Copy</code>, mais pas <code>(i32, String)</code>.</li>
</ul>
<!--
### Ownership and Functions
-->
<h3><a class="header" href="#la-possession-et-les-fonctions" id="la-possession-et-les-fonctions">La possession et les fonctions</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>La syntaxe pour passer une valeur Ã  une fonction est similaire Ã  celle pour
assigner une valeur Ã  une variable. Passer une variable Ã  une fonction va la
dÃ©placer ou la copier, comme l'assignation. L'encart 4-3 est un exemple avec
quelques commentaires qui montrent oÃ¹ les variables rentrent et sortent de la
portÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so itâ€™s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello&quot;);  // s rentre dans la portÃ©e.

  prendre_possession(s);  // La valeur de s est dÃ©placÃ©e dans la fonctionâ€¦
                          // â€¦ et n'est plus en vigueur Ã  partir d'ici

  let x = 5;              // x rentre dans la portÃ©e.

  creer_copie(x);         // x va Ãªtre dÃ©placÃ©e dans la fonction,
                          // mais i32 est Copy, donc on peut
                          // utiliser x ensuite.

} // Ici, x sort de la portÃ©e, puis ensuite s. Mais puisque la valeur de s a
// Ã©tÃ© dÃ©placÃ©e, il ne se passe rien de spÃ©cial.

fn prendre_possession(texte: String) { // texte rentre dans la portÃ©e.
  println!(&quot;{}&quot;, texte);
} // Ici, texte sort de la portÃ©e et `drop` est appelÃ©. La mÃ©moire est libÃ©rÃ©e.

fn creer_copie(entier: i32) { // entier rentre dans la portÃ©e.
  println!(&quot;{}&quot;, entier);
} // Ici, entier sort de la portÃ©e. Il ne se passe rien de spÃ©cial.
</code></pre></pre>
<!--
<span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span>
-->
<p><span class="caption">Encart 4-3Â : Les fonctions avec les possessions et les
portÃ©es qui sont commentÃ©es</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p>Si on essayait d'utiliser <code>s</code> aprÃ¨s l'appel Ã  <code>prendre_possession</code>, Rust
dÃ©clencherait une erreur Ã  la compilation. Ces vÃ©rifications statiques
nous protÃ¨gent des erreurs. Essayez d'ajouter du code au <code>main</code> qui utilise <code>s</code>
et <code>x</code> pour dÃ©couvrir lorsque vous pouvez les utiliser et lorsque les rÃ¨gles de
la possession vous empÃªchent de le faire.</p>
<!--
### Return Values and Scope
-->
<h3><a class="header" href="#les-valeurs-de-retour-et-les-portÃ©es" id="les-valeurs-de-retour-et-les-portÃ©es">Les valeurs de retour et les portÃ©es</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 is an example with
similar annotations to those in Listing 4-3.
-->
<p>Retourner des valeurs peut aussi transfÃ©rer leur possession. L'encart 4-4 est un
exemple avec des annotations similaires Ã  celles de l'encart 4-3Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s1 = donne_possession();     // donne_possession dÃ©place sa valeur de
                                   // retour dans s1

  let s2 = String::from(&quot;hello&quot;);  // s2 rentre dans la portÃ©e

  let s3 = prend_et_rend(s2);      // s2 est dÃ©placÃ©e dans
                                   // prend_et_rend, qui elle aussi
                                   // dÃ©place sa valeur de retour dans s3.
} // Ici, s3 sort de la portÃ©e et est Ã©liminÃ©e. s2 sort de la portÃ©e mais a Ã©tÃ©
  // dÃ©placÃ©e donc il ne se passe rien. s1 sort aussi de la portÃ©e et est
  // Ã©liminÃ©e.

fn donne_possession() -&gt; String {      // donne_possession va dÃ©placer sa
                                       // valeur de retour dans la
                                       // fonction qui l'appelle.

  let texte = String::from(&quot;hello&quot;);   // texte rentre dans la portÃ©e.

  texte                                // texte est retournÃ©e et
                                       // est dÃ©placÃ©e vers le code qui
                                       // l'appelle.
}

// prend_et_rend va prendre une String et en retourne aussi une.
fn prend_et_rend(texte: String) -&gt; String { // texte rentre dans la portÃ©e.

  texte  // texte est retournÃ©e et dÃ©placÃ©e vers le code qui l'appelle.
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">Encart 4-4Â : Transferts de possession des valeurs de
retour</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless the data
has been moved to be owned by another variable.
-->
<p>La possession d'une variable suit toujours le mÃªme schÃ©ma Ã  chaque foisÂ :
assigner une valeur Ã  une autre variable la dÃ©place. Quand une variable qui
contient des donnÃ©es sur le tas sort de la portÃ©e, la valeur sera nettoyÃ©e
avec <code>drop</code> Ã  moins que la donnÃ©e ait Ã©tÃ© dÃ©placÃ©e pour Ãªtre possÃ©dÃ©e par une
autre variable.</p>
<!--
Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
Itâ€™s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.
-->
<p>Il est un peu fastidieux de prendre la possession puis ensuite de retourner la
possession Ã  chaque fonction. Et qu'est-ce qu'il se passe si nous voulons
qu'une fonction utilise une valeur, mais n'en prenne pas possessionÂ ? C'est
assez pÃ©nible que tout ce que nous passons doit Ãªtre retournÃ© si nous voulons
l'utiliser Ã  nouveau, en plus de toutes les donnÃ©es qui dÃ©coulent du corps
de la fonction que nous voulons aussi rÃ©cupÃ©rer.</p>
<!--
Itâ€™s possible to return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>Il est possible de retourner plusieurs valeurs Ã  l'aide d'un tuple, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, taille) = calculer_taille(s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s2, taille);
}

fn calculer_taille(s: String) -&gt; (String, usize) {
    let taille = s.len(); // len() retourne la taille d'une String.

    (s, taille)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">Encart 4-5Â : Retourner la possession des paramÃ¨tres</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
*references*.
-->
<p>Mais c'est trop laborieux et beaucoup de travail pour un principe qui devrait
Ãªtre banal. Heureusement pour nous, Rust a une fonctionnalitÃ© pour ce principe,
c'est ce qu'on appelle les <em>rÃ©fÃ©rences</em>.</p>
<!-- markdownlint-disable -->
<!--
[data-types]: ch03-02-data-types.html#data-types
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->
<!-- markdownlint-restore -->
<!--
## References and Borrowing
-->
<h2><a class="header" href="#les-rÃ©fÃ©rences-et-lemprunt" id="les-rÃ©fÃ©rences-et-lemprunt">Les rÃ©fÃ©rences et l'emprunt</a></h2>
<!--
The issue with the tuple code in Listing 4-5 is that we have to return the
`String` to the calling function so we can still use the `String` after the
call to `calculate_length`, because the `String` was moved into
`calculate_length`.
-->
<p>La difficultÃ© avec le code du tuple Ã  la fin de la section prÃ©cÃ©dente est que
nous avons besoin de retourner la <code>String</code> au code appelant pour qu'il puisse
continuer Ã  utiliser la <code>String</code> aprÃ¨s l'appel Ã  <code>calculer_taille</code>, car la
<code>String</code> a Ã©tÃ© dÃ©placÃ©e dans <code>calculer_taille</code>.</p>
<!--
Here is how you would define and use a `calculate_length` function that has a
reference to an object as a parameter instead of taking ownership of the
value:
-->
<p>Voici comment dÃ©finir et utiliser une fonction <code>calculer_taille</code> qui prend une
<em>rÃ©fÃ©rence</em> Ã  un objet en paramÃ¨tre plutÃ´t que de prendre possession de la
valeurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
}

fn calculer_taille(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!--
First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass `&s1` into
`calculate_length` and, in its definition, we take `&String` rather than
`String`.
-->
<p>PremiÃ¨rement, on peut observer que tout le code des <em>tuples</em> dans la dÃ©claration
des variables et dans la valeur de retour de la fonction a Ã©tÃ© enlevÃ©.
DeuxiÃ¨mement, remarquez que nous passons <code>&amp;s1</code> Ã  <code>calculer_taille</code>, et que dans
sa dÃ©finition, nous utilisons <code>&amp;String</code> plutÃ´t que <code>String</code>.</p>
<!--
These ampersands are *references*, and they allow you to refer to some value
without taking ownership of it. Figure 4-5 shows a diagram.
-->
<p>Ces esperluettes sont des <em>rÃ©fÃ©rences</em>, et elles permettent de vous rÃ©fÃ©rer Ã 
une valeur sans en prendre possession. L'illustration 4-5 nous montre cela dans
un schÃ©ma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img alt="&String s qui pointe vers la String s1" src="img/trpl04-05.svg"
class="center" /></p>
<!--
<span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String
s1`</span>
-->
<p><span class="caption">Illustration 4-5Â : Un schÃ©ma de la <code>&amp;String s</code> qui pointe
vers la <code>String s1</code></span></p>
<!--
> Note: The opposite of referencing by using `&` is *dereferencing*, which is
> accomplished with the dereference operator, `*`. Weâ€™ll see some uses of the
> dereference operator in Chapter 8 and discuss details of dereferencing in
> Chapter 15.
-->
<blockquote>
<p>RemarqueÂ : l'opposÃ© de la crÃ©ation de rÃ©fÃ©rences avec <code>&amp;</code> est le
<em>dÃ©rÃ©fÃ©rencement</em>, qui s'effectue avec l'opÃ©rateur de dÃ©rÃ©fÃ©rencement, <code>*</code>.
Nous allons voir quelques utilisations de l'opÃ©rateur de dÃ©rÃ©fÃ©rencement dans
le chapitre 8 et nous aborderons les dÃ©tails du dÃ©rÃ©fÃ©rencement dans le
chapitre 15.</p>
</blockquote>
<!--
Letâ€™s take a closer look at the function call here:
-->
<p>Regardons de plus prÃ¨s l'appel Ã  la fonctionÂ :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
# fn calculate_length(s: &String) -> usize {
#     s.len()
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculer_taille(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<!--
The `&s1` syntax lets us create a reference that *refers* to the value of `s1`
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference goes out of scope.
-->
<p>La syntaxe <code>&amp;s1</code> nous permet de crÃ©er une rÃ©fÃ©rence qui se <em>rÃ©fÃ¨re</em> Ã  la valeur
de <code>s1</code> mais n'en prend pas possession. Et comme elle ne la possÃ¨de pas, la
valeur vers laquelle elle pointe ne sera pas libÃ©rÃ©e quand cette rÃ©fÃ©rence
sortira de la portÃ©e.</p>
<!--
Likewise, the signature of the function uses `&` to indicate that the type of
the parameter `s` is a reference. Letâ€™s add some explanatory annotations:
-->
<p>De la mÃªme maniÃ¨re, la signature de la fonction utilise <code>&amp;</code> pour indiquer que
le type du paramÃ¨tre <code>s</code> est une rÃ©fÃ©rence. Ajoutons quelques commentaires
explicatifsÂ :</p>
<!--
```rust
# fn main() {
#     let s1 = String::from("hello");
# 
#     let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let long = calculer_taille(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculer_taille(s: &amp;String) -&gt; usize { // s est une rÃ©fÃ©rence Ã  une String
  s.len()
} // Ici, s sort de la portÃ©e. Mais comme elle ne prend pas possession de ce
  // Ã  quoi elle fait rÃ©fÃ©rence, il ne se passe rien.
</code></pre></pre>
<!--
The scope in which the variable `s` is valid is the same as any function
parameterâ€™s scope, but we donâ€™t drop what the reference points to when it goes
out of scope because we donâ€™t have ownership. When functions have references as
parameters instead of the actual values, we wonâ€™t need to return the values in
order to give back ownership, because we never had ownership.
-->
<p>La portÃ©e dans laquelle la variable <code>s</code> est en vigueur est la mÃªme que toute
portÃ©e d'un paramÃ¨tre de fonction, mais nous ne libÃ©rons pas ce sur quoi cette
rÃ©fÃ©rence pointe quand elle sort de la portÃ©e, car nous n'en prenons pas
possession. Lorsque les fonctions ont des rÃ©fÃ©rences en paramÃ¨tres au lieu des
valeurs rÃ©elles, nous n'avons pas besoin de retourner les valeurs pour les
rendre, car nous n'en avons jamais pris possession.</p>
<!--
We call having references as function parameters *borrowing*. As in real life,
if a person owns something, you can borrow it from them. When youâ€™re done, you
have to give it back.
-->
<p>Quand nous avons des rÃ©fÃ©rences dans les paramÃ¨tres d'une fonction, nous
appelons cela <em>l'emprunt</em>. Comme dans la vie rÃ©elle, quand un objet appartient
Ã  quelqu'un, vous pouvez le lui emprunter. Et quand vous avez fini, vous devez
le lui rendre.</p>
<!--
So what happens if we try to modify something weâ€™re borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesnâ€™t work!
-->
<p>Donc qu'est-ce qui se passe si nous essayons de modifier quelque chose que nous
empruntonsÂ ? Essayez le code dans l'encart 4-6. Attention, spoilerÂ : cela ne
fonctionne pasÂ !</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    changer(&amp;s);
}

fn changer(texte: &amp;String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 4-6: Attempting to modify a borrowed value</span>
-->
<p><span class="caption">EntrÃ©e 4-6Â : Tentative de modification d'une valeur
empruntÃ©e.</span></p>
<!--
Hereâ€™s the error:
-->
<p>Voici l'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 -- > src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut std::string::String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*texte` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn changer(texte: &amp;String) {
  |                   ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
8 |     texte.push_str(&quot;, world&quot;);
  |     ^^^^^ `texte` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Just as variables are immutable by default, so are references. Weâ€™re not
allowed to modify something we have a reference to.
-->
<p>Comme les variables sont immuables par dÃ©faut, les rÃ©fÃ©rences le sont aussi.
Nous ne sommes pas autorisÃ©s Ã  modifier une chose quand nous avons une rÃ©fÃ©rence
vers elle.</p>
<!--
### Mutable References
-->
<h3><a class="header" href="#les-rÃ©fÃ©rences-mutables" id="les-rÃ©fÃ©rences-mutables">Les rÃ©fÃ©rences mutables</a></h3>
<!--
We can fix the error in the code from Listing 4-6 with just a small tweak:
-->
<p>Nous pouvons rÃ©soudre l'erreur du code de l'encart 4-6 avec une petite
modificationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    changer(&amp;mut s);
}

fn changer(texte: &amp;mut String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!--
First, we had to change `s` to be `mut`. Then we had to create a mutable
reference with `&mut s` and accept a mutable reference with `some_string: &mut
String`.
-->
<p>D'abord, nous avons dÃ» prÃ©ciser que <code>s</code> est <code>mut</code>. Ensuite, nous avons dÃ»
crÃ©er une rÃ©fÃ©rence mutable avec <code>&amp;mut s</code> et accepter de prendre une rÃ©fÃ©rence
mutable avec <code>texte: &amp;mut String</code>.</p>
<!--
But mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data in a particular scope. This code will
fail:
-->
<p>Mais les rÃ©fÃ©rences mutables ont une grosse contrainteÂ : vous ne pouvez avoir
qu'une seule rÃ©fÃ©rence mutable pour chaque donnÃ©e dans chaque portÃ©e. Le code
suivant va Ã©chouerÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<!--
Hereâ€™s the error:
-->
<p>Voici l'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 -- > src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This restriction allows for mutation but in a very controlled fashion. Itâ€™s
something that new Rustaceans struggle with, because most languages let you
mutate whenever youâ€™d like.
-->
<p>Cette contrainte autorise les mutations, mais de maniÃ¨re trÃ¨s contrÃ´lÃ©e. C'est
quelque chose que les nouveaux RustacÃ©s ont du mal Ã  surmonter, car la plupart
des langages vous permettent de modifier les donnÃ©es quand vous le voulez.</p>
<!--
The benefit of having this restriction is that Rust can prevent data races at
compile time. A *data race* is similar to a race condition and happens when
these three behaviors occur:
-->
<p>L'avantage d'avoir cette contrainte est que Rust peut empÃªcher les accÃ¨s
concurrents au moment de la compilation. Un <em>accÃ¨s concurrent</em> est une situation
de concurrence qui se produit lorsque ces trois facteurs se combinentÂ :</p>
<!--
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* Thereâ€™s no mechanism being used to synchronize access to the data.
-->
<ul>
<li>Deux pointeurs ou plus accÃ¨dent Ã  la mÃªme donnÃ©e au mÃªme moment.</li>
<li>Au moins un des pointeurs est utilisÃ© pour Ã©crire dans cette donnÃ©e.</li>
<li>On n'utilise aucun mÃ©canisme pour synchroniser l'accÃ¨s aux donnÃ©es.</li>
</ul>
<!--
Data races cause undefined behavior and can be difficult to diagnose and fix
when youâ€™re trying to track them down at runtime; Rust prevents this problem
from happening because it wonâ€™t even compile code with data races!
-->
<p>L'accÃ¨s concurrent provoque des comportements indÃ©finis et rend difficile le
diagnostic et la rÃ©solution de problÃ¨mes lorsque vous essayez de les reproduire
au moment de l'exÃ©cutionÂ ; Rust Ã©vite ce problÃ¨me parce qu'il ne va pas compiler
du code avec des accÃ¨s concurrentsÂ !</p>
<!--
As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not *simultaneous* ones:
-->
<p>Comme d'habitude, nous pouvons utiliser des accolades pour crÃ©er une nouvelle
portÃ©e, pour nous permettre d'avoir plusieurs rÃ©fÃ©rences mutables, mais pas
<em>en mÃªme temps</em>Â :</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 sort de la portÃ©e ici, donc nous pouvons crÃ©er une nouvelle rÃ©fÃ©rence
      // sans problÃ¨mes.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<!--
A similar rule exists for combining mutable and immutable references. This code
results in an error:
-->
<p>Une rÃ¨gle similaire existe pour combiner les rÃ©fÃ©rences immuables et mutables.
Ce code va mener Ã  une erreurÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans problÃ¨me
    let r2 = &amp;s; // sans problÃ¨me
    let r3 = &amp;mut s; // GROS PROBLEME
    
    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<!--
Hereâ€™s the error:
-->
<p>Voici l'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // sans problÃ¨me
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // sans problÃ¨me
6 |     let r3 = &amp;mut s; // GROS PROBLEME
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Whew! We *also* cannot have a mutable reference while we have an immutable one.
Users of an immutable reference donâ€™t expect the values to suddenly change out
from under them! However, multiple immutable references are okay because no one
who is just reading the data has the ability to affect anyone elseâ€™s reading of
the data.
-->
<p>OuahÂ ! Nous ne pouvons pas <em>non plus</em> avoir une rÃ©fÃ©rence mutable pendant que
nous en avons une autre immuable. Les utilisateurs d'une rÃ©fÃ©rence immuable ne
s'attendent pas Ã  ce que sa valeur change soudainementÂ ! Cependant,
l'utilisation de plusieurs rÃ©fÃ©rences immuables ne pose pas de problÃ¨me, car
simplement lire une donnÃ©e ne va pas affecter la lecture de la donnÃ©e par les
autres.</p>
<!--
Note that a referenceâ€™s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references occurs before the
mutable reference is introduced:
-->
<p>Notez bien que la portÃ©e d'une rÃ©fÃ©rence commence dÃ¨s qu'elle est introduite et
se poursuit jusqu'au dernier endroit oÃ¹ cette rÃ©fÃ©rence est utilisÃ©e. Par
exemple, le code suivant va se compiler car la derniÃ¨re utilisation de la
rÃ©fÃ©rence immuable est situÃ©e avant l'introduction de la rÃ©fÃ©rence mutableÂ :</p>
<!--
```rust,edition2018
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // r1 and r2 are no longer used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans problÃ¨me
    let r2 = &amp;s; // sans problÃ¨me
    println!(&quot;{} et {}&quot;, r1, r2);
    // r1 et r2 ne sont plus utilisÃ©s Ã  partir d'ici
    
    let r3 = &amp;mut s; // sans problÃ¨me
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<!--
The scopes of the immutable references `r1` and `r2` end after the `println!`
where they are last used, which is before the mutable reference `r3` is
created. These scopes donâ€™t overlap, so this code is allowed.
-->
<p>Les portÃ©es des rÃ©fÃ©rences immuables <code>r1</code> et <code>r2</code> se terminent aprÃ¨s le
<code>println!</code> oÃ¹ elles sont utilisÃ©es pour la derniÃ¨re fois, c'est-Ã -dire avant que
la rÃ©fÃ©rence mutable <code>r3</code> soit crÃ©Ã©e. Ces portÃ©es ne se chevauchent pas, donc ce
code est autorisÃ©.</p>
<!--
Even though borrowing errors may be frustrating at times, remember that itâ€™s
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you donâ€™t
have to track down why your data isnâ€™t what you thought it was.
-->
<p>MÃªme si ces erreurs d'emprunt peuvent parfois Ãªtre frustrantes, n'oubliez pas
que le compilateur de Rust nous signale un bogue potentiel en avance (au moment
de la compilation plutÃ´t que l'exÃ©cution) et vous montre oÃ¹ se situe exactement
le problÃ¨me. Ainsi, vous n'avez pas Ã  chercher pourquoi vos donnÃ©es ne
correspondent pas Ã  ce que vous pensiez qu'elles devraient Ãªtre.</p>
<!--
### Dangling References
-->
<h3><a class="header" href="#les-rÃ©fÃ©rences-pendouillantes" id="les-rÃ©fÃ©rences-pendouillantes">Les rÃ©fÃ©rences pendouillantes</a></h3>
<!--
In languages with pointers, itâ€™s easy to erroneously create a *dangling
pointer*, a pointer that references a location in memory that may have been
given to someone else, by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.
-->
<p>Avec les langages qui utilisent les pointeurs, il est facile de crÃ©er par erreur
un <em>pointeur pendouillant</em> (<em>dangling pointer</em>), qui est un pointeur qui pointe
vers un emplacement mÃ©moire qui a Ã©tÃ© donnÃ© Ã  quelqu'un d'autre, en libÃ©rant de
la mÃ©moire tout en conservant un pointeur vers cette mÃ©moire. En revanche, avec
Rust, le compilateur garantit que les rÃ©fÃ©rences ne seront jamais des rÃ©fÃ©rences
pendouillantesÂ : si nous avons une rÃ©fÃ©rence vers une donnÃ©e, le compilateur va
s'assurer que cette donnÃ©e ne va pas sortir de la portÃ©e avant que la rÃ©fÃ©rence
vers cette donnÃ©e en soit elle-mÃªme sortie.</p>
<!--
Letâ€™s try to create a dangling reference, which Rust will prevent with a
compile-time error:
-->
<p>Essayons de crÃ©er une rÃ©fÃ©rence pendouillante, ce que Rust va empÃªcher avec une
erreur au moment de la compilationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_vers_rien = pendouille();
}

fn pendouille() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!--
Hereâ€™s the error:
-->
<p>Voici l'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 -- > src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ help: consider giving it a 'static lifetime: `&'static`
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn pendouille() -&gt; &amp;String {
  |                    ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error message refers to a feature we havenâ€™t covered yet: lifetimes. Weâ€™ll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:
-->
<p>Ce message d'erreur fait rÃ©fÃ©rence Ã  une fonctionnalitÃ© que nous n'avons pas
encore vueÂ : les <em>durÃ©es de vie</em>. Nous aborderons les durÃ©es de vie dans le
chapitre 10. Mais, si vous mettez de cÃ´tÃ© les parties qui parlent de durÃ©es de
vie, le message explique pourquoi le code pose problÃ¨meÂ :</p>
<!--
```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
```
-->
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>Ce qui peut se traduire parÂ :</p>
<pre><code class="language-text">Le type de retour de cette fonction contient une valeur empruntÃ©e, mais il n'y a
plus aucune valeur qui peut Ãªtre empruntÃ©e.
</code></pre>
<!--
Letâ€™s take a closer look at exactly whatâ€™s happening at each stage of our
`dangle` code:
-->
<p>Regardons de plus prÃ¨s ce qui se passe exactement Ã  chaque Ã©tape de notre code
de <code>pendouille</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let reference_to_nothing = dangle();
# }
# 
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_vers_rien = pendouille();
</span><span class="boring">}
</span><span class="boring">
</span>fn pendouille() -&gt; &amp;String { // pendouille retourne une rÃ©fÃ©rence vers une String

  let s = String::from(&quot;hello&quot;); // s est une nouvelle String

  &amp;s // nous retournons une rÃ©fÃ©rence vers la String, s
} // Ici, s sort de la portÃ©e, et est libÃ©rÃ©. Sa mÃ©moire disparaÃ®t.
  // Attention, dangerÂ !
</code></pre>
<!--
Because `s` is created inside `dangle`, when the code of `dangle` is finished,
`s` will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid `String`. Thatâ€™s no good! Rust
wonâ€™t let us do this.
-->
<p>Comme <code>s</code> est crÃ©Ã© dans <code>pendouille</code>, lorsque le code de <code>pendouille</code> est
terminÃ©, la variable <code>s</code> sera dÃ©sallouÃ©e. Mais nous avons essayÃ© de retourner
une rÃ©fÃ©rence vers elle. Cela veut dire que cette rÃ©fÃ©rence va pointer vers une
<code>String</code> invalide. Ce n'est pas bon ! Rust ne nous laissera pas faire cela.</p>
<!--
The solution here is to return the `String` directly:
-->
<p>Ici la solution est de renvoyer la <code>String</code> directementÂ :</p>
<!--
```rust
# fn main() {
#     let string = no_dangle();
# }
# 
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = ne_pendouille_pas();
</span><span class="boring">}
</span><span class="boring">
</span>fn ne_pendouille_pas() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<!--
This works without any problems. Ownership is moved out, and nothing is
deallocated.
-->
<p>Cela fonctionne sans problÃ¨me. La possession est transfÃ©rÃ©e Ã  la valeur de
retour de la fonction, et rien n'est dÃ©sallouÃ©.</p>
<!--
### The Rules of References
-->
<h3><a class="header" href="#les-rÃ¨gles-de-rÃ©fÃ©rencement" id="les-rÃ¨gles-de-rÃ©fÃ©rencement">Les rÃ¨gles de rÃ©fÃ©rencement</a></h3>
<!--
Letâ€™s recap what weâ€™ve discussed about references:
-->
<p>RÃ©capitulons ce que nous avons vu Ã  propos des rÃ©fÃ©rencesÂ :</p>
<!--
* At any given time, you can have *either* one mutable reference *or* any
  number of immutable references.
* References must always be valid.
-->
<ul>
<li>Ã€ un instant donnÃ©, vous pouvez avoir <em>soit</em> une rÃ©fÃ©rence mutable, <em>soit</em> un
nombre quelconque de rÃ©fÃ©rences immuables.</li>
<li>Les rÃ©fÃ©rences doivent toujours Ãªtre en vigueur.</li>
</ul>
<!--
Next, weâ€™ll look at a different kind of reference: slices.
-->
<p>Ensuite, nous aborderons un autre type de rÃ©fÃ©renceÂ : les <em>slices</em>.</p>
<!--
## The Slice Type
-->
<h2><a class="header" href="#le-type-slice" id="le-type-slice">Le type slice</a></h2>
<!--
Another data type that does not have ownership is the *slice*. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.
-->
<p>Un autre type de donnÃ©e qui ne prend pas possession est la <em>slice</em>. Une slice
vous permet d'obtenir une rÃ©fÃ©rence vers une sÃ©quence continue d'Ã©lÃ©ments d'une
collection plutÃ´t que toute la collection.</p>
<!--
Hereâ€™s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesnâ€™t find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>Voici un petit problÃ¨me de programmationÂ : Ã©crire une fonction qui prend une
chaÃ®ne de caractÃ¨res et retourne le premier mot qu'elle trouve dans cette
chaÃ®ne. Si la fonction ne trouve pas d'espace dans la chaÃ®ne, cela veut dire
que la chaÃ®ne est en un seul mot, donc la chaÃ®ne en entier doit Ãªtre retournÃ©e.</p>
<!--
Letâ€™s think about the signature of this function:
-->
<p>Imaginons la signature de cette fonctionÂ :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> ?
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; ?
</code></pre>
<!--
This function, `first_word`, has a `&String` as a parameter. We donâ€™t want
ownership, so this is fine. But what should we return? We donâ€™t really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word. Letâ€™s try that, as shown in Listing 4-7.
-->
<p>Cette fonction, <code>premier_mot</code>, prend un <code>&amp;String</code> comme paramÃ¨tre. Nous ne
voulons pas en prendre possession, donc c'est ce qu'il nous faut. Mais que
devons-nous retournerÂ ? Nous n'avons aucun moyen de dÃ©signer une <em>partie</em>
d'une chaÃ®ne de caractÃ¨res. Cependant, nous pouvons retourner l'indice de la
fin du mot. Essayons cela, dans l'encart 4-7Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; usize {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">Encart 4-7Â : La fonction <code>premier_mot</code> qui retourne
l'indice d'un octet provenant du paramÃ¨tre <code>String</code></span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, weâ€™ll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p>Comme nous avons besoin de parcourir la <code>String</code> Ã©lÃ©ment par Ã©lÃ©ment et de
vÃ©rifier si la valeur est une espace, nous convertissons notre <code>String</code> en un
tableau d'octets en utilisant la mÃ©thode <code>as_bytes</code>Â :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span>    let octets = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>Ensuite, nous crÃ©ons un itÃ©rateur sur le tableau d'octets en utilisant la
mÃ©thode <code>iter</code>Â :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
    for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;element) in octets.iter().enumerate() {
<span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Weâ€™ll discuss iterators in more detail in Chapter 13. For now, know that `iter`
is a method that returns each element in a collection and that `enumerate`
wraps the result of `iter` and returns each element as part of a tuple instead.
The first element of the tuple returned from `enumerate` is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.
-->
<p>Nous aborderons plus en dÃ©tail les itÃ©rateurs dans le chapitre 13. Pour le
moment, sachez que <code>iter</code> est une mÃ©thode qui retourne chaque Ã©lÃ©ment d'une
collection, et que <code>enumerate</code> transforme le rÃ©sultat de <code>iter</code> pour retourner
plutÃ´t chaque Ã©lÃ©ment comme un tuple. Le premier Ã©lÃ©ment du tuple retournÃ© par
<code>enumerate</code> est l'indice, et le second Ã©lÃ©ment est une rÃ©fÃ©rence vers l'Ã©lÃ©ment.
C'est un peu plus pratique que de calculer les indices par nous-mÃªmes.</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple, just like everywhere else in Rust. So in the `for`
loop, we specify a pattern that has `i` for the index in the tuple and `&item`
for the single byte in the tuple. Because we get a reference to the element
from `.iter().enumerate()`, we use `&` in the pattern.
-->
<p>Comme la mÃ©thode <code>enumerate</code> retourne un tuple, nous pouvons utiliser des motifs
pour dÃ©structurer ce tuple, comme nous pourrions le faire n'importe oÃ¹ avec
Rust. Donc dans la boucle <code>for</code>, nous prÃ©cisons un motif qui indique que nous
dÃ©finissons <code>i</code> pour l'indice au sein du tuple et <code>&amp;element</code> pour l'octet dans
le tuple. Comme nous obtenons une rÃ©fÃ©rence vers l'Ã©lÃ©ment avec
<code>.iter().enumerate()</code>, nous utilisons <code>&amp;</code> dans le motif.</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p>Au sein de la boucle <code>for</code>, nous recherchons l'octet qui reprÃ©sente l'espace en
utilisant la syntaxe de littÃ©ral d'octet. Si nous trouvons une espace, nous
retournons sa position. Sinon, nous retournons la taille de la chaÃ®ne en
utilisant <code>s.len()</code>Â :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span>        if element == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but thereâ€™s a problem. Weâ€™re returning a `usize` on its own, but itâ€™s
only a meaningful number in the context of the `&String`. In other words,
because itâ€™s a separate value from the `String`, thereâ€™s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>Nous avons maintenant une faÃ§on de trouver l'indice de la fin du premier mot
dans la chaÃ®ne de caractÃ¨res, mais il y a un problÃ¨me. Nous retournons un
<code>usize</code> tout seul, mais il n'a du sens que lorsqu'il est liÃ© au <code>&amp;String</code>.
Autrement dit, comme il a une valeur sÃ©parÃ©e de la <code>String</code>, il n'y a pas de
garantie qu'il restera toujours valide dans le futur. Imaginons le programme
dans l'encart 4-8 qui utilise la fonction <code>premier_mot</code> de l'encart 4-7Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s); // la variable mot aura 5 comme valeur.

    s.clear(); // ceci vide la String, elle vaut maintenant &quot;&quot;.

    // mot a toujours la valeur 5 ici, mais il n'y a plus de chaÃ®ne qui donne
    // du sens Ã  la valeur 5. mot est maintenant complÃ¨tement invalideÂ !
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">Encart 4-8Â : On stocke le rÃ©sultat de l'appel Ã  la
fonction <code>premier_mot</code> et ensuite on change le contenu de la <code>String</code></span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isnâ€™t connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>Ce programme se compile sans aucune erreur et le ferait toujours si nous
utilisions <code>mot</code> aprÃ¨s avoir appelÃ© <code>s.clear()</code>. Comme <code>mot</code> n'est pas du tout
liÃ© Ã  <code>s</code>, <code>mot</code> contient toujours la valeur <code>5</code>. Nous pourrions utiliser cette
valeur <code>5</code> avec la variable <code>s</code> pour essayer d'en extraire le premier mot, mais
cela serait un bogue, car le contenu de <code>s</code> a changÃ© depuis que nous avons
enregistrÃ© <code>5</code> dans <code>mot</code>.</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p>Se prÃ©occuper en permanence que l'indice prÃ©sent dans <code>mot</code> ne soit plus
synchronisÃ© avec les donnÃ©es prÃ©sentes dans <code>s</code> est fastidieux et source
d'erreurÂ ! La gestion de ces indices est encore plus risquÃ©e si nous Ã©crivons
une fonction <code>second_mot</code>. Sa signature ressemblerait Ã  ceciÂ :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now weâ€™re tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but arenâ€™t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.
-->
<p>Maintenant, nous avons un indice de dÃ©but <em>et</em> un indice de fin, donc nous avons
encore plus de valeurs qui sont calculÃ©es Ã  partir d'une donnÃ©e dans un Ã©tat
donnÃ©, mais qui ne sont pas liÃ©es du tout Ã  l'Ã©tat de cette donnÃ©e. Nous avons
maintenant trois variables isolÃ©es qui ont besoin d'Ãªtre maintenues Ã  jour.</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>Heureusement, Rust a une solution pour ce problÃ¨meÂ : les <em>slices</em> de chaÃ®nes de
caractÃ¨res.</p>
<!--
### String Slices
-->
<h3><a class="header" href="#les-slices-de-chaÃ®nes-de-caractÃ¨res" id="les-slices-de-chaÃ®nes-de-caractÃ¨res">Les slices de chaÃ®nes de caractÃ¨res</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p>Une <em>slice de chaÃ®ne de caractÃ¨res</em> (ou <em>slice de chaÃ®ne</em>) est une rÃ©fÃ©rence Ã 
une partie d'une <code>String</code>, et ressemble Ã  ceciÂ :</p>
<!--
```rust
# fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
This is similar to taking a reference to the whole `String` but with the extra
`[0..5]` bit. Rather than a reference to the entire `String`, itâ€™s a reference
to a portion of the `String`.
-->
<p>Cela ressemble Ã  une rÃ©fÃ©rence pour toute la <code>String</code>, mais avec la partie
<code>[0..5]</code> en plus. PlutÃ´t que d'Ãªtre une rÃ©fÃ©rence vers toute la <code>String</code>, c'est
une rÃ©fÃ©rence vers une partie de la <code>String</code>.</p>
<!-- markdownlint-disable -->
<!--
We can create slices using a range within brackets by specifying
`[starting_index..ending_index]`, where `starting_index` is the first position
in the slice and `ending_index` is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to `ending_index` minus
`starting_index`. So in the case of `let world = &s[6..11];`, `world` would be
a slice that contains a pointer to the 7th byte (counting from 1) of `s` with a length value of 5.
-->
<!-- markdownlint-enable -->
<p>Nous pouvons crÃ©er des slices en utilisant un intervalle entre crochets en
spÃ©cifiant <code>[indice_debut..indice_fin]</code>, oÃ¹ <code>indice_debut</code> est la position du
premier octet de la slice et <code>indice_fin</code> est la position juste aprÃ¨s le dernier
octet de la slice. En interne, la structure de donnÃ©es de la slice stocke la
position de dÃ©part et la longueur de la slice, ce qui correspond Ã  <code>indice_fin</code>
moins <code>indice_debut</code>. Donc dans le cas de <code>let world = &amp;s[6..11];</code>, <code>world</code> est
une slice qui contient un pointeur vers le septiÃ¨me octet (en comptant Ã  partir
de 1) de <code>s</code> et une longueur de 5.</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>L'illustration 4-6 montre ceci dans un schÃ©ma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="world contient un pointeur vers l'octet d'indice 6 de la String s et
une longueur de 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">Illustration 4-6Â : Une slice de chaÃ®ne qui pointe vers
une partie d'une <code>String</code></span></p>
<!--
With Rustâ€™s `..` range syntax, if you want to start at the first index (zero),
you can drop the value before the two periods. In other words, these are equal:
-->
<p>Avec la syntaxe d'intervalle <code>..</code> de Rust, si vous voulez commencer au premier
indice (zÃ©ro), vous pouvez ne rien mettre avant les deux points. Autrement dit,
ces deux cas sont identiquesÂ :</p>
<!--
```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>De la mÃªme maniÃ¨re, si votre slice contient le dernier octet de la <code>String</code>,
vous pouvez ne rien mettre Ã  la fin. Cela veut dire que ces deux cas sont
identiquesÂ :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[3..taille];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>Vous pouvez aussi ne mettre aucune limite pour crÃ©er une slice de toute la
chaÃ®ne de caractÃ¨res. Ces deux cas sont donc identiquesÂ :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[0..taille];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [â€œStoring UTF-8 Encoded
> Text with Stringsâ€][strings]<!-- ignore -- > section of Chapter 8.
-->
<blockquote>
<p>RemarqueÂ : Les indices de l'intervalle d'une slice de chaÃ®ne doivent toujours
se trouver dans les zones acceptables de sÃ©paration des caractÃ¨res encodÃ©s en
UTF-8. Si vous essayez de crÃ©er une slice de chaÃ®ne qui s'arrÃªte au milieu
d'un caractÃ¨re encodÃ© sur plusieurs octets, votre programme va se fermer avec
une erreur. Afin de simplifier l'explication des slices de chaÃ®nes, nous
utiliserons uniquement l'ASCII dans cette sectionÂ ; nous verrons la gestion
d'UTF-8 dans la section <a href="ch08-02-strings.html">â€œStocker du texte encodÃ© en UTF-8 avec les chaÃ®nes de
caractÃ¨resâ€</a><!-- ignore --> du chapitre 8.</p>
</blockquote>
<!--
With all this information in mind, letâ€™s rewrite `first_word` to return a
slice. The type that signifies â€œstring sliceâ€ is written as `&str`:
-->
<p>Maintenant que nous savons tout cela, essayons de rÃ©Ã©crire <code>premier_mot</code> pour
qu'il retourne une slice. Le type pour les slices de chaÃ®nes de caractÃ¨res
s'Ã©crit <code>&amp;str</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>Nous rÃ©cupÃ©rons l'indice de la fin du mot de la mÃªme faÃ§on que nous l'avions
fait dans l'encart 4-7, en cherchant la premiÃ¨re occurrence d'une espace.
Lorsque nous trouvons une espace, nous retournons une slice de chaÃ®ne en
utilisant le dÃ©but de la chaÃ®ne de caractÃ¨res et l'indice de l'espace comme
indices de dÃ©but et de fin respectivement.</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>DÃ©sormais, quand nous appelons <code>premier_mot</code>, nous rÃ©cupÃ©rons une unique valeur
qui est liÃ©e Ã  la donnÃ©e de base. La valeur se compose d'une rÃ©fÃ©rence vers le
point de dÃ©part de la slice et du nombre d'Ã©lÃ©ments dans la slice.</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p>Retourner une slice fonctionnerait aussi pour une fonction <code>second_mot</code>Â :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API thatâ€™s much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didnâ€™t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>Nous avons maintenant une API simple qui est bien plus difficile Ã  mal utiliser,
puisque le compilateur va s'assurer que les rÃ©fÃ©rences dans la <code>String</code> seront
toujours en vigueur. Vous souvenez-vous du bogue du programme de l'encart 4-8,
lorsque nous avions un indice vers la fin du premier mot mais qu'ensuite nous
avions vidÃ© la chaÃ®ne de caractÃ¨res et que notre indice n'Ã©tait plus valideÂ ? Ce
code Ã©tait logiquement incorrect, mais ne montrait pas immÃ©diatement une erreur.
Les problÃ¨mes apparaÃ®tront plus tard si nous essayons d'utiliser l'indice du
premier mot avec une chaÃ®ne de caractÃ¨res qui a Ã©tÃ© vidÃ©e. Les slices rendent ce
bogue impossible et nous signalent bien plus tÃ´t que nous avons un problÃ¨me avec
notre code. Utiliser la version avec la slice de <code>premier_mot</code> va causer une
erreur de compilationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn first_word(s: &String) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s);

    s.clear(); // ErreurÂ !

    println!(&quot;Le premier mot estÂ : {}&quot;, mot);
}
</code></pre>
<!--
Hereâ€™s the compiler error:
-->
<p>Voici l'erreur du compilateurÂ :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  -- > src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let mot = premier_mot(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // ErreurÂ !
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Le premier mot estÂ : {}&quot;, mot);
   |                                         --- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. Rust disallows
this, and compilation fails. Not only has Rust made our API easier to use, but
it has also eliminated an entire class of errors at compile time!
-->
<p>Rappelons-nous que d'aprÃ¨s les rÃ¨gles d'emprunt, si nous avons une rÃ©fÃ©rence
immuable vers quelque chose, nous ne pouvons pas avoir une rÃ©fÃ©rence mutable
en mÃªme temps. Ã‰tant donnÃ© que <code>clear</code> a besoin de modifier la <code>String</code>, il a
besoin d'une rÃ©fÃ©rence mutable. Rust interdit cette situation, et la compilation
Ã©choue. Non seulement Rust a simplifiÃ© l'utilisation de notre API, mais il a
aussi Ã©liminÃ© une catÃ©gorie entiÃ¨re d'erreurs au moment de la compilationÂ !</p>
<!--
#### String Literals Are Slices
-->
<h4><a class="header" href="#les-littÃ©raux-de-chaÃ®ne-de-caractÃ¨res-sont-aussi-des-slices" id="les-littÃ©raux-de-chaÃ®ne-de-caractÃ¨res-sont-aussi-des-slices">Les littÃ©raux de chaÃ®ne de caractÃ¨res sont aussi des slices</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>Rappelez-vous lorsque nous avons appris que les littÃ©raux de chaÃ®ne de
caractÃ¨res Ã©taient enregistrÃ©s dans le binaire. Maintenant que nous connaissons
les slices, nous pouvons dÃ©sormais comprendre les littÃ©raux de chaÃ®ne.</p>
<!--
```rust
let s = "Hello, world!";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: itâ€™s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>Ici, le type de <code>s</code> est un <code>&amp;str</code>Â : c'est une slice qui pointe vers un endroit
prÃ©cis du binaire. C'est aussi la raison pour laquelle les littÃ©raux de chaÃ®ne
sont immuablesÂ ; <code>&amp;str</code> est une rÃ©fÃ©rence immuable.</p>
<!--
#### String Slices as Parameters
-->
<h4><a class="header" href="#les-slices-de-chaÃ®nes-de-caractÃ¨res-en-paramÃ¨tres" id="les-slices-de-chaÃ®nes-de-caractÃ¨res-en-paramÃ¨tres">Les slices de chaÃ®nes de caractÃ¨res en paramÃ¨tres</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and thatâ€™s its signature:
-->
<p>Savoir que l'on peut utiliser des slices de littÃ©raux et de <code>String</code> nous incite
Ã  apporter une petite amÃ©lioration Ã  <code>premier_mot</code>, dont voici la signatureÂ :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>Un RustacÃ© plus expÃ©rimentÃ© Ã©crirait plutÃ´t la signature de l'encart 4-9, car
cela nous permet d'utiliser la mÃªme fonction sur les <code>&amp;String</code> et aussi les
<code>&amp;str</code>Â :</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // first_word works on slices of `String`s
#     let word = first_word(&my_string[..]);
# 
#     let my_string_literal = "hello world";
# 
#     // first_word works on slices of string literals
#     let word = first_word(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = first_word(my_string_literal);
# }
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ma_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // premier_mot fonctionne avec les slices de `String`
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[..]);
</span><span class="boring">
</span><span class="boring">    let mon_litteral_de_chaine = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // premier_mot fonctionne avec les slices de littÃ©raux de chaÃ®ne
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);
</span><span class="boring">
</span><span class="boring">    // Comme les littÃ©raux de chaÃ®ne *sont* dÃ©jÃ  des slices de chaÃ®nes,
</span><span class="boring">    // cela fonctionne aussi, sans la syntaxe de sliceÂ !
</span><span class="boring">    let mot = premier_mot(mon_litteral_de_chaine);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">Encart 4-9Â : AmÃ©lioration de la fonction <code>premier_mot</code> en
utilisant une slice de chaÃ®ne de caractÃ¨res comme type du paramÃ¨tre <code>s</code></span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the entire `String`. Defining a function to take a string
slice instead of a reference to a `String` makes our API more general and useful
without losing any functionality:
-->
<p>Si nous avons une slice de chaÃ®ne, nous pouvons la passer en argument
directement. Si nous avons une <code>String</code>, nous pouvons envoyer une slice de toute
la <code>String</code>. DÃ©finir une fonction qui prend une slice de chaÃ®ne plutÃ´t qu'une
rÃ©fÃ©rence Ã  une <code>String</code> rend notre API plus gÃ©nÃ©rique et plus utile sans perdre
aucune fonctionnalitÃ©Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let ma_string = String::from(&quot;hello world&quot;);

    // premier_mot fonctionne avec les slices de `String`
    let mot = premier_mot(&amp;ma_string[..]);

    let mon_litteral_de_chaine = &quot;hello world&quot;;

    // premier_mot fonctionne avec les slices de littÃ©raux de chaÃ®ne
    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);

    // Comme les littÃ©raux de chaÃ®ne *sont* dÃ©jÃ  des slices de chaÃ®nes,
    // cela fonctionne aussi, sans la syntaxe de sliceÂ !
    let mot = premier_mot(mon_litteral_de_chaine);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3><a class="header" href="#les-autres-slices" id="les-autres-slices">Les autres slices</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But thereâ€™s a
more general slice type, too. Consider this array:
-->
<p>Les slices de chaÃ®nes de caractÃ¨res, comme vous pouvez l'imaginer, sont
spÃ©cifiques aux chaÃ®nes de caractÃ¨res. Mais il existe aussi un type de slice
plus gÃ©nÃ©rique. Imaginons ce tableau de donnÃ©esÂ :</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. Weâ€™d do so like this:
-->
<p>Tout comme nous pouvons nous rÃ©fÃ©rer Ã  une partie d'une chaÃ®ne de caractÃ¨res,
nous pouvons nous rÃ©fÃ©rer Ã  une partie d'un tableau. Nous pouvons le faire comme
ceciÂ :</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. Youâ€™ll use this kind of
slice for all sorts of other collections. Weâ€™ll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>Cette slice est de type <code>&amp;[i32]</code>. Elle fonctionne de la mÃªme maniÃ¨re que les
slices de chaÃ®nes de caractÃ¨res, en enregistrant une rÃ©fÃ©rence vers le premier
Ã©lÃ©ment et une longueur. Vous utiliserez ce type de slice pour tous les autres
types de collections. Nous aborderons ces collections en dÃ©tail quand nous
verrons les vecteurs au chapitre 8.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-3" id="rÃ©sumÃ©-3">RÃ©sumÃ©</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you donâ€™t have to write and debug extra code to get this control.
-->
<p>Les concepts de possession, d'emprunt et de slices garantissent la sÃ©curitÃ© de
la mÃ©moire dans les programmes Rust au moment de la compilation. Le langage Rust
vous donne le contrÃ´le sur l'utilisation de la mÃ©moire comme tous les autres
langages de programmation systÃ¨me, mais le fait que celui qui possÃ¨de des
donnÃ©es nettoie automatiquement ces donnÃ©es quand il sort de la portÃ©e vous
permet de ne pas avoir Ã  Ã©crire et dÃ©boguer du code en plus pour avoir cette
fonctionnalitÃ©.</p>
<!--
Ownership affects how lots of other parts of Rust work, so weâ€™ll talk about
these concepts further throughout the rest of the book. Letâ€™s move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>La possession influe sur de nombreuses autres fonctionnalitÃ©s de Rust, c'est
pourquoi nous allons encore parler de ces concepts plus loin dans le livre.
Passons maintenant au chapitre 5 et dÃ©couvrons comment regrouper des donnÃ©es
ensemble dans une <code>struct</code>.</p>
<!--
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
-->
<!-- # Using Structs to Structure Related Data -->
<h1><a class="header" href="#utiliser-les-structures-pour-structurer-des-donnÃ©es-apparentÃ©es" id="utiliser-les-structures-pour-structurer-des-donnÃ©es-apparentÃ©es">Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></h1>
<!--
A *struct*, or *structure*, is a custom data type that lets you name and
package together multiple related values that make up a meaningful group. If
youâ€™re familiar with an object-oriented language, a *struct* is like an
objectâ€™s data attributes. In this chapter, weâ€™ll compare and contrast tuples
with structs, demonstrate how to use structs, and discuss how to define methods
and associated functions to specify behavior associated with a structâ€™s data.
Structs and enums (discussed in Chapter 6) are the building blocks for creating
new types in your programâ€™s domain to take full advantage of Rustâ€™s compile
time type checking.
-->
<p>Une <em>struct</em>, ou <em>structure</em>, est un type de donnÃ©es personnalisÃ© qui vous
permet de nommer et de rassembler plusieurs valeurs associÃ©es qui forment
un groupe cohÃ©rent.
Si vous Ãªtes familier avec un langage orientÃ© objet, une structure est en
quelque sorte l'ensemble des attributs d'un objet.
Dans ce chapitre, nous comparerons les tuples avec les structures, nous
montrerons comment utiliser les structures et nous aborderons la dÃ©finition des
mÃ©thodes et des fonctions associÃ©es pour spÃ©cifier le comportement associÃ© aux
donnÃ©es d'une structure.
Les structures et les Ã©numÃ©rations (traitÃ©es au chapitre 6) sont les fondements
de la crÃ©ation de nouveaux types au sein de votre programme pour tirer
pleinement parti des vÃ©rifications de types effectuÃ©es par Rust Ã  la
compilation.</p>
<!--
## Defining and Instantiating Structs
-->
<h2><a class="header" href="#dÃ©finir-et-instancier-des-structures" id="dÃ©finir-et-instancier-des-structures">DÃ©finir et instancier des structures</a></h2>
<!--
Structs are similar to tuples, which were discussed in Chapter 3. Like tuples,
the pieces of a struct can be different types. Unlike with tuples, youâ€™ll name
each piece of data so itâ€™s clear what the values mean. As a result of these
names, structs are more flexible than tuples: you donâ€™t have to rely on the
order of the data to specify or access the values of an instance.
-->
<p>Les structures sont similaires aux tuples, qu'on a vus au chapitre 3. Comme pour
les tuples, les Ã©lÃ©ments d'une structure peuvent Ãªtre de diffÃ©rents types.
Contrairement aux tuples, on doit nommer chaque Ã©lÃ©ment des donnÃ©es afin de
clarifier le rÃ´le de chaque valeur. GrÃ¢ce Ã  ces noms, les structures sont plus
flexibles que les tuplesÂ : on n'a pas Ã  utiliser l'ordre des donnÃ©es pour
spÃ©cifier ou accÃ©der aux valeurs d'une instance.</p>
<!--
To define a struct, we enter the keyword `struct` and name the entire struct. A
structâ€™s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call *fields*. For example, Listing 5-1 shows a
struct that stores information about a user account.
-->
<p>Pour dÃ©finir une structure, on tape le mot-clÃ© <code>struct</code> et on donne un nom Ã 
toute la structure. Le nom d'une structure devrait dÃ©crire l'utilisation des
Ã©lÃ©ments des donnÃ©es regroupÃ©s. Ensuite, entre des accolades, on dÃ©finit le nom
et le type de chaque Ã©lÃ©ment des donnÃ©es, qu'on appelle un <em>champ</em>. Par exemple,
l'encart 5-1 montre une structure qui stocke des informations Ã  propos d'un
compte d'utilisateur.</p>
<!--
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Utilisateur {
    pseudo: String,
    email: String,
    nombre_de_connexions: u64,
    actif: bool,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-1: A `User` struct definition</span>
-->
<p><span class="caption">Encart 5-1Â : La dÃ©finition d'une structure
<code>Utilisateur</code></span></p>
<!--
To use a struct after weâ€™ve defined it, we create an *instance* of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing `key:
value` pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We donâ€™t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.
-->
<p>Pour utiliser une structure aprÃ¨s l'avoir dÃ©finie, on crÃ©e une <em>instance</em> de
cette structure en indiquant des valeurs concrÃ¨tes pour chacun des champs.
On crÃ©e une instance en indiquant le nom de la structure puis en ajoutant des
accolades qui contiennent des paires de <code>clÃ©: valeur</code>, oÃ¹ les clÃ©s sont les noms
des champs et les valeurs sont les donnÃ©es que l'on souhaite stocker dans ces
champs. Nous n'avons pas Ã  prÃ©ciser les champs dans le mÃªme ordre qu'on les a
dÃ©clarÃ©s dans la structure. En d'autres termes, la dÃ©finition de la structure
dÃ©crit un gabarit pour le type, et les instances remplissent ce gabarit avec des
donnÃ©es prÃ©cises pour crÃ©er des valeurs de ce type. Par exemple, nous pouvons
dÃ©clarer un utilisateur prÃ©cis comme dans l'encart 5-2.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-2: Creating an instance of the `User`
struct</span>
-->
<p><span class="caption">Encart 5-2Â : CrÃ©ation d'une instance de la structure
<code>Utilisateur</code></span></p>
<!--
To get a specific value from a struct, we can use dot notation. If we wanted
just this userâ€™s email address, we could use `user1.email` wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the `email` field of a mutable `User` instance.
-->
<p>Pour obtenir une valeur spÃ©cifique depuis une structure, on utilise la notation
avec le point. Si nous voulions seulement l'adresse e-mail de cet utilisateur,
on pourrait utiliser <code>utilisateur1.email</code> partout oÃ¹ on voudrait utiliser cette
valeur. Si l'instance est mutable, nous pourrions changer une valeur en
utilisant la notation avec le point et assigner une valeur Ã  ce champ en
particulier. L'encart 5-3 montre comment changer la valeur du champ <code>email</code>
d'une instance mutable de <code>Utilisateur</code>.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
    
    utilisateur1.email = String::from(&quot;unautremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-3: Changing the value in the `email` field of a
`User` instance</span>
-->
<p><span class="caption">Encart 5-3Â : Changement de la valeur du champ <code>email</code>
d'une instance de <code>Utilisateur</code></span></p>
<!--
Note that the entire instance must be mutable; Rust doesnâ€™t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.
-->
<p>Ã€ noter que l'instance tout entiÃ¨re doit Ãªtre mutableÂ ; Rust ne nous permet pas
de marquer seulement certains champs comme mutables. Comme pour toute
expression, nous pouvons construire une nouvelle instance de la structure comme
derniÃ¨re expression du corps d'une fonction pour retourner implicitement cette
nouvelle instance.</p>
<!--
Listing 5-4 shows a `build_user` function that returns a `User` instance with
the given email and username. The `active` field gets the value of `true`, and
the `sign_in_count` gets a value of `1`.
-->
<p>L'encart 5-4 montre une fonction <code>creer_utilisateur</code> qui retourne une instance
de <code>Utilisateur</code> avec l'adresse e-mail et le pseudo fournis. Le champ <code>actif</code>
prend la valeur <code>true</code> et le <code>nombre_de_connexions</code> prend la valeur <code>1</code>.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email: email,
        pseudo: pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-4: A `build_user` function that takes an email
and username and returns a `User` instance</span>
-->
<p><span class="caption">Encart 5-4Â : Une fonction <code>creer_utilisateur</code> qui prend
en entrÃ©e une adresse e-mail et un pseudo et retourne une instance de
<code>Utilisateur</code></span></p>
<!--
It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the `email` and `username` field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, thereâ€™s a convenient shorthand!
-->
<p>Il est logique de nommer les paramÃ¨tres de fonction avec le mÃªme nom que les
champs de la structure, mais devoir rÃ©pÃ©ter les noms de variables et de champs
<code>email</code> et <code>pseudo</code> est un peu pÃ©nible. Si la structure avait plus de champs,
rÃ©pÃ©ter chaque nom serait encore plus fatigant. Heureusement, il existe un
raccourci pratiqueÂ !</p>
<!--
### Using the Field Init Shorthand when Variables and Fields Have the Same Name
-->
<h3><a class="header" href="#utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-mÃªme-nom" id="utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-mÃªme-nom">Utiliser le raccourci d'initialisation des champs lorsque les variables et les champs ont le mÃªme nom</a></h3>
<!--
Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the *field init shorthand* syntax to rewrite
`build_user` so that it behaves exactly the same but doesnâ€™t have the
repetition of `email` and `username`, as shown in Listing 5-5.
-->
<p>Puisque les noms des paramÃ¨tres et les noms de champs de la structure sont
exactement les mÃªmes dans l'encart 5-4, on peut utiliser la syntaxe de
<em>raccourci d'initialisation des champs</em> pour rÃ©Ã©crire <code>creer_utilisateur</code> de
sorte qu'elle se comporte exactement de la mÃªme faÃ§on sans avoir Ã  rÃ©pÃ©ter
<code>email</code> et <code>pseudo</code>, comme le montre l'encart 5-5.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email,
        pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-5: A `build_user` function that uses field init
shorthand because the `email` and `username` parameters have the same name as
struct fields</span>
-->
<p><span class="caption">Encart 5-5Â : Une fonction <code>creer_utilisateur</code> qui utilise
le raccourci d'initialisation des champs parce que les paramÃ¨tres <code>email</code> et
<code>pseudo</code> ont le mÃªme nom que les champs de la structure</span></p>
<!--
Here, weâ€™re creating a new instance of the `User` struct, which has a field
named `email`. We want to set the `email` fieldâ€™s value to the value in the
`email` parameter of the `build_user` function. Because the `email` field and
the `email` parameter have the same name, we only need to write `email` rather
than `email: email`.
-->
<p>Ici, on crÃ©e une nouvelle instance de la structure <code>Utilisateur</code>, qui possÃ¨de
un champ nommÃ© <code>email</code>. On veut donner au champ <code>email</code> la valeur du paramÃ¨tre
<code>email</code> de la fonction <code>creer_utilisateur</code>. Comme le champ <code>email</code> et le
paramÃ¨tre <code>email</code> ont le mÃªme nom, on a uniquement besoin d'Ã©crire <code>email</code>
plutÃ´t que <code>email: email</code>.</p>
<!--
### Creating Instances From Other Instances With Struct Update Syntax
-->
<h3><a class="header" href="#crÃ©er-des-instances-Ã -partir-dautres-instances-avec-la-syntaxe-de-mise-Ã -jour-de-structure" id="crÃ©er-des-instances-Ã -partir-dautres-instances-avec-la-syntaxe-de-mise-Ã -jour-de-structure">CrÃ©er des instances Ã  partir d'autres instances avec la syntaxe de mise Ã  jour de structure</a></h3>
<!--
Itâ€™s often useful to create a new instance of a struct that uses most of an old
instanceâ€™s values but changes some. Youâ€™ll do this using *struct update syntax*.
-->
<p>Il est souvent utile de crÃ©er une nouvelle instance de structure qui utilise la
plupart des valeurs d'une ancienne instance tout en en changeant certaines. On
utilisera pour cela la <em>syntaxe de mise Ã  jour de structure</em>.</p>
<!--
First, Listing 5-6 shows how we create a new `User` instance in `user2` without
the update syntax. We set new values for `email` and `username` but otherwise
use the same values from `user1` that we created in Listing 5-2.
-->
<p>Tout d'abord, l'encart 5-6 nous montre comment crÃ©er une nouvelle instance de
<code>Utilisateur</code> dans <code>utilisateur2</code> sans la syntaxe de mise Ã  jour de structure.
On donne de nouvelles valeurs Ã  <code>email</code> et <code>pseudo</code> mais on utilise pour les
autres champs les mÃªmes valeurs que dans <code>utilisateur1</code> qu'on a crÃ©Ã© Ã 
l'encart 5-2.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };
# 
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let utilisateur2 = Utilisateur {
        email: String::from(&quot;quelquundautre@example.com&quot;),
        pseudo: String::from(&quot;autrepseudo567&quot;),
        actif: utilisateur1.actif,
        nombre_de_connexions: utilisateur1.nombre_de_connexions,
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-6: Creating a new `User` instance using some of
the values from `user1`</span>
-->
<p><span class="caption">Encart 5-6Â : CrÃ©ation d'une nouvelle instance de
<code>Utilisateur</code> en utilisant certaines valeurs de <code>utilisateur1</code>.</span></p>
<!--
Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax `..` specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.
-->
<p>En utilisant la syntaxe de mise Ã  jour de structure, on peut produire le mÃªme
rÃ©sultat avec moins de code, comme le montre l'encart 5-7. La syntaxe <code>..</code>
indique que les autres champs auxquels on ne donne pas explicitement de valeur
devraient avoir la mÃªme valeur que dans l'instance prÃ©cisÃ©e.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
# 
# fn main() {
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };
# 
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let utilisateur2 = Utilisateur {
        email: String::from(&quot;quelquundautre@example.com&quot;),
        pseudo: String::from(&quot;autrepseudo567&quot;),
        ..utilisateur1
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-7: Using struct update syntax to set new
`email` and `username` values for a `User` instance but use the rest of the
values from the fields of the instance in the `user1` variable</span>
-->
<p><span class="caption">Encart 5-7Â : Utilisation de la syntaxe de mise Ã  jour de
structure pour assigner de nouvelles valeurs Ã  <code>email</code> et <code>pseudo</code> Ã  une
nouvelle instance de <code>Utilisateur</code> tout en utilisant les autres valeurs des
champs de l'instance de la variable <code>utilisateur1</code></span></p>
<!--
The code in Listing 5-7 also creates an instance in `user2` that has a
different value for `email` and `username` but has the same values for the
`active` and `sign_in_count` fields from `user1`.
-->
<p>Le code dans l'encart 5-7 crÃ©e aussi une instance dans <code>utilisateur2</code> qui a une
valeur diffÃ©rente pour <code>email</code> et <code>pseudo</code> mais qui a les mÃªmes valeurs pour les
champs <code>actif</code> et <code>nombre_de_connexions</code> que <code>utilisateur1</code>.</p>
<!--
### Using Tuple Structs without Named Fields to Create Different Types
-->
<h3><a class="header" href="#utilisation-de-structures-tuples-sans-champ-nommÃ©-pour-crÃ©er-des-types-diffÃ©rents" id="utilisation-de-structures-tuples-sans-champ-nommÃ©-pour-crÃ©er-des-types-diffÃ©rents">Utilisation de structures tuples sans champ nommÃ© pour crÃ©er des types diffÃ©rents</a></h3>
<!--
You can also define structs that look similar to tuples, called *tuple
structs*. Tuple structs have the added meaning the struct name provides but
donâ€™t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type from other tuples, and naming each
field as in a regular struct would be verbose or redundant.
-->
<p>On peut aussi dÃ©finir des structures qui ressemblent Ã  des tuples, appelÃ©es
<em>structures tuples</em>. La signification d'une structure tuple est donnÃ©e par son
nom. En revanche, ses champs ne sont pas nommÃ©sÂ ; on ne prÃ©cise que leurs types.
Les structures tuples servent lorsqu'on veut donner un nom Ã  un tuple pour qu'il
ait un type diffÃ©rent des autres tuples, mais que nommer chaque champ comme dans
une structure classique serait trop verbeux ou redondant.</p>
<!--
To define a tuple struct, start with the `struct` keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named `Color` and `Point`:
-->
<p>La dÃ©finition d'une structure tuple commence par le mot-clÃ© <code>struct</code> et le nom
de la structure suivis des types des champs du tuple. Par exemple, voici une
dÃ©finition et une utilisation de deux structures tuples nommÃ©es <code>Couleur</code> et
<code>Point</code>Â :</p>
<!--
```rust
# fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Couleur(i32, i32, i32);
    struct Point(i32, i32, i32);

    let noir = Couleur(0, 0, 0);
    let origine = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the `black` and `origin` values are different types, because theyâ€™re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type `Color` cannot take a `Point` as an
argument, even though both types are made up of three `i32` values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a `.` followed by the index to access an
individual value, and so on.
-->
<p>Notez que les valeurs <code>noir</code> et <code>origine</code> sont de types diffÃ©rents parce que ce
sont des instances de structures tuples diffÃ©rentes. Chaque structure que l'on
dÃ©finit constitue son propre type, mÃªme si les champs au sein de la structure
ont les mÃªmes types. Par exemple, une fonction qui prend un paramÃ¨tre de type
<code>Couleur</code> ne peut pas prendre un argument de type <code>Point</code> Ã  la place, bien que
ces deux types soient tous les deux constituÃ©s de trois valeurs <code>i32</code>. Mis Ã 
part cela, les instances de stuctures tuples se comportent comme des tuplesÂ : on
peut les dÃ©structurer en Ã©lÃ©ments individuels, on peut utiliser un <code>.</code> suivi de
l'indice pour accÃ©der individuellement Ã  une valeur, et ainsi de suite.</p>
<!--
### Unit-Like Structs Without Any Fields
-->
<h3><a class="header" href="#les-structures-unitÃ©-sans-champs" id="les-structures-unitÃ©-sans-champs">Les structures unitÃ©Â sans champs</a></h3>
<!--
You can also define structs that donâ€™t have any fields! These are called
*unit-like structs* because they behave similarly to `()`, the unit type.
Unit-like structs can be useful in situations in which you need to implement a
trait on some type but donâ€™t have any data that you want to store in the type
itself. Weâ€™ll discuss traits in Chapter 10.
-->
<p>On peut aussi dÃ©finir des structures qui n'ont pas de champsÂ ! Cela s'appelle
des <em>structures unitÃ©</em> parce qu'elles se comportent d'une faÃ§on analogue au type
unitÃ©, <code>()</code>. Les structures unitÃ© sont utiles lorsqu'on doit implÃ©menter un
trait sur un type mais qu'on n'a aucune donnÃ©e Ã  stocker dans le type en
lui-mÃªme. Nous aborderons les traits au chapitre 10.</p>
<!--
> ### Ownership of Struct Data
>
> In the `User` struct definition in Listing 5-1, we used the owned `String`
> type rather than the `&str` string slice type. This is a deliberate choice
> because we want instances of this struct to own all of its data and for that
> data to be valid for as long as the entire struct is valid.
>
> Itâ€™s possible for structs to store references to data owned by something else,
> but to do so requires the use of *lifetimes*, a Rust feature that weâ€™ll
> discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
> is valid for as long as the struct is. Letâ€™s say you try to store a reference
> in a struct without specifying lifetimes, like this, which wonâ€™t work:
>
> <span class="filename">Filename: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -- >
>
> ```rust,ignore,does_not_compile
> struct User {
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
>     active: bool,
> }
>
> fn main() {
>     let user1 = User {
>         email: "someone@example.com",
>         username: "someusername123",
>         active: true,
>         sign_in_count: 1,
>     };
> }
> ```
>
> The compiler will complain that it needs lifetime specifiers:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:2:15
>   |
> 2 |     username: &str,
>   |               ^ expected lifetime parameter
>
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:3:12
>   |
> 3 |     email: &str,
>   |            ^ expected lifetime parameter
>
> error: aborting due to 2 previous errors
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs`.
>
> To learn more, run the command again with --verbose.
> ```
>
> In Chapter 10, weâ€™ll discuss how to fix these errors so you can store
> references in structs, but for now, weâ€™ll fix errors like these using owned
> types like `String` instead of references like `&str`.
-->
<blockquote>
<h3><a class="header" href="#la-possession-des-donnÃ©es-dune-structure" id="la-possession-des-donnÃ©es-dune-structure">La possession des donnÃ©es d'une structure</a></h3>
<p>Dans la dÃ©finition de la structure <code>Utilisateur</code> de l'encart 5-1, nous avions
utilisÃ© le type possÃ©dÃ© <code>String</code> plutÃ´t que le type de <em>slice</em> de chaÃ®ne de
caractÃ¨res <code>&amp;str</code>. Il s'agit d'un choix dÃ©libÃ©rÃ© puisque nous voulons que les
instances de cette structure possÃ¨dent toutes leurs donnÃ©es et que ces donnÃ©es
restent valides tant que la structure tout entiÃ¨re est valide.</p>
<p>Il est possible pour les structures de stocker des rÃ©fÃ©rences vers des donnÃ©es
possÃ©dÃ©es par autre chose, mais cela nÃ©cessiterait d'utiliser des
<em>durÃ©es de vie</em>, une fonctionnalitÃ© de Rust que nous aborderons au
chapitre 10. Les durÃ©es de vie assurent que les donnÃ©es rÃ©fÃ©rencÃ©es par une
structure restent valides tant que la structure l'est aussi. Disons que vous
essayiez de stocker une rÃ©fÃ©rence dans une structure sans indiquer de durÃ©es
de vie, comme ceci, ce qui ne fonctionnera pasÂ :</p>
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct Utilisateur {
    pseudo: &amp;str,
    email: &amp;str,
    nombre_de_connexions: u64,
    actif: bool,
}

fn main() {
    let utilisateur1 = Utilisateur {
        email: &quot;quelquun@example.com&quot;,
        pseudo: &quot;pseudoquelconque123&quot;,
        actif: true,
        nombre_de_connexions: 1,
    };
}
</code></pre>
<p>Le compilateur rÃ©clamera l'ajout des durÃ©es de vieÂ :</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Au chapitre 10, nous aborderons la faÃ§on de corriger ces erreurs pour qu'on
puisse stocker des rÃ©fÃ©rences dans des structures, mais pour le moment, nous
rÃ©soudrons les erreurs comme celles-ci en utilisant des types possÃ©dÃ©s comme
<code>String</code> plutÃ´t que des rÃ©fÃ©rences comme <code>&amp;str</code>.</p>
</blockquote>
<!--
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -- >
-->
<!--
## An Example Program Using Structs
-->
<h2><a class="header" href="#un-exemple-de-programme-qui-utilise-des-structures" id="un-exemple-de-programme-qui-utilise-des-structures">Un exemple de programme qui utilise des structures</a></h2>
<!--
To understand when we might want to use structs, letâ€™s write a program that
calculates the area of a rectangle. Weâ€™ll start with single variables, and then
refactor the program until weâ€™re using structs instead.
-->
<p>Pour comprendre dans quels cas nous voudrions utiliser des structures, Ã©crivons
un programme qui calcule l'aire d'un rectangle. Nous commencerons avec de
simples variables, puis on remaniera le code jusqu'Ã  utiliser des structures Ã 
la place.</p>
<!--
Letâ€™s make a new binary project with Cargo called *rectangles* that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our projectâ€™s *src/main.rs*.
-->
<p>CrÃ©ons un nouveau projet binaire avec Cargo nommÃ© <em>rectangles</em> qui prendra la
largeur et la hauteur en pixels d'un rectangle et qui calculera l'aire de ce
rectangle. L'encart 5-8 montre un petit programme qui effectue cette tÃ¢che d'une
certaine maniÃ¨re dans le <em>src/main.rs</em> de notre projet.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let largeur1 = 30;
    let hauteur1 = 50;

    println!(
        &quot;L'aire du rectangle est de {} pixels carrÃ©s.&quot;,
        aire(largeur1, hauteur1)
    );
}

fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
    largeur * hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by separate width and height variables</span>
-->
<p><span class="caption">Encart 5-8Â : Calcul de l'aire d'un rectangle dÃ©fini par
les variables distinctes <code>largeur</code> et <code>hauteur</code></span></p>
<!--
Now, run this program using `cargo run`:
-->
<p>Maintenant, lancez ce programme avec <code>cargo run</code>Â :</p>
<!--
```console
$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
The area of the rectangle is 1500 square pixels.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
L'aire du rectangle est de 1500 pixels carrÃ©s.
</code></pre>
<!--
Even though Listing 5-8 works and figures out the area of the rectangle by
calling the `area` function with each dimension, we can do better. The width
and the height are related to each other because together they describe one
rectangle.
-->
<p>Bien que l'encart 5-8 fonctionne et dÃ©termine l'aire du rectangle en appelant
la fonction <code>aire</code> avec chaque dimension, on peut faire mieux. La largeur et la
hauteur sont couplÃ©es entre elles car elles dÃ©crivent toutes les deux un rectangle.</p>
<!--
The issue with this code is evident in the signature of `area`:
-->
<p>Le problÃ¨me de ce code se voit dans la signature de <code>aire</code>Â :</p>
<!--
```rust,ignore
# fn main() {
#     let width1 = 30;
#     let height1 = 50;
# 
#     println!(
#         "The area of the rectangle is {} square pixels.",
#         area(width1, height1)
#     );
# }
# 
fn area(width: u32, height: u32) -> u32 {
#     width * height
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let largeur1 = 30;
</span><span class="boring">    let hauteur1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;L'aire du rectangle est de {} pixels carrÃ©s.&quot;,
</span><span class="boring">        aire(largeur1, hauteur1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
<span class="boring">    largeur * hauteur
</span><span class="boring">}
</span></code></pre>
<!--
The `area` function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but thatâ€™s
not expressed anywhere in our program. It would be more readable and more
manageable to group width and height together. Weâ€™ve already discussed one way
we might do that in [â€œThe Tuple Typeâ€][the-tuple-type]<!âˆ’âˆ’ ignore âˆ’âˆ’ > section
of Chapter 3: by using tuples.
-->
<p>La fonction <code>aire</code> est censÃ©e calculer l'aire d'un rectangle, mais la fonction
que nous avons Ã©crite a deux paramÃ¨tres. Les paramÃ¨tres sont liÃ©s, mais ce n'est
exprimÃ© nulle part dans notre programme. Il serait plus lisible et plus gÃ©rable
de regrouper ensemble la largeur et la hauteur. Nous avons dÃ©jÃ  vu dans la
section <a href="ch03-02-data-types.html#le-type-tuple">â€œLe type <em>tuple</em>â€</a><!-- ignore --> du chapitre 3 une
faÃ§on qui nous permettrait de le faireÂ : en utilisant des tuples.</p>
<!--
### Refactoring with Tuples
-->
<h3><a class="header" href="#remanier-le-code-avec-des-tuples" id="remanier-le-code-avec-des-tuples">Remanier le code avec des tuples</a></h3>
<!--
Listing 5-9 shows another version of our program that uses tuples.
-->
<p>L'encart 5-9 nous montre une autre version de notre programme qui utilise des
tuples.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;L'aire du rectangle est de {} pixels carrÃ©s.&quot;,
        aire(rect1)
    );
}

fn aire(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span>
-->
<p><span class="caption">Encart 5-9Â : Renseigner la largeur et la hauteur du
rectangle dans un tuple</span></p>
<!--
In one way, this program is better. Tuples let us add a bit of structure, and
weâ€™re now passing just one argument. But in another way, this version is less
clear: tuples donâ€™t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.
-->
<p>D'une certaine faÃ§on, ce programme est meilleur. Les tuples nous permettent de
structurer un peu plus et nous ne passons plus qu'un argument. Mais d'une autre
faÃ§on, cette version est moins claireÂ : les tuples ne donnent pas de noms Ã 
leurs Ã©lÃ©ments, donc notre calcul est devenu plus dÃ©routant puisqu'il faut
accÃ©der aux Ã©lÃ©ments du tuple via leur indice.</p>
<!--
It doesnâ€™t matter if we mix up width and height for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that `width` is the tuple index `0` and `height` is the tuple
index `1`. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we havenâ€™t conveyed the meaning of our data in
our code.
-->
<p>Ce n'est pas grave de confondre la largeur et la hauteur pour calculer l'aire,
mais si on voulait afficher le rectangle Ã  l'Ã©cran, cela serait problÃ©matiqueÂ !
Il nous faut garder Ã  l'esprit que la <code>largeur</code> est l'Ã©lÃ©ment Ã  l'indice 0 du
tuple et que la <code>hauteur</code> est l'Ã©lÃ©ment Ã  l'indice 1. Si quelqu'un d'autre
travaillait sur ce code, il devrait le dÃ©duire et s'en souvenir aussi. Il est
facile d'oublier ou de confondre ces valeurs et par consÃ©quent provoquer des
erreurs, parce qu'on n'a pas exprimÃ© la signification de nos donnÃ©es dans notre
code.</p>
<!--
### Refactoring with Structs: Adding More Meaning
-->
<h3><a class="header" href="#remanier-avec-des-structures--donner-plus-de-sens" id="remanier-avec-des-structures--donner-plus-de-sens">Remanier avec des structuresÂ : donner plus de sens</a></h3>
<!--
We use structs to add meaning by labeling the data. We can transform the tuple
weâ€™re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-10.
-->
<p>On utilise des structures pour rendre les donnÃ©es plus expressives en leur
donnant des noms. On peut transformer le tuple que nous avons utilisÃ© en un type
de donnÃ©e nommÃ© dont ses Ã©lÃ©ments sont aussi nommÃ©s, comme le montre l'encart
5-10.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrÃ©s.&quot;,
        aire(&amp;rect1)
    );
}

fn aire(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.largeur * rectangle.hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-10: Defining a `Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-10Â : DÃ©finition d'une structure
<code>Rectangle</code></span></p>
<!--
Here weâ€™ve defined a struct and named it `Rectangle`. Inside the curly
brackets, we defined the fields as `width` and `height`, both of which have
type `u32`. Then in `main`, we created a particular instance of `Rectangle`
that has a width of 30 and a height of 50.
-->
<p>Ici, on a dÃ©fini une structure et on l'a appelÃ©e <code>Rectangle</code>. Entre les
accolades, on a dÃ©fini les champs <code>largeur</code> et <code>hauteur</code>, tous deux du type
<code>u32</code>. Puis dans <code>main</code>, on crÃ©e une instance de <code>Rectangle</code> de largeur 30 et de
hauteur 50.</p>
<!--
Our `area` function is now defined with one parameter, which weâ€™ve named
`rectangle`, whose type is an immutable borrow of a struct `Rectangle`
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, `main` retains its ownership and can continue
using `rect1`, which is the reason we use the `&` in the function signature and
where we call the function.
-->
<p>Notre fonction <code>aire</code> est dÃ©sormais dÃ©finie avec un unique paramÃ¨tre, nommÃ©
<code>rectangle</code>, et dont le type est une rÃ©fÃ©rence immuable vers une instance de la
structure <code>Rectangle</code>. Comme mentionnÃ© au chapitre 4, on prÃ©fÃ¨re emprunter la
structure au lieu d'en prendre possession. Ainsi, elle reste en possession de
<code>main</code> qui peut continuer Ã  utiliser <code>rect1</code>Â ; c'est pourquoi on utilise le <code>&amp;</code>
dans la signature de la fonction ainsi que dans l'appel de fonction.</p>
<!--
The `area` function accesses the `width` and `height` fields of the `Rectangle`
instance. Our function signature for `area` now says exactly what we mean:
calculate the area of `Rectangle`, using its `width` and `height` fields. This
conveys that the width and height are related to each other, and it gives
descriptive names to the values rather than using the tuple index values of `0`
and `1`. This is a win for clarity.
-->
<p>La fonction <code>aire</code> accÃ¨de aux champs <code>largeur</code> et <code>hauteur</code> de l'instance de
<code>Rectangle</code>. Notre signature de fonction pour <code>aire</code> est enfin expliciteÂ :
calculer l'aire d'un <code>Rectangle</code> en utilisant ses champs <code>largeur</code> et <code>hauteur</code>.
Cela explique que la largeur et la hauteur sont liÃ©es entre elles, et cela donne
des noms descriptifs aux valeurs plutÃ´t que d'utiliser les valeurs du tuple avec
les indices <code>0</code> et <code>1</code>. On gagne en clartÃ©.</p>
<!--
### Adding Useful Functionality with Derived Traits
-->
<h3><a class="header" href="#ajouter-des-fonctionnalitÃ©s-utiles-avec-les-traits-dÃ©rivÃ©s" id="ajouter-des-fonctionnalitÃ©s-utiles-avec-les-traits-dÃ©rivÃ©s">Ajouter des fonctionnalitÃ©s utiles avec les traits dÃ©rivÃ©s</a></h3>
<!--
Itâ€™d be nice to be able to print an instance of `Rectangle` while weâ€™re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the `println!` macro as we have used in previous chapters. This wonâ€™t
work, however.
-->
<p>Cela serait bien de pouvoir afficher une instance de <code>Rectangle</code> pendant qu'on
dÃ©bogue notre programme et de voir la valeur de chacun de ses champs. L'encart
5-11 essaye de le faire en utilisant la macro <code>println!</code> comme on l'a fait
dans les chapitres prÃ©cÃ©dents. Cependant, cela ne fonctionne pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };

    println!(&quot;rect1 est {}&quot;, rect1);
}
</code></pre>
<!--
<span class="caption">Listing 5-11: Attempting to print a `Rectangle`
instance</span>
-->
<p><span class="caption">Encart 5-11Â : Tentative d'afficher une instance de
<code>Rectangle</code></span></p>
<!--
When we compile this code, we get an error with this core message:
-->
<p>Lorsqu'on compile ce code, on obtient ce message d'erreur qui nous informe que
<code>Rectangle</code> n'implÃ©mente pas le trait <code>std::fmt::Display</code>Â :</p>
<!--
```text
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```
-->
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<!--
The `println!` macro can do many kinds of formatting, and by default, the curly
brackets tell `println!` to use formatting known as `Display`: output intended
for direct end user consumption. The primitive types weâ€™ve seen so far
implement `Display` by default, because thereâ€™s only one way youâ€™d want to show
a `1` or any other primitive type to a user. But with structs, the way
`println!` should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesnâ€™t try to guess what we want, and structs donâ€™t have a provided
implementation of `Display`.
-->
<p>La macro <code>println!</code> peut faire toutes sortes de formatages textuels, et par
dÃ©faut, les accolades demandent Ã  <code>println!</code> d'utiliser le formatage appelÃ©
<code>Display</code>, pour convertir en texte destinÃ© Ã  Ãªtre vu par l'utilisateur final.
Les types primitifs qu'on a vus jusqu'ici implÃ©mentent <code>Display</code> par dÃ©faut
puisqu'il n'existe qu'une seule faÃ§on d'afficher un <code>1</code> ou tout autre type
primitif Ã  l'utilisateur. Mais pour les structures, la faÃ§on dont <code>println!</code>
devrait formater son rÃ©sultat est moins claire car il y a plus de possibilitÃ©s
d'affichageÂ : Voulez-vous des virgulesÂ ? Voulez-vous afficher les accoladesÂ ?
Est-ce que tous les champs devraient Ãªtre affichÃ©sÂ ? Ã€ cause de ces ambiguÃ¯tÃ©s,
Rust n'essaye pas de deviner ce qu'on veut, et les structures n'implÃ©mentent pas
<code>Display</code> par dÃ©faut.</p>
<!--
If we continue reading the errors, weâ€™ll find this helpful note:
-->
<p>Si nous continuons de lire les erreurs, nous trouvons cette remarque utileÂ :</p>
<!--
```text
   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```
-->
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Le compilateur nous informe que dans notre chaÃ®ne de formatage, on est peut-Ãªtre
en mesure d'utiliser <code>{:?}</code> (ou <code>{:#?}</code> pour un affichage plus Ã©lÃ©gant).</p>
<!--
Letâ€™s try it! The `println!` macro call will now look like `println!("rect1 is
{:?}", rect1);`. Putting the specifier `:?` inside the curly brackets tells
`println!` we want to use an output format called `Debug`. The `Debug` trait
enables us to print our struct in a way that is useful for developers so we can
see its value while weâ€™re debugging our code.
-->
<p>Essayons celaÂ ! L'appel de la macro <code>println!</code> ressemble maintenant Ã 
<code>println!(&quot;rect1 est {:?}&quot;, rect1);</code>. InsÃ©rer le sÃ©lecteur <code>:?</code> entre les
accolades permet d'indiquer Ã  <code>println!</code> que nous voulons utiliser le formatage
appelÃ© <code>Debug</code>. Le trait <code>Debug</code> nous permet d'afficher notre structure d'une
maniÃ¨re utile aux dÃ©veloppeurs pour qu'on puisse voir sa valeur pendant qu'on
dÃ©bogue le code.</p>
<!--
Compile the code with this change. Drat! We still get an error:
-->
<p>Compilez le code avec ce changement. ZutÂ ! On a encore une erreur, nous
informant cette fois-ci que <code>Rectangle</code> n'implÃ©mente pas <code>std::fmt::Debug</code>Â :</p>
<!--
```text
error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
```
-->
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<!--
But again, the compiler gives us a helpful note:
-->
<p>Mais une nouvelle fois, le compilateur nous fait une remarque utileÂ :</p>
<!--
```text
   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
```
-->
<pre><code class="language-text">   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Il nous conseille d'ajouter <code>#[derive(Debug)]</code> ou d'implÃ©menter manuellement
<code>std::fmt::Debug</code>.</p>
<!--
Rust *does* include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the annotation `#[derive(Debug)]` just before the struct
definition, as shown in Listing 5-12.
-->
<p>Rust <em>inclut</em> bel et bien une fonctionnalitÃ© pour afficher des informations de
dÃ©bogage, mais nous devons l'activer explicitement pour la rendre disponible sur
notre structure. Pour ce faire, on ajoute l'annotation <code>#[derive(Debug)]</code> juste
avant la dÃ©finition de la structure, comme le montre l'encart 5-12.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };

    println!(&quot;rect1 est {:?}&quot;, rect1);
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-12: Adding the annotation to derive the `Debug`
trait and printing the `Rectangle` instance using debug formatting</span>
-->
<p><span class="caption">Encart 5-12Â : L'ajout de l'annotation pour dÃ©river le
trait <code>Debug</code> et afficher l'instance de <code>Rectangle</code> en utilisant le formatage
de dÃ©bogage</span></p>
<!--
Now when we run the program, we wonâ€™t get any errors, and weâ€™ll see the
following output:
-->
<p>Maintenant, quand on exÃ©cute le programme, nous n'avons plus d'erreurs et ce
texte s'affiche Ã  l'Ã©cranÂ :</p>
<!--
```console
$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 is Rectangle { width: 30, height: 50 }
```
-->
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 est Rectangle { width: 30, height: 50 }
</code></pre>
<!--
Nice! Itâ€™s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, itâ€™s useful to have output thatâ€™s a bit easier to read; in
those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string.
When we use the `{:#?}` style in the example, the output will look like this:
-->
<p>SuperÂ ! Ce n'est pas le plus beau des affichages, mais cela montre les
valeurs de tous les champs de cette instance, ce qui serait assurÃ©ment utile
lors du dÃ©bogage. Quand on a des structures plus grandes, il serait bien d'avoir
un affichage un peu plus lisibleÂ ; dans ces cas-lÃ , on pourra utiliser <code>{:#?}</code>
au lieu de <code>{:?}</code> dans la chaÃ®ne de formatage. Quand on utilise <code>{:#?}</code> dans cet
exemple, l'affichage donnera plutÃ´t ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```
-->
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 est Rectangle {
    largeur: 30,
    hauteur: 50,
}
</code></pre>
<!--
Rust has provided a number of traits for us to use with the `derive` annotation
that can add useful behavior to our custom types. Those traits and their
behaviors are listed in Appendix C. Weâ€™ll cover how to implement these traits
with custom behavior as well as how to create your own traits in Chapter 10.
-->
<p>Rust nous fournit un certain nombre de traits qu'on peut utiliser avec
l'annotation <code>derive</code> qui peuvent ajouter des comportements utiles Ã  nos propres
types. Ces traits et leurs comportements sont listÃ©s Ã  l'annexe C. Nous
expliquerons comment implÃ©menter ces traits avec des comportements personnalisÃ©s
et comment crÃ©er vos propres traits au chapitre 10.</p>
<!--
Our `area` function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our `Rectangle`
struct, because it wonâ€™t work with any other type. Letâ€™s look at how we can
continue to refactor this code by turning the `area` function into an `area`
*method* defined on our `Rectangle` type.
-->
<p>Notre fonction <code>aire</code> est trÃ¨s spÃ©cifiqueÂ : elle ne fait que calculer l'aire
d'un rectangle. Il serait utile de lier un peu plus ce comportement Ã  notre
structure <code>Rectangle</code>, puisque cela ne fonctionnera pas avec un autre type.
Voyons comment on peut continuer de remanier ce code en transformant la fonction
<code>aire</code> en <em>mÃ©thode</em> <code>aire</code> dÃ©finie sur notre type <code>Rectangle</code>.</p>
<!-- [the-tuple-type]: ch03-02-data-types.html#the-tuple-type -->
<!--
## Method Syntax
-->
<h2><a class="header" href="#la-syntaxe-des-mÃ©thodes" id="la-syntaxe-des-mÃ©thodes">La syntaxe des mÃ©thodes</a></h2>
<!--
*Methods* are similar to functions: theyâ€™re declared with the `fn` keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when theyâ€™re called from somewhere else. However, methods are
different from functions in that theyâ€™re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always `self`, which represents the
instance of the struct the method is being called on.
-->
<p>Les <em>mÃ©thodes</em> sont similaires aux fonctionsÂ : on les dÃ©clare avec le mot-clÃ©
<code>fn</code> et leur nom, elles peuvent avoir des paramÃ¨tres et une valeur de retour, et
elles contiennent du code qui est exÃ©cutÃ© quand on les appelle depuis un autre
endroit. Cependant, les mÃ©thodes diffÃ¨rent des fonctions parce qu'elles sont
dÃ©finies dans le contexte d'une structure (ou d'une Ã©numÃ©ration ou d'un objet de
trait, que nous aborderons respectivement aux chapitres 6 et 17) et que leur
premier paramÃ¨tre est toujours <code>self</code>, un mot-clÃ© qui reprÃ©sente l'instance de
la structure sur laquelle on appelle la mÃ©thode.</p>
<!--
### Defining Methods
-->
<h3><a class="header" href="#dÃ©finir-des-mÃ©thodes" id="dÃ©finir-des-mÃ©thodes">DÃ©finir des mÃ©thodes</a></h3>
<!--
Letâ€™s change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p>RemplaÃ§ons la fonction <code>aire</code> qui prend une instance de <code>Rectangle</code> en paramÃ¨tre
par une mÃ©thode <code>aire</code> dÃ©finie sur la structure <code>Rectangle</code>, comme dans
l'encart 5-13.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrÃ©s.&quot;,
        rect1.aire()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-13Â : DÃ©finition d'une mÃ©thode <code>aire</code> sur la
structure <code>Rectangle</code></span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block. Then we move the `area` function within the `impl`
curly brackets and change the first (and in this case, only) parameter to be
`self` in the signature and everywhere within the body. In `main`, where we
called the `area` function and passed `rect1` as an argument, we can instead
use *method syntax* to call the `area` method on our `Rectangle` instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.
-->
<p>Pour dÃ©finir la fonction dans le contexte de <code>Rectangle</code>, nous dÃ©marrons un bloc
<code>impl</code> (<em>implÃ©mentation</em>). Puis nous dÃ©plaÃ§ons la fonction <code>aire</code> entre les
accolades du <code>impl</code> et nous remplaÃ§ons le premier paramÃ¨tre (et dans notre cas,
le seul) par <code>self</code> dans la signature et dans tout le corps. Dans <code>main</code>, oÃ¹
nous avons appelÃ© la fonction <code>aire</code> et passÃ© <code>rect1</code> en argument, nous pouvons
utiliser Ã  la place la <em>syntaxe des mÃ©thodes</em> pour appeler la mÃ©thode <code>aire</code> sur
notre instance de <code>Rectangle</code>. La syntaxe des mÃ©thodes se place aprÃ¨s
l'instanceÂ : on ajoute un point suivi du nom de la mÃ©thode et des parenthÃ¨ses
contenant les arguments s'il y en a.</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`
because Rust knows the type of `self` is `Rectangle` due to this methodâ€™s being
inside the `impl Rectangle` context. Note that we still need to use the `&`
before `self`, just as we did in `&Rectangle`. Methods can take ownership of
`self`, borrow `self` immutably as weâ€™ve done here, or borrow `self` mutably,
just as they can any other parameter.
-->
<p>Dans la signature de <code>aire</code>, nous utilisons <code>&amp;self</code> Ã  la place de
<code>rectangle: &amp;Rectangle</code> parce que Rust sait que le type de <code>self</code> est
<code>Rectangle</code> puisque la mÃ©thode se trouve au sein du contexte <code>impl Rectangle</code>.
Veuillez noter qu'il nous faut quand mÃªme utiliser le <code>&amp;</code> avant le <code>self</code>, comme
nous l'avions fait pour <code>&amp;Rectangle</code>. Les mÃ©thodes peuvent prendre possession de
<code>self</code>, emprunter <code>self</code> de faÃ§on immuable comme nous l'avons fait ici, ou
emprunter <code>self</code> de faÃ§on mutable, comme pour n'importe quel autre paramÃ¨tre.</p>
<!--
Weâ€™ve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we donâ€™t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
weâ€™ve called the method on as part of what the method does, weâ€™d use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and you want
to prevent the caller from using the original instance after the transformation.
-->
<p>Nous avons choisi <code>&amp;self</code> ici pour la mÃªme raison que nous avions utilisÃ©
<code>&amp;Rectangle</code> quand il s'agissait d'une fonctionÂ ; nous ne voulons pas en prendre
possession, et nous voulons seulement lire les donnÃ©es de la structure, pas les
modifier. Si nous voulions que la mÃ©thode modifie l'instance sur laquelle on
l'appelle, on utiliserait <code>&amp;mut self</code> comme premier paramÃ¨tre. Il est rare
d'avoir une mÃ©thode qui prend possession de l'instance en utilisant uniquement
<code>self</code> comme premier argumentÂ ; cette technique est gÃ©nÃ©ralement utilisÃ©e
lorsque la mÃ©thode transforme <code>self</code> en quelque chose d'autre et que vous voulez
empÃªcher le code appelant d'utiliser l'instance d'origine aprÃ¨s la
transformation.</p>
<!--
The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of `self` in every methodâ€™s
signature, is for organization. Weâ€™ve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>Outre l'utilisation de la syntaxe des mÃ©thodes et le fait de ne pas Ãªtre obligÃ©
de rÃ©pÃ©ter le type de <code>self</code> dans la signature de chaque mÃ©thode, le principal
avantage de l'utilisation de mÃ©thodes plutÃ´t que de fonctions est pour
l'organisation. Nous avons mis tout ce qu'on pouvait faire avec une instance de
notre type dans un bloc <code>impl</code> plutÃ´t que d'imposer aux futurs utilisateurs de
notre code Ã  rechercher les fonctionnalitÃ©s de <code>Rectangle</code> Ã  divers endroits de
la bibliothÃ¨que que nous fournissons.</p>
<!--
> ### Whereâ€™s the `->` Operator?
>
> In C and C++, two different operators are used for calling methods: you use
> `.` if youâ€™re calling a method on the object directly and `->` if youâ€™re
> calling the method on a pointer to the object and need to dereference the
> pointer first. In other words, if `object` is a pointer,
> `object->something()` is similar to `(*object).something()`.
>
> Rust doesnâ€™t have an equivalent to the `->` operator; instead, Rust has a
> feature called *automatic referencing and dereferencing*. Calling methods is
> one of the few places in Rust that has this behavior.
>
> Hereâ€™s how it works: when you call a method with `object.something()`, Rust
> automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
> the method. In other words, the following are the same:
>
<!-- CAN'T EXTRACT SEE BUG TODO -- >
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> The first one looks much cleaner. This automatic referencing behavior works
> because methods have a clear receiverâ€”the type of `self`. Given the receiver
> and name of a method, Rust can figure out definitively whether the method is
> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
> that Rust makes borrowing implicit for method receivers is a big part of
> making ownership ergonomic in practice.
-->
<blockquote>
<h3><a class="header" href="#oÃ¹-est-lopÃ©rateur---" id="oÃ¹-est-lopÃ©rateur---">OÃ¹ est l'opÃ©rateur <code>-&gt;</code>Â ?</a></h3>
<p>En C et en C++, deux opÃ©rateurs diffÃ©rents sont utilisÃ©s pour appeler les
mÃ©thodesÂ : on utilise <code>.</code> si on appelle une mÃ©thode directement sur l'objet
et <code>-&gt;</code> si on appelle la mÃ©thode sur un pointeur vers l'objet et qu'il faut
d'abord dÃ©rÃ©fÃ©rencer le pointeur. En d'autres termes, si <code>objet</code> est un
pointeur, <code>objet-&gt;methode()</code> est similaire Ã  <code>(*objet).methode()</code>.</p>
<p>Rust n'a pas d'Ã©quivalent Ã  l'opÃ©rateur <code>-&gt;</code>Â ; Ã  la place, Rust a une
fonctionnalitÃ© appelÃ©e <em>rÃ©fÃ©rencement et dÃ©rÃ©fÃ©rencement automatiques</em>.
L'appel de mÃ©thodes est l'un des rares endroits de Rust oÃ¹ on retrouve ce
comportement.</p>
<p>VoilÃ  comment cela fonctionneÂ : quand on appelle une mÃ©thode avec
<code>objet.methode()</code>, Rust ajoute automatiquement le <code>&amp;</code>, <code>&amp;mut</code> ou <code>*</code> pour que
<code>objet</code> corresponde Ã  la signature de la mÃ©thode. Autrement dit, ces deux
lignes sont identiquesÂ :</p>
</blockquote>
<!-- CAN'T EXTRACT SEE BUG TODO -->
<blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, autre: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_carre = f64::powi(autre.x - self.x, 2);
</span><span class="boring">       let y_carre = f64::powi(autre.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_carre + y_carre)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>La premiÃ¨re ligne semble bien plus propre. Ce comportement du
(dÃ©)rÃ©fÃ©rencement automatique fonctionne parce que les mÃ©thodes ont une
cible claireÂ : le type de <code>self</code>. Compte tenu du nom de la mÃ©thode et
de l'instance sur laquelle elle s'applique, Rust peut dÃ©terminer de maniÃ¨re
irrÃ©futable si la mÃ©thode lit (<code>&amp;self</code>), modifie (<code>&amp;mut self</code>) ou consomme
(<code>self</code>) l'instance. Le fait que Rust rend implicite l'emprunt pour les
instances sur lesquelles on appelle les mÃ©thodes amÃ©liore significativement
l'ergonomie de la possession.</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3><a class="header" href="#les-mÃ©thodes-avec-davantage-de-paramÃ¨tres" id="les-mÃ©thodes-avec-davantage-de-paramÃ¨tres">Les mÃ©thodes avec davantage de paramÃ¨tres</a></h3>
<!--
Letâ€™s practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self`; otherwise it should return `false`. That is, we want to be able
to write the program shown in Listing 5-14, once weâ€™ve defined the `can_hold`
method.
-->
<p>EntraÃ®nons-nous Ã  utiliser des mÃ©thodes en implÃ©mentant une seconde mÃ©thode sur
la structure <code>Rectangle</code>. Cette fois-ci, nous voulons qu'une instance de
<code>Rectangle</code> prenne une autre instance de <code>Rectangle</code> et qu'on retourne <code>true</code> si
le second <code>Rectangle</code> peut se dessiner intÃ©gralement Ã  l'intÃ©rieur de <code>self</code>Â ;
sinon, on renverra <code>false</code>. En d'autres termes, on veut pouvoir Ã©crire le
programme de l'encart 5-14 une fois qu'on aura dÃ©fini la mÃ©thode
<code>peut_contenir</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };
    let rect2 = Rectangle {
        largeur: 10,
        hauteur: 40
    };
    let rect3 = Rectangle {
        largeur: 60,
        hauteur: 45
    };

    println!(&quot;rect1 peut-il contenir rect2Â ? {}&quot;, rect1.peut_contenir(&amp;rect2));
    println!(&quot;rect1 peut-il contenir rect3Â ? {}&quot;, rect1.peut_contenir(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">Encart 5-14Â : Utilisation de la mÃ©thode <code>peut_contenir</code>
qui reste Ã  Ã©crire</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>Et on s'attend Ã  ce que le texte suivant s'affiche, puisque les deux dimensions
de <code>rect2</code> sont plus petites que les dimensions de <code>rect1</code>, mais <code>rect3</code> est
plus large que <code>rect1</code>Â :</p>
<!--
```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
-->
<pre><code class="language-text">rect1 peut-il contenir rect2Â ? true
rect1 peut-il contenir rect3Â ? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean weâ€™d need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Letâ€™s add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>Nous voulons dÃ©finir une mÃ©thode, donc elle doit se trouver dans le bloc
<code>impl Rectangle</code>. Le nom de la mÃ©thode sera <code>peut_contenir</code> et elle prendra une
rÃ©fÃ©rence immuable vers un autre <code>Rectangle</code> en paramÃ¨tre. On peut dÃ©terminer le
type du paramÃ¨tre en regardant le code qui appelle la mÃ©thodeÂ :
<code>rect1.peut_contenir(&amp;rect2)</code> prend en argument <code>&amp;rect2</code>, une rÃ©fÃ©rence immuable
vers <code>rect2</code>, une instance de <code>Rectangle</code>. Cela est logique puisque nous voulons
uniquement lire <code>rect2</code> (plutÃ´t que de la modifier, ce qui aurait nÃ©cessitÃ© une
rÃ©fÃ©rence mutable) et nous souhaitons que <code>main</code> garde possession de <code>rect2</code>
pour qu'on puisse le rÃ©utiliser aprÃ¨s avoir appelÃ© la mÃ©thode <code>peut_contenir</code>.
La valeur de retour de <code>peut_contenir</code> sera un boolÃ©en et l'implÃ©mentation de la
mÃ©thode vÃ©rifiera si la largeur et la hauteur de <code>self</code> sont respectivement plus
grandes que la largeur et la hauteur de l'autre <code>Rectangle</code>. Ajoutons la
nouvelle mÃ©thode <code>peut_contenir</code> dans le bloc <code>impl</code> de l'encart 5-13, comme le
montre l'encart 5-15.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }

    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2Â ? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3Â ? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">Encart 5-15Â : ImplÃ©mentation de la mÃ©thode <code>peut_contenir</code>
sur <code>Rectangle</code> qui prend une autre instance de <code>Rectangle</code> en paramÃ¨tre</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, weâ€™ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>Lorsque nous exÃ©cutons ce code avec la fonction <code>main</code> de l'encart 5-14, nous
obtenons l'affichage attendu. Les mÃ©thodes peuvent prendre plusieurs paramÃ¨tres
qu'on peut ajouter Ã  la signature aprÃ¨s le paramÃ¨tre <code>self</code>, et ces paramÃ¨tres
fonctionnent de la mÃªme maniÃ¨re que les paramÃ¨tres des fonctions.</p>
<!--
### Associated Functions
-->
<h3><a class="header" href="#les-fonctions-associÃ©es" id="les-fonctions-associÃ©es">Les fonctions associÃ©es</a></h3>
<!--
Another useful feature of `impl` blocks is that weâ€™re allowed to define
functions within `impl` blocks that *donâ€™t* take `self` as a parameter. These
are called *associated functions* because theyâ€™re associated with the struct.
Theyâ€™re still functions, not methods, because they donâ€™t have an instance of
the struct to work with. Youâ€™ve already used the `String::from` associated
function.
-->
<p>Une autre fonctionnalitÃ© utile des blocs <code>impl</code> est qu'on peut dÃ©finir des
fonctions dans des blocs <code>impl</code> qui ne prennent <em>pas</em> <code>self</code> en paramÃ¨tre. Cela
s'appelle des <em>fonctions associÃ©es</em> parce qu'elles sont associÃ©es Ã  la
structure. Cela reste des fonctions, pas des mÃ©thodes, parce qu'elles ne
s'appliquent pas Ã  une instance de structure. Vous avez dÃ©jÃ  utilisÃ© la fonction
associÃ©e <code>String::from</code>.</p>
<!--
Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both width and height,
thus making it easier to create a square `Rectangle` rather than having to
specify the same value twice:
-->
<p>Les fonctions associÃ©es sont souvent utilisÃ©es comme constructeurs qui vont
retourner une nouvelle instance de la structure. Par exemple, on pourrait Ã©crire
une fonction associÃ©e qui prend une unique dimension en paramÃ¨tre et l'utilise
Ã  la fois pour la largeur et pour la hauteur, ce qui rend plus aisÃ© la crÃ©ation
d'un <code>Rectangle</code> carrÃ© plutÃ´t que d'avoir Ã  indiquer la mÃªme valeur deux foisÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
# 
# fn main() {
#     let sq = Rectangle::square(3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn carre(cote: u32) -&gt; Rectangle {
        Rectangle {
            largeur: cote,
            hauteur: cote
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mon_carre = Rectangle::carre(3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. Weâ€™ll discuss modules in Chapter 7.
-->
<p>Pour appeler cette fonction associÃ©e, on utilise la syntaxe <code>::</code> avec le nom de
la structureÂ ; <code>let mon_carre = Rectangle::carre(3);</code> en est un exemple. Cette
fonction est cloisonnÃ©e dans l'espace de noms de la structureÂ : la syntaxe <code>::</code>
s'utilise aussi bien pour les fonctions associÃ©es que pour les espaces de noms
crÃ©Ã©s par des modules. Nous aborderons les modules au chapitre 7.</p>
<!--
### Multiple `impl` Blocks
-->
<h3><a class="header" href="#plusieurs-blocs-impl" id="plusieurs-blocs-impl">Plusieurs blocs <code>impl</code></a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>Chaque structure peut avoir plusieurs blocs <code>impl</code>. Par exemple, l'encart 5-15
est Ã©quivalent au code de l'encart 5-16, oÃ¹ chaque mÃ©thode est dans son propre
bloc <code>impl</code>.</p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

impl Rectangle {
    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2Â ? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3Â ? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">Encart 5-16Â : RÃ©Ã©criture de l'encart 5-15 en utilisant
plusieurs blocs <code>impl</code></span></p>
<!--
Thereâ€™s no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. Weâ€™ll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>Il n'y a aucune raison de sÃ©parer ces mÃ©thodes dans plusieurs blocs <code>impl</code> dans
notre exemple, mais c'est une syntaxe valide. Nous verrons un exemple de
l'utilitÃ© d'avoir plusieurs blocs <code>impl</code> au chapitre 10, oÃ¹ nous aborderons les
types gÃ©nÃ©riques et les traits.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-4" id="rÃ©sumÃ©-4">RÃ©sumÃ©</a></h2>
<!--
Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. Methods let you specify the
behavior that instances of your structs have, and associated functions let you
namespace functionality that is particular to your struct without having an
instance available.
-->
<p>Les structures vous permettent de crÃ©er des types personnalisÃ©s significatifs
pour votre domaine. En utilisant des structures, on peut relier entre elles
des donnÃ©es associÃ©es et nommer chaque donnÃ©e pour rendre le code plus clair.
Les mÃ©thodes vous permettent de dÃ©finir le comportement des instances de vos
structures, et les fonctions associÃ©es vous permettent de cloisonner dans un
espace de noms des fonctionnalitÃ©s qui sont spÃ©cifiques Ã  votre structure sans
avoir besoin d'une instance disponible.</p>
<!--
But structs arenâ€™t the only way you can create custom types: letâ€™s turn to
Rustâ€™s enum feature to add another tool to your toolbox.
-->
<p>Mais les structures ne sont pas le seul moyen de crÃ©er des types personnalisÃ©sÂ :
nous allons maintenant voir les Ã©numÃ©rations de Rust, une fonctionnalitÃ© que
vous pourrez bientÃ´t ajouter Ã  votre boÃ®te Ã  outils.</p>
<!--
# Enums and Pattern Matching
-->
<h1><a class="header" href="#les-Ã©numÃ©rations-et-le-filtrage-par-motif" id="les-Ã©numÃ©rations-et-le-filtrage-par-motif">Les Ã©numÃ©rations et le filtrage par motif</a></h1>
<!--
In this chapter weâ€™ll look at *enumerations*, also referred to as *enums*.
Enums allow you to define a type by enumerating its possible *variants*. First,
weâ€™ll define and use an enum to show how an enum can encode meaning along with
data. Next, weâ€™ll explore a particularly useful enum, called `Option`, which
expresses that a value can be either something or nothing. Then weâ€™ll look at
how pattern matching in the `match` expression makes it easy to run different
code for different values of an enum. Finally, weâ€™ll cover how the `if let`
construct is another convenient and concise idiom available to you to handle
enums in your code.
-->
<p>Dans ce chapitre, nous allons aborder les <em>Ã©numÃ©rations</em>, aussi appelÃ©es
<em>enums</em>. Les Ã©numÃ©rations vous permettent de dÃ©finir un type en Ã©numÃ©rant ses
<em>variantes</em> possibles. Pour commencer, nous allons dÃ©finir et utiliser une
Ã©numÃ©ration pour voir comment une Ã©numÃ©ration peut donner du sens aux donnÃ©es.
Ensuite, nous examinerons une Ã©numÃ©ration particuliÃ¨rement utile qui s'appelle
<code>Option</code> et qui permet de dÃ©crire des situations oÃ¹ la valeur peut Ãªtre soit
quelque chose, soit rien. Ensuite, nous regarderons comment le filtrage par
motif avec l'expression <code>match</code> peut faciliter l'exÃ©cution de codes diffÃ©rents
pour chaque valeur d'une Ã©numÃ©ration. Enfin, nous analyserons pourquoi la
construction <code>if let</code> est un autre outil commode et concis Ã  votre disposition
pour traiter les Ã©numÃ©rations dans votre code.</p>
<!--
Enums are a feature in many languages, but their capabilities differ in each
language. Rustâ€™s enums are most similar to *algebraic data types* in functional
languages, such as F#, OCaml, and Haskell.
-->
<p>Les Ã©numÃ©rations sont des fonctionnalitÃ©s prÃ©sentes dans de nombreux langages,
mais leurs aptitudes varient d'un langage Ã  l'autre. Les Ã©numÃ©rations de Rust
sont plus proches des <em>types de donnÃ©es algÃ©briques</em> des langages fonctionnels,
comme F#, OCaml et Haskell.</p>
<!--
## Defining an Enum
-->
<h2><a class="header" href="#dÃ©finir-une-Ã©numÃ©ration" id="dÃ©finir-une-Ã©numÃ©ration">DÃ©finir une Ã©numÃ©ration</a></h2>
<!--
Letâ€™s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can *enumerate* all possible
variants, which is where enumeration gets its name.
-->
<p>Imaginons une situation que nous voudrions exprimer avec du code et regardons
pourquoi les Ã©numÃ©rations sont utiles et plus appropriÃ©es que les structures
dans ce cas. Disons que nous avons besoin de travailler avec des adresses IP.
Pour le moment, il existe deux normes principales pour les adresses IPÂ : la
version quatre et la version six. Ce seront les seules possibilitÃ©s d'adresse
IP que notre programme va rencontrerÂ : nous pouvons <em>Ã©numÃ©rer</em> toutes les
variantes possibles, d'oÃ¹ vient le nom de l'Ã©numÃ©ration.</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because enum values can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>N'importe quelle adresse IP peut Ãªtre soit une adresse en version quatre, soit
en version six, mais pas les deux en mÃªme temps. Cette propriÃ©tÃ© des adresses IP
est appropriÃ©e Ã  la structure de donnÃ©es d'Ã©numÃ©rations, car les valeurs de
l'Ã©numÃ©ration ne peuvent Ãªtre qu'une de ses variantes. Les adresses en version
quatre et six sont toujours fondamentalement des adresses IP, donc elles doivent
Ãªtre traitÃ©es comme Ã©tant du mÃªme type lorsque le code travaille avec des
situations qui s'appliquent Ã  n'importe quelle sorte d'adresse IP.</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are the
variants of the enum:
-->
<p>Nous pouvons exprimer ce concept dans le code en dÃ©finissant une Ã©numÃ©ration
<code>SorteAdresseIp</code> et en listant les diffÃ©rentes sortes possibles d'adresses IP
qu'elle peut avoir, <code>V4</code> et <code>V6</code>. Ce sont les variantes de l'Ã©numÃ©rationÂ :</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum SorteAdresseIp {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p><code>SorteAdresseIp</code> est maintenant un type de donnÃ©es personnalisÃ© que nous pouvons
utiliser n'importe oÃ¹ dans notre code.</p>
<!--
### Enum Values
-->
<h3><a class="header" href="#les-valeurs-dÃ©numÃ©rations" id="les-valeurs-dÃ©numÃ©rations">Les valeurs d'Ã©numÃ©rations</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>Nous pouvons crÃ©er des instances de chacune des deux variantes de
<code>SorteAdresseIp</code> de cette maniÃ¨reÂ :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let quatre = SorteAdresseIp::V4;
    let six = SorteAdresseIp::V6;
<span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type:
`IpAddrKind`. We can then, for instance, define a function that takes any
`IpAddrKind`:
-->
<p>Remarquez que les variantes de l'Ã©numÃ©ration sont dans un espace de nom qui se
situe avant leur nom, et nous utilisons un double deux-points pour les sÃ©parer
tous les deux. C'est utile car maintenant les deux valeurs <code>SorteAdresseIp::V4</code>
et <code>SorteAdresseIp::V6</code> sont du mÃªme typeÂ : <code>SorteAdresseIp</code>. Ensuite, nous
pouvons, par exemple, dÃ©finir une fonction qui accepte n'importe quelle
<code>SorteAdresseIp</code>Â :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn router(sorte_ip: SorteAdresseIp) { }
</code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>Et nous pouvons appeler cette fonction avec chacune des variantesÂ :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span>    router(SorteAdresseIp::V4);
    router(SorteAdresseIp::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we donâ€™t have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1.
-->
<p>L'utilisation des Ã©numÃ©rations a encore plus d'avantages. En Ã©tudiant un peu
plus notre type d'adresse IP, nous constatons que pour le moment, nous ne
pouvons pas stocker <em>la donnÃ©e</em> de l'adresse IPÂ ; nous savons seulement de
quelle sorte elle est. Avec ce que vous avez appris au chapitre 5, vous pouvez
rÃ©soudre ce problÃ¨me comme dans l'encart 6-1.</p>
<!--
```rust
# fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SorteAdresseIp {
        V4,
        V6,
    }

    struct AdresseIp {
        sorte: SorteAdresseIp,
        adresse: String,
    }

    let local = AdresseIp {
        sorte: SorteAdresseIp::V4,
        adresse: String::from(&quot;127.0.0.1&quot;),
    };
    
    let rebouclage = AdresseIp {
        sorte: SorteAdresseIp::V6,
        adresse: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">Encart 6-1Â : Stockage de la donnÃ©e et de la variante de
<code>SorteAdresseIp</code> d'une adresse IP en utilisant une <code>struct</code></span></p>
<!--
Here, weâ€™ve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first, `home`, has
the value `IpAddrKind::V4` as its `kind` with associated address data of
`127.0.0.1`. The second instance, `loopback`, has the other variant of
`IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with
it. Weâ€™ve used a struct to bundle the `kind` and `address` values together, so
now the variant is associated with the value.
-->
<p>Ainsi, nous avons dÃ©fini une structure <code>AdresseIp</code> qui a deux champsÂ : un champ
<code>sorte</code> qui est du type <code>SorteAdresseIp</code> (l'Ã©numÃ©ration que nous avons dÃ©finie
prÃ©cÃ©demment) et un champ <code>adresse</code> qui est du type <code>String</code>. Nous avons deux
instances de cette structure. La premiÃ¨re, <code>local</code>, a la valeur
<code>SorteAdresseIp::V4</code> pour son champ <code>sorte</code>, associÃ© Ã  la donnÃ©e d'adresse qui
est <code>127.0.0.1</code>. La seconde instance, <code>rebouclage</code>, a comme valeur de champ
<code>sorte</code> l'autre variante de <code>SorteAdresseIp</code>, <code>V6</code>, et a l'adresse<code>::1</code> qui lui
est associÃ©e. Nous avons utilisÃ© une structure pour relier ensemble la <code>sorte</code>
et l'<code>adresse</code>, donc maintenant la variante est liÃ©e Ã  la valeur.</p>
<!--
We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>Nous pouvons appliquer le mÃªme principe de maniÃ¨re plus concise en utilisant
uniquement une Ã©numÃ©ration, plutÃ´t que d'utiliser une Ã©numÃ©ration dans une
structure, en insÃ©rant directement la donnÃ©e dans chaque variante de
l'Ã©numÃ©ration. Cette nouvelle dÃ©finition de l'Ã©numÃ©ration <code>AdresseIp</code> indique
que chacune des variantes <code>V4</code> et <code>V6</code> auront des valeurs associÃ©es de type
<code>String</code>Â :</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(String),
        V6(String),
    }
    
    let local = AdresseIp::V4(String::from(&quot;127.0.0.1&quot;));
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct.
-->
<p>Nous relions les donnÃ©es de chaque variante directement Ã  l'Ã©numÃ©ration, donc il
n'est pas nÃ©cessaire d'avoir une structure en plus.</p>
<!--
Thereâ€™s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldnâ€™t be able to with
a struct. Enums handle this case with ease:
-->
<p>Il y a un autre avantage Ã  utiliser une Ã©numÃ©ration plutÃ´t qu'une structureÂ :
chaque variante peut stocker des types diffÃ©rents, et aussi avoir une quantitÃ©
diffÃ©rente de donnÃ©es associÃ©es. Les adresses IP version quatre vont toujours
avoir quatre composantes numÃ©riques qui auront une valeur entre 0 et 255. Si
nous voulions stocker les adresses <code>V4</code> avec quatre valeurs de type <code>u8</code> mais
continuer Ã  stocker les adresses <code>V6</code> dans une <code>String</code>, nous ne pourrions pas
le faire avec une structure. Les Ã©numÃ©rations permettent de faire cela
facilementÂ :</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    
    let local = AdresseIp::V4(127, 0, 0, 1);
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
Weâ€™ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr]<!-- ignore -- > Letâ€™s look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
weâ€™ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>Nous avons vu diffÃ©rentes maniÃ¨res de dÃ©finir des structures de donnÃ©es pour
enregistrer des adresses IP en version quatre et version six. Cependant, il
s'avÃ¨re que vouloir stocker des adresses IP et identifier de quelle sorte elles
sont est si frÃ©quent que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la bibliothÃ¨que standard a une dÃ©finition que nous
pouvons utiliserÂ !</a><!-- ignore --> Analysons comment la bibliothÃ¨que
standard a dÃ©fini <code>IpAddr</code> (l'Ã©quivalent de notre <code>AdresseIp</code>)Â : nous retrouvons
la mÃªme Ã©numÃ©ration et les variantes que nous avons dÃ©finies et utilisÃ©es, mais
stocke les donnÃ©es d'adresse dans des variantes dans deux structures
diffÃ©rentes, qui sont dÃ©finies chacune pour chaque varianteÂ :</p>
<!--
[IpAddr]: ../std/net/enum.IpAddr.html
-->
<!--
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // -- code masquÃ© ici --
}

struct Ipv6Addr {
    // -- code masquÃ© ici --
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>Ce code montre comment vous pouvez insÃ©rer n'importe quel type de donnÃ©es dans
une variante d'Ã©numÃ©rationÂ : des chaÃ®nes de caractÃ¨res, des nombres ou des
structures, par exemple. Vous pouvez mÃªme y intÃ©grer d'autres Ã©numÃ©rationsÂ ! Par
ailleurs, les types de la bibliothÃ¨que standard ne sont parfois pas plus
compliquÃ©s que ce que vous pourriez inventer.</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
havenâ€™t brought the standard libraryâ€™s definition into our scope. Weâ€™ll talk
more about bringing types into scope in Chapter 7.
-->
<p>Notez aussi que mÃªme si la bibliothÃ¨que standard embarque une dÃ©finition de
<code>IpAddr</code>, nous pouvons quand mÃªme crÃ©er et utiliser notre propre dÃ©finition de
ce type sans avoir de conflit de nom car nous n'avons pas importÃ© cette
dÃ©finition de la bibliothÃ¨que standard dans la portÃ©e. Nous verrons plus en
dÃ©tail comment importer les types dans la portÃ©e au chapitre 7.</p>
<!--
Letâ€™s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>Analysons un autre exemple d'une Ã©numÃ©ration dans l'encart 6-2Â : celle-ci a une
grande diversitÃ© de types dans ses variantes.</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span>enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
</code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">Encart 6-2Â : Une Ã©numÃ©ration <code>Message</code> dont chaque
variante stocke des valeurs de diffÃ©rents types et en diffÃ©rentes
quantitÃ©s</span></p>
<!--
This enum has four variants with different types:
-->
<p>Cette Ã©numÃ©ration a quatre variantes avec des types diffÃ©rentsÂ :</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` includes an anonymous struct inside it.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quitter</code> n'a pas du tout de donnÃ©e associÃ©e.</li>
<li><code>Deplacer</code> intÃ¨gre une structure anonyme.</li>
<li><code>Ecrire</code> intÃ¨gre une seule <code>String</code>.</li>
<li><code>ChangerCouleur</code> intÃ¨gre trois valeurs de type <code>i32</code>.</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesnâ€™t use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>DÃ©finir une Ã©numÃ©ration avec des variantes comme celles dans l'encart 6-2
ressemble Ã  la dÃ©finition de diffÃ©rentes sortes de structures, sauf que
l'Ã©numÃ©ration n'utilise pas le mot-clÃ© <code>struct</code> et que toutes les variantes sont
regroupÃ©es ensemble sous le type <code>Message</code>. Les structures suivantes peuvent
stocker les mÃªmes donnÃ©es que celles stockÃ©es par les variantes prÃ©cÃ©dentesÂ :</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MessageQuitter; // une structure unitÃ©
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
<span class="boring">
</span><span class="boring">fn main() {}
</span>struct MessageQuitter; // une structure unitÃ©
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
</code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldnâ€™t as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<p>Mais si nous utilisions les diffÃ©rentes structures, qui ont chacune leur propre
type, nous ne pourrions pas dÃ©finir facilement une fonction qui prend en
paramÃ¨tre toutes les sortes de messages, tel que nous pourrions le faire avec
l'Ã©numÃ©ration <code>Message</code> que nous avons dÃ©finie dans l'encart 6-2, qui est un
seul type.</p>
<!--
There is one more similarity between enums and structs: just as weâ€™re able to
define methods on structs using `impl`, weâ€™re also able to define methods on
enums. Hereâ€™s a method named `call` that we could define on our `Message` enum:
-->
<p>Il y a un autre point commun entre les Ã©numÃ©rations et les structuresÂ : tout
comme on peut dÃ©finir des mÃ©thodes sur les structures en utilisant <code>impl</code>, on
peut aussi dÃ©finir des mÃ©thodes sur des Ã©numÃ©rations. Voici une mÃ©thode appelÃ©e
<code>appeler</code> que nous pouvons dÃ©finir sur notre Ã©numÃ©ration <code>Message</code>Â :</p>
<!--
```rust
# fn main() {
#     enum Message {
#         Quit,
#         Move { x: i32, y: i32 },
#         Write(String),
#         ChangeColor(i32, i32, i32),
#     }
# 
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quitter,
</span><span class="boring">        Deplacer { x: i32, y: i32 },
</span><span class="boring">        Ecrire(String),
</span><span class="boring">        ChangerCouleur(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn appeler(&amp;self) {
            // le corps de la mÃ©thode sera dÃ©fini ici
        }
    }
    
    let m = Message::Ecrire(String::from(&quot;hello&quot;));
    m.appeler();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, weâ€™ve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>Le corps de la mÃ©thode va utiliser <code>self</code> pour obtenir la valeur sur laquelle
nous avons utilisÃ© la mÃ©thode. Dans cet exemple, nous avons crÃ©Ã© une variable
<code>m</code> qui a la valeur <code>Message::Ecrire(String::from(&quot;hello&quot;))</code>, et cela sera ce
que <code>self</code> aura comme valeur dans le corps de la mÃ©thode <code>appeler</code> quand nous
lancerons <code>m.appeler()</code>.</p>
<!--
Letâ€™s look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>Regardons maintenant une autre Ã©numÃ©ration de la bibliothÃ¨que standard qui est
trÃ¨s utilisÃ©e et utileÂ : <code>Option</code>.</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3><a class="header" href="#lÃ©numÃ©ration-option-et-ses-avantages-par-rapport-Ã -la-valeur-null" id="lÃ©numÃ©ration-option-et-ses-avantages-par-rapport-Ã -la-valeur-null">L'Ã©numÃ©ration <code>Option</code> et ses avantages par rapport Ã  la valeur null</a></h3>
<!--
In the previous section, we looked at how the `IpAddr` enum let us use Rustâ€™s
type system to encode more information than just the data into our program.
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check whether youâ€™ve handled all the cases you should be handling;
this functionality can prevent bugs that are extremely common in other
programming languages.
-->
<p>Dans la section prÃ©cÃ©dente, nous avons dÃ©couvert comment l'Ã©numÃ©ration
<code>AdresseIp</code> nous permet d'utiliser le systÃ¨me de types de Rust pour enregistrer
dans nos programmes encore plus d'informations qu'uniquement la donnÃ©e. Cette
section Ã©tudie le cas de <code>Option</code>, qui est une autre Ã©numÃ©ration dÃ©finie dans la
bibliothÃ¨que standard. Le type <code>Option</code> est utilisÃ© dans de nombreux endroits
car il dÃ©crit un scÃ©nario trÃ¨s courant oÃ¹ une valeur peut Ãªtre soit quelque
chose, soit rien du tout. Exprimer ce concept avec le systÃ¨me de types implique
que le compilateur peut vÃ©rifier si vous avez gÃ©rÃ© tous les cas que vous
pourriez rencontrerÂ ; cette fonctionnalitÃ© peut Ã©viter des bogues qui sont trÃ¨s
courants dans d'autres langages de programmation.</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesnâ€™t have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>La conception d'un langage de programmation est souvent pensÃ©e en fonction des
fonctionnalitÃ©s qu'on inclut, mais les fonctionnalitÃ©s qu'on refuse sont elles
aussi importantes. Rust n'a pas de fonctionnalitÃ© <em>null</em> qu'ont de nombreux
langages. <em>Null</em> est une valeur qui signifie qu'il n'y a pas de valeur Ã  cet
endroit. Avec les langages qui utilisent null, les variables peuvent toujours
Ãªtre dans deux Ã©tatsÂ : null ou non null.</p>
<!--
In his 2009 presentation â€œNull References: The Billion Dollar Mistake,â€ Tony
Hoare, the inventor of null, has this to say:
-->
<p>Dans sa thÃ¨se de 2009 â€œNull References: The Billion Dollar Mistakeâ€ (les
rÃ©fÃ©rences nullesÂ : l'erreur Ã  un milliard de dollars), Tony Hoare, l'inventeur
de null, a Ã©crit ceciÂ :</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldnâ€™t resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>Je l'appelle mon erreur Ã  un milliard de dollars. Ã€ cette Ã©poque, je concevais
le premier systÃ¨me de type complet pour des rÃ©fÃ©rences dans un langage orientÃ©
objet. Mon objectif Ã©tait de garantir que toutes les utilisations des
rÃ©fÃ©rences soient totalement sÃ»res, et soient vÃ©rifiÃ©es automatiquement par le
compilateur. Mais je n'ai pas pu rÃ©sister Ã  la tentation d'inclure la
rÃ©fÃ©rence nulle, simplement parce que c'Ã©tait si simple Ã  implÃ©menter. Cela a
conduit Ã  d'innombrables erreurs, vulnÃ©rabilitÃ©s, et pannes systÃ¨mes, qui ont
probablement causÃ© un milliard de dollars de dommages au cours des quarante
derniÃ¨res annÃ©es.</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, youâ€™ll get an error of some kind. Because this null or not-null
property is pervasive, itâ€™s extremely easy to make this kind of error.
-->
<p>Le problÃ¨me avec les valeurs nulles, c'est que si vous essayez d'utiliser une
valeur nulle comme si elle n'Ã©tait pas nulle, vous obtiendrez une erreur d'une
faÃ§on ou d'une autre. Comme cette propriÃ©tÃ© nulle ou non nulle est omniprÃ©sente,
il est trÃ¨s facile de faire cette erreur.</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>Cependant, le concept que null essaye d'exprimer reste utileÂ : une valeur nulle
est une valeur qui est actuellement invalide ou absente pour une raison ou une
autre.</p>
<!--
The problem isnâ€™t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]<!-- ignore -- >
as follows:
-->
<p>Le problÃ¨me ne vient pas vraiment du concept, mais de son implÃ©mentation. C'est
pourquoi Rust n'a pas de valeurs nulles, mais il a une Ã©numÃ©ration qui dÃ©crit le
concept d'une valeur qui peut Ãªtre soit prÃ©sente, soit absente. Cette
Ã©numÃ©ration est <code>Option&lt;T&gt;</code>, et elle est <a href="https://doc.rust-lang.org/std/option/enum.Option.html">dÃ©finie dans la bibliothÃ¨que
standard</a><!-- ignore --> comme ci-dessousÂ :</p>
<!--
[option]: ../std/option/enum.Option.html
-->
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that itâ€™s even included in the prelude; you
donâ€™t need to bring it into scope explicitly. In addition, so are its variants:
you can use `Some` and `None` directly without the `Option::` prefix. The
`Option<T>` enum is still just a regular enum, and `Some(T)` and `None` are
still variants of type `Option<T>`.
-->
<p>L'Ã©numÃ©ration <code>Option&lt;T&gt;</code> est tellement utile qu'elle est intÃ©grÃ©e dans l'Ã©tape
prÃ©liminaireÂ ; vous n'avez pas besoin de l'importer explicitement dans la
portÃ©e. De plus, voici ses variantesÂ : vous pouvez utiliser directement <code>Some</code>
(<em>quelque chose</em>) et <code>None</code> (<em>rien</em>) sans les prÃ©fixer par <code>Option::</code>.
L'Ã©numÃ©ration <code>Option&lt;T&gt;</code> reste une Ã©numÃ©ration normale, et <code>Some(T)</code> ainsi que
<code>None</code> sont toujours des variantes de type <code>Option&lt;T&gt;</code>.</p>
<!--
The `<T>` syntax is a feature of Rust we havenâ€™t talked about yet. Itâ€™s a
generic type parameter, and weâ€™ll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type. Here are some examples of
using `Option` values to hold number types and string types:
-->
<p>La syntaxe <code>&lt;T&gt;</code> est une fonctionnalitÃ© de Rust que nous n'avons pas encore
abordÃ©e. Il s'agit d'un paramÃ¨tre de type gÃ©nÃ©rique, et nous verrons la
gÃ©nÃ©ricitÃ© plus en dÃ©tail au chapitre 10. Pour le moment, dites-vous que ce
<code>&lt;T&gt;</code> signifie que la variante <code>Some</code> de l'Ã©numÃ©ration <code>Option</code> peut stocker un
Ã©lÃ©ment de donnÃ©e de n'importe quel type. Voici quelques exemples d'utilisation
de valeurs de <code>Option</code> pour stocker des types de nombres et des types de chaÃ®nes
de caractÃ¨resÂ :</p>
<!--
```rust
# fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let un_nombre = Some(5);
    let une_chaine = Some(&quot;une chaÃ®ne&quot;);

    let nombre_absent: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
If we use `None` rather than `Some`, we need to tell Rust what type of
`Option<T>` we have, because the compiler canâ€™t infer the type that the `Some`
variant will hold by looking only at a `None` value.
-->
<p>Si nous utilisons <code>None</code> plutÃ´t que <code>Some</code>, nous devons indiquer Ã  Rust quel
type de <code>Option&lt;T&gt;</code> nous avons, car le compilateur ne peut pas dÃ©duire le type
que cette variante <code>Some</code> va stocker en considÃ©rant uniquement une valeur
<code>None</code>.</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we donâ€™t have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p>Lorsque nous avons une valeur <code>Some</code>, nous savons que la valeur est prÃ©sente et
que la valeur est stockÃ©e dans le <code>Some</code>. Lorsque nous avons une valeur <code>None</code>,
en quelque sorte, cela veut dire la mÃªme chose que nullÂ : nous n'avons pas une
valeur valide. Donc pourquoi obtenir <code>Option&lt;T&gt;</code> est meilleur que d'avoir nullÂ ?</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler wonâ€™t let us use an `Option<T>` value as if it were
definitely a valid value. For example, this code wonâ€™t compile because itâ€™s
trying to add an `i8` to an `Option<i8>`:
-->
<p>En bref, comme <code>Option&lt;T&gt;</code> et <code>T</code> (oÃ¹ <code>T</code> reprÃ©sente n'importe quel type) sont
de types diffÃ©rents, le compilateur ne va pas nous autoriser Ã  utiliser une
valeur <code>Option&lt;T&gt;</code> comme si cela Ã©tait bien une valeur valide. Par exemple, le
code suivant ne se compile pas car il essaye d'additionner un <code>i8</code> et une
<code>Option&lt;i8&gt;</code>Â :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let somme = x + y;
<span class="boring">}
</span></code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>Si nous lanÃ§ons ce code, nous aurons un message d'erreur comme celui-ciÂ :</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `std::option::Option<i8>` to `i8`
 -- > src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option<i8>`
  |
  = help: the trait `std::ops::Add<std::option::Option<i8>>` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let somme = x + y;
  |                   ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
  = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesnâ€™t understand how
to add an `i8` and an `Option<i8>`, because theyâ€™re different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value weâ€™re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>IntenseÂ ! Effectivement, ce message d'erreur signifie que Rust ne comprend pas
comment additionner un <code>i8</code> et une <code>Option&lt;i8&gt;</code>, car ils sont de types
diffÃ©rents. Quand nous avons une valeur d'un type comme <code>i8</code> avec Rust, le
compilateur va s'assurer que nous avons toujours une valeur valide. Nous pouvons
continuer en toute confiance sans avoir Ã  vÃ©rifier que cette valeur n'est pas
nulle avant de l'utiliser. Ce n'est que lorsque nous avons une <code>Option&lt;i8&gt;</code> (ou
tout autre type de valeur avec lequel nous travaillons) que nous devons nous
inquiÃ©ter de ne pas avoir de valeur, et le compilateur va s'assurer que nous
gÃ©rons ce cas avant d'utiliser la valeur.</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isnâ€™t null when it actually
is.
-->
<p>Autrement dit, vous devez convertir une <code>Option&lt;T&gt;</code> en <code>T</code> pour pouvoir faire
avec elle des opÃ©rations du type <code>T</code>. GÃ©nÃ©ralement, cela permet de rÃ©soudre l'un
des problÃ¨mes les plus courants avec nullÂ : supposer qu'une valeur n'est pas
nulle alors qu'en rÃ©alitÃ©, elle l'est.</p>
<!--
Not having to worry about incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isnâ€™t an
`Option<T>`, you *can* safely assume that the value isnâ€™t null. This was a
deliberate design decision for Rust to limit nullâ€™s pervasiveness and increase
the safety of Rust code.
-->
<p>Ne pas avoir Ã  s'inquiÃ©ter que des valeurs nulles puissent Ãªtre mal gÃ©rÃ©es vous
aide Ã  Ãªtre plus confiant en votre code. Pour avoir une valeur qui peut
potentiellement Ãªtre nulle, vous devez l'indiquer explicitement en dÃ©clarant que
le type de cette valeur est <code>Option&lt;T&gt;</code>. Ensuite, quand vous utiliserez cette
valeur, il vous faudra gÃ©rer explicitement le cas oÃ¹ cette valeur est nulle. Si
vous utilisez une valeur qui n'est pas une <code>Option&lt;T&gt;</code>, alors vous <em>pouvez</em>
considÃ©rer que cette valeur ne sera jamais nulle sans prendre de risques. Il
s'agit d'un choix de conception dÃ©libÃ©rÃ© de Rust pour limiter l'omniprÃ©sence de
null et augmenter la sÃ©curitÃ© du code en Rust.</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]<!-- ignore -- >. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>Donc, comment rÃ©cupÃ©rer la valeur de type <code>T</code> d'une variante <code>Some</code> quand vous
avez une valeur de type <code>Option&lt;T&gt;</code> afin de l'utiliserÂ ? L'Ã©numÃ©ration
<code>Option&lt;T&gt;</code> a un large choix de mÃ©thodes qui sont plus ou moins utiles selon les
casÂ ; vous pouvez les dÃ©couvrir dans <a href="https://doc.rust-lang.org/std/option/enum.Option.html">sa documentation</a><!-- ignore -->. Se
familiariser avec les mÃ©thodes de <code>Option&lt;T&gt;</code> peut Ãªtre trÃ¨s utile dans votre
aventure avec Rust.</p>
<!--
[docs]: ../std/option/enum.Option.html
-->
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. You want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. You want some
other code to run if you have a `None` value, and that code doesnâ€™t have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>De maniÃ¨re gÃ©nÃ©rale, pour pouvoir utiliser une valeur de <code>Option&lt;T&gt;</code>, votre code
doit gÃ©rer chaque variante. On veut que du code soit exÃ©cutÃ© uniquement quand on
a une valeur <code>Some(T)</code>, et que ce code soit autorisÃ© Ã  utiliser la valeur de
type <code>T</code> Ã  l'intÃ©rieur. On veut aussi qu'un autre code soit exÃ©cutÃ© si on a une
valeur <code>None</code>, et ce code n'aura pas de valeur de type <code>T</code> de disponible.
L'expression <code>match</code> est une structure de contrÃ´le qui fait bien ceci
lorsqu'elle est utilisÃ©e avec les Ã©numÃ©rationsÂ : elle va exÃ©cuter du code
diffÃ©rent en fonction de quelle variante de l'Ã©numÃ©ration elle obtient, et ce
code pourra utiliser la donnÃ©e prÃ©sente dans la valeur correspondante.</p>
<!--
## The `match` Control Flow Operator
-->
<h2><a class="header" href="#la-structure-de-contrÃ´le-match" id="la-structure-de-contrÃ´le-match">La structure de contrÃ´le <code>match</code></a></h2>
<!--
Rust has an extremely powerful control flow operator called `match` that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rust a un opÃ©rateur de contrÃ´le trÃ¨s puissant appelÃ© <code>match</code>, qui
vous permet de comparer une valeur avec une sÃ©rie de motifs et d'exÃ©cuter du
code en fonction du motif qui correspond. Les motifs peuvent Ãªtre constituÃ©s de
valeurs pures, de noms de variables, de jokers, parmi tant d'autresÂ ; le
chapitre 18 va couvrir tous les diffÃ©rents types de motifs et ce qu'ils font. Ce
qui fait la puissance de <code>match</code> est l'expressivitÃ© des motifs et le fait que le
compilateur vÃ©rifie que tous les cas possibles sont bien gÃ©rÃ©s.</p>
<!--
Think of a `match` expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value â€œfits,â€
the value falls into the associated code block to be used during execution.
-->
<p>ConsidÃ©rez l'expression <code>match</code> comme une machine Ã  trier les piÃ¨ces de
monnaieÂ : les piÃ¨ces descendent le long d'une piste avec des trous de taille
diffÃ©rente, et chaque piÃ¨ce tombe dans le premier trou qu'elle
rencontre Ã  sa taille. De maniÃ¨re similaire, les valeurs parcourent tous les
motifs dans un <code>match</code>, et au premier motif auquel la valeur â€œcorrespondâ€, la
valeur va descendre dans le bloc de code correspondant afin d'Ãªtre utilisÃ©e
pendant son exÃ©cution.</p>
<!--
Because we just mentioned coins, letâ€™s use them as an example using `match`! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3.
-->
<p>Comme nous venons de mentionner des piÃ¨ces, utilisons-les avec un exemple qui
utilise <code>match</code>Â ! Nous pouvons Ã©crire une fonction qui prend en paramÃ¨tre une
piÃ¨ce inconnue des Etats Unis d'AmÃ©rique (USA) et, de la mÃªme maniÃ¨re qu'une
machine Ã  trier, dÃ©terminer quelle piÃ¨ce c'est et retourner sa valeur en
centimes, comme ci-dessous dans l'encart 6-3.</p>
<!--
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; 1,
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns</span>
-->
<p><span class="caption">Encart 6-3Â : Une Ã©numÃ©ration et une expression <code>match</code> qui
trie les variantes de l'Ã©numÃ©ration dans ses motifs</span></p>
<!--
Letâ€™s break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but thereâ€™s a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can be any type. The type of `coin` in this example is the `Coin` enum
that we defined on line 1.
-->
<p>DÃ©composons le <code>match</code> dans la fonction <code>valeur_en_centimes</code>. En premier lieu,
nous utilisons le mot-clÃ© <code>match</code> suivi par une expression, qui dans notre cas
est la valeur de <code>piece</code>. Cela ressemble beaucoup Ã  une expression utilisÃ©e avec
<code>if</code>, mais il y a une grosse diffÃ©renceÂ : avec <code>if</code>, l'expression doit retourner
un valeur boolÃ©enne, mais ici, elle peut retourner n'importe quel type. Dans cet
exemple, <code>piece</code> est de type <code>USACoin</code>, qui est l'Ã©numÃ©ration que nous avons
dÃ©finie Ã  la ligne 1.</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>Ensuite, nous avons les branches du <code>match</code>. Une branche a deux partiesÂ : un
motif et du code. La premiÃ¨re branche a ici pour motif la valeur
<code>USACoin::Penny</code> et ensuite l'opÃ©rateur <code>=&gt;</code> qui sÃ©pare le motif et le code Ã 
exÃ©cuter. Le code dans ce cas est uniquement la valeur <code>1</code>. Chaque branche est
sÃ©parÃ©e de la suivante par une virgule.</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesnâ€™t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>Lorsqu'une expression <code>match</code> est exÃ©cutÃ©e, elle compare la valeur de <code>piece</code>
avec le motif de chaque branche, dans l'ordre. Si un motif correspond Ã  la
valeur, le code correspondant Ã  ce motif est alors exÃ©cutÃ©. Si ce motif ne
correspond pas Ã  la valeur, l'exÃ©cution passe Ã  la prochaine branche, un peu
comme dans une machine de tri de piÃ¨ces. Nous pouvons avoir autant de branches
que nous avons besoinÂ : dans l'encart 6-3, notre <code>match</code> a quatre branches.</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>Le code correspondant Ã  chaque branche est une expression, et la valeur qui
rÃ©sulte de l'expresssion dans la branche correspondante est la valeur qui sera
retournÃ©e par l'expression <code>match</code>.</p>
<!--
Curly brackets typically arenâ€™t used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print â€œLucky penny!â€ every time the method was called with
a `Coin::Penny` but would still return the last value of the block, `1`:
-->
<p>Les accolades ne sont gÃ©nÃ©ralement pas utilisÃ©es si le code de la branche
correspondante est court, comme est le cas dans l'encart 6-3 oÃ¹ chaque branche
retourne simplement une valeur. Si vous voulez exÃ©cuter plusieures lignes de
code dans une branche d'un <code>match</code>, vous devez utiliser les accolades. Par
exemple, le code suivant va afficher â€œUn centime porte-bonheurÂ !â€ Ã  chaque fois
que la mÃ©thode est appellÃ©e avec une valeur <code>USACoin::Penny</code> mais va continuer
Ã  retourner la derniÃ¨re valeur du bloc, <code>1</code>Â :</p>
<!--
```rust
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter,
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum USACoin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; {
            println!(&quot;Un centime porte-bonheurÂ !&quot;);
            1
        },
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3><a class="header" href="#des-motifs-reliÃ©s-Ã -des-valeurs" id="des-motifs-reliÃ©s-Ã -des-valeurs">Des motifs reliÃ©s Ã  des valeurs</a></h3>
<!--
Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>Une autre fonctionnalitÃ© intÃ©ressante des branches de <code>match</code> est qu'elles
peuvent se lier aux valeurs qui correspondent au motif. C'est ainsi que nous
pouvons extraire les valeurs d'une variante d'Ã©numÃ©ration.</p>
<!--
As an example, letâ€™s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which weâ€™ve done here in Listing 6-4.
-->
<p>En guise d'exemple, changeons une de nos variantes d'Ã©numÃ©ration pour stocker
une donnÃ©e Ã  l'intÃ©rieur. Entre 1999 et 2008, les Etats-Unis d'AmÃ©rique ont
frappÃ© un cÃ´tÃ© des piÃ¨ces de monnaie &quot;Quarter&quot; avec des dÃ©cors diffÃ©rents pour
chacun des 50 Ã©tats. Les autres piÃ¨ces n'ont pas eu de dÃ©cors d'Ã©tats, donc
seul le &quot;Quarter&quot; a cette valeur en plus. Nous pouvons ajouter cette information
Ã  notre <code>enum</code> en changeant la variante <code>Quarter</code> pour y ajouter une valeur
<code>USAState</code> qui y sera stockÃ©e Ã  l'intÃ©rieur, comme nous l'avons fait dans
l'encart 6-4.</p>
<!--
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // pour pouvoir afficher l'Ã‰tat
enum USAState {
    Alabama,
    Alaska,
    // -- partie masquÃ©e ici --
}

enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter(USAState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">Encart 6-4Â : Une Ã©numÃ©ration <code>USACoin</code> dans laquelle la
variante <code>Quarter</code> stocke en plus une valeur de type <code>USAState</code></span></p>
<!--
Letâ€™s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, weâ€™ll also call out the name of
the state associated with each quarter so if itâ€™s one our friend doesnâ€™t have,
they can add it to their collection.
-->
<p>Imaginons qu'un de vos amis essaye de rÃ©cupÃ©rer tous les &quot;Quarter&quot; des 50 Ã©tats.
Pendant que nous trions notre monnaie en vrac par type de piÃ¨ce, nous
mentionnerons aussi le nom de l'Ã©tat correspondant Ã  chaque &quot;Quarter&quot; de sorte
que si notre ami ne l'a pas, il puisse l'ajouter Ã  sa collection.</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarterâ€™s state. Then we can use `state` in the code for that arm, like so:
-->
<p>Dans l'expression <code>match</code> de ce code, nous avons ajoutÃ© une variable <code>etat</code> au
motif qui correspond Ã  la variante <code>USACoin::Quarter</code>. Quand on aura une
correspondance <code>USACoin::Quarter</code>, la variable <code>etat</code> sera liÃ©e Ã  la valeur de
l'Ã©tat de cette piÃ¨ce. Ensuite, nous pourrons utiliser <code>etat</code> dans le code de
cette branche, comme ceciÂ :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
# 
# fn main() {
#     value_in_cents(Coin::Quarter(UsState::Alaska));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masquÃ©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; 1,
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter(etat) =&gt; {
            println!(&quot;Il s'agit d'un Quarter de l'Ã©tat de {:?}Â !&quot;, etat);
            25
        },
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    valeur_en_centimes(USACoin::Quarter(USAState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p>Si nous appelons <code>valeur_en_centimes(USACoin::Quarter(USAState::Alaska))</code>,
<code>piece</code> vaudra <code>USACoin::Quarter(USAState::Alaska)</code>. Quand nous comparons cette
valeur avec toutes les branches du <code>match</code>, aucune d'entre elles ne
correspondront jusqu'Ã  ce qu'on arrive Ã  <code>USACoin::Quarter(etat)</code>. A partir de
ce moment, la variable <code>etat</code> aura la valeur <code>USAState::Alaska</code>. Nous pouvons
alors utiliser cette variable dans l'expression <code>println!</code>, ce qui nous permet
d'afficher la valeur de l'Ã©tat Ã  l'intÃ©rieur de la variante <code>Quarter</code> de la
l'Ã©numÃ©ration <code>USACoin</code>.</p>
<!--
### Matching with `Option<T>`
-->
<h3><a class="header" href="#utiliser-match-avec-optiont" id="utiliser-match-avec-optiont">Utiliser <code>match</code> avec <code>Option&lt;T&gt;</code></a></h3>
<!--
In the previous section, we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, weâ€™ll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>Dans la section prÃ©cÃ©dente, nous voulions obtenir la valeur interne <code>T</code> dans le
cas de <code>Some</code> lorsqu'on utilisait <code>Option&lt;T&gt;</code>Â ; nous pouvons aussi gÃ©rer les
<code>Option&lt;T&gt;</code> en utilisant <code>match</code> comme nous l'avons fait avec l'Ã©numÃ©ration
<code>USACoin</code>Â ! Au lieu de comparer des piÃ¨ces, nous allons comparer les variantes
de <code>Option&lt;T&gt;</code>, mais la faÃ§on d'utiliser l'expression <code>match</code> reste la mÃªme.</p>
<!--
Letâ€™s say we want to write a function that takes an `Option<i32>` and, if
thereâ€™s a value inside, adds 1 to that value. If there isnâ€™t a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p>Disons que nous voulons Ã©crire une fonction qui prend une <code>Option&lt;i32&gt;</code> et, si
il y a une valeur Ã  l'intÃ©rieur, ajouter 1 Ã  cette valeur. S'il n'y pas de
valeur Ã  l'intÃ©rieur, la fonction retournera la valeur <code>None</code> et ne va rien
faire de plus.</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p>Cette fonction est trÃ¨s facile Ã  Ã©crire, grÃ¢ce Ã  <code>match</code>, et ressemblera Ã 
l'encart 6-5.</p>
<!--
```rust
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let cinq = Some(5);
    let six = plus_un(cinq);
    let none = plus_un(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">Encart 6-5Â : Une fonction qui utilise une expression
<code>match</code> sur une <code>Option&lt;i32&gt;</code></span></p>
<!--
Letâ€™s examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p>Examinons la premiÃ¨re exÃ©cution de <code>plus_un</code> en dÃ©tail. Lorsque nous appellons
<code>plus_un(cinq)</code>, la variable <code>x</code> dans le corps de <code>plus_un</code> aura la valeur
<code>Some(5)</code>. Ensuite, nous comparons cela Ã  chaque branche du <code>match</code>.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
The `Some(5)` value doesnâ€™t match the pattern `None`, so we continue to the
next arm.
-->
<p>La valeur <code>Some(5)</code> ne correspond pas au motif <code>None</code>, donc nous continuons Ã  la
prochaine branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
#             None => None,
            Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add 1 to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<p>Est-ce que <code>Some(5)</code> correspond au <code>Some(i)</code>Â ? Bien sÃ»rÂ ! Nous avons la
mÃªme variante. Le <code>i</code> va prendre la valeur contenue dans le <code>Some</code>, donc <code>i</code>
prend la valeur <code>5</code>. La code dans la branche du <code>match</code> est exÃ©cutÃ©, donc nous
ajoutons 1 Ã  la valeur de <code>i</code> et nous crÃ©ons une nouvelle valeur <code>Some</code> avec
notre rÃ©sultat <code>6</code> Ã  l'intÃ©rieur.</p>
<!--
Now letâ€™s consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>Maintenant, regardons le second appel Ã  <code>plus_un</code> dans l'encart 6-5, oÃ¹ <code>x</code> vaut
<code>None</code>. Nous entrons dans le <code>match</code> et nous le comparons Ã  la premiÃ¨re branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
It matches! Thereâ€™s no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>Cela correspondÂ ! Il n'y a pas de valeur Ã  additionner, donc le programmme
s'arrÃªte et retourne la valeur <code>None</code> qui est dans le cÃ´tÃ© droit du <code>=&gt;</code>. Comme
la premiÃ¨re branche correspond, les autres branches ne sont pas comparÃ©es.</p>
<!--
Combining `match` and enums is useful in many situations. Youâ€™ll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. Itâ€™s a bit tricky at first, but
once you get used to it, youâ€™ll wish you had it in all languages. Itâ€™s
consistently a user favorite.
-->
<p>La combinaison de <code>match</code> et des Ã©numÃ©rations est utile dans de nombreuses
situations. Vous allez revoir de nombreuses fois ce schÃ©ma dans du code RustÂ :
utiliser <code>match</code> sur une Ã©numÃ©ration, rÃ©cupÃ©rer la valeur qu'elle renferme, et
exÃ©cuter du code en fonction de sa valeur. C'est un peu dÃ©licat au dÃ©but, mais
une fois que vous vous y Ãªtes habituÃ©, vous regretterez de ne pas l'avoir dans
les autres langages. Cela devient toujours l'outil prÃ©fÃ©rÃ© de ses utilisateurs.</p>
<!--
### Matches Are Exhaustive
-->
<h3><a class="header" href="#les-match-sont-toujours-exhaustifs" id="les-match-sont-toujours-exhaustifs">Les <code>match</code> sont toujours exhaustifs</a></h3>
<!--
Thereâ€™s one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and wonâ€™t compile:
-->
<p>Il y a un autre point de <code>match</code> que nous devons aborder. Admettons que cette
version de notre fonction <code>plus_un</code> a un bogue et ne va pas se compilerÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
We didnâ€™t handle the `None` case, so this code will cause a bug. Luckily, itâ€™s
a bug Rust knows how to catch. If we try to compile this code, weâ€™ll get this
error:
-->
<p>Nous n'avons pas gÃ©rÃ© le cas du <code>None</code>, donc ce code va gÃ©nÃ©rer un bogue.
Heureusement, c'est un bogue que Rust sait gÃ©rer. Si nous essayons de compiler
ce code, nous allons obtenir cette erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 -- > src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rust knows that we didnâ€™t cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier impossible.
-->
<p>Rust sait que nous n'avons pas couvert toutes les possibilitÃ©s et sait mÃªme quel
motif nous avons oubliÃ©Â ! Les <code>match</code> de Rust sont <em>exhaustifs</em>Â : nous devons
traiter toutes les possibilitÃ©s afin que le code soit valide. Dans notre cas de
<code>Option&lt;T&gt;</code>, quand Rust nous empÃªche d'oublier de gÃ©rer explicitement le cas de
<code>None</code>, il nous protÃ¨ge d'une situation oÃ¹ nous supposons que nous avons une
valeur alors que nous pourrions avoir null, ce qui rend impossible l'erreur aux
milliards de dollars que nous avons vu prÃ©cÃ©demment.</p>
<!--
### The `_` Placeholder
-->
<h3><a class="header" href="#le-caractÃ¨re-rÃ©servÃ©-_" id="le-caractÃ¨re-rÃ©servÃ©-_">Le caractÃ¨re rÃ©servÃ© <code>_</code></a></h3>
<!--
Rust also has a pattern we can use when we donâ€™t want to list all possible
values. For example, a `u8` can have valid values of 0 through 255. If we only
care about the values 1, 3, 5, and 7, we donâ€™t want to have to list out 0, 2,
4, 6, 8, 9 all the way up to 255. Fortunately, we donâ€™t have to: we can use the
special pattern `_` instead:
-->
<p>Rust a aussi un motif que nous pouvons utliser quand nous ne voulons pas traiter
toutes les valeurs possibles. Par exemple, un <code>u8</code> peut Ãªtre valide entre 0
et 255. Si nous n'avons besoin que des valeurs 1, 3, 5 et 7, nous ne voulons pas
traiter 0, 2, 4, 6, 7, 8, 9 et ainsi de suite jusqu'Ã  255. Heureusement, nous
n'avons pas Ã  le faireÂ : nous pouvons utiliser le motif spÃ©cial <code>_</code>Â :</p>
<!--
```rust
# fn main() {
    let some_u8_value = 0u8;
    match some_u8_value {
        1 => println!("one"),
        3 => println!("three"),
        5 => println!("five"),
        7 => println!("seven"),
        _ => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = 0u8;
    match une_valeur_u8 {
        1 =&gt; println!(&quot;un&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        5 =&gt; println!(&quot;cinq&quot;),
        7 =&gt; println!(&quot;sept&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
The `_` pattern will match any value. By putting it after our other arms, the
`_` will match all the possible cases that arenâ€™t specified before it. The `()`
is just the unit value, so nothing will happen in the `_` case. As a result, we
can say that we want to do nothing for all the possible values that we donâ€™t
list before the `_` placeholder.
-->
<p>Le motif <code>_</code> va correspondre Ã  toutes les valeurs. En l'ajoutant Ã  la fin de nos
branches, le <code>_</code> va correspondre Ã  tous les autres cas qui ne sont pas listÃ©s
avant. Au final, nous avons pu dire que nous ne voulons rien faire pour les
valeurs possibles que nous ne traitons pas avant le caractÃ¨re rÃ©servÃ© <code>_</code>.</p>
<!--
However, the `match` expression can be a bit wordy in a situation in which we
care about only *one* of the cases. For this situation, Rust provides `if let`.
-->
<p>Cependant, l'expression <code>match</code> peut Ãªtre un peu lourde dans une situation oÃ¹
nous nous prÃ©occupons uniquement <em>d'un seul</em> cas. Pour ce cas, Rust nous propose
d'utiliser une autre structure, <code>if let</code>.</p>
<!--
More about patterns and matching can be found in [chapter 18][ch18-00-patterns].
-->
<p>Vous pouvez en apprendre plus sur les motifs et le filtrage par motif au
<a href="ch18-00-patterns.html">chapter 18</a>.</p>
<!--
[ch18-00-patterns]:
ch18-00-patterns.html
-->
<!--
## Concise Control Flow with `if let`
-->
<h2><a class="header" href="#une-structure-de-contrÃ´le-concise--if-let" id="une-structure-de-contrÃ´le-concise--if-let">Une structure de contrÃ´le conciseÂ : <code>if let</code></a></h2>
<!--
The `if let` syntax lets you combine `if` and `let` into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an `Option<u8>` value but only wants to
execute code if the value is 3.
-->
<p>La syntaxe <code>if let</code> vous permet de combiner <code>if</code> et <code>let</code> afin de gÃ©rer une
valeur qui correspond Ã  un motif tout en ignorant les autres possibilitÃ©s.
Imaginons le programme dans l'encart 6-6 qui fait un <code>match</code> sur une valeur
<code>Option&lt;u8&gt;</code> mais n'a besoin d'exÃ©cuter du code que si la valeur est 3.</p>
<!--
```rust
# fn main() {
    let some_u8_value = Some(0u8);
    match some_u8_value {
        Some(3) => println!("three"),
        _ => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = Some(0u8);
    match une_valeur_u8 {
        Some(3) =&gt; println!(&quot;trois&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-6: A `match` that only cares about executing
code when the value is `Some(3)`</span>
-->
<p><span class="caption">Encart 6-6Â : Un <code>match</code> qui n'exÃ©cute du code que si la
valeur est <code>Some(3)</code></span></p>
<!--
We want to do something with the `Some(3)` match but do nothing with any other
`Some<u8>` value or the `None` value. To satisfy the `match` expression, we
have to add `_ => ()` after processing just one variant, which is a lot of
boilerplate code to add.
-->
<p>Nous voulons faire quelque chose avec la valeur <code>Some(3)</code> mais ignorer
les autres valeurs de type <code>Some&lt;u8&gt;</code> ou la valeur <code>None</code>. Pour satisfaire
l'expression <code>match</code>, nous devons ajouter <code>_ =&gt; ()</code> aprÃ¨s avoir gÃ©rÃ© une seule
variante, ce qui fait beaucoup de code inutile.</p>
<!--
Instead, we could write this in a shorter way using `if let`. The following
code behaves the same as the `match` in Listing 6-6:
-->
<p>A la place, nous pourrions Ã©crire le mÃªme programme de maniÃ¨re plus concise en
utilisant <code>if let</code>. Le code suivant se comporte comme le <code>match</code> de l'encart
6-6Â :</p>
<!--
```rust
# fn main() {
#     let some_u8_value = Some(0u8);
    if let Some(3) = some_u8_value {
        println!("three");
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let une_valeur_u8 = Some(0u8);
</span>    if let Some(3) = une_valeur_u8 {
        println!(&quot;trois&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
The syntax `if let` takes a pattern and an expression separated by an equal
sign. It works the same way as a `match`, where the expression is given to the
`match` and the pattern is its first arm.
-->
<p>La syntaxe <code>if let</code> prend un motif et une expression sÃ©parÃ©s par un signe Ã©gal.
Elle fonctionne de la mÃªme maniÃ¨re qu'un <code>match</code> oÃ¹ l'expression est donnÃ©e au
<code>match</code> et que le motif est sa premiÃ¨re branche.</p>
<!--
Using `if let` means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that `match` enforces. Choosing
between `match` and `if let` depends on what youâ€™re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.
-->
<p>Utiliser <code>if let</code> permet d'Ã©crire moins de code, et de moins l'indenter.
Cependant, vous perdez la vÃ©rification de l'exhaustivitÃ© qu'assure le <code>match</code>.
Choisir entre <code>match</code> et <code>if let</code> dÃ©pend de la situationÂ : Ã  vous de choisir
un Ã©quilibre entre Ãªtre concis et appliquer une vÃ©rification exhaustive.</p>
<!--
In other words, you can think of `if let` as syntax sugar for a `match` that
runs code when the value matches one pattern and then ignores all other values.
-->
<p>Autrement dit, vous pouvez considÃ©rer le <code>if let</code> comme du sucre syntaxique pour
un <code>match</code> qui exÃ©cute du code uniquement quand la valeur correspond Ã  un motif
et ignore tous autres valeurs.</p>
<!--
We can include an `else` with an `if let`. The block of code that goes with the
`else` is the same as the block of code that would go with the `_` case in the
`match` expression that is equivalent to the `if let` and `else`. Recall the
`Coin` enum definition in Listing 6-4, where the `Quarter` variant also held a
`UsState` value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a `match`
expression like this:
-->
<p>Nous pouvons joindre un <code>else</code> Ã  un <code>if let</code>. Le bloc de code qui va dans le
<code>else</code> est le mÃªme que le bloc de code qui va dans le cas <code>_</code> avec l'expression
<code>match</code>. Souvenez-vous de la dÃ©finition de l'Ã©numÃ©ration <code>USACoin</code> de l'encart
6-4, oÃ¹ la variante <code>Quarter</code> avait aussi une valeur <code>USAState</code>. Si nous
voulions compter toutes les piÃ¨ces qui ne sont pas des <code>Quarter</code> que nous voyons
passer, tout en affichant l'Ã©tat des <code>Quarter</code>, nous pourrions le faire avec
une expression <code>match</code> comme ceciÂ :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
# fn main() {
#     let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masquÃ©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let piece = USACoin::Penny;
</span>    let mut compteur = 0;
    match piece {
        USACoin::Quarter(etat) =&gt; println!(&quot;Il s'agit d'un Quarter de l'Ã©tat de {:?}Â !&quot;, etat),
        _ =&gt; compteur += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could use an `if let` and `else` expression like this:
-->
<p>Ou nous pourrions utiliser une expression <code>if let</code>/<code>else</code> comme ceciÂ :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
# fn main() {
#     let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masquÃ©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let piece = USACoin::Penny;
</span>    let mut compteur = 0;
    if let USACoin::Quarter(etat) = piece {
        println!(&quot;Il s'agit d'un Quarter de l'Ã©tat de {:?}!&quot;, etat);
    } else {
        compteur += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If you have a situation in which your program has logic that is too verbose to
express using a `match`, remember that `if let` is in your Rust toolbox as well.
-->
<p>Si vous trouvez que votre programme est alourdi par l'utilisation d'un <code>match</code>,
souvenez-vous que <code>if let</code> est aussi prÃ©sent dans votre boite Ã  outils Rust.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-5" id="rÃ©sumÃ©-5">RÃ©sumÃ©</a></h2>
<!--
Weâ€™ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. Weâ€™ve shown how the standard libraryâ€™s `Option<T>`
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use `match` or `if let` to extract and use those
values, depending on how many cases you need to handle.
-->
<p>Nous avons dÃ©sormais appris comment utiliser les Ã©numÃ©rations pour crÃ©er des
types personnalisÃ©s qui peuvent faire partie d'un jeu de valeurs recensÃ©es. Nous
avons montrÃ© comment le type <code>Option&lt;T&gt;</code> de la bibliothÃ¨que standard vous aide
Ã  utiliser le systÃ¨me de types pour Ã©viter les erreurs. Lorsque les valeurs
d'Ã©numÃ©ration contiennent des donnÃ©es, vous pouvez utiliser <code>match</code>
ou <code>if let</code> pour extraire et utiliser ces valeurs, Ã  choisir en fonction du
nombre de cas que vous voulez gÃ©rer.</p>
<!--
Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions get only values of the type each
function expects.
-->
<p>Vos programmes Rust peuvent maintenant dÃ©crire des concepts mÃ©tier Ã  l'aide de
structures et d'Ã©numÃ©rations. CrÃ©er des types personnalisÃ©s Ã  utiliser dans
votre API assure la sÃ©curitÃ© des typesÂ : le compilateur s'assurera que vos
fonctions ne reÃ§oivent que des valeurs du type attendu.</p>
<!--
In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, letâ€™s now turn to
Rustâ€™s modules.
-->
<p>Afin de fournir une API bien organisÃ©e, simple Ã  utiliser et qui n'expose que ce
dont vos utilisateurs auront besoin, dÃ©couvrons maintenant les modules de Rust.</p>
<!--
# Managing Growing Projects with Packages, Crates, and Modules
-->
<h1><a class="header" href="#gÃ©rer-des-projets-grandissants-avec-les-paquets-crates-et-modules" id="gÃ©rer-des-projets-grandissants-avec-les-paquets-crates-et-modules">GÃ©rer des projets grandissants avec les paquets, crates et modules</a></h1>
<!--
As you write large programs, organizing your code will be important because
keeping track of your entire program in your head will become impossible. By
grouping related functionality and separating code with distinct features,
youâ€™ll clarify where to find code that implements a particular feature and
where to go to change how a feature works.
-->
<p>Lorsque vous commencez Ã  Ã©crire des gros programmes, organiser votre code va
devenir important car vous ne pourrez plus vous souvenir de l'intÃ©gralitÃ© de
votre programme. En regroupant des fonctionnalitÃ©s qui ont des points
communs et en sÃ©parant des autres fonctionnalitÃ©s, vous clarifiez l'endroit oÃ¹
trouver le code qui implÃ©mente une fonctionnalitÃ© spÃ©cifique afin de pouvoir le
relire ou le modifier.</p>
<!--
The programs weâ€™ve written so far have been in one module in one file. As a
project grows, you can organize code by splitting it into multiple modules and
then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects of a set of interrelated packages
that evolve together, Cargo provides workspaces, which weâ€™ll cover in the
[â€œCargo Workspacesâ€][workspaces]<!-- ignore -- > section in Chapter 14.
-->
<p>Le programme que nous avons Ã©crit prÃ©cÃ©demment Ã©tait dans un module et dans un
seul fichier. Quand le projet grandit, vous pouvez organiser votre code en le
dÃ©coupant en plusieurs modules et ensuite en plusieurs fichiers. Un paquet peut
contenir plusieurs crates binaires et accessoirement une crate de bibliothÃ¨que.
Lorsqu'un paquet grandit, vous pouvez en extraire des parties dans des crates
sÃ©parÃ©es qui deviennent des dÃ©pendances externes. Ce chapitre va aborder toutes
ces techniques. Pour un projet de trÃ¨s grande envergure qui a des paquets
interconnectÃ©s qui Ã©voluent ensemble, Cargo propose les espaces de travail, que
nous allons dÃ©couvrir dans une section du
<a href="ch14-03-cargo-workspaces.html">chapitre 14</a><!-- ignore -->.</p>
<!--
In addition to grouping functionality, encapsulating implementation details
lets you reuse code at a higher level: once youâ€™ve implemented an operation,
other code can call that code via the codeâ€™s public interface without knowing
how the implementation works. The way you write code defines which parts are
public for other code to use and which parts are private implementation details
that you reserve the right to change. This is another way to limit the amount
of detail you have to keep in your head.
-->
<p>En plus de regrouper des fonctionnalitÃ©s, les modules vous permettent
d'encapsuler les dÃ©tails de l'implÃ©mentation d'une opÃ©ration : vous pouvez
Ã©crire du code puis l'utiliser comme une abstraction Ã  travers l'interface de
programmation publique (API) du code sans se soucier de connaÃ®tre les dÃ©tails de
son implÃ©mentation. La faÃ§on dont vous Ã©crivez le code dÃ©finit quelles sont les
parties sont publiques pour qu'un autre code puisse l'utiliser et quelles
parties sont des dÃ©tails d'implÃ©mentation privÃ©es dont vous vous rÃ©servez le
droit de modifier. C'est un autre moyen de limiter le nombre d'Ã©lÃ©ments de
l'API pour celui qui l'utilise.</p>
<!--
A related concept is scope: the nested context in which code is written has a
set of names that are defined as â€œin scope.â€ When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You canâ€™t have two items with the
same name in the same scope; tools are available to resolve name conflicts.
-->
<p>Un concept qui lui est associÃ© est la portÃ©eÂ : le contexte dans lequel le code
est Ã©crit a un jeu de noms qui sont dÃ©finis comme â€œdans la portÃ©eâ€. Quand ils
lisent, Ã©crivent et compilent du code, les dÃ©veloppeurs et les compilateurs ont
besoin de savoir prÃ©cisÃ©ment ce que dÃ©signe une entitÃ©, que cette entitÃ© soit
une variable, une fonction, une structure, une Ã©numÃ©ration, un module, une
constanteÂ ... Vous pouvez crÃ©er des portÃ©es et dÃ©cider si les entitÃ©s sont dans
la portÃ©e ou non. Vous ne pouvez pas avoir deux entitÃ©s avec le mÃªme nom dans la
mÃªme portÃ©eÂ ; cependant des outils existent pour rÃ©soudre les conflits de nom.</p>
<!--
Rust has a number of features that allow you to manage your codeâ€™s
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the *module system*, include:
-->
<p>Rust a de nombreuses fonctionnalitÃ©s qui vous permettent de gÃ©rer l'organisation
de votre code, grÃ¢ce Ã  ce que la communautÃ© Rust appelle le <em>systÃ¨me de
modules</em>.
Ce systÃ¨me dÃ©finit quels sont les Ã©lÃ©ments qui sont accessibles depuis
l'extÃ©rieur de la bibliothÃ¨que (notion de privÃ© ou public), ansi que leur
portÃ©e.
Ces fonctionnalitÃ©s comprennent :</p>
<!--
* **Packages:** A Cargo feature that lets you build, test, and share crates
* **Crates:** A tree of modules that produces a library or executable
* **Modules** and **use:** Let you control the organization, scope, and
  privacy of paths
* **Paths:** A way of naming an item, such as a struct, function, or module
-->
<ul>
<li><strong>les paquetsÂ :</strong> une fonctionnalitÃ© de Cargo qui vous permet de compiler,
tester, et partager des crates.</li>
<li><strong>les <code>Crates</code>Â :</strong> une arborescence de modules qui fournit une bibliothÃ¨que ou
un exÃ©cutable</li>
<li><strong>les cheminsÂ :</strong> une faÃ§on de nommer un Ã©lÃ©ment, comme une structure, une
fonction ou un module.</li>
</ul>
<!--
In this chapter, weâ€™ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!
-->
<p>Dans ce chapitre, nous allons dÃ©couvrir ces fonctionnalitÃ©s, voir comment elles
intÃ©ragissent, et expliquer comment les utiliser pour gÃ©rer les portÃ©es. Ã€
l'issue de ce chapitre, vous aurez de solides connaissances sur le systÃ¨me de
modules et vous pourrez travailler avec les portÃ©es comme un proÂ !</p>
<!--
[workspaces]: ch14-03-cargo-workspaces.html
-->
<!--
## Packages and Crates
-->
<h2><a class="header" href="#les-paquets-et-les-crates" id="les-paquets-et-les-crates">Les paquets et les crates</a></h2>
<!--
The first parts of the module system weâ€™ll cover are packages and crates. A
crate is a binary or library. The *crate root* is a source file that the Rust
compiler starts from and makes up the root module of your crate (weâ€™ll explain
modules in depth in the [â€œDefining Modules to Control Scope and
Privacyâ€][modules]<!-- ignore -- > section). A *package* is one or more crates
that provide a set of functionality. A package contains a *Cargo.toml* file
that describes how to build those crates.
-->
<p>La premiÃ¨re partie du systÃ¨me de modules que nous allons aborder concerne les
paquets et les <em>crates</em>. Une crate est un binaire ou une bibliothÃ¨que. Pour la
compiler, le compilateur Rust part d'un fichier source, la racine de la <em>crate</em>,
Ã  partir duquel est alors crÃ©Ã© le <em>module racine</em> de votre <em>crate</em> (nous verrons
les modules plus en dÃ©tail dans la <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">section suivante</a><!-- ignore -->).</p>
<!--
Several rules determine what a package can contain. A package *must* contain
zero or one library crates, and no more. It can contain as many binary crates
as youâ€™d like, but it must contain at least one crate (either library or
binary).
-->
<p>Il y a plusieurs rÃ¨gles qui dÃ©terminent ce qu'un paquet peut contenir. il doit
contenir une seule crate de bibliothÃ¨que, ou aucune. Il peut contenir autant de
crates binaires que vous le souhaitez, mais il doit contenir au moins une crate
(que ce soit une bibliothÃ¨que ou un binaire).</p>
<!--
Letâ€™s walk through what happens when we create a package. First, we enter the
command `cargo new`:
-->
<p>DÃ©couvrons ce qui se passe quand nous crÃ©ons un paquet. D'abord, nous utilisons
la commande <code>cargo new</code>Â :</p>
<!--
```console
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```
-->
<pre><code class="language-console">$ cargo new mon-projet
     Created binary (application) `mon-projet` package
$ ls mon-projet
Cargo.toml
src
$ ls mon-projet/src
main.rs
</code></pre>
<!--
When we entered the command, Cargo created a *Cargo.toml* file, giving us a
package. Looking at the contents of *Cargo.toml*, thereâ€™s no mention of
*src/main.rs* because Cargo follows a convention that *src/main.rs* is the
crate root of a binary crate with the same name as the package. Likewise, Cargo
knows that if the package directory contains *src/lib.rs*, the package contains
a library crate with the same name as the package, and *src/lib.rs* is its
crate root. Cargo passes the crate root files to `rustc` to build the library
or binary.
-->
<p>Lorsque nous avons saisi la commande, Cargo a crÃ©Ã© un fichier <em>Cargo.toml</em>, qui
dÃ©finit un paquet. Si on regarde le contenu de <em>Cargo.toml</em>, le fichier
<em>src/main.rs</em> n'est pas mentionnÃ© car Cargo obÃ©it Ã  une convention selon
laquelle <em>src/main.rs</em> est la racine de la crate binaire portant le mÃªme
nom que le paquet. De la mÃªme faÃ§on, Cargo sait que si le dossier du paquet
contient <em>src/lib.rs</em>, alors le paquet contient une crate de bibliothÃ¨que qui a
le mÃªme nom que le paquet, et que <em>src/lib.rs</em> est sa racine. Cargo transmet les
fichiers de la crate racine Ã  <code>rustc</code> pour compiler la bibliothÃ¨que ou le
binaire.</p>
<!--
Here, we have a package that only contains *src/main.rs*, meaning it only
contains a binary crate named `my-project`. If a package contains *src/main.rs*
and *src/lib.rs*, it has two crates: a library and a binary, both with the same
name as the package. A package can have multiple binary crates by placing files
in the *src/bin* directory: each file will be a separate binary crate.
-->
<p>Dans notre cas, nous avons un paquet qui contient uniquement <em>src/main.rs</em>, ce
qui veut dire qu'il contient uniquement une crate binaire qui s'appelle
<code>mon-projet</code>. Si un paquet contient <em>src/main.rs</em> et <em>src/lib.rs</em>, il a deux
cratesÂ : une bibliothÃ¨que et une binaire, chacune avec le mÃªme nom que le
paquet. Un paquet peut avoir plusieurs crates binaires en ajoutant des fichiers
dans le rÃ©pertoire <em>src/bin</em>Â : chaque fichier sera une crate sÃ©parÃ©e.</p>
<!--
A crate will group related functionality together in a scope so the
functionality is easy to share between multiple projects. For example, the
`rand` crate we used in [Chapter 2][rand]<!-- ignore -- > provides functionality
that generates random numbers. We can use that functionality in our own
projects by bringing the `rand` crate into our projectâ€™s scope. All the
functionality provided by the `rand` crate is accessible through the crateâ€™s
name, `rand`.
-->
<p>Une crate regroupe plusieurs fonctionnalitÃ©s associÃ©es ensemble dans une
portÃ©e afin que les fonctionnalitÃ©s soient faciles Ã  partager entre plusieurs
projets. Par exemple, la crate <code>rand</code> que nous avons utilisÃ© dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">le chapitre 2</a><!-- ignore --> nous permet de gÃ©nÃ©rer
des nombres alÃ©atoires. Nous pouvons utiliser cette fonctionnalitÃ© dans notre
propre projet en important la crate <code>rand</code> dans la portÃ©e de notre projet.
Toutes les fonctionnalitÃ©s fournies par la crate <code>rand</code> seront accessibles via
le nom de la crate, <code>rand</code>.</p>
<!--
Keeping a crateâ€™s functionality in its own scope clarifies whether particular
functionality is defined in our crate or the `rand` crate and prevents
potential conflicts. For example, the `rand` crate provides a trait named
`Rng`. We can also define a `struct` named `Rng` in our own crate. Because a
crateâ€™s functionality is namespaced in its own scope, when we add `rand` as a
dependency, the compiler isnâ€™t confused about what the name `Rng` refers to. In
our crate, it refers to the `struct Rng` that we defined. We would access the
`Rng` trait from the `rand` crate as `rand::Rng`.
-->
<p>Ranger une fonctionnalitÃ© d'une crate dans sa propre portÃ©e clarifie si une
fonctionnalitÃ© prÃ©cise est dÃ©finie dans notre crate ou dans la crate <code>rand</code> et
Ã©vite ainsi de potentiels conflits. Par exemple, la crate <code>rand</code> fournit un
<em>trait</em> qui s'appelle <code>Rng</code>. Nous pouvons nous aussi dÃ©finir une structure qui
s'appelle <code>Rng</code> dans notre propre crate. Comme les fonctionnalitÃ©s des crates
sont dans la portÃ©e de leur propre espace de nom, quand nous ajoutons <code>rand</code> en
dÃ©pendance, il n'y a pas d'ambiguÃ¯tÃ© pour le compilateur sur le nom <code>Rng</code>. Dans
notre crate, il se rÃ©fÃ¨re au <code>struct Rng</code> que nous avons dÃ©fini. Nous accÃ©dons
au <em>trait</em> <code>Rng</code> de la crate <code>rand</code> via <code>rand::Rng</code>.</p>
<!--
Letâ€™s move on and talk about the module system!
-->
<p>Continuons d'avancer et parlons maintenant du systÃ¨me de modulesÂ !</p>
<!--
[modules]: ch07-02-defining-modules-to-control-scope-and-privacy.html
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
-->
<!--
## Defining Modules to Control Scope and Privacy
-->
<h2><a class="header" href="#dÃ©finir-des-modules-pour-gÃ©rer-la-portÃ©e-et-la-protection" id="dÃ©finir-des-modules-pour-gÃ©rer-la-portÃ©e-et-la-protection">DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></h2>
<!--
In this section, weâ€™ll talk about modules and other parts of the module system,
namely *paths* that allow you to name items; the `use` keyword that brings a
path into scope; and the `pub` keyword to make items public. Weâ€™ll also discuss
the `as` keyword, external packages, and the glob operator. For now, letâ€™s
focus on modules!
-->
<p>Dans cette section, nous allons aborder les modules et les autres outils du
systÃ¨me de modules, Ã  savoir les <em>chemins</em> qui nous permettent de nommer les
Ã©lÃ©ments; l'utilisation du mot-clÃ© <code>use</code> qui importe un chemin dans la portÃ©e;
et le mot-clÃ© <code>pub</code> qui rend publics les Ã©lÃ©ments. Nous verrons aussi le mot-clÃ©
<code>as</code>, les paquets externes, et l'opÃ©rateur glob. Pour commencer, penchons-nous
sur les modulesÂ !</p>
<!--
*Modules* let us organize code within a crate into groups for readability and
easy reuse. Modules also control the *privacy* of items, which is whether an
item can be used by outside code (*public*) or is an internal implementation
detail and not available for outside use (*private*).
-->
<p>Les <em>modules</em> nous permettent de regrouper le code d'une crate pour une
meilleure lisibilitÃ© et pour la facilitÃ© de rÃ©utilisation. Les modules
permettent aussi de gÃ©rer la <em>protection</em> des Ã©lÃ©ments, qui prÃ©cise si un
Ã©lÃ©ment peut Ãªtre utilisÃ© Ã  l'extÃ©rieur du module (<em>c'est public</em>) ou s'il est
un constituant interne et n'est pas disponible pour une utilisation externe
(<em>c'est privÃ©</em>).</p>
<!--
As an example, letâ€™s write a library crate that provides the functionality of a
restaurant. Weâ€™ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than actually
implement a restaurant in code.
-->
<p>Voici un exemple, Ã©crivons une crate de bibliothÃ¨que qui permet de simuler un
restaurant. Nous allons dÃ©finir les signatures des fonctions mais nous allons
laisser leurs corps vides pour nous concentrer sur l'organisation du code,
plutÃ´t que de coder pour de vrai un restaurant.</p>
<!--
In the restaurant industry, some parts of a restaurant are referred to as
*front of house* and others as *back of house*. Front of house is where
customers are; this is where hosts seat customers, servers take orders and
payment, and bartenders make drinks. Back of house is where the chefs and cooks
work in the kitchen, dishwashers clean up, and managers do administrative work.
-->
<p>Dans le secteur de la restauration, certaines parties d'un restaurant sont
assimilÃ©es Ã  la <em>salle Ã  manger</em> et d'autres <em>aux cuisines</em>. La partie salle Ã 
manger est l'endroit oÃ¹ se trouvent les clients; c'est l'endroit oÃ¹ les hÃ´tes
installent les clients, oÃ¹ les serveurs prennent les commandes et encaissent les
clients, et oÃ¹ les barmans prÃ©parent des boissons. Dans la partie cuisines, nous
retrouvons les chefs et les cuisiniers qui travaillent dans la cuisine, mais
aussi les plongeurs qui nettoient la vaisselle et les gestionnaires qui
s'occupent des tÃ¢ches administratives.</p>
<!--
To structure our crate in the same way that a real restaurant works, we can
organize the functions into nested modules. Create a new library named
`restaurant` by running `cargo new --lib restaurant`; then put the code in
Listing 7-1 into *src/lib.rs* to define some modules and function signatures.
-->
<p>Pour organiser notre crate de la mÃªme maniÃ¨re qu'un vrai restaurant, nous
pouvons organiser les fonctions avec des modules imbriquÃ©s. CrÃ©ez une nouvelle
bibliothÃ¨que qui s'appelle <code>restaurant</code> en utilisant
<code>cargo new --lib restaurant</code>; puis Ã©crivez le code de l'encart 7-1 dans
<em>src/lib.rs</em> afin de dÃ©finir quelques modules et quelques signatures de
fonctions.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">mod salle_a_manger {
    mod accueil {
        fn ajouter_a_la_liste_attente() {}

        fn installer_a_une_table() {}
    }

    mod service {
        fn prendre_commande() {}

        fn servir_commande() {}

        fn encaisser() {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-1: A `front_of_house` module containing other
modules that then contain functions</span>
-->
<p><span class="caption">Encart 7-1Â : Un module <code>salle_a_manger</code> qui contient
d'autres modules qui contiennent eux-mÃªmes des fonctions</span></p>
<!--
We define a module by starting with the `mod` keyword and then specify the
name of the module (in this case, `front_of_house`) and place curly brackets
around the body of the module. Inside modules, we can have other modules, as in
this case with the modules `hosting` and `serving`. Modules can also hold
definitions for other items, such as structs, enums, constants, traits, orâ€”as
in Listing 7-1â€”functions.
-->
<p>Nous dÃ©finissons un module en commenÃ§ant avec le mot-clÃ© <code>mod</code> et nous prÃ©cisons
ensuite le nom du module (dans notre cas, <code>salle_a_manger</code>) et nous ajoutons des
accolades autour du corps du module. Dans les modules, nous pouvons avoir
d'autres modules, comme dans notre cas avec les modules <code>accueil</code> et <code>service</code>.
Les modules peuvent aussi contenir des dÃ©finitions pour d'autres Ã©lÃ©ments, comme
des structures, des Ã©numÃ©rations, des constantes, des traits, ou des fonctions
(comme c'est le cas dans l'encart 7-1).</p>
<!--
By using modules, we can group related definitions together and name why
theyâ€™re related. Programmers using this code would have an easier time finding
the definitions they wanted to use because they could navigate the code based
on the groups rather than having to read through all the definitions.
Programmers adding new functionality to this code would know where to place the
code to keep the program organized.
-->
<p>GrÃ¢ce aux modules, nous pouvons regrouper ensemble des dÃ©finitions qui sont
liÃ©es et donner un nom Ã  ce lien. Les dÃ©veloppeurs qui utiliseront ce code
pourront plus facilement trouver les dÃ©finitions dont ils ont besoin car ils
peuvent parcourir le code en fonction des groupes plutÃ´t que d'avoir Ã  lire
toutes les dÃ©finitions. Les dÃ©veloppeurs qui veulent rajouter des nouvelles
fonctionnalitÃ©s Ã  ce code sauront maintenant oÃ¹ placer le code tout en gardant
le programme organisÃ©.</p>
<!--
Earlier, we mentioned that *src/main.rs* and *src/lib.rs* are called crate
roots. The reason for their name is that the contents of either of these two
files form a module named `crate` at the root of the crateâ€™s module structure,
known as the *module tree*.
-->
<p>PrÃ©cÃ©demment, nous avons dit que <em>src/main.rs</em> et <em>src/lib.rs</em> Ã©taient des
racines de crates. Nous les appelons ainsi car le contenu de chacun de ces
deux fichiers constituent un module qui s'appelle <code>crate</code> Ã  la racine de
<em>l'arborescence du module</em>.</p>
<!--
Listing 7-2 shows the module tree for the structure in Listing 7-1.
-->
<p>L'encart 7-2 prÃ©sente l'arborescence du module pour la structure de
l'encart 7-1.</p>
<!--
```text
crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
```
-->
<pre><code class="language-text">crate
 â””â”€â”€ salle_a_manger
     â”œâ”€â”€ accueil
     â”‚   â”œâ”€â”€ ajouter_a_la_liste_attente
     â”‚   â””â”€â”€ installer_a_une_table
     â””â”€â”€ service
         â”œâ”€â”€ prendre_commande
         â”œâ”€â”€ servir_commande
         â””â”€â”€ encaisser
</code></pre>
<!--
<span class="caption">Listing 7-2: The module tree for the code in Listing
7-1</span>
-->
<p><span class="caption">Encart 7-2Â : L'arborescence des modules pour le code de
l'encart 7-1</span></p>
<!--
This tree shows how some of the modules nest inside one another (for example,
`hosting` nests inside `front_of_house`). The tree also shows that some modules
are *siblings* to each other, meaning theyâ€™re defined in the same module
(`hosting` and `serving` are defined within `front_of_house`). To continue the
family metaphor, if module A is contained inside module B, we say that module A
is the *child* of module B and that module B is the *parent* of module A.
Notice that the entire module tree is rooted under the implicit module named
`crate`.
-->
<p>Cette arborescence montre comment les modules sont imbriquÃ©s entre eux (par
exemple, <code>accueil</code> est imbriquÃ© dans <code>salle_a_manger</code>). L'arborescence montre
aussi que certains modules sont les <em>frÃ¨res</em> d'autres modules, ce qui veut dire
qu'ils sont dÃ©finis dans le mÃªme module (<code>accueil</code> et <code>service</code> sont dÃ©finis
dans <code>salle_a_manger</code>). Pour prolonger la mÃ©taphore familiale, si le module A
est contenu dans le module B, on dit que le module A est <em>l'enfant</em> du module B
et que ce module B est le <em>parent</em> du module A. Notez aussi que tout le module
implicite <code>crate</code> est le parent de toute cette arborescence.</p>
<!--
The module tree might remind you of the filesystemâ€™s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.
-->
<p>L'arborescence des modules peut rappeler les dossiers du systÃ¨me de fichiers de
votre ordinateur; et c'est une excellente comparaisonÂ ! Comme les dossier dans
un systÃ¨me de fichiers, vous utilisez les modules pour organiser votre code. Et
comme pour les fichiers dans un dossier, nous avons besoin d'un moyen de trouver
nos modules.</p>
<!--
## Paths for Referring to an Item in the Module Tree
-->
<h2><a class="header" href="#dÃ©signer-un-Ã©lÃ©ment-dans-larborescence-de-modules" id="dÃ©signer-un-Ã©lÃ©ment-dans-larborescence-de-modules">DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></h2>
<!--
To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. If we want to call a function,
we need to know its path.
-->
<p>Pour indiquer Ã  Rust oÃ¹ trouver un Ã©lÃ©ment dans l'arborescence de modules, nous
utilisons un chemin Ã  l'instar des chemins que nous utilisons lorsque nous
naviguons dans un systÃ¨me de fichiers. Si nous voulons appeler une fonction,
nous avons besoin de connaÃ®tre son chemin.</p>
<!--
A path can take two forms:
-->
<p>Il existe deux types de cheminsÂ :</p>
<!--
* An *absolute path* starts from a crate root by using a crate name or a
  literal `crate`.
* A *relative path* starts from the current module and uses `self`, `super`, or
  an identifier in the current module.
-->
<ul>
<li>Un <em>chemin absolu</em> qui commence Ã  partir de la racine de la crate en utilisant
le nom d'une crate, ou le mot <code>crate</code>.</li>
<li>Un <em>chemin relatif</em> qui commence Ã  partir du module courant et qui utilise
<code>self</code>, <code>super</code>, ou un identificateur Ã  l'intÃ©rieur du module.</li>
</ul>
<!--
Both absolute and relative paths are followed by one or more identifiers
separated by double colons (`::`).
-->
<p>Les chemins absolus et relatifs sont suivis par un ou plusieurs identificateurs
sÃ©parÃ©s par <code>::</code>.</p>
<!--
Letâ€™s return to the example in Listing 7-1. How do we call the
`add_to_waitlist` function? This is the same as asking, whatâ€™s the path of the
`add_to_waitlist` function? In Listing 7-3, we simplified our code a bit by
removing some of the modules and functions. Weâ€™ll show two ways to call the
`add_to_waitlist` function from a new function `eat_at_restaurant` defined in
the crate root. The `eat_at_restaurant` function is part of our library crateâ€™s
public API, so we mark it with the `pub` keyword. In the [â€Exposing Paths with
the `pub` Keywordâ€][pub]<!-- ignore -- > section, weâ€™ll go into more detail
about `pub`. Note that this example wonâ€™t compile just yet; weâ€™ll explain why
in a bit.
-->
<p>Reprenons notre exemple de l'encart 7-1. Comment utiliserions-nous la fonction
<code>ajouter_a_la_liste_attente</code>Â ? Cela revient Ã  se demanderÂ : quel est le chemin
de la fonction <code>ajouter_a_la_liste_attente</code>Â ? Dans l'encart 7-3, nous avons un
peu simplifiÃ© notre code en enlevant quelques modules et quelques fonctions.
Nous allons voir deux faÃ§ons d'appeler la fonction <code>ajouter_a_la_liste_attente</code>
Ã  partir d'une nouvelle fonction <code>manger_au_restaurant</code> dÃ©finie dans la crate
racine. La fonction <code>manger_au_restaurant</code> fait partie de l'API publique de
notre crate de bibliothÃ¨que, donc nous la marquons avec le mot-clÃ© <code>pub</code>. Dans
la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposer-des-chemins-avec-le-mot-cl%C3%A9-pub">â€Exposer les chemins avec le mot-clÃ© <code>pub</code>â€</a><!-- ignore -->,
nous en apprendrons plus sur <code>pub</code>. Notez que cet exemple ne se compile pas pour
le moment; nous allons l'expliquer un peu plus tard.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">mod salle_a_manger {
    mod accueil {
        fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-3: Calling the `add_to_waitlist` function using
absolute and relative paths</span>
-->
<p><span class="caption">Encart 7-3Â : appel Ã  la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant un chemin absolu et relatif</span></p>
<!--
The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,
we use an absolute path. The `add_to_waitlist` function is defined in the same
crate as `eat_at_restaurant`, which means we can use the `crate` keyword to
start an absolute path.
-->
<p>Au premier appel de la fonction <code>ajouter_a_la_liste_attente</code> dans
<code>manger_au_restaurant</code>, nous utilisons un chemin absolu. La fonction
<code>ajouter_a_la_liste_attente</code> est dÃ©finie dans la mÃªme crate que
<code>manger_au_restaurant</code>, ce qui veut dire que nous pouvons utiliser le mot-clÃ©
<code>crate</code> pour dÃ©marrer un chemin absolu.</p>
<!--
After `crate`, we include each of the successive modules until we make our way
to `add_to_waitlist`. You can imagine a filesystem with the same structure, and
weâ€™d specify the path `/front_of_house/hosting/add_to_waitlist` to run the
`add_to_waitlist` program; using the `crate` name to start from the crate root
is like using `/` to start from the filesystem root in your shell.
-->
<p>AprÃ¨s <code>crate</code>, nous ajoutons chacun des modules successifs jusqu'Ã 
<code>ajouter_a_la_liste_attente</code>. Nous pouvons faire l'analogie avec un systÃ¨me de
fichiers qui a la mÃªme structure, oÃ¹ nous pourrions utiliser le chemin
<code>/salle_a_manger/accueil/ajouter_a_la_liste_attente</code> pour lancer le programme
<code>ajouter_a_la_liste_attente</code>; utiliser le nom <code>crate</code> pour partir de la crate
racine revient Ã  utiliser <code>/</code> pour partir de la racine de votre systÃ¨me de
fichiers dans votre invite de commande.</p>
<!--
The second time we call `add_to_waitlist` in `eat_at_restaurant`, we use a
relative path. The path starts with `front_of_house`, the name of the module
defined at the same level of the module tree as `eat_at_restaurant`. Here the
filesystem equivalent would be using the path
`front_of_house/hosting/add_to_waitlist`. Starting with a name means that the
path is relative.
-->
<p>Lors du second appel Ã  <code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>,
nous utilisons un chemin relatif. Le chemin commence par <code>salle_a_manger</code>, le
nom du module qui est dÃ©fini au mÃªme niveau que <code>manger_au_restaurant</code> dans
l'arborescence de modules. Ici, l'Ã©quivalent en terme de systÃ¨me de fichier
serait le chemin <code>salle_a_manger/accueil/ajouter_a_la_liste_attente</code>. Commencer
par un nom signifie que le chemin est relatif.</p>
<!--
Choosing whether to use a relative or absolute path is a decision youâ€™ll make
based on your project. The decision should depend on whether youâ€™re more likely
to move item definition code separately from or together with the code that
uses the item. For example, if we move the `front_of_house` module and the
`eat_at_restaurant` function into a module named `customer_experience`, weâ€™d
need to update the absolute path to `add_to_waitlist`, but the relative path
would still be valid. However, if we moved the `eat_at_restaurant` function
separately into a module named `dining`, the absolute path to the
`add_to_waitlist` call would stay the same, but the relative path would need to
be updated. Our preference is to specify absolute paths because itâ€™s more
likely to move code definitions and item calls independently of each other.
-->
<p>Choisir entre utiliser un chemin relatif ou absolu sera une dÃ©cision que vous
ferez en fonction de votre projet. Le choix se fera en fonction de si vous Ãªtes
susceptible de dÃ©placer la dÃ©finition de l'Ã©lÃ©ment souhaitÃ© sÃ©parÃ©ment ou en
mÃªme temps que le code qui l'utilise. Par exemple, si nous dÃ©plaÃ§ons le module
<code>salle_a_manger</code> ainsi que la fonction <code>manger_au_restaurant</code> dans un module qui
s'appelle <code>experience_client</code>, nous aurons besoin de mettre Ã  jour le chemin
absolu vers <code>ajouter_a_la_liste_attente</code>, mais le chemin relatif restera valide.
Cependant, si nous avions dÃ©placÃ© uniquement la fonction <code>manger_au_restaurant</code>
dans un module <code>repas</code> sÃ©parÃ©, le chemin absolu de l'appel Ã 
<code>ajouter_a_la_liste_attente</code> restera le mÃªme, mais le chemin relatif aura besoin
d'Ãªtre mis Ã  jour. Notre prÃ©fÃ©rence est d'utiliser un chemin absolu car il est
plus facile de dÃ©placer les codes de dÃ©finitions et les appels aux Ã©lÃ©ments
indÃ©pendamment les uns des autres.</p>
<!--
Letâ€™s try to compile Listing 7-3 and find out why it wonâ€™t compile yet! The
error we get is shown in Listing 7-4.
-->
<p>Essayons de compiler l'encart 7-3 et essayons de comprendre pourquoi il ne se
compile pas pour le momentÂ ! L'erreur que nous obtenons est affichÃ©e dans
l'encart 7-4.</p>
<!--
```console
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 -- > src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  -- > src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `accueil` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();
  |                            ^^^^^^^

error[E0603]: module `accueil` is private
  --&gt; src/lib.rs:12:21
   |
12 |     salle_a_manger::accueil::ajouter_a_la_liste_attente();
   |                     ^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
<span class="caption">Listing 7-4: Compiler errors from building the code in
Listing 7-3</span>
-->
<p><span class="caption">Encart 7-4Â : les erreurs de compilation du code de
l'encart 7-3</span></p>
<!--
The error messages say that module `hosting` is private. In other words, we
have the correct paths for the `hosting` module and the `add_to_waitlist`
function, but Rust wonâ€™t let us use them because it doesnâ€™t have access to the
private sections.
-->
<p>Le message d'erreur nous rappelle que ce module <code>accueil</code> est privÃ©. Autrement
dit, nous avons des chemins corrects pour le module <code>accueil</code> et pour la
fonction <code>ajouter_a_la_liste_attente</code>, mais Rust ne nous laisse pas les utiliser
car il n'a pas accÃ¨s aux sections privÃ©es.</p>
<!--
Modules arenâ€™t useful only for organizing your code. They also define Rustâ€™s
*privacy boundary*: the line that encapsulates the implementation details
external code isnâ€™t allowed to know about, call, or rely on. So, if you want to
make an item like a function or struct private, you put it in a module.
-->
<p>Les modules ne servent pas uniquement Ã  organiser votre code. Ils dÃ©finissent
aussi les <em>limites de protection</em> de RustÂ : le code externe n'est pas autorisÃ©
Ã  connaÃ®tre, Ã  appeler ou Ã  se fier Ã  des Ã©lÃ©ments internes au module. Donc, si
vous voulez rendre un Ã©lÃ©ment privÃ© comme une fonction ou une structure, vous
devez le placer dans un module.</p>
<!--
The way privacy works in Rust is that all items (functions, methods, structs,
enums, modules, and constants) are private by default. Items in a parent module
canâ€™t use the private items inside child modules, but items in child modules
can use the items in their ancestor modules. The reason is that child modules
wrap and hide their implementation details, but the child modules can see the
context in which theyâ€™re defined. To continue with the restaurant metaphor,
think of the privacy rules as being like the back office of a restaurant: what
goes on in there is private to restaurant customers, but office managers can
see and do everything in the restaurant in which they operate.
-->
<p>La protection avec Rust fait en sorte que tous les Ã©lÃ©ments (fonctions,
mÃ©thodes, structures, Ã©numÃ©rations, modules et constantes) sont privÃ©s par
dÃ©faut. Les Ã©lÃ©ments dans un module parent ne peuvent pas utiliser les Ã©lÃ©ments
privÃ©s dans les modules enfants, mais les Ã©lÃ©ments dans les modules enfants
peuvent utiliser les Ã©lÃ©ments dans les modules parents. C'est parce que les
modules enfants englobent et cachent les dÃ©tails de leur implÃ©mentation, mais
les modules enfants peuvent voir dans quel contexte ils sont dÃ©finis. Pour
continuer la mÃ©taphore du restaurant, considÃ©rez que les rÃ¨gles de protection
sont comme les cuisines d'un restaurantÂ : ce qui s'y passe n'est pas connu des
clients, mais les gestionnaires peuvent tout voir et tout faire dans le
restaurant dans lequel ils travaillent.</p>
<!--
Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. But you can expose inner
parts of child modules' code to outer ancestor modules by using the `pub`
keyword to make an item public.
-->
<p>Rust a dÃ©cidÃ© de faire fonctionner le systÃ¨me de modules de faÃ§on Ã  ce que les
dÃ©tails d'implÃ©mentation interne sont cachÃ©s par dÃ©faut. Ainsi, vous savez
quelles parties du code interne vous pouvez changer sans casser le code externe.
Mais vous pouvez exposer aux parents des parties internes des modules enfants en
utilisant le mot-clÃ© <code>pub</code> afin de les rendre public.</p>
<!--
### Exposing Paths with the `pub` Keyword
-->
<h3><a class="header" href="#exposer-des-chemins-avec-le-mot-clÃ©-pub" id="exposer-des-chemins-avec-le-mot-clÃ©-pub">Exposer des chemins avec le mot-clÃ© <code>pub</code></a></h3>
<!--
Letâ€™s return to the error in Listing 7-4 that told us the `hosting` module is
private. We want the `eat_at_restaurant` function in the parent module to have
access to the `add_to_waitlist` function in the child module, so we mark the
`hosting` module with the `pub` keyword, as shown in Listing 7-5.
-->
<p>Retournons Ã  l'erreur de l'encart 7-4 qui nous informe que le module <code>accueil</code>
est privÃ©. Nous voulons que la fonction <code>manger_au_restaurant</code> du module parent
ait accÃ¨s Ã  la fonction <code>ajouter_a_la_liste_attente</code> du module enfant, donc nous
utilisons le mot-clÃ© <code>pub</code> sur le module <code>accueil</code>, comme dans l'encart 7-5.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">mod salle_a_manger {
    pub mod accueil {
        fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-5: Declaring the `hosting` module as `pub` to
use it from `eat_at_restaurant`</span>
-->
<p><span class="caption">Encart 7-5Â : utiliser <code>pub</code> sur le module <code>accueil</code> permet
de l'utiliser dans <code>manger_au_restaurant</code></span></p>
<!--
Unfortunately, the code in Listing 7-5 still results in an error, as shown in
Listing 7-6.
-->
<p>Malheureusement, il reste une erreur dans le code de l'encart 7-5, la voici dans
l'encart 7-6.</p>
<!--
```console
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 -- > src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  -- > src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `ajouter_a_la_liste_attente` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `ajouter_a_la_liste_attente` is private
  --&gt; src/lib.rs:12:30
   |
12 |     salle_a_manger::accueil::ajouter_a_la_liste_attente();
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
<span class="caption">Listing 7-6: Compiler errors from building the code in
Listing 7-5</span>
-->
<p><span class="caption">Encart 7-6Â : erreurs de compilation du code de l'encart
7-5</span></p>
<!--
What happened? Adding the `pub` keyword in front of `mod hosting` makes the
module public. With this change, if we can access `front_of_house`, we can
access `hosting`. But the *contents* of `hosting` are still private; making the
module public doesnâ€™t make its contents public. The `pub` keyword on a module
only lets code in its ancestor modules refer to it.
-->
<p>Que s'est-il passÃ©Â ? Ajouter le mot-clÃ© <code>pub</code> devant <code>mod accueil</code> rend public
le module. Avec cette modification, si nous pouvons accÃ©der Ã  <code>salle_a_manger</code>,
alors nous pouvons accÃ©der Ã  <code>accueil</code>. Mais le <em>contenu</em> de <code>accueil</code> reste
privÃ©Â ; rendre le module public ne rend pas son contenu public. Le mot-clÃ© <code>pub</code>
sur un module permet uniquement au code de ses parents d'y faire rÃ©fÃ©rence.</p>
<!--
The errors in Listing 7-6 say that the `add_to_waitlist` function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.
-->
<p>Les erreurs dans l'encart 7-6 nous informent que la fonction
<code>ajouter_a_la_liste_attente</code> est privÃ©e. Les rÃ¨gles de protection s'appliquent
aussi bien aux modules qu'aux structures, Ã©numÃ©rations, fonctions et mÃ©thodes.</p>
<!--
Letâ€™s also make the `add_to_waitlist` function public by adding the `pub`
keyword before its definition, as in Listing 7-7.
-->
<p>Rendons publique la fonction <code>ajouter_a_la_liste_attente</code>, en ajoutant le
mot-clÃ© <code>pub</code> devant sa dÃ©finition, comme dans l'encart 7-7.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-7: Adding the `pub` keyword to `mod hosting`
and `fn add_to_waitlist` lets us call the function from
`eat_at_restaurant`</span>
-->
<p><span class="caption">Encart 7-7Â : ajout du mot-clÃ© <code>pub</code> devant <code>mod accueil</code>
et <code>fn ajouter_a_la_liste_attente</code> pour nous permettre d'appeler la fonction Ã 
partir de <code>manger_au_restaurant</code></span></p>
<!--
Now the code will compile! Letâ€™s look at the absolute and the relative path and
double-check why adding the `pub` keyword lets us use these paths in
`add_to_waitlist` with respect to the privacy rules.
-->
<p>Maintenant, le code va compilerÂ ! Analysons les chemins relatifs et absolus et
vÃ©rifions pourquoi l'ajout du mot-clÃ© <code>pub</code> nous permet d'utiliser ces chemins
dans <code>ajouter_a_la_liste_attente</code> tout en respectant les rÃ¨gles de protection.</p>
<!--
In the absolute path, we start with `crate`, the root of our crateâ€™s module
tree. Then the `front_of_house` module is defined in the crate root. The
`front_of_house` module isnâ€™t public, but because the `eat_at_restaurant`
function is defined in the same module as `front_of_house` (that is,
`eat_at_restaurant` and `front_of_house` are siblings), we can refer to
`front_of_house` from `eat_at_restaurant`. Next is the `hosting` module marked
with `pub`. We can access the parent module of `hosting`, so we can access
`hosting`. Finally, the `add_to_waitlist` function is marked with `pub` and we
can access its parent module, so this function call works!
-->
<p>Dans le chemin absolu, nous commenÃ§ons avec <code>crate</code>, la racine de notre
arborescence de modules de notre crate. Ensuite, le module <code>salle_a_manger</code> est
dÃ©fini dans la crate racine. Le module <code>salle_a_manger</code> n'est pas public, mais
comme la fonction <code>manger_au_restaurant</code> est dÃ©finie dans le mÃªme module que
<code>salle_a_manger</code> (car <code>manger_au_restaurant</code> et <code>salle_a_manger</code> sont frÃ¨res),
nous pouvons utiliser <code>salle_a_manger</code> Ã  partir de <code>manger_au_restaurant</code>.
Ensuite, nous avons le module <code>accueil</code>, dÃ©fini avec <code>pub</code>. Nous pouvons accÃ©der
au module parent de <code>accueil</code>, donc nous pouvons accÃ©der Ã  <code>accueil</code>. Enfin, la
fonction <code>ajouter_a_la_liste_attente</code> est elle aussi dÃ©finie avec <code>pub</code> et nous
pouvons accÃ©der Ã  son module parent, donc au final cet appel Ã  la fonction
fonctionne bienÂ !</p>
<!--
In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
`front_of_house`. The `front_of_house` module is defined within the same module
as `eat_at_restaurant`, so the relative path starting from the module in which
`eat_at_restaurant` is defined works. Then, because `hosting` and
`add_to_waitlist` are marked with `pub`, the rest of the path works, and this
function call is valid!
-->
<p>Dans le chemin relatif, le fonctionnement est le mÃªme que le chemin absolu sauf
pour la premiÃ¨re Ã©tapeÂ : plutÃ´t que de dÃ©marrer de la crate racine, le chemin
commence Ã  partir de <code>salle_a_manger</code>. Le module <code>salle_a_manger</code> est dÃ©fini
dans le mÃªme module que <code>manger_au_restaurant</code>, donc le chemin relatif qui
commence Ã  partir du module oÃ¹ est dÃ©fini <code>manger_au_restaurant</code> fonctionne
bien. Ensuite, comme <code>accueil</code> et <code>ajouter_a_la_liste_attente</code> sont dÃ©finis avec
<code>pub</code>, le reste du chemin fonctionne, et cet appel Ã  la fonction est donc
valideÂ !</p>
<!--
### Starting Relative Paths with `super`
-->
<h3><a class="header" href="#commencer-les-chemins-relatifs-avec-super" id="commencer-les-chemins-relatifs-avec-super">Commencer les chemins relatifs avec <code>super</code></a></h3>
<!--
We can also construct relative paths that begin in the parent module by using
`super` at the start of the path. This is like starting a filesystem path with
the `..` syntax. Why would we want to do this?
-->
<p>Nous pouvons aussi crÃ©er des chemins relatifs qui commencent Ã  partir du module
parent en utilisant <code>super</code> au dÃ©but du chemin. C'est comme dÃ©buter un chemin
dans le systÃ¨me de fichiers avec la syntaxe <code>..</code>. Mais pourquoi voudrions-nous
faire celaÂ ?</p>
<!--
Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function `fix_incorrect_order` calls the function `serve_order` by specifying
the path to `serve_order` starting with `super`:
-->
<p>Imaginons le code dans l'encart 7-8 qui reprÃ©sente le cas oÃ¹ le chef corrige une
commande erronÃ©e et l'apporte personnellement au client pour s'excuser. La
fonction <code>corriger_commande_erronee</code> appelle la fonction <code>servir_commande</code> en
commenÃ§ant le chemin de <code>servir_commande</code> avec <code>super</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn servir_commande() {}

mod cuisines {
    fn corriger_commande_erronee() {
        cuisiner_commande();
        super::servir_commande();
    }

    fn cuisiner_commande() {}
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-8: Calling a function using a relative path
starting with `super`</span>
-->
<p><span class="caption">Encart 7-8Â : appel d'une fonction en utilisant un chemin
relatif qui commence par <code>super</code></span></p>
<!--
The `fix_incorrect_order` function is in the `back_of_house` module, so we can
use `super` to go to the parent module of `back_of_house`, which in this case
is `crate`, the root. From there, we look for `serve_order` and find it.
Success! We think the `back_of_house` module and the `serve_order` function are
likely to stay in the same relationship to each other and get moved together
should we decide to reorganize the crateâ€™s module tree. Therefore, we used
`super` so weâ€™ll have fewer places to update code in the future if this code
gets moved to a different module.
-->
<p>La fonction <code>corriger_commande_erronee</code> est dans le module <code>cuisines</code>, donc nous
pouvons utiliser <code>super</code> pour nous rendre au module parent de <code>cuisines</code>, qui
dans notre cas est <code>crate</code>, la racine. De lÃ , nous cherchons <code>servir_commande</code>
et nous la trouvons. Avec succÃ¨sÂ ! Nous pensons que le module <code>cuisines</code> et la
fonction <code>servir_commande</code> vont toujours garder la mÃªme relation et devrons Ãªtre
dÃ©placÃ©s ensemble si nous rÃ©organisons l'arborescence de modules de la crate.
Ainsi, nous avons utilisÃ© <code>super</code> pour avoir moins de code Ã  mettre Ã  jour le
code Ã  l'avenir si le code est dÃ©placÃ© dans un module diffÃ©rent.</p>
<!--
### Making Structs and Enums Public
-->
<h3><a class="header" href="#rendre-publiques-des-structures-et-des-Ã©numÃ©rations" id="rendre-publiques-des-structures-et-des-Ã©numÃ©rations">Rendre publiques des structures et des Ã©numÃ©rations</a></h3>
<!--
We can also use `pub` to designate structs and enums as public, but there are a
few extra details. If we use `pub` before a struct definition, we make the
struct public, but the structâ€™s fields will still be private. We can make each
field public or not on a case-by-case basis. In Listing 7-9, weâ€™ve defined a
public `back_of_house::Breakfast` struct with a public `toast` field but a
private `seasonal_fruit` field. This models the case in a restaurant where the
customer can pick the type of bread that comes with a meal, but the chef
decides which fruit accompanies the meal based on whatâ€™s in season and in
stock. The available fruit changes quickly, so customers canâ€™t choose the fruit
or even see which fruit theyâ€™ll get.
-->
<p>Nous pouvons aussi utiliser <code>pub</code> pour dÃ©clarer des structures et des
Ã©numÃ©rations publiquement, mais il y a d'autres points Ã  prendre en compte. Si
nous utilisons <code>pub</code> avant la dÃ©finition d'une structure, nous rendons la
structure publique, mais les champs de la structure restent privÃ©s. Nous pouvons
rendre chaque champ public ou non au cas par cas. Dans l'encart 7-9, nous avons
dÃ©fini une structure publique <code>cuisines::PetitDejeuner</code> avec un champ public
<code>tartine_grillee</code> mais avec un champ privÃ© <code>fruit_de_saison</code>. Cela simule un
restaurant oÃ¹ le client peut choisir le type de pain qui accompagne le repas,
mais le chef dÃ©cide des fruits qui accompagnent le repas en fonction de la
saison et ce qu'il y a en stock. Les fruits disponibles changent rapidement,
donc les clients ne peuvent pas choisir le fruit ou mÃªme voir quel fruit ils
obtiendront.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod cuisines {
    pub struct PetitDejeuner {
        pub tartine_grillee: String,
        fruit_de_saison: String,
    }

    impl PetitDejeuner {
        pub fn en_ete(tartine_grillee: &amp;str) -&gt; PetitDejeuner {
            PetitDejeuner {
                tartine_grillee: String::from(tartine_grillee),
                fruit_de_saison: String::from(&quot;pÃªches&quot;),
            }
        }
    }
}

pub fn manger_au_restaurant() {
    // On commande un petit-dÃ©jeuner en Ã©tÃ© avec tartine grillÃ©e au seigle
    let mut repas = cuisines::PetitDejeuner::en_ete(&quot;seigle&quot;);
    // On change d'avis sur le pain que nous souhaitons
    repas.tartine_grillee = String::from(&quot;blÃ©&quot;);
    println!( &quot;Je voudrait une tartine grillÃ©e au {}, s'il vous plaÃ®t.&quot;,
              repas.tartine_grillee);

    // La prochaine ligne ne va pas se compiler si nous ne la commentons pas;
    // car nous ne sommes pas autorisÃ© Ã  voir ou modifier le fruit de saison
    // qui accompagne le repas.

    // repas.fruit_de_saison = String::from(&quot;myrtilles&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-9: A struct with some public fields and some
private fields</span>
-->
<p><span class="caption">Encart 7-9Â : une structure avec certains champs publics et
d'autres privÃ©s</span></p>
<!--
Because the `toast` field in the `back_of_house::Breakfast` struct is public,
in `eat_at_restaurant` we can write and read to the `toast` field using dot
notation. Notice that we canâ€™t use the `seasonal_fruit` field in
`eat_at_restaurant` because `seasonal_fruit` is private. Try uncommenting the
line modifying the `seasonal_fruit` field value to see what error you get!
-->
<p>Comme le champ <code>tartine_grillee</code> est public dans la structure
<code>cuisines::PetitDejeuner</code>, nous pouvons lire et Ã©crire dans le champ
<code>tartine_grillee</code> Ã  partir de <code>manger_au_restaurant</code> en utilisant <code>.</code>. Notez
aussi que nous ne pouvons pas utiliser le champ <code>fruit_de_saison</code> dans
<code>manger_au_restaurant</code> car <code>fruit_de_saison</code> est privÃ©. Essayez de dÃ©-commenter
la ligne qui tente de modifier la valeur du champ <code>fruit_de_saison</code> et voyez
l'erreur que vous obtenezÂ !</p>
<!--
Also, note that because `back_of_house::Breakfast` has a private field, the
struct needs to provide a public associated function that constructs an
instance of `Breakfast` (weâ€™ve named it `summer` here). If `Breakfast` didnâ€™t
have such a function, we couldnâ€™t create an instance of `Breakfast` in
`eat_at_restaurant` because we couldnâ€™t set the value of the private
`seasonal_fruit` field in `eat_at_restaurant`.
-->
<p>Aussi, remarquez que comme <code>cuisines::PetitDejeuner</code> a un champ privÃ©, la
structure a besoin de fournir une fonction publique qui construit une instance
de <code>PetitDejeuner</code> (que nous avons nommÃ© <code>en_ete</code> ici). Si <code>PetitDejeuner</code>
n'avait pas une fonction comme celle-ci, nous ne pourrions pas crÃ©er une
instance de <code>PetitDejeuner</code> dans <code>manger_au_restaurant</code> car nous ne pourrions
pas donner une valeur au champ privÃ© <code>fruit_de_saison</code> dans
<code>manger_au_restaurant</code>.</p>
<!--
In contrast, if we make an enum public, all of its variants are then public. We
only need the `pub` before the `enum` keyword, as shown in Listing 7-10.
-->
<p>Par contre, si nous rendons publique une Ã©numÃ©ration, toutes ses variantes
seront publiques. Nous avons simplement besoin d'un <code>pub</code> devant le mot-clÃ©
<code>enum</code>, comme dans l'encart 7-10.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod cuisines {
    pub enum AmuseBouche {
        Soupe,
        Salade,
    }
}

pub fn manger_au_restaurant() {
    let commande1 = cuisines::AmuseBouche::Soupe;
    let commande2 = cuisines::AmuseBouche::Salade;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-10: Designating an enum as public makes all its
variants public</span>
-->
<p><span class="caption">Encart 7-10Â : on rend publique une Ã©numÃ©ration et cela
rend aussi toutes ses variantes publiques</span></p>
<!--
Because we made the `Appetizer` enum public, we can use the `Soup` and `Salad`
variants in `eat_at_restaurant`. Enums arenâ€™t very useful unless their variants
are public; it would be annoying to have to annotate all enum variants with
`pub` in every case, so the default for enum variants is to be public. Structs
are often useful without their fields being public, so struct fields follow the
general rule of everything being private by default unless annotated with `pub`.
-->
<p>Comme nous rendons l'Ã©numÃ©ration <code>AmuseBouche</code> publique, nous pouvons utiliser
les variantes <code>Soupe</code> et <code>Salade</code> dans <code>manger_au_restaurant</code>. Les Ã©numÃ©rations
ne sont pas trÃ¨s utiles si elles n'ont pas leurs variantes publiquesÂ ; et cela
serait pÃ©nible d'avoir Ã  marquer toutes les variantes de l'Ã©numÃ©ration avec
<code>pub</code>, donc par dÃ©faut les variantes d'Ã©numÃ©rations sont publiques. Les
structures peuvent Ãªtre utiles sans avoir de champs publics, donc les champs des
structures sont tous privÃ©s par dÃ©faut, sauf si ces Ã©lÃ©ments sont marquÃ©s d'un
<code>pub</code>.</p>
<!--
Thereâ€™s one more situation involving `pub` that we havenâ€™t covered, and that is
our last module system feature: the `use` keyword. Weâ€™ll cover `use` by itself
first, and then weâ€™ll show how to combine `pub` and `use`.
-->
<p>Il y a encore une chose que nous n'avons pas abordÃ© concernant <code>pub</code>, et c'est
la derniÃ¨re fonctionnalitÃ© du systÃ¨me de modulesÂ : le mot-clÃ© <code>use</code>. Nous
commencerons par parler de l'utilisation de <code>use</code> de maniÃ¨re gÃ©nÃ©rale, puis nous
verrons comment combiner <code>pub</code> et <code>use</code>.</p>
<!--
[pub]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
-->
<!--
## Bringing Paths into Scope with the `use` Keyword
-->
<h2><a class="header" href="#importer-des-chemins-dans-la-portÃ©e-via-le-mot-clÃ©-use" id="importer-des-chemins-dans-la-portÃ©e-via-le-mot-clÃ©-use">Importer des chemins dans la portÃ©e via le mot-clÃ© <code>use</code></a></h2>
<!--
It might seem like the paths weâ€™ve written to call functions so far are
inconveniently long and repetitive. For example, in Listing 7-7, whether we
chose the absolute or relative path to the `add_to_waitlist` function, every
time we wanted to call `add_to_waitlist` we had to specify `front_of_house` and
`hosting` too. Fortunately, thereâ€™s a way to simplify this process. We can
bring a path into a scope once and then call the items in that path as if
theyâ€™re local items with the `use` keyword.
-->
<p>Les chemins que nous avons crÃ©Ã©s peuvent dÃ©sormais paraÃ®tre gÃ©nants car trop
longs et rÃ©pÃ©titifs. Par exemple, dans l'encart 7-7, si nous avions choisi
d'utiliser le chemin absolu ou relatif pour la fonction
<code>ajouter_a_la_liste_attente</code>, nous devrions aussi Ã©crire <code>salle_a_manger</code> et
<code>accueil</code> Ã  chaque fois que nous voullions appeler <code>ajouter_a_la_liste_attente</code>.
Heureusement, il existe une solution pour simplifier ce cheminement.
Nous pouvons importer un chemin dans la portÃ©e et appeler ensuite les Ã©lÃ©ments
de ce chemin comme s'ils Ã©taient des locaux grÃ¢ce au mot-clÃ© <code>use</code>.</p>
<!--
In Listing 7-11, we bring the `crate::front_of_house::hosting` module into the
scope of the `eat_at_restaurant` function so we only have to specify
`hosting::add_to_waitlist` to call the `add_to_waitlist` function in
`eat_at_restaurant`.
-->
<p>Dans l'encart 7-11, nous importons le module <code>crate::salle_a_manger::accueil</code>
dans la portÃ©e de la fonction <code>manger_au_restaurant</code> afin que nous n'ayons plus
qu'Ã  utiliser <code>accueil::ajouter_a_la_liste_attente</code> pour appeler la fonction
<code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-11: Bringing a module into scope with
`use`</span>
-->
<p><span class="caption">Encart 7-11Â : importer un module dans la portÃ©e via <code>use</code>
</span></p>
<!--
Adding `use` and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding `use crate::front_of_house::hosting` in the crate
root, `hosting` is now a valid name in that scope, just as though the `hosting`
module had been defined in the crate root. Paths brought into scope with `use`
also check privacy, like any other paths.
-->
<p>Dans une portÃ©e, utiliser un <code>use</code> et un chemin revient Ã  crÃ©er un lien
symbolique dans le systÃ¨me de fichier. GrÃ¢ce Ã  l'ajout de
<code>use crate::salle_a_manger::accueil</code> dans la crate racine, <code>accueil</code> est
maintenant un nom valide dans cette portÃ©e, comme si le module <code>accueil</code> avait
Ã©tÃ© dÃ©fini dans la crate racine. Les chemins importÃ©s dans la portÃ©e via <code>use</code>
sont soumis au principe de protection, tout comme les autres chemins.</p>
<!--
You can also bring an item into scope with `use` and a relative path. Listing
7-12 shows how to specify a relative path to get the same behavior as in
Listing 7-11.
-->
<p>Vous pouvez aussi importer un Ã©lÃ©ment dans portÃ©e avec <code>use</code> et un chemin
relatif. L'encart 7-12 nous montre comment utiliser un
chemin relatif pour obtenir le mÃªme rÃ©sultat que l'encart 7-11.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-12: Bringing a module into scope with `use` and
a relative path</span>
-->
<p><span class="caption">Encart 7-12Â : importer un module dans la portÃ©e avec <code>use</code>
et un chemin relatif</span></p>
<!--
### Creating Idiomatic `use` Paths
-->
<h3><a class="header" href="#crÃ©er-des-chemins-idÃ©aux-pour-use" id="crÃ©er-des-chemins-idÃ©aux-pour-use">CrÃ©er des chemins idÃ©aux pour <code>use</code></a></h3>
<!--
In Listing 7-11, you might have wondered why we specified `use
crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` in
`eat_at_restaurant` rather than specifying the `use` path all the way out to
the `add_to_waitlist` function to achieve the same result, as in Listing 7-13.
-->
<p>Dans l'encart 7-11, vous vous Ãªtes peut-Ãªtre demandÃ© pourquoi nous avions
utilisÃ© <code>use crate::salle_a_manger::accueil</code> et appelÃ© ensuite
<code>accueil::ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code> plutÃ´t que
d'Ã©crire le chemin du <code>use</code> jusqu'Ã  la fonction <code>ajouter_a_la_liste_attente</code>
pour avoir le mÃªme rÃ©sultat, comme dans l'encart 7-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil::ajouter_a_la_liste_attente;

pub fn manger_au_restaurant() {
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-13: Bringing the `add_to_waitlist` function
into scope with `use`, which is unidiomatic</span>
-->
<p><span class="caption">Encart 7-13Â : importer la fonction
<code>ajouter_a_la_liste_attente</code> dans la portÃ©e avec <code>use</code>, ce qui n'est pas idÃ©al
</span></p>
<!--
Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with `use`. Bringing the
functionâ€™s parent module into scope with `use` so we have to specify the parent
module when calling the function makes it clear that the function isnâ€™t locally
defined while still minimizing repetition of the full path. The code in Listing
7-13 is unclear as to where `add_to_waitlist` is defined.
-->
<p>Bien que l'encart 7-11 et 7-13 accomplissent la mÃªme tÃ¢che, l'encart 7-11 est la
faÃ§on idÃ©ale d'importer une fonction dans la portÃ©e via <code>use</code>. Le fait
d'importer le module parent de la fonction dans notre portÃ©e avec <code>use</code>, de
sorte que nous ayons Ã  prÃ©ciser le module parent quand nous appelons la fonction
prÃ©cise clairement que la fonction n'est pas dÃ©finie localement, tout en
minimisant la rÃ©pÃ©tition du chemin complet. Nous ne pouvons pas en dÃ©duire
facilement oÃ¹ est dÃ©fini <code>ajouter_a_la_liste_attente</code> dans l'encart 7-13.</p>
<!--
On the other hand, when bringing in structs, enums, and other items with `use`,
itâ€™s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard libraryâ€™s `HashMap` struct into the scope of a binary
crate.
-->
<p>Cela dit, lorsque nous importons des structures, des Ã©numÃ©rations, et d'autres
Ã©lÃ©ments avec <code>use</code>, il est idÃ©al de prÃ©ciser le chemin complet. L'encart 7-14
montre la maniÃ¨re idÃ©ale d'importer la structure <code>HashMap</code> de la bibliothÃ¨que
standard dans la portÃ©e d'une crate binaire.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<!--
<span class="caption">Listing 7-14: Bringing `HashMap` into scope in an
idiomatic way</span>
-->
<p><span class="caption">Encart 7-14Â : import de <code>HashMap</code> dans la portÃ©e de
maniÃ¨re idÃ©ale</span></p>
<!--
Thereâ€™s no strong reason behind this idiom: itâ€™s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.
-->
<p>Il n'y a pas de forte justification Ã  cette pratiqueÂ : c'est simplement une
convention qui a germÃ©, et les gens se sont habituÃ©s Ã  lire et Ã©crire du code
Rust de cette faÃ§on.</p>
<!--
The exception to this idiom is if weâ€™re bringing two items with the same name
into scope with `use` statements, because Rust doesnâ€™t allow that. Listing 7-15
shows how to bring two `Result` types into scope that have the same name but
different parent modules and how to refer to them.
-->
<p>Il y a une exception Ã  cette pratiqueÂ : nous ne pouvons pas utiliser
l'instruction <code>use</code> pour importer deux Ã©lÃ©ments avec le mÃªme nom dans la portÃ©e,
car Rust ne l'autorise pas. L'encart 7-15 nous montre comment importer puis
utiliser deux types <code>Result</code> ayant le mÃªme nom mais dont leurs modules parents
sont distincts.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
#     Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn fonction1() -&gt; fmt::Result {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; io::Result&lt;()&gt; {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span>
-->
<p><span class="caption">Encart 7-15Â : l'import de deux types ayant le mÃªme nom
dans la mÃªme portÃ©e nÃ©cessite d'utiliser leurs modules parents.</span></p>
<!--
As you can see, using the parent modules distinguishes the two `Result` types.
If instead we specified `use std::fmt::Result` and `use std::io::Result`, weâ€™d
have two `Result` types in the same scope and Rust wouldnâ€™t know which one we
meant when we used `Result`.
-->
<p>Comme vous pouvez le constater, l'utilisation des modules parents permet de
distinguer les deux types <code>Result</code>. Si nous avions utilisÃ©
<code>use std::fmt::Result</code> et <code>use std::io::Result</code>, nous aurions deux types de
<code>Result</code> dans la mÃªme portÃ©e et donc Rust ne pourrait pas comprendre lequel nous
utiliserions en demandant <code>Result</code>.</p>
<!--
### Providing New Names with the `as` Keyword
-->
<h3><a class="header" href="#renommer-des-Ã©lÃ©ments-avec-le-mot-clÃ©-as" id="renommer-des-Ã©lÃ©ments-avec-le-mot-clÃ©-as">Renommer des Ã©lÃ©ments avec le mot-clÃ© <code>as</code></a></h3>
<!--
Thereâ€™s another solution to the problem of bringing two types of the same name
into the same scope with `use`: after the path, we can specify `as` and a new
local name, or alias, for the type. Listing 7-16 shows another way to write the
code in Listing 7-15 by renaming one of the two `Result` types using `as`.
-->
<p>Il y a une autre solution au fait d'avoir deux types du mÃªme nom dans la mÃªme
portÃ©e Ã  cause de <code>use</code>Â : aprÃ¨s le chemin, nous pouvons rajouter <code>as</code> suivi d'un
nouveau nom local, ou alias, sur le type. L'encart 7-16 nous montre une autre
faÃ§on d'Ã©crire le code de l'encart 7-15 en utilisant <code>as</code> pour renommant un des
deux types <code>Result</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
#     Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn fonction1() -&gt; Result {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; IoResult&lt;()&gt; {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-16: Renaming a type when itâ€™s brought into
scope with the `as` keyword</span>
-->
<p><span class="caption">Encart 7-16Â : renommer un type lorsqu'il est importÃ© dans
la portÃ©e, avec le mot-clÃ© <code>as</code></span></p>
<!--
In the second `use` statement, we chose the new name `IoResult` for the
`std::io::Result` type, which wonâ€™t conflict with the `Result` from `std::fmt`
that weâ€™ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!
-->
<p>Dans la seconde instruction <code>use</code>, nous avons choisi <code>IoResult</code> comme nouveau
nom du type <code>std::io::Result</code>, qui n'est plus en conflit avec le <code>Result</code> de
<code>std::fmt</code> que nous avons aussi importÃ© dans la portÃ©e. Les encarts 7-15 et 7-16
sont idÃ©aux, donc le choix vous revientÂ ! </p>
<!--
### Re-exporting Names with `pub use`
-->
<h3><a class="header" href="#re-exporter-des-Ã©lÃ©ments-avec-pub-use" id="re-exporter-des-Ã©lÃ©ments-avec-pub-use">Re-exporter des Ã©lÃ©ments avec <code>pub use</code></a></h3>
<!--
When we bring a name into scope with the `use` keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that codeâ€™s scope, we can combine `pub`
and `use`. This technique is called *re-exporting* because weâ€™re bringing
an item into scope but also making that item available for others to bring into
their scope.
-->
<p>Lorsque nous importons un Ã©lÃ©ment dans la portÃ©e avec le mot-clÃ© <code>use</code>, son nom
dans la nouvelle portÃ©e est privÃ©. Pour permettre au code appelant d'utiliser ce
nom comme s'il Ã©tait dÃ©fini dans cette portÃ©e, nous pouvons associer <code>pub</code> et
<code>use</code>. Cette technique est appelÃ©e <em>re-exporter</em> car nous importons un
Ã©lÃ©ment dans la portÃ©e, mais nous rendons aussi cet Ã©lÃ©ment disponible aux
portÃ©es des autres.</p>
<!--
Listing 7-17 shows the code in Listing 7-11 with `use` in the root module
changed to `pub use`.
-->
<p>L'encart 7-17 nous montre le code de l'encart 7-11 oÃ¹ le <code>use</code> du module racine
a Ã©tÃ© remplacÃ© par <code>pub use</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with `pub use`</span>
-->
<p><span class="caption">Encart 7-17Â : rendre un Ã©lÃ©ment disponible pour n'importe
quel code qui l'importera dans sa portÃ©e, avec <code>pub use</code></span></p>
<!--
By using `pub use`, external code can now call the `add_to_waitlist` function
using `hosting::add_to_waitlist`. If we hadnâ€™t specified `pub use`, the
`eat_at_restaurant` function could call `hosting::add_to_waitlist` in its
scope, but external code couldnâ€™t take advantage of this new path.
-->
<p>GrÃ¢ce Ã  <code>pub use</code>, le code externe peut maintenant appeler la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant <code>accueil::ajouter_a_la_liste_attente</code>.
Si nous n'avions pas utilisÃ© <code>pub use</code>, la fonction <code>manger_au_restaurant</code>
aurait pu appeler <code>accueil::ajouter_a_la_liste_attente</code> dans sa portÃ©e, mais le
code externe n'aurait pas pu profiter de ce nouveau chemin.</p>
<!--
Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about â€œfront of houseâ€ and â€œback of house.â€ But customers visiting a restaurant
probably wonâ€™t think about the parts of the restaurant in those terms. With
`pub use`, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.
-->
<p>Re-exporter est utile quand la structure interne de votre code est diffÃ©rente de
comment les dÃ©veloppeurs qui utilisent votre code imaginent le domaine. Par
exemple, dans cette mÃ©taphore du restaurant, les personnes qui font fonctionner
le restaurant se structurent en fonction de la â€œsalle Ã  mangerâ€ et des
â€œcuisinesâ€. Mais les clients qui utilisent le restaurant ne vont probablement
voir les choses ainsi. Avec <code>pub use</code>, nous pouvons Ã©crire notre code selon une
certaine organisation, mais l'exposer avec une organisation diffÃ©rente. En
faisant ainsi, la bibliothÃ¨que est bien organisÃ©e autant pour les dÃ©veloppeurs
qui travaillent dans la bibliothÃ¨que que les dÃ©veloppeurs qui utilisent la
bibliothÃ¨que.</p>
<!--
### Using External Packages
-->
<h3><a class="header" href="#utiliser-des-paquets-externes" id="utiliser-des-paquets-externes">Utiliser des paquets externes</a></h3>
<!--
In Chapter 2, we programmed a guessing game project that used an external
package called `rand` to get random numbers. To use `rand` in our project, we
added this line to *Cargo.toml*:
-->
<p>Dans le chapitre 2, nous avions dÃ©veloppÃ© un projet de jeu de devinettes qui
utilisait le paquet externe <code>rand</code> afin d'obtenir des nombres alÃ©atoires.
Pour pouvoir utiliser <code>rand</code> dans notre projet, nous avons ajoutÃ© cette ligne
dans <em>Cargo.toml</em>Â :</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[dependencies]
rand = "0.5.5"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<!--
Adding `rand` as a dependency in *Cargo.toml* tells Cargo to download the
`rand` package and any dependencies from [crates.io](https://crates.io/) and
make `rand` available to our project.
-->
<p>L'ajout de <code>rand</code> comme dÃ©pendance dans <em>Cargo.toml</em> demande Ã  Cargo de
tÃ©lÃ©charger le paquet <code>rand</code> et toutes ses dÃ©pendances Ã  partir de
<a href="https://crates.io/">crates.io</a> et rend disponible <code>rand</code> pour notre projet.</p>
<!--
Then, to bring `rand` definitions into the scope of our package, we added a
`use` line starting with the name of the crate, `rand`, and listed the items
we wanted to bring into scope. Recall that in the [â€œGenerating a Random
Numberâ€][rand]<!-- ignore -- > section in Chapter 2, we brought the `Rng` trait
into scope and called the `rand::thread_rng` function:
-->
<p>Ensuite, pour importer les dÃ©finitions de <code>rand</code> dans la portÃ©e de notre paquet,
nous avons ajoutÃ© une ligne <code>use</code> qui commence avec le nom de la crate, <code>rand</code>,
et nous avons listÃ© les Ã©lÃ©ments que nous voulions importer dans notre portÃ©e.
Dans la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">â€œGÃ©nÃ©rer le nombre secretâ€</a><!-- ignore --> du chapitre 2,
nous avons importÃ© le trait <code>Rng</code> dans la portÃ©e, puis nous avons appelÃ© la
fonction <code>rand::thread_rng</code>Â :</p>
<!--
```rust,ignore
# use std::io;
use rand::Rng;

fn main() {
#     println!("Guess the number!");
# 
    let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span>    let nombre_secret = rand::thread_rng().gen_range(1, 101);
<span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span>}
</code></pre>
<!--
Members of the Rust community have made many packages available at
[crates.io](https://crates.io/), and pulling any of them into your package
involves these same steps: listing them in your packageâ€™s *Cargo.toml* file and
using `use` to bring items from their crates into scope.
-->
<p>Les membres de la communautÃ© Rust ont mis Ã  disposition de nombreux paquets
dans <a href="https://crates.io/">crates.io</a>, et utiliser l'un d'entre eux dans votre
paquet implique toujours ces mÃªmes Ã©tapesÂ : les lister dans le fichier
<em>Cargo.toml</em> de votre paquet et utiliser <code>use</code> pour importer certains Ã©lÃ©ments
de ces crates dans la portÃ©e.</p>
<!--
Note that the standard library (`std`) is also a crate thatâ€™s external to our
package. Because the standard library is shipped with the Rust language, we
donâ€™t need to change *Cargo.toml* to include `std`. But we do need to refer to
it with `use` to bring items from there into our packageâ€™s scope. For example,
with `HashMap` we would use this line:
-->
<p>Notez que la bibliothÃ¨que standard (<code>std</code>) est aussi une crate qui est externe Ã 
notre paquet. Comme la bibliothÃ¨que standard est livrÃ©e avec le langage Rust,
nous n'avons pas Ã  modifier le <em>Cargo.toml</em> pour y inclure <code>std</code>. Mais nous
devons utiliser <code>use</code> pour importer les Ã©lÃ©ments qu'y se trouvent dans la portÃ©e
de notre paquet. Par exemple, pour <code>HashMap</code> nous pourrions utiliser cette
ligneÂ :</p>
<!--
```rust
use std::collections::HashMap;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<!--
This is an absolute path starting with `std`, the name of the standard library
crate.
-->
<p>C'est un chemin absolu qui commence par <code>std</code>, le nom de la crate de la
bibliothÃ¨que standard.</p>
<!--
### Using Nested Paths to Clean Up Large `use` Lists
-->
<h3><a class="header" href="#utiliser-des-chemins-imbriquÃ©s-pour-simplifier-les-grandes-listes-de-use" id="utiliser-des-chemins-imbriquÃ©s-pour-simplifier-les-grandes-listes-de-use">Utiliser des chemins imbriquÃ©s pour simplifier les grandes listes de <code>use</code></a></h3>
<!--
If weâ€™re using multiple items defined in the same crate or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two `use` statements we had in the Guessing Game in
Listing 2-4 bring items from `std` into scope:
-->
<p>Si vous utilisez de nombreux Ã©lÃ©ments dÃ©finis dans une mÃªme crate ou dans un
mÃªme module, lister chaque Ã©lÃ©ment sur sa propre ligne prendra beaucoup d'espace
vertical dans vos fichiers. Par exemple, ces deux instructions <code>use</code>, que nous
avions dans le jeu de devinettes, dans l'encart 2-4, importaient des Ã©lÃ©ments de
<code>std</code> dans la portÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masquÃ©e ici --
use std::cmp::Ordering;
use std::io;
// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.
-->
<p>A la place, nous pouvons utiliser des chemins imbriquÃ©s afin d'importer les
mÃªmes Ã©lÃ©ments dans la portÃ©e en une seule ligne. Nous pouvons faire cela en
indiquant la partie commune du chemin, suivi de deux double-points, puis
d'accolades autour d'une liste d'Ã©lÃ©ments du chemin, comme dans l'encart 7-18Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masquÃ©e ici --
use std::{cmp::Ordering, io};
// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez saisir un nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span>
-->
<p><span class="caption">Encart 7-18Â : utiliser un chemin imbriquÃ© pour importer
plusieurs Ã©lÃ©ments avec le mÃªme prÃ©fixe dans la portÃ©e</span></p>
<!--
In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate `use` statements
needed by a lot!
-->
<p>Pour des programmes plus gros, importer plusieurs Ã©lÃ©ments dans la portÃ©e pour
la mÃªme crate ou module en utilisant des chemins imbriquÃ©s peut rÃ©duire
considÃ©rablement le nombre de <code>use</code> utilisÃ©sÂ !</p>
<!--
We can use a nested path at any level in a path, which is useful when combining
two `use` statements that share a subpath. For example, Listing 7-19 shows two
`use` statements: one that brings `std::io` into scope and one that brings
`std::io::Write` into scope.
-->
<p>Nous pouvons utiliser un chemin imbriquÃ© Ã  tous les niveaux d'un chemin, ce qui
peut Ãªtre utile lorsqu'on utilise deux instructions <code>use</code> qui partagent un
sous-chemin. Par exemple, l'encart 7-19 nous montre deux instructions <code>use</code>Â :
un qui importe <code>std::io</code> dans la portÃ©e et un autre qui importe <code>std::io::Write</code>
dans la portÃ©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::io;
use std::io::Write;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-19: Two `use` statements where one is a subpath
of the other</span>
-->
<p><span class="caption">Encart 7-19Â : deux instructions <code>use</code> oÃ¹ l'une est un
sous-chemin de l'autre</span></p>
<!--
The common part of these two paths is `std::io`, and thatâ€™s the complete first
path. To merge these two paths into one `use` statement, we can use `self` in
the nested path, as shown in Listing 7-20.
-->
<p>La partie commune entre ces deux chemins est <code>std::io</code>, et c'est le premier
chemin complet. Pour imbriquer ces deux chemins en une seule instruction <code>use</code>,
nous pouvons utiliser <code>self</code> dans le chemin imbriquÃ©, comme dans l'encart 7-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::io::{self, Write};
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one `use` statement</span>
-->
<p><span class="caption">Encart 7-20Â : imbrication des chemins de l'encart 7-19
dans une seule instruction <code>use</code></span></p>
<!--
This line brings `std::io` and `std::io::Write` into scope.
-->
<p>Cette ligne importe <code>std::io</code> et <code>std::io::Write</code> dans la portÃ©e.</p>
<!--
### The Glob Operator
-->
<h3><a class="header" href="#lopÃ©rateur-global" id="lopÃ©rateur-global">L'opÃ©rateur global</a></h3>
<!--
If we want to bring *all* public items defined in a path into scope, we can
specify that path followed by `*`, the glob operator:
-->
<p>Si nous voulons importer, dans la portÃ©e, <em>tous</em> les Ã©lÃ©ments publics dÃ©finis
dans un chemin, nous pouvons indiquer ce chemin suivi par <code>*</code>, l'opÃ©rateur
globalÂ :</p>
<!--
```rust
use std::collections::*;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This `use` statement brings all public items defined in `std::collections` into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.
-->
<p>Cette instruction <code>use</code> va importer tous les Ã©lÃ©ments publics dÃ©finis dans
<code>std::collections</code> dans la portÃ©e courante. Mais soyez prudent quand vous
utilisez l'opÃ©rateur globalÂ ! L'opÃ©rateur global rend difficile Ã  dire quels
Ã©lÃ©ments sont dans la portÃ©e et oÃ¹ un Ã©lÃ©ment est utilisÃ© dans notre programme.</p>
<!--
The glob operator is often used when testing to bring everything under test
into the `tests` module; weâ€™ll talk about that in the [â€œHow to Write
Testsâ€][writing-tests]<!-- ignore -- > section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see [the standard
library documentation](../std/prelude/index.html#other-preludes)<!-- ignore -- >
for more information on that pattern.
-->
<p>L'opÃ©rateur global est souvent utilisÃ© lorsque nous Ã©crivons des tests, pour
importer tout ce qui a Ã  tester dans le module <code>tests</code>Â ; nous verrons cela dans
une section du <a href="ch11-01-writing-tests.html">chapitre 11</a>. L'opÃ©rateur global est parfois
aussi utilisÃ© pour l'Ã©tape prÃ©liminaireÂ : rendez-vous dans <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">la documentation de
la bibliothÃ¨que
standard</a><!--
ignore --> pour plus d'informations sur cela.</p>
<!--
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
[writing-tests]: ch11-01-writing-tests.html#how-to-write-tests
-->
<!--
## Separating Modules into Different Files
-->
<h2><a class="header" href="#sÃ©parer-les-modules-dans-diffÃ©rents-fichiers" id="sÃ©parer-les-modules-dans-diffÃ©rents-fichiers">SÃ©parer les modules dans diffÃ©rents fichiers</a></h2>
<!--
So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.
-->
<p>Jusqu'Ã  prÃ©sent, tous les exemples de ce chapitre ont dÃ©fini plusieurs modules
dans un seul fichier. Quand les modules vont grossir, il est probable que vous
vouliez dÃ©placer leurs dÃ©finitions dans un fichier sÃ©parÃ© pour faciliter le
parcours de votre code.</p>
<!--
For example, letâ€™s start from the code in Listing 7-17 and move the
`front_of_house` module to its own file *src/front_of_house.rs* by changing the
crate root file so it contains the code shown in Listing 7-21. In this case,
the crate root file is *src/lib.rs*, but this procedure also works with binary
crates whose crate root file is *src/main.rs*.
-->
<p>Prenons par exemple le code de l'encart 7-17 et dÃ©plaÃ§ons le module
<code>salle_a_manger</code> dans son propre fichier <em>src/salle_a_manger.rs</em> en changeant le
fichier Ã  la racine de la crate afin qu'il corresponde au code de l'encart 7-21.
Dans notre cas, le fichier Ã  la racine de la crate est <em>src/lib.rs</em>, mais cette
procÃ©dure fonctionne aussi avec les crates binaires dans lesquels le fichier Ã 
la racine de la crate est <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore">mod salle_a_manger;

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-21: Declaring the `front_of_house` module whose
body will be in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Encart 7-21Â : DÃ©claration du module <code>salle_a_manger</code> dont
le corps sera dans <em>src/salle_a_manger.rs</em></span></p>
<!--
And *src/front_of_house.rs* gets the definitions from the body of the
`front_of_house` module, as shown in Listing 7-22.
-->
<p>Et <em>src/salle_a_manger.rs</em> contiendra la dÃ©finition du corps du module
<code>salle_a_manger</code>, comme dans l'encart 7-22.</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">FichierÂ : src/salle_a_manger.rs</span></p>
<!--
```rust,ignore
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```
-->
<pre><code class="language-rust ignore">pub mod accueil {
    pub fn ajouter_a_la_liste_attente() {}
}
</code></pre>
<!--
<span class="caption">Listing 7-22: Definitions inside the `front_of_house`
module in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Encart 7-22Â : Les dÃ©finitions Ã  l'intÃ©rieur du module
<code>salle_a_manger</code> dans <em>src/salle_a_manger.rs</em></span></p>
<!--
Using a semicolon after `mod front_of_house` rather than using a block tells
Rust to load the contents of the module from another file with the same name as
the module. To continue with our example and extract the `hosting` module to
its own file as well, we change *src/front_of_house.rs* to contain only the
declaration of the `hosting` module:
-->
<p>Utiliser un point-virgule aprÃ¨s <code>mod salle_a_manger</code> plutÃ´t que de crÃ©er un bloc
indique Ã  Rust de charger le contenu du module Ã  partir d'un autre fichier avec
le mÃªme nom que le module. Pour continuer avec notre exemple et dÃ©placer
Ã©galement le module <code>accueil</code> dans son propre fichier, nous modifions
<em>src/salle_a_manger.rs</em> pour avoir uniquement la dÃ©claration du module
<code>accueil</code>Â :</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">FichierÂ : src/salle_a_manger.rs</span></p>
<!--
```rust,ignore
pub mod hosting;
```
-->
<pre><code class="language-rust ignore">pub mod accueil;
</code></pre>
<!--
Then we create a *src/front_of_house* directory and a file
*src/front_of_house/hosting.rs* to contain the definitions made in the
`hosting` module:
-->
<p>Ensuite, nous crÃ©ons un dossier <em>src/salle_a_manger</em> et un fichier
<em>src/salle_a_manger/accueil.rs</em> qui contiendra les dÃ©finitions du module
<code>accueil</code>Â :</p>
<!--
<span class="filename">Filename: src/front_of_house/hosting.rs</span>
-->
<p><span class="filename">FichierÂ : src/salle_a_manger/accueil.rs</span></p>
<!--
```rust
pub fn add_to_waitlist() {}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_a_la_liste_attente() {}
<span class="boring">}
</span></code></pre></pre>
<!--
The module tree remains the same, and the function calls in `eat_at_restaurant`
will work without any modification, even though the definitions live in
different files. This technique lets you move modules to new files as they grow
in size.
-->
<p>L'arborescence des modules reste identique, et les appels aux fonctions de
<code>manger_au_restaurant</code> vont continuer Ã  fonctionner sans aucune modification,
mÃªme si les dÃ©finitions se retrouvent dans des fichiers diffÃ©rents. Cette
technique vous permet de dÃ©placer des modules dans de nouveaux fichiers au fur
et Ã  mesure qu'ils s'agrandissent.</p>
<!--
Note that the `pub use crate::front_of_house::hosting` statement in
*src/lib.rs* also hasnâ€™t changed, nor does `use` have any impact on what files
are compiled as part of the crate. The `mod` keyword declares modules, and Rust
looks in a file with the same name as the module for the code that goes into
that module.
-->
<p>Remarquez que l'instruction <code>pub use crate::salle_a_manger::accueil</code> dans
<em>src/lib.rs</em> n'a pas changÃ©e, et que <code>use</code> n'a aucun impact sur quels fichiers
sont compilÃ©s pour constituer la crate. Le mot-clÃ© <code>mod</code> dÃ©clare un module, et
Rust recherche un fichier de code qui porte le nom du dit module.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-6" id="rÃ©sumÃ©-6">RÃ©sumÃ©</a></h2>
<!--
Rust lets you split a package into multiple crates and a crate into modules
so you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a `use` statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is private by default, but you can make
definitions public by adding the `pub` keyword.
-->
<p>Rust vous permet de dÃ©couper un paquet en plusieurs crates et un crate en
modules afin que vous puissiez rÃ©utiliser vos Ã©lÃ©ments d'un module Ã  un autre.
Vous pouvez faire cela en utilisant des chemins absolus ou relatifs. Ces chemins
peuvent Ãªtre importÃ©s dans la portÃ©e avec l'instruction <code>use</code> pour pouvoir
utiliser l'Ã©lÃ©mÃ©nt plusieurs fois dans la portÃ©e avec un chemin plus court. Le
code du module est privÃ© par dÃ©faut, mais vous pouvez rendre public des
dÃ©finitions en ajoutant le mot-clÃ© <code>pub</code>.</p>
<!--
In the next chapter, weâ€™ll look at some collection data structures in the
standard library that you can use in your neatly organized code.
-->
<p>Au prochain chapitre, nous allons nous intÃ©resser Ã  quelques collections de
structures de donnÃ©es de la bibliothÃ¨que standard que vous pourrez utiliser dans
votre code soigneusement organisÃ©.</p>
<!--
# Common Collections
-->
<h1><a class="header" href="#les-collections-standard" id="les-collections-standard">Les collections standard</a></h1>
<!--
Rustâ€™s standard library includes a number of very useful data structures called
*collections*. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data these collections point to is stored on the heap, which means
the amount of data does not need to be known at compile time and can grow or
shrink as the program runs. Each kind of collection has different capabilities
and costs, and choosing an appropriate one for your current situation is a
skill youâ€™ll develop over time. In this chapter, weâ€™ll discuss three
collections that are used very often in Rust programs:
-->
<p>La bibliothÃ¨que standard de Rust apporte quelques structures de donnÃ©es trÃ¨s
utiles appelÃ©es <em>collections</em>. La plupart des autres types de donnÃ©es
reprÃ©sentent une seule valeur prÃ©cise, mais les collections peuvent avoir
plusieurs valeurs. Contrairement aux tableaux et aux tuples,
les donnÃ©es que ces collections contiennent sont stockÃ©es sur le tas, ce qui
veut dire que la quantitÃ© de donnÃ©es n'a pas Ã  Ãªtre connue au moment de la
compilation et peut augmenter ou diminuer pendant l'exÃ©cution du programme.
Chaque type de collection a ses avantages et ses inconvÃ©nients, et en choisir un
qui rÃ©pond Ã  votre besoin sur le moment est une aptitude que vous allez
dÃ©velopper avec le temps. Dans ce chapitre, nous allons dÃ©couvrir trois
collections qui sont trÃ¨s utilisÃ©es dans les programmes RustÂ :</p>
<!--
* A *vector* allows you to store a variable number of values next to each other.
* A *string* is a collection of characters. Weâ€™ve mentioned the `String` type
  previously, but in this chapter weâ€™ll talk about it in depth.
* A *hash map* allows you to associate a value with a particular key. Itâ€™s a
  particular implementation of the more general data structure called a *map*.
-->
<ul>
<li>Le <em>vecteur</em> qui vous permet de stocker un nombre variable de valeurs l'une Ã 
cÃ´tÃ© de l'autre.</li>
<li>La <em>String</em>, qui est une collection de caractÃ¨res. Nous avons dÃ©jÃ  vu le type
<code>String</code> prÃ©cÃ©demment, mais dans ce chapitre nous allons le dÃ©couvrir en
dÃ©tail.</li>
<li>La <em>table de hachage</em> qui vous permet d'associer une valeur Ã  une clÃ© prÃ©cise.
C'est une implÃ©mentation spÃ©cifique d'une structure de donnÃ©es plus gÃ©nÃ©rique :
le <em>tableau associatif</em>.</li>
</ul>
<!--
To learn about the other kinds of collections provided by the standard library,
see [the documentation][collections].
-->
<p>Pour en savoir plus sur les autres types de collections fournies par la
bibliothÃ¨que standard, allez voir <a href="https://doc.rust-lang.org/std/collections/index.html">la documentation</a>.</p>
<!--
[collections]: ../std/collections/index.html
-->
<!--
Weâ€™ll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.
-->
<p>Nous allons voir comment crÃ©er et modifier les vecteurs, les String, et les
tables de hachage, et Ã©tudier leurs diffÃ©rences.</p>
<!--
## Storing Lists of Values with Vectors
-->
<h2><a class="header" href="#stocker-des-listes-de-valeurs-avec-des-vecteurs" id="stocker-des-listes-de-valeurs-avec-des-vecteurs">Stocker des listes de valeurs avec des vecteurs</a></h2>
<!--
The first collection type weâ€™ll look at is `Vec<T>`, also known as a *vector*.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.
-->
<p>Le premier type de collection que nous allons voir est <code>Vec&lt;T&gt;</code>, aussi appelÃ©
<em>vecteur</em>. Les vecteurs vous permettent de stocker plus qu'une seule valeur dans
une seule structure de donnÃ©es qui stocke les valeurs proches l'une de l'autre
dans la mÃ©moire. Les vecteurs peuvent stocker uniquement des valeurs du mÃªme
type. Ils sont utiles lorsque vous avez une liste d'Ã©lÃ©ments, tels que les
lignes de texte provenant d'un fichier ou les prix des articles d'un panier
d'achat.</p>
<!--
### Creating a New Vector
-->
<h3><a class="header" href="#crÃ©er-un-nouveau-vecteur" id="crÃ©er-un-nouveau-vecteur">CrÃ©er un nouveau vecteur</a></h3>
<!--
To create a new, empty vector, we can call the `Vec::new` function, as shown in
Listing 8-1.
-->
<p>Pour crÃ©er un nouveau vecteur vide, nous pouvons appeler la fonction
<code>Vec::new</code>, comme dans l'encart 8-1.</p>
<!--
```rust
# fn main() {
    let v: Vec<i32> = Vec::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-1: Creating a new, empty vector to hold values
of type `i32`</span>
-->
<p><span class="caption">Encart 8-1Â : crÃ©ation d'un nouveau vecteur vide pour y
stocker des valeurs de type <code>i32</code></span></p>
<!--
Note that we added a type annotation here. Because we arenâ€™t inserting any
values into this vector, Rust doesnâ€™t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
weâ€™ll cover how to use generics with your own types in Chapter 10. For now,
know that the `Vec<T>` type provided by the standard library can hold any type,
and when a specific vector holds a specific type, the type is specified within
angle brackets. In Listing 8-1, weâ€™ve told Rust that the `Vec<T>` in `v` will
hold elements of the `i32` type.
-->
<p>Remarquez que nous avons ajoutÃ© ici une annotation de type. Comme nous
n'ajoutons pas de valeurs dans ce vecteur, Rust ne sait pas quel type d'Ã©lÃ©ments
nous souhaitons stocker. C'est une information importante. Les vecteurs sont
implÃ©mentÃ©s avec la gÃ©nÃ©ricitÃ©, nous allons voir comment utiliser la gÃ©nÃ©ricitÃ©
sur vos propres types au chapitre 10. Pour l'instant, sachez que le type
<code>Vec&lt;T&gt;</code> qui est fourni par la bibliothÃ¨que standard peut stocker n'importe quel
type, et lorsqu'un vecteur prÃ©cis stocke un type prÃ©cis, ce type est renseignÃ©
entre des chevrons. Dans l'encart 8-1, nous prÃ©cisons Ã  Rust que le <code>Vec&lt;T&gt;</code>
dans <code>v</code> va stocker des Ã©lÃ©ments de type <code>i32</code>.</p>
<!--
In more realistic code, Rust can often infer the type of value you want to
store once you insert values, so you rarely need to do this type annotation.
Itâ€™s more common to create a `Vec<T>` that has initial values, and Rust
provides the `vec!` macro for convenience. The macro will create a new vector
that holds the values you give it. Listing 8-2 creates a new `Vec<i32>` that
holds the values `1`, `2`, and `3`. The integer type is `i32` because thatâ€™s
the default integer type, as we discussed in the [â€œData Typesâ€][data-types]<!--
ignore -- > section of Chapter 3.
-->
<p>Dans du code plus rÃ©aliste, Rust peut parfois deviner le type de la valeur que
vous souhaitez stocker lorsque vous ajouterez des valeurs, donc vous n'aurez pas
souvent besoin de faire cette annotation de type. Il est plus frÃ©quent de crÃ©er
un <code>Vec&lt;T&gt;</code> qui a des valeurs initiales, et Rust fournit la macro <code>vec!</code> par
commoditÃ©. La macro va crÃ©er un nouveau vecteur qui stockera les valeurs que
vous lui donnerez. L'encart 8-2 crÃ©e un nouveau <code>Vec&lt;i32&gt;</code> qui stocke les
valeurs <code>1</code>, <code>2</code> et <code>3</code>. Le type d'entier est <code>i32</code> car c'est le type d'entier
par dÃ©faut, comme nous l'avons Ã©voquÃ© dans la section <a href="ch03-02-data-types.html">â€œLes types de
donnÃ©esâ€</a><!-- ignore --> du chapitre 3.</p>
<!--
```rust
# fn main() {
    let v = vec![1, 2, 3];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-2: Creating a new vector containing
values</span>
-->
<p><span class="caption">Encart 8-2Â : crÃ©ation d'un nouveau vecteur qui contient
des valeurs</span></p>
<!--
Because weâ€™ve given initial `i32` values, Rust can infer that the type of `v`
is `Vec<i32>`, and the type annotation isnâ€™t necessary. Next, weâ€™ll look at how
to modify a vector.
-->
<p>Comme nous avons donnÃ© des valeurs initiales <code>i32</code>, Rust peut en dÃ©duire que le
type de <code>v</code> est <code>Vec&lt;i32&gt;</code>, et l'annotation de type n'est plus nÃ©cessaire.
Maintenant, nous allons voir comment modifier un vecteur.</p>
<!--
### Updating a Vector
-->
<h3><a class="header" href="#modifier-un-vecteur" id="modifier-un-vecteur">Modifier un vecteur</a></h3>
<!--
To create a vector and then add elements to it, we can use the `push` method,
as shown in Listing 8-3.
-->
<p>Pour crÃ©er un vecteur et ensuite lui ajouter des Ã©lÃ©ments, nous pouvons utiliser
la mÃ©thode <code>push</code>, comme dans l'encart 8-3.</p>
<!--
```rust
# fn main() {
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-3: Using the `push` method to add values to a
vector</span>
-->
<p><span class="caption">Encart 8-3Â : utilisation de la mÃ©thode <code>push</code> pour ajouter
des valeurs Ã  un vecteur</span></p>
<!--
As with any variable, if we want to be able to change its value, we need to
make it mutable using the `mut` keyword, as discussed in Chapter 3. The numbers
we place inside are all of type `i32`, and Rust infers this from the data, so
we donâ€™t need the `Vec<i32>` annotation.
-->
<p>Comme avec chaque variable, si nous voulons pouvoir modifier sa valeur, nous
devons la rendre mutable en utilisant le mot-clÃ© <code>mut</code>, comme nous l'avons vu
au chapitre 3. Les nombres que nous ajoutons dedans sont tous du type <code>i32</code>, et
Rust le devine Ã  partir des donnÃ©es, donc nous n'avons pas besoin de
l'annotation <code>Vec&lt;i32&gt;</code>.</p>
<!--
### Dropping a Vector Drops Its Elements
-->
<h3><a class="header" href="#libÃ©rer-un-vecteur-libÃ¨re-aussi-ses-Ã©lÃ©ments" id="libÃ©rer-un-vecteur-libÃ¨re-aussi-ses-Ã©lÃ©ments">LibÃ©rer un vecteur libÃ¨re aussi ses Ã©lÃ©ments</a></h3>
<!--
Like any other `struct`, a vector is freed when it goes out of scope, as
annotated in Listing 8-4.
-->
<p>Comme tous les autres <code>struct</code>, un vecteur est libÃ©rÃ© quand il sort de la
portÃ©e, comme prÃ©cisÃ© dans l'encart 8-4.</p>
<!--
```rust
# fn main() {
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];
    
        // on fait des choses avec v
    
    } // &lt;- v sort de la portÃ©e et est libÃ©rÃ© ici
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-4: Showing where the vector and its elements
are dropped</span>
-->
<p><span class="caption">Encart 8-4Â : mise en Ã©vidence oÃ¹ le vecteur et ses
Ã©lÃ©ments sont libÃ©rÃ©s</span></p>
<!--
When the vector gets dropped, all of its contents are also dropped, meaning
those integers it holds will be cleaned up. This may seem like a
straightforward point but can get a bit more complicated when you start to
introduce references to the elements of the vector. Letâ€™s tackle that next!
-->
<p>Lorsque le vecteur est libÃ©rÃ©, tout son contenu est aussi libÃ©rÃ©, ce qui veut
dire que les nombres entiers qu'il stocke vont Ãªtre effacÃ©s de la mÃ©moire. Cela
semble trÃ¨s simple mais cela peut devenir plus compliquÃ© quand vous commencez Ã 
utiliser des rÃ©fÃ©rences dans les Ã©lÃ©ments du vecteur. Voyons ceci dÃ¨s Ã 
prÃ©sentÂ !</p>
<!--
### Reading Elements of Vectors
-->
<h3><a class="header" href="#lire-les-Ã©lÃ©ments-des-vecteurs" id="lire-les-Ã©lÃ©ments-des-vecteurs">Lire les Ã©lÃ©ments des vecteurs</a></h3>
<!--
Now that you know how to create, update, and destroy vectors, knowing how to
read their contents is a good next step. There are two ways to reference a
value stored in a vector. In the examples, weâ€™ve annotated the types of the
values that are returned from these functions for extra clarity.
-->
<p>Maintenant que vous savez comment crÃ©er, modifier, et dÃ©truire des vecteurs,
la prochaine Ã©tape est de savoir lire leur contenu. Il existe deux faÃ§ons de
dÃ©signer une valeur enregistrÃ©e dans un vecteur. Dans ces exemples, nous avons
prÃ©cisÃ© les types des valeurs qui sont retournÃ©es par ces fonctions pour plus de
clartÃ©.</p>
<!--
Listing 8-5 shows both methods of accessing a value in a vector, either with
indexing syntax or the `get` method.
-->
<p>L'encart 8-5 nous montre les deux faÃ§ons pour accÃ©der Ã  une valeur d'un vecteur,
soit la syntaxe d'indexation, soit avec la mÃ©thode <code>get</code>.</p>
<!--
```rust
# fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    match v.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let troisieme: &amp;i32 = &amp;v[2];
    println!(&quot;Le troisiÃ¨me Ã©lÃ©ment est {}&quot;, troisieme);

    match v.get(2) {
        Some(troisieme) =&gt; println!(&quot;Le troisiÃ¨me Ã©lÃ©ment est {}&quot;, troisieme),
        None =&gt; println!(&quot;Il n'y a pas de troisiÃ¨me Ã©lÃ©ment.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-5: Using indexing syntax or the `get` method to
access an item in a vector</span>
-->
<p><span class="caption">Encart 8-5Â : utilisation de la syntaxe d'indexation ainsi
que la mÃ©thode <code>get</code> pour accÃ©der Ã  un Ã©lÃ©ment d'un vecteur</span></p>
<!--
Note two details here. First, we use the index value of `2` to get the third
element: vectors are indexed by number, starting at zero. Second, the two ways
to get the third element are by using `&` and `[]`, which gives us a reference,
or by using the `get` method with the index passed as an argument, which gives
us an `Option<&T>`.
-->
<p>Il y a deux dÃ©tails Ã  remarquer ici. PremiÃ¨rement, nous avons utilisÃ© l'indice
<code>2</code> pour obtenir le troisiÃ¨me Ã©lÃ©mentÂ : les vecteurs sont indexÃ©s par des
nombres, qui commencent Ã  partir de zÃ©ro. DeuxiÃ¨mement, les deux faÃ§ons
d'obtenir le troisiÃ¨me Ã©lÃ©ment consistent soit Ã  utiliser <code>&amp;</code> et <code>[]</code>, ce qui
nous donne une rÃ©fÃ©rence, soit en utilisant la mÃ©thode <code>get</code> avec l'indice en
argument, ce qui nous fournit un <code>Option&lt;&amp;T&gt;</code>.</p>
<!--
Rust has two ways to reference an element so you can choose how the program
behaves when you try to use an index value that the vector doesnâ€™t have an
element for. As an example, letâ€™s see what a program will do if it has a vector
that holds five elements and then tries to access an element at index 100, as
shown in Listing 8-6.
-->
<p>Rust a deux maniÃ¨res de rÃ©cupÃ©rer un Ã©lÃ©ment afin que vous puissiez choisir
comment le programme doit se comporter lorsque vous essayerez d'utiliser un
indice dont le vecteur n'a pas d'Ã©lÃ©ment correspondant. Par exemple, regardons
ce qu'un programme fait s'il a vecteur qui contient cinq Ã©lÃ©ments et qu'il
essaye d'accÃ©der Ã  l'Ã©lÃ©ment Ã  l'indice 100, comme dans l'encart 8-6.</p>
<!--
```rust,should_panic,panics
# fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
# }
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let existe_pas = &amp;v[100];
    let existe_pas = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-6: Attempting to access the element at index
100 in a vector containing five elements</span>
-->
<p><span class="caption">Encart 8-6Â : tentative d'accÃ¨s Ã  l'Ã©lÃ©ment Ã  l'indice 100
dans un vecteur qui contient cinq Ã©lÃ©ments</span></p>
<!--
When we run this code, the first `[]` method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if thereâ€™s an attempt to access an element past the
end of the vector.
-->
<p>Lorsque nous exÃ©cutons ce code, la premiÃ¨re mÃ©thode <code>[]</code> va faire paniquer le
programme car il demande un Ã©lÃ©ment non existant. Cette mÃ©thode doit Ãªtre
favorisÃ©e lorsque vous souhaitez que votre programme plante s'il y a une
tentative d'accÃ©der Ã  un Ã©lÃ©ment aprÃ¨s la fin du vecteur.</p>
<!--
When the `get` method is passed an index that is outside the vector, it returns
`None` without panicking. You would use this method if accessing an element
beyond the range of the vector happens occasionally under normal circumstances.
Your code will then have logic to handle having either `Some(&element)` or
`None`, as discussed in Chapter 6. For example, the index could be coming from
a person entering a number. If they accidentally enter a number thatâ€™s too
large and the program gets a `None` value, you could tell the user how many
items are in the current vector and give them another chance to enter a valid
value. That would be more user-friendly than crashing the program due to a typo!
-->
<p>Lorsque nous passons un indice en dehors de l'intervalle du vecteur Ã  la mÃ©thode
<code>get</code>, elle retourne <code>None</code> sans paniquer. Vous devriez utiliser cette mÃ©thode
s'il vous arrive occasionnellement de vouloir accÃ©der Ã  un Ã©lÃ©ment en dehors de
l'intervalle du vecteur en temps normal. Votre code va ensuite devoir gÃ©rer les
deux valeurs <code>Some(&amp;element)</code> ou <code>None</code>, comme nous l'avons vu au chapitre 6.
Par exemple, l'indice peut provenir d'une saisie utilisateur. Si par accident il
saisit un nombre qui est trop grand et que le programme obtient une valeur
<code>None</code>, vous pouvez alors dire Ã  l'utilisateur combien il y a d'Ã©lÃ©ments dans le
vecteur courant et lui donner une nouvelle chance de saisir une valeur valide.
Cela sera plus convivial que de faire planter le programme Ã  cause d'une faute
de frappeÂ !</p>
<!--
When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you canâ€™t have mutable and immutable references in the same
scope. That rule applies in Listing 8-7, where we hold an immutable reference to
the first element in a vector and try to add an element to the end, which wonâ€™t
work if we also try to refer to that element later in the function:
-->
<p>Lorsque le programme obtient une rÃ©fÃ©rence valide, le vÃ©rificateur d'emprunt va
faire appliquer les rÃ¨gles de possession et d'emprunt (que nous avons vu au
chapitre 4) pour s'assurer que cette rÃ©fÃ©rence ainsi que toutes les autres
rÃ©fÃ©rences au contenu de ce vecteur restent valides. Souvenez-vous de la rÃ¨gle
qui dit que vous ne pouvez pas avoir des rÃ©fÃ©rences mutables et immuables dans
la mÃªme portÃ©e. Cette rÃ¨gle s'applique Ã  l'encart 8-7, oÃ¹ nous obtenons une
rÃ©fÃ©rence immuable vers le premier Ã©lÃ©ment d'un vecteur et nous essayons
d'ajouter un Ã©lÃ©ment Ã  la fin, ce qui ne fonctionnera pas si nous essayons aussi
d'utiliser cet Ã©lÃ©ment plus tard dans la fonctionÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {}", first);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let premier = &amp;v[0];

    v.push(6);

    println!(&quot;Le premier Ã©lÃ©ment estÂ : {}&quot;, premier);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-7: Attempting to add an element to a vector
while holding a reference to an item</span>
-->
<p><span class="caption">Encart 8-7Â : tentative d'ajout d'un Ã©lÃ©ment Ã  un vecteur
alors que nous utilisons une rÃ©fÃ©rence Ã  un Ã©lÃ©ment</span></p>
<!--
Compiling this code will result in this error:
-->
<p>Compiler ce code va nous mener Ã  cette erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("The first element is: {}", first);
  |                                          ----- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let premier = &amp;v[0];
  |                    - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;Le premier Ã©lÃ©ment estÂ : {}&quot;, premier);
  |                                             ------- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The code in Listing 8-7 might look like it should work: why should a reference
to the first element care about what changes at the end of the vector? This
error is due to the way vectors work: adding a new element onto the end of the
vector might require allocating new memory and copying the old elements to the
new space, if there isnâ€™t enough room to put all the elements next to each
other where the vector currently is. In that case, the reference to the first
element would be pointing to deallocated memory. The borrowing rules prevent
programs from ending up in that situation.
-->
<p>Le code dans l'encart 8-7 semble pourtant marcherÂ : pourquoi une rÃ©fÃ©rence au
premier Ã©lÃ©ment devrait se soucier de ce qui se passe Ã  la fin du vecteurÂ ?
Cette erreur s'explique par la faÃ§on dont les vecteurs fonctionnentÂ : ajouter un
nouvel Ã©lÃ©ment Ã  la fin du vecteur peut nÃ©cessiter d'allouer un nouvel espace
mÃ©moire et copier tous les anciens Ã©lÃ©ments dans ce nouvel espace, s'il n'y a
pas assez de place pour placer tous les Ã©lÃ©ments les un Ã  cÃ´tÃ© des autres dans
la mÃ©moire oÃ¹ se trouve actuellement le vecteur. Dans notre cas, la rÃ©fÃ©rence
au premier Ã©lÃ©ment pourrait pointer sur de la mÃ©moire supprimÃ©e. Les rÃ¨gles
d'emprunt Ã©vitent aux programmes de se retrouver dans cette situation.</p>
<!--
> Note: For more on the implementation details of the `Vec<T>` type, see [â€œThe
> Rustonomiconâ€][nomicon].
-->
<blockquote>
<p>RemarqueÂ : pour plus de dÃ©tails sur l'implÃ©mentation du type <code>Vec&lt;T&gt;</code>,
consultez <a href="https://doc.rust-lang.org/nomicon/vec.html">â€œThe Rustonomiconâ€</a>.</p>
</blockquote>
<!--
### Iterating over the Values in a Vector
-->
<h3><a class="header" href="#itÃ©rer-sur-les-valeurs-dun-vecteur" id="itÃ©rer-sur-les-valeurs-dun-vecteur">ItÃ©rer sur les valeurs d'un vecteur</a></h3>
<!--
If we want to access each element in a vector in turn, we can iterate through
all of the elements rather than use indices to access one at a time. Listing
8-8 shows how to use a `for` loop to get immutable references to each element
in a vector of `i32` values and print them.
-->
<p>Si nous voulons accÃ©der Ã  chaque Ã©lÃ©ment d'un vecteur chacun Ã  leur tour, nous
pouvons itÃ©rer sur tous les Ã©lÃ©ments plutÃ´t que d'utiliser individuellement les
indices. L'encart 8-8 nous montre comment utiliser une boucle <code>for</code> pour obtenir
des rÃ©fÃ©rences immuables pour chacun des Ã©lÃ©ments dans un vecteur de <code>i32</code>, et
les afficher.</p>
<!--
```rust
# fn main() {
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{}", i);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-8: Printing each element in a vector by
iterating over the elements using a `for` loop</span>
-->
<p><span class="caption">Encart 8-8Â : affichage de chaque Ã©lÃ©ment d'un vecteur en
itÃ©rant sur les Ã©lÃ©ments en utilisant une boucle <code>for</code></span></p>
<!--
We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The `for` loop in Listing 8-9
will add `50` to each element.
-->
<p>Nous pouvons aussi itÃ©rer avec des rÃ©fÃ©rences mutables pour chacun des Ã©lÃ©ments
d'un vecteur mutable afin de modifier tous les Ã©lÃ©ments. La boucle <code>for</code> de
l'encart 8-9 va ajouter <code>50</code> Ã  chacun des Ã©lÃ©ments.</p>
<!--
```rust
# fn main() {
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-9: Iterating over mutable references to
elements in a vector</span>
-->
<p><span class="caption">Encart 8-9Â : itÃ©rations sur des rÃ©fÃ©rences mutables vers
des Ã©lÃ©ments d'un vecteur</span></p>
<!--
To change the value that the mutable reference refers to, we have to use the
dereference operator (`*`) to get to the value in `i` before we can use the
`+=` operator. Weâ€™ll talk more about the dereference operator in the
[â€œFollowing the Pointer to the Value with the Dereference Operatorâ€][deref]
section of Chapter 15.
-->
<p>Afin de changer la valeur pointÃ©e par la rÃ©fÃ©rence mutable, nous devons utiliser
l'opÃ©rateur de dÃ©rÃ©fÃ©rencement (<code>*</code>) pour obtenir la valeur dans <code>i</code> avant que
nous puissions utiliser l'opÃ©rateur <code>+=</code>. Nous verrons plus en dÃ©tail
l'opÃ©rateur de dÃ©rÃ©fÃ©rencement dans une section du <a href="ch15-02-deref.html">chapitre 15</a>.</p>
<!--
### Using an Enum to Store Multiple Types
-->
<h3><a class="header" href="#utiliser-une-Ã©numÃ©ration-pour-stocker-diffÃ©rents-types" id="utiliser-une-Ã©numÃ©ration-pour-stocker-diffÃ©rents-types">Utiliser une Ã©numÃ©ration pour stocker diffÃ©rents types</a></h3>
<!--
At the beginning of this chapter, we said that vectors can only store values
that are the same type. This can be inconvenient; there are definitely use
cases for needing to store a list of items of different types. Fortunately, the
variants of an enum are defined under the same enum type, so when we need to
store elements of a different type in a vector, we can define and use an enum!
-->
<p>Au dÃ©but de ce chapitre, nous avons dit que les vecteurs ne peuvent que stocker
des valeurs du mÃªme type. Cela peut Ãªtre un problÃ¨meÂ ; il y a forcÃ©ment des cas
oÃ¹ on a besoin de stocker une liste d'Ã©lÃ©ments de types diffÃ©rents.
Heureusement, les variantes d'une Ã©numÃ©ration sont dÃ©finies sous le mÃªme type
qui est l'Ã©numÃ©ration, donc lorsque nous avons besoin de stocker des Ã©lÃ©ments
d'un type diffÃ©rent dans un vecteur, nous pouvons dÃ©finir et utiliser une
Ã©numÃ©rationÂ !</p>
<!--
For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and then all the enum variants will be considered the same type:
that of the enum. Then we can create a vector that holds that enum and so,
ultimately, holds different types. Weâ€™ve demonstrated this in Listing 8-10.
-->
<p>Par exemple, imaginons que nous voulions obtenir les valeurs d'une ligne d'une
feuille de calculs dans laquelle quelques colonnes sont des entiers, d'autres
des nombres Ã  virgule flottante, et quelques chaÃ®nes de caractÃ¨res. Nous pouvons
dÃ©finir une Ã©numÃ©ration dont les variantes vont avoir les diffÃ©rents types, et
ainsi toutes les variantes de l'Ã©numÃ©ration seront du mÃªme typeÂ : celui de
l'Ã©numÃ©ration. Ensuite, nous pouvons crÃ©er un vecteur qui stocke cette
Ã©numÃ©ration et ainsi, au final, qui stocke diffÃ©rents types. La dÃ©monstration de
cette technique est dans l'encart 8-10.</p>
<!--
```rust
# fn main() {
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Cellule {
        Int(i32),
        Float(f64),
        Text(String),
    }
    
    let ligne = vec![
        Cellule::Int(3),
        Cellule::Text(String::from(&quot;bleu&quot;)),
        Cellule::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-10: Defining an `enum` to store values of
different types in one vector</span>
-->
<p><span class="caption">Encart 8-10Â : dÃ©finition d'une <code>enum</code> pour stocker des
valeurs de diffÃ©rents types dans un seul vecteur</span></p>
<!--
Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. A
secondary advantage is that we can be explicit about what types are allowed in
this vector. If Rust allowed a vector to hold any type, there would be a chance
that one or more of the types would cause errors with the operations performed
on the elements of the vector. Using an enum plus a `match` expression means
that Rust will ensure at compile time that every possible case is handled, as
discussed in Chapter 6.
-->
<p>Rust a besoin de savoir quel type de donnÃ©e sera stockÃ© dans le vecteur au
moment de la compilation afin de connaÃ®tre la quantitÃ© de mÃ©moire nÃ©cessaire
pour stocker chaque Ã©lÃ©ment sur le tas. Le second avantage est que nous sommes
prÃ©cis sur les types autorisÃ©s dans ce vecteur. Si Rust avait permis qu'un
vecteur stocke n'importe quel type, il y aurait pu avoir un risque qu'un ou
plusieurs des types provoque(nt) une erreur avec les manipulations effectuÃ©es
sur les Ã©lÃ©ments du vecteur. L'utilisation d'une Ã©numÃ©ration ainsi qu'une
expression <code>match</code> peut permettre Ã  Rust de garantir au moment de la compilation
que tous les cas possibles sont traitÃ©s, comme nous l'avons appris au
chapitre 6.</p>
<!--
When youâ€™re writing a program, if you donâ€™t know the exhaustive set of types
the program will get at runtime to store in a vector, the enum technique wonâ€™t
work. Instead, you can use a trait object, which weâ€™ll cover in Chapter 17.
-->
<p>Lorsque vous Ã©crivez un programme, si vous n'avez pas une liste prÃ©cise des
types que votre vecteur va stocker, la technique de l'Ã©numÃ©ration ne va pas
fonctionner. A la place, vous pouvez utiliser un objet trait, que nous verrons
au chapitre 17.</p>
<!--
Now that weâ€™ve discussed some of the most common ways to use vectors, be sure
to review [the API documentation][vec-api] for all the many useful methods defined on
`Vec<T>` by the standard library. For example, in addition to `push`, a `pop`
method removes and returns the last element. Letâ€™s move on to the next
collection type: `String`!
-->
<p>Maintenant que nous avons vu les maniÃ¨res les plus courantes d'utiliser les
vecteurs, prenez le temps de consulter <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">la documentation de l'API</a> pour
dÃ©couvrir toutes les mÃ©thodes trÃ¨s utiles dÃ©finies dans la bibliothÃ¨que standard
pour <code>Vec&lt;T&gt;</code>. Par exemple, en plus de <code>push</code>, nous avons une mÃ©thode <code>pop</code> qui
retire et retourne le dernier Ã©lÃ©ment. IntÃ©ressons-nous maintenant au prochain
type de collectionÂ : les <code>String</code>Â !</p>
<!--
[data-types]: ch03-02-data-types.html#data-types
[nomicon]: ../nomicon/vec.html
[vec-api]: ../std/vec/struct.Vec.html
[deref]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator
-->
<!--
## Storing UTF-8 Encoded Text with Strings
-->
<h2><a class="header" href="#stocker-du-texte-encodÃ©-en-utf-8-avec-les-strings" id="stocker-du-texte-encodÃ©-en-utf-8-avec-les-strings">Stocker du texte encodÃ© en UTF-8 avec les Strings</a></h2>
<!--
We talked about strings in Chapter 4, but weâ€™ll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rustâ€™s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when youâ€™re
coming from other programming languages.
-->
<p>Nous avons dÃ©jÃ  parlÃ© des chaÃ®nes de caractÃ¨res dans le chapitre 4, mais nous
allons Ã  prÃ©sent les analyser plus en dÃ©tail. Les nouveaux RustacÃ©s bloquent
souvent avec les chaÃ®nes de caractÃ¨res pour trois raisonsÂ : la tendance de Rust
Ã  prÃ©venir les erreurs, le fait que les chaÃ®nes de caractÃ¨res sont des structures de
donnÃ©es plus compliquÃ©es que ne le pensent la plupart des dÃ©veloppeurs, et
l'UTF-8. Ces raisons cumulÃ©es rendent les choses compliquÃ©es lorsque vous
venez d'un autre langage de programmation.</p>
<!--
Itâ€™s useful to discuss strings in the context of collections because strings
are implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, weâ€™ll
talk about the operations on `String` that every collection type has, such as
creating, updating, and reading. Weâ€™ll also discuss the ways in which `String`
is different from the other collections, namely how indexing into a `String` is
complicated by the differences between how people and computers interpret
`String` data.
-->
<p>Il est pertinent de prÃ©senter les chaÃ®nes de caractÃ¨res comme des collections
car les chaÃ®nes de caractÃ¨res sont en rÃ©alitÃ© des ensembles d'octets, avec
quelques mÃ©thodes supplÃ©mentaires qui sont utiles lorsque ces octets sont
considÃ©rÃ©s comme du texte. Dans cette section, nous allons voir les points
communs entre le fonctionnement des <code>String</code> et celui des autres collections,
comme la crÃ©ation, la modification, et la lecture. Nous verrons les raisons pour
lesquelles les <code>String</code> sont diffÃ©rents des autres collections, en particulier
pourquoi l'indexation d'un <code>String</code> est compliquÃ©e Ã  cause de la faÃ§on dont les
gens et les ordinateurs interprÃ¨tent les donnÃ©es d'une <code>String</code>.</p>
<!--
### What Is a String?
-->
<h3><a class="header" href="#quest-ce-quune-chaÃ®ne-de-caractÃ¨res-" id="quest-ce-quune-chaÃ®ne-de-caractÃ¨res-">Qu'est-ce qu'une chaÃ®ne de caractÃ¨resÂ ?</a></h3>
<!--
Weâ€™ll first define what we mean by the term *string*. Rust has only one string
type in the core language, which is the string slice `str` that is usually seen
in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the programâ€™s binary and are therefore
string slices.
-->
<p>Nous allons d'abord dÃ©finir ce que nous entendons par le terme <em>chaÃ®ne de
caractÃ¨res</em>. Rust a un seul type de chaÃ®nes de caractÃ¨res dans le noyau du
langage, qui est la slice de chaÃ®ne de caractÃ¨res <code>str</code> qui est habituellement
utilisÃ©e sous sa forme empruntÃ©e, <code>&amp;str</code>. Dans le chapitre 4, nous avons abordÃ©
les <em>slices de chaÃ®ne de caractÃ¨res</em>, qui sont des rÃ©fÃ©rences Ã  une partie des
donnÃ©es d'une chaÃ®ne de caractÃ¨res encodÃ©e en UTF-8 qui sont stockÃ©s autre part.
Les chaÃ®nes de caractÃ¨res pures, par exemple, sont stockÃ©es dans le binaire du
programme et sont des slices de chaÃ®nes de caractÃ¨res.</p>
<!--
The `String` type, which is provided by Rustâ€™s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to â€œstringsâ€ in Rust, they usually mean the
`String` and the string slice `&str` types, not just one of those types.
Although this section is largely about `String`, both types are used heavily in
Rustâ€™s standard library, and both `String` and string slices are UTF-8 encoded.
-->
<p>Le type <code>String</code>, qui est fourni par la bibliothÃ¨que standard de Rust plutÃ´t que
d'Ãªtre intÃ©grÃ© au noyau du langage, est un type de chaÃ®ne de caractÃ¨res encodÃ©
en UTF-8 qui peut s'agrandir, Ãªtre mutable, et Ãªtre possÃ©dÃ©. Lorsque les
RustacÃ©s parlent de â€œchaÃ®nes de caractÃ¨resâ€ en Rust, cela dÃ©signe le type
<code>String</code> mais aussi le type de slice de chaÃ®nes de caractÃ¨res <code>&amp;str</code>, et non pas
un seul de ces types. Bien que cette section traite essentiellement de <code>String</code>,
ces deux types sont utilisÃ©s massivement dans la bibliothÃ¨que standard de Rust,
et tous les deux sont encodÃ©s en UTF-8.</p>
<!--
Rustâ€™s standard library also includes a number of other string types, such as
`OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even
more options for storing string data. See how those names all end in `String`
or `Str`? They refer to owned and borrowed variants, just like the `String` and
`str` types youâ€™ve seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We wonâ€™t discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.
-->
<p>La bibliothÃ¨que standard de Rust apporte aussi un certain nombre d'autres types
de chaÃ®nes de caractÃ¨res, comme <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, et <code>CStr</code>. Les
crates de bibliothÃ¨que peuvent fournir encore plus de solutions pour stocker des
chaÃ®nes de caractÃ¨res. Avez vous remarquÃ© que ces noms finissent tous par <code>String</code>
ou <code>Str</code>Â ? Cela fait rÃ©fÃ©rence aux variantes possÃ©dÃ©es et empruntÃ©es, comme les
types <code>String</code> et <code>str</code> que nous avons vu prÃ©cÃ©demment. Ces types de chaÃ®nes de
caractÃ¨res peuvent stocker leur texte dans de diffÃ©rents encodages, ou le
stocker en mÃ©moire de maniÃ¨re diffÃ©rente, par exemple. Nous n'allons pas traiter
ces autres types de chaÃ®nes de caractÃ¨res dans ce chapitreÂ ; rÃ©fÃ©rez-vous Ã 
la documentation de leur API pour en savoir plus sur leur utilisation et leur utilitÃ©.</p>
<!--
### Creating a New String
-->
<h3><a class="header" href="#crÃ©er-une-nouvelle-string" id="crÃ©er-une-nouvelle-string">CrÃ©er une nouvelle String</a></h3>
<!--
Many of the same operations available with `Vec<T>` are available with `String`
as well, starting with the `new` function to create a string, shown in Listing
8-11.
-->
<p>De nombreuses opÃ©rations disponibles avec <code>Vec&lt;T&gt;</code> sont aussi disponibles avec
<code>String</code>, en commenÃ§ant par la fonction <code>new</code> pour crÃ©er une <code>String</code>, utilisÃ©e
dans l'encart 8-11.</p>
<!--
```rust
# fn main() {
    let mut s = String::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-11: Creating a new, empty `String`</span>
-->
<p><span class="caption">Encart 8-11Â : CrÃ©ation d'une nouvelle <code>String</code> vide</span></p>
<!--
This line creates a new empty string called `s`, which we can then load data
into. Often, weâ€™ll have some initial data that we want to start the string
with. For that, we use the `to_string` method, which is available on any type
that implements the `Display` trait, as string literals do. Listing 8-12 shows
two examples.
-->
<p>Cette ligne crÃ©Ã©e une nouvelle <code>String</code> vide qui s'appelle <code>s</code>, dans laquelle
nous pouvons ensuite y charger des donnÃ©es. Parfois, nous aurons quelques
donnÃ©es initiales que nous voudrions ajouter dans la <code>String</code>. Pour cela, nous
utilisons la mÃ©thode <code>to_string</code>, qui est disponible sur tous les types qui
implÃ©mentent le trait <code>Display</code>, comme le font les chaÃ®nes de caractÃ¨res pures.
L'encart 8-12 nous montre deux exemples.</p>
<!--
```rust
# fn main() {
    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let donnee = &quot;contenu initial&quot;;

    let s = donnee.to_string();

    // cette mÃ©thode fonctionne aussi directement sur une
    // chaÃ®ne de caractÃ¨res pureÂ :
    let s = &quot;contenu initial&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-12: Using the `to_string` method to create a
`String` from a string literal</span>
-->
<p><span class="caption">Encart 8-12Â : Utilisation de la mÃ©thode <code>to_string</code> pour
crÃ©er un <code>String</code> Ã  partir d'une chaÃ®ne de caractÃ¨res pure</span></p>
<!--
This code creates a string containing `initial contents`.
-->
<p>Ce code crÃ©e une <code>String</code> qui contient <code>contenu initial</code>.</p>
<!--
We can also use the function `String::from` to create a `String` from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses `to_string`.
-->
<p>Nous pouvons aussi utiliser la fonction <code>String::from</code> pour crÃ©er une <code>String</code>
Ã  partir d'une chaÃ®ne de caractÃ¨res pure. Le code dans l'encart 8-13 est
Ã©quivalent au code dans l'encart 8-12 qui utilisait <code>to_string</code>.</p>
<!--
```rust
# fn main() {
    let s = String::from("initial contents");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;contenu initial&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-13: Using the `String::from` function to create
a `String` from a string literal</span>
-->
<p><span class="caption">Encart 8-13Â : Utilisation de la fonction <code>String::from</code>
afin de crÃ©er une <code>String</code> Ã  partir d'une chaÃ®ne de caractÃ¨res pure</span></p>
<!--
Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, `String::from` and
`to_string` do the same thing, so which you choose is a matter of style.
-->
<p>Comme les chaÃ®nes de caractÃ¨res sont utilisÃ©es pour de nombreuses choses, nous
pouvons utiliser beaucoup d'APIs gÃ©nÃ©riques pour les chaÃ®nes de caractÃ¨res.
Certaines d'entre elles peuvent paraÃ®tre redondantes, mais elles ont toutes
leur placeÂ ! Dans notre cas, <code>String::from</code> et <code>to_string</code> font la mÃªme
chose, donc votre choix est une question de goÃ»t.</p>
<!--
Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.
-->
<p>Souvenez-vous que les chaÃ®nes de caractÃ¨res sont encodÃ©es en UTF-8, donc nous
pouvons y intÃ©grer n'importe quelle donnÃ©e valide, comme nous
le voyons dans l'encart 8-14.</p>
<!--
```rust
# fn main() {
    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
    let hello = String::from("DobrÃ½ den");
    let hello = String::from("Hello");
    let hello = String::from("×©Ö¸××œ×•Ö¹×");
    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
    let hello = String::from("ä½ å¥½");
    let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;);
    let hello = String::from(&quot;DobrÃ½ den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;×©Ö¸××œ×•Ö¹×&quot;);
    let hello = String::from(&quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;);
    let hello = String::from(&quot;ã“ã‚“ã«ã¡ã¯&quot;);
    let hello = String::from(&quot;ì•ˆë…•í•˜ì„¸ìš”&quot;);
    let hello = String::from(&quot;ä½ å¥½&quot;);
    let hello = String::from(&quot;OlÃ¡&quot;);
    let hello = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span>
-->
<p><span class="caption">Encart 8-14Â : Stockage de texte dans diffÃ©rents langages
dans des chaÃ®nes de caractÃ¨res</span></p>
<!--
All of these are valid `String` values.
-->
<p>Toutes ces chaÃ®nes sont des valeurs <code>String</code> valides.</p>
<!--
### Updating a String
-->
<h3><a class="header" href="#modifier-une-string" id="modifier-une-string">Modifier une <code>String</code></a></h3>
<!--
A `String` can grow in size and its contents can change, just like the contents
of a `Vec<T>`, if you push more data into it. In addition, you can conveniently
use the `+` operator or the `format!` macro to concatenate `String` values.
-->
<p>Une <code>String</code> peut s'agrandir et son contenu peut changer, exactement comme le
contenu d'un <code>Vec&lt;T&gt;</code>, si vous utilisez <code>push</code> pour y rajouter des donnÃ©es Ã 
l'intÃ©rieur. De plus, vous pouvez correctement utiliser l'opÃ©rateur <code>+</code> ou la
macro <code>format!</code> pour concatener des valeurs <code>String</code>.</p>
<!--
#### Appending to a String with `push_str` and `push`
-->
<h4><a class="header" href="#ajouter-du-texte-Ã -une-chaÃ®ne-avec-push_str-et-push" id="ajouter-du-texte-Ã -une-chaÃ®ne-avec-push_str-et-push">Ajouter du texte Ã  une chaÃ®ne avec <code>push_str</code> et <code>push</code></a></h4>
<!--
We can grow a `String` by using the `push_str` method to append a string slice,
as shown in Listing 8-15.
-->
<p>Nous pouvons agrandir un <code>String</code> en utilisant la mÃ©thode <code>push_str</code> pour
ajouter une slice de chaÃ®ne de caractÃ¨res, comme dans l'encart 8-15.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-15: Appending a string slice to a `String`
using the `push_str` method</span>
-->
<p><span class="caption">Encart 8-15Â : Ajout d'une slice de chaÃ®ne de caractÃ¨res
dans un <code>String</code> en utilisant la mÃ©thode <code>push_str</code></span></p>
<!--
After these two lines, `s` will contain `foobar`. The `push_str` method takes a
string slice because we donâ€™t necessarily want to take ownership of the
parameter. For example, the code in Listing 8-16 shows that it would be
unfortunate if we werenâ€™t able to use `s2` after appending its contents to `s1`.
-->
<p>A l'issue de ces deux lignes, <code>s</code> va contenir <code>foobar</code>. La mÃ©thode <code>push_str</code>
prend une slice de chaÃ®ne de caractÃ¨res car nous ne souhaitons pas forcÃ©ment
prendre possession du paramÃ¨tre. Par exemple, le code de l'encart 8-16 nous
montre une situation oÃ¹ il serait regrettable si nous ne pouvions plus utiliser
<code>s2</code> aprÃ¨s avoir ajoutÃ© son contenu dans <code>s1</code>.</p>
<!--
```rust
# fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 est {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-16: Using a string slice after appending its
contents to a `String`</span>
-->
<p><span class="caption">Encart 8-16Â : Utilisation d'une slice de chaÃ®ne de
caractÃ¨res aprÃ¨s avoir ajoutÃ© son contenu dans une <code>String</code></span></p>
<!--
If the `push_str` method took ownership of `s2`, we wouldnâ€™t be able to print
its value on the last line. However, this code works as weâ€™d expect!
-->
<p>Si la mÃ©thode <code>push_str</code> prenait possession de <code>s2</code>, Ã  la derniÃ¨re ligne, nous
ne pourrions pas afficher sa valeur. Cependant, ce code fonctionne comme nous
l'espÃ©rionsÂ !</p>
<!--
The `push` method takes a single character as a parameter and adds it to the
`String`. Listing 8-17 shows code that adds the letter *l* to a `String` using
the `push` method.
-->
<p>La mÃ©thode <code>push</code> prend un seul caractÃ¨re en paramÃ¨tre et l'ajoute au <code>String</code>.
L'encart 8-17 nous montre du code qui ajoute la lettre <em>l</em> au <code>String</code> en
utilisant la mÃ©thode <code>push</code>.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("lo");
    s.push('l');
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-17: Adding one character to a `String` value
using `push`</span>
-->
<p><span class="caption">Encart 8-17Â : Ajout d'un unique caractÃ¨re Ã  la valeur d'une
<code>String</code> en utilisant <code>push</code></span></p>
<!--
As a result of this code, `s` will contain `lol`.
-->
<p>AprÃ¨s exÃ©cution de ce code, <code>s</code> contiendra <code>lol</code>.</p>
<!--
#### Concatenation with the `+` Operator or the `format!` Macro
-->
<h4><a class="header" href="#concatÃ©nation-avec-lopÃ©rateur--ou-la-macro-format" id="concatÃ©nation-avec-lopÃ©rateur--ou-la-macro-format">ConcatÃ©nation avec l'opÃ©rateur <code>+</code> ou la macro <code>format!</code></a></h4>
<!--
Often, youâ€™ll want to combine two existing strings. One way is to use the `+`
operator, as shown in Listing 8-18.
-->
<p>Parfois, vous aurez besoin de combiner deux chaÃ®nes de caractÃ¨res existantes.
Une faÃ§on de faire cela est d'utiliser l'opÃ©rateur <code>+</code>, comme dans l'encart
8-18.</p>
<!--
```rust
# fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // notez que s1 a Ã©tÃ© dÃ©placÃ© ici
                       // et ne pourra plus Ãªtre utilisÃ©
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-18: Using the `+` operator to combine two
`String` values into a new `String` value</span>
-->
<p><span class="caption">Encart 8-18Â : Utilisation de l'opÃ©rateur <code>+</code> pour
combiner deux valeurs de <code>String</code></span></p>
<!--
The string `s3` will contain `Hello, world!` as a result of this code. The
reason `s1` is no longer valid after the addition and the reason we used a
reference to `s2` has to do with the signature of the method that gets called
when we use the `+` operator. The `+` operator uses the `add` method, whose
signature looks something like this:
-->
<p>La chaÃ®ne de caractÃ¨res <code>s3</code> va contenir <code>Hello, world!</code> Ã  l'issue de
l'exÃ©cution de ce code. La raison pour laquelle <code>s1</code> n'est plus utilisable aprÃ¨s
avoir Ã©tÃ© ajoutÃ© et la raison pour laquelle nous utilisons une rÃ©fÃ©rence vers
<code>s2</code> s'expliquent par la signature de la mÃ©thode qui est appelÃ©e lorsque nous
utilisons l'opÃ©rateur <code>+</code>. L'opÃ©rateur <code>+</code> utilise la mÃ©thode <code>add</code>, dont la
signature ressemble Ã  ceciÂ :</p>
<!--
```rust,ignore
fn add(self, s: &str) -> String {
```
-->
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!--
This isnâ€™t the exact signature thatâ€™s in the standard library: in the standard
library, `add` is defined using generics. Here, weâ€™re looking at the signature
of `add` with concrete types substituted for the generic ones, which is what
happens when we call this method with `String` values. Weâ€™ll discuss generics
in Chapter 10. This signature gives us the clues we need to understand the
tricky bits of the `+` operator.
-->
<p>Ce n'est pas exactement la mÃªme signature que celle de la bibliothÃ¨que
standardÂ : dans la bibliothÃ¨que standard, <code>add</code> est dÃ©fini avec des types
gÃ©nÃ©riques. Ici, nous voyons la signature de <code>add</code> avec des types concrets Ã  la
place des gÃ©nÃ©riques, ce qui se passe lorsque nous utilisons cette mÃ©thode avec
des valeurs de type <code>String</code>. Nous verrons les gÃ©nÃ©riques au chapitre 10. Cette
signature nous donne les Ã©lÃ©ments dont nous avons besoin pour comprendre les
subtilitÃ©s de l'opÃ©rateur <code>+</code>.</p>
<!--
First, `s2` has an `&`, meaning that weâ€™re adding a *reference* of the second
string to the first string because of the `s` parameter in the `add` function:
we can only add a `&str` to a `String`; we canâ€™t add two `String` values
together. But waitâ€”the type of `&s2` is `&String`, not `&str`, as specified in
the second parameter to `add`. So why does Listing 8-18 compile?
-->
<p>PremiÃ¨rement, <code>s2</code> a un <code>&amp;</code>, ce qui veut dire que nous ajoutons une <em>rÃ©fÃ©rence</em>
vers la seconde chaÃ®ne de caractÃ¨res en raison du paramÃ¨tre <code>s</code> dans la fonction
<code>add</code>Â : nous pouvons seulement ajouter une <code>&amp;str</code> Ã  une <code>String</code>Â ; nous ne
pouvons pas ajouter deux valeurs de type <code>String</code> ensemble. Mais attendez â€” le
type de <code>&amp;s2</code> est <code>&amp;String</code>, et non pas <code>&amp;str</code>, comme c'est Ã©crit dans le second
paramÃ¨tre de <code>add</code>. Donc pourquoi est-ce que le code l'encart 8-18 se compileÂ ?</p>
<!--
The reason weâ€™re able to use `&s2` in the call to `add` is that the compiler
can *coerce* the `&String` argument into a `&str`. When we call the `add`
method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`.
Weâ€™ll discuss deref coercion in more depth in Chapter 15. Because `add` does
not take ownership of the `s` parameter, `s2` will still be a valid `String`
after this operation.
-->
<p>La raison pour laquelle nous pouvons utiliser <code>&amp;s2</code> dans l'appel Ã  <code>add</code> est que
le compilateur peut <em>extrapoler</em> l'argument <code>&amp;String</code> en un <code>&amp;str</code>. Lorsque
nous appelons la mÃ©thode <code>add</code>, Rust va utiliser une <em>extrapolation de
dÃ©rÃ©fÃ©rencement</em>, qui transforme ici <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Nous verrons plus en
dÃ©tails l'extrapolation de dÃ©rÃ©fÃ©rencement au chapitre 15. Comme <code>add</code> ne prend
pas possession du paramÃ¨tre <code>s</code>, <code>s2</code> sera toujours une <code>String</code> valide aprÃ¨s
cette opÃ©ration.</p>
<!--
Second, we can see in the signature that `add` takes ownership of `self`,
because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be
moved into the `add` call and no longer be valid after that. So although `let
s3 = s1 + &s2;` looks like it will copy both strings and create a new one, this
statement actually takes ownership of `s1`, appends a copy of the contents of
`s2`, and then returns ownership of the result. In other words, it looks like
itâ€™s making a lot of copies but isnâ€™t; the implementation is more efficient
than copying.
-->
<p>Ensuite, nous pouvons constater que la signature de <code>add</code> prend possession de
<code>self</code>, car <code>self</code> n'a <em>pas</em> de <code>&amp;</code>. Cela signifie que <code>s1</code> dans l'encart 8-18
va Ãªtre dÃ©placÃ© dans l'appel Ã  <code>add</code> et ne sera plus en vigueur aprÃ¨s cela. Donc
bien que <code>let s3 = s1 + &amp;s2</code> semble copier les deux chaÃ®nes de caractÃ¨res pour
en crÃ©er une nouvelle, cette instruction va en rÃ©alitÃ© prendre possession du
rÃ©sultat. Autrement dit, cela semble faire beaucoup de copies mais en rÃ©alitÃ©
nonÂ ; son implÃ©mentation est plus efficace que la copie.</p>
<!--
If we need to concatenate multiple strings, the behavior of the `+` operator
gets unwieldy:
-->
<p>Si nous avons besoin de concatÃ©ner plusieurs chaÃ®nes de caractÃ¨res, le
comportement de l'opÃ©rateur <code>+</code> devient difficile Ã  utiliserÂ :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<!--
At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"`
characters, itâ€™s difficult to see whatâ€™s going on. For more complicated string
combining, we can use the `format!` macro:
-->
<p>Au final, <code>s</code> vaudra <code>tic-tac-toe</code>. Avec tous les caractÃ¨res <code>+</code>et <code>&quot;</code>, il est
difficile de visualiser ce qu'il se passe. Pour une combinaison de chaÃ®nes de
caractÃ¨res plus complexes, nous pouvons utiliser la macro <code>format!</code>Â :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<!--
This code also sets `s` to `tic-tac-toe`. The `format!` macro works in the same
way as `println!`, but instead of printing the output to the screen, it returns
a `String` with the contents. The version of the code using `format!` is much
easier to read and doesnâ€™t take ownership of any of its parameters.
-->
<p>Ce code assigne lui aussi Ã  <code>s</code> la valeur <code>tic-tac-toe</code>. La macro <code>format!</code>
fonctionne de la mÃªme maniÃ¨re que <code>println!</code>, mais au lieu d'afficher son
rÃ©sultat Ã  l'Ã©cran, elle retourne un <code>String</code> avec son contenu. La version du
code qui utilise <code>format!</code> est plus facile Ã  lire et ne prends pas possession de
ses paramÃ¨tres.</p>
<!--
### Indexing into Strings
-->
<h3><a class="header" href="#lindexation-des-string" id="lindexation-des-string">L'indexation des <code>String</code></a></h3>
<!--
In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a `String` using indexing syntax in Rust, youâ€™ll
get an error. Consider the invalid code in Listing 8-19.
-->
<p>Dans de nombreux autres langages de programmation, l'accÃ¨s individuel aux
caractÃ¨res d'une chaÃ®ne de caractÃ¨res en utilisant leur indice est une
opÃ©ration valide et courante. Cependant, si vous essayez d'accÃ©der Ã  des
Ã©lÃ©ments d'une <code>String</code> en utilisant la syntaxe des indices avec Rust, vous
allez avoir une erreur. Nous tentons cela dans le code invalide de l'encart
8-19.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span>
-->
<p><span class="caption">Encart 8-19Â : Essai d'utilisation de la syntaxe
d'indexation avec une <code>String</code></span></p>
<!--
This code will result in the following error:
-->
<p>Ce code va produire l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 -- > src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error and the note tell the story: Rust strings donâ€™t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.
-->
<p>L'erreur et la remarque nous expliquent le problÃ¨meÂ : les <code>String</code> de Rust
n'acceptent pas l'utilisation des indices. Mais pourquoiÂ ? Pour rÃ©pondre Ã 
cette question, nous avons besoin de savoir comment Rust enregistre les chaÃ®nes
de caractÃ¨res dans la mÃ©moire.</p>
<!--
#### Internal Representation
-->
<h4><a class="header" href="#reprÃ©sentation-du-fonctionnement-interne" id="reprÃ©sentation-du-fonctionnement-interne">ReprÃ©sentation du fonctionnement interne</a></h4>
<!--
A `String` is a wrapper over a `Vec<u8>`. Letâ€™s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:
-->
<p>Une <code>String</code> est une surcouche de <code>Vec&lt;u8&gt;</code>. Revenons sur certains exemples de
chaÃ®nes de caractÃ¨res correctement encodÃ©es en UTF-8 que nous avions dans
l'encart 8-14. PremiÃ¨rement, celle-ciÂ :</p>
<!--
```rust
# fn main() {
#     let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
#     let hello = String::from("DobrÃ½ den");
#     let hello = String::from("Hello");
#     let hello = String::from("×©Ö¸××œ×•Ö¹×");
#     let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
#     let hello = String::from("ã“ã‚“ã«ã¡ã¯");
#     let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
#     let hello = String::from("ä½ å¥½");
#     let hello = String::from("OlÃ¡");
#     let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;);
</span><span class="boring">    let hello = String::from(&quot;DobrÃ½ den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;×©Ö¸××œ×•Ö¹×&quot;);
</span><span class="boring">    let hello = String::from(&quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;);
</span><span class="boring">    let hello = String::from(&quot;ã“ã‚“ã«ã¡ã¯&quot;);
</span><span class="boring">    let hello = String::from(&quot;ì•ˆë…•í•˜ì„¸ìš”&quot;);
</span><span class="boring">    let hello = String::from(&quot;ä½ å¥½&quot;);
</span><span class="boring">    let hello = String::from(&quot;OlÃ¡&quot;);
</span><span class="boring">    let hello = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
In this case, `len` will be 4, which means the vector storing the string â€œHolaâ€
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But
what about the following line? (Note that this string begins with the capital
Cyrillic letter Ze, not the Arabic number 3.)
-->
<p>Dans ce cas-ci, <code>len</code> vaudra 4, ce qui veut dire que le vecteur qui stocke la
chaÃ®ne â€œHolaâ€ a une taille de 4 octets. Chacune des lettres prends 1 octet
lorsqu'elles sont encodÃ©es en UTF-8. Mais que se passe-t-il Ã  la ligne
suivanteÂ ? (Notez que cette chaÃ®ne de caractÃ¨res commence avec la lettre
majuscule cyrillique Ze, et non pas le nombre arabe 3.)</p>
<!--
```rust
# fn main() {
#     let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
#     let hello = String::from("DobrÃ½ den");
#     let hello = String::from("Hello");
#     let hello = String::from("×©Ö¸××œ×•Ö¹×");
#     let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
#     let hello = String::from("ã“ã‚“ã«ã¡ã¯");
#     let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
#     let hello = String::from("ä½ å¥½");
#     let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
#     let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;);
</span><span class="boring">    let hello = String::from(&quot;DobrÃ½ den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;×©Ö¸××œ×•Ö¹×&quot;);
</span><span class="boring">    let hello = String::from(&quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;);
</span><span class="boring">    let hello = String::from(&quot;ã“ã‚“ã«ã¡ã¯&quot;);
</span><span class="boring">    let hello = String::from(&quot;ì•ˆë…•í•˜ì„¸ìš”&quot;);
</span><span class="boring">    let hello = String::from(&quot;ä½ å¥½&quot;);
</span><span class="boring">    let hello = String::from(&quot;OlÃ¡&quot;);
</span>    let hello = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Asked how long the string is, you might say 12. However, Rustâ€™s answer is 24:
thatâ€™s the number of bytes it takes to encode â€œĞ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€ in UTF-8, because
each Unicode scalar value in that string takes 2 bytes of storage. Therefore,
an index into the stringâ€™s bytes will not always correlate to a valid Unicode
scalar value. To demonstrate, consider this invalid Rust code:
-->
<p>Si vous vous demandez la longueur de la chaÃ®ne de caractÃ¨res, vous vous direz
probablement 12. Cependant, la rÃ©ponse de Rust sera 24Â : c'est le nombre
d'octets nÃ©cessaires pour encoder â€œĞ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€ en UTF-8, car chaque valeur
scalaire Unicode dans cette chaÃ®ne de caractÃ¨res prend 2 octets en mÃ©moire.
Par consÃ©quent, un indice dans les octets de la chaÃ®ne de caractÃ¨res ne
correspondra pas forcÃ©ment Ã  une valeur unicode valide. Pour dÃ©montrer cela,
utilisons ce code Rust invalideÂ :</p>
<!--
```rust,ignore,does_not_compile
let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
let answer = &hello[0];
```
-->
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
let answer = &amp;hello[0];
</code></pre>
<!--
What should the value of `answer` be? Should it be `Ğ—`, the first letter? When
encoded in UTF-8, the first byte of `Ğ—` is `208` and the second is `151`, so
`answer` should in fact be `208`, but `208` is not a valid character on its
own. Returning `208` is likely not what a user would want if they asked for the
first letter of this string; however, thatâ€™s the only data that Rust has at
byte index 0. Users generally donâ€™t want the byte value returned, even if the
string contains only Latin letters: if `&"hello"[0]` were valid code that
returned the byte value, it would return `104`, not `h`. To avoid returning an
unexpected value and causing bugs that might not be discovered immediately,
Rust doesnâ€™t compile this code at all and prevents misunderstandings early in
the development process.
-->
<p>Quelle sera la valeur de <code>answer</code>Â ? Est-ce que ce sera <code>Ğ—</code>, la premiÃ¨re
lettreÂ ?  Lorsqu'il est encodÃ© en UTF-8, le premier octet de <code>Ğ—</code> est <code>208</code> et
le second est <code>151</code>, donc en vÃ©ritÃ© <code>answer</code> vaudra <code>208</code>, mais <code>208</code> n'est pas
un caractÃ¨re valide Ã  lui seul. Renvoyer <code>208</code> n'est pas ce qu'un utilisateur
attend s'il demande la premiÃ¨re lettre de cette chaÃ®ne de caractÃ¨resÂ ;
cependant, c'est la seule valeur que Rust a Ã  l'indice 0 des octets. Les
utilisateurs ne souhaitent gÃ©nÃ©ralement pas obtenir la valeur en octets, mÃªme si
la chaÃ®ne de caractÃ¨res contient uniquement des lettres latinesÂ : si
<code>&amp;&quot;hello&quot;[0]</code> Ã©tait un code valide qui retournerait la valeur de l'octet, il
retournerait <code>104</code> et non pas <code>h</code>. Pour Ã©viter de retourner une valeur
inattendue et gÃ©nÃ©rer des bogues qui ne seraient pas dÃ©couverts immÃ©diatement,
Rust ne va pas compiler ce code et ainsi Ã©viter des erreurs dÃ¨s le dÃ©but du
processus de dÃ©veloppement.</p>
<!--
#### Bytes and Scalar Values and Grapheme Clusters! Oh My!
-->
<h4><a class="header" href="#les-valeurs-des-octets-et-des-scalaires-et-les-groupes-de-graphÃ¨mes-" id="les-valeurs-des-octets-et-des-scalaires-et-les-groupes-de-graphÃ¨mes-">Les valeurs des octets et des scalaires et les groupes de graphÃ¨mes !</a></h4>
<!--
Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rustâ€™s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call *letters*).
-->
<p>Un autre problÃ¨me avec l'UTF-8 est qu'il a en fait trois maniÃ¨res pertinentes
pour considÃ©rer les chaÃ®nes de caractÃ¨res avec RustÂ : comme des octets, comme
des valeurs scalaires et comme des groupes de graphÃ¨mes (la chose qui se
rapproche le plus de ce que nous pourrions appeler des <em>lettres</em>).</p>
<!--
If we look at the Hindi word â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:
-->
<p>Si l'on considÃ¨re le mot en Hindi â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ Ã©crit dans le style Devanagari, il est
stockÃ© comme un vecteur de valeurs <code>u8</code> qui sont les suivantsÂ :</p>
<!--
```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```
-->
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!--
Thatâ€™s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rustâ€™s `char` type is, those
bytes look like this:
-->
<p>Cela fait 18 octets et c'est ainsi que les ordinateurs stockeront cette donnÃ©e.
Si nous les voyons comme des valeurs scalaires Unicode, ce qu'est le type <code>char</code>
de Rust, ces octets seront les suivantsÂ :</p>
<!--
```text
['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
```
-->
<pre><code class="language-text">['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
</code></pre>
<!--
There are six `char` values here, but the fourth and sixth are not letters:
theyâ€™re diacritics that donâ€™t make sense on their own. Finally, if we look at
them as grapheme clusters, weâ€™d get what a person would call the four letters
that make up the Hindi word:
-->
<p>Nous avons six valeurs <code>char</code> ici, mais la quatriÃ¨me et sixiÃ¨me valeur ne sont
pas des lettresÂ : ce sont des signes diacritiques qui n'ont pas de sens employÃ©s seuls.
Enfin, si nous les voyons comme des groupes de graphÃ¨mes, on obtient ce qu'une
personne pourrait appeler les quatre lettres qui constituent le mot HindiÂ :</p>
<!--
```text
["à¤¨", "à¤®", "à¤¸à¥", "à¤¤à¥‡"]
```
-->
<pre><code class="language-text">[&quot;à¤¨&quot;, &quot;à¤®&quot;, &quot;à¤¸à¥&quot;, &quot;à¤¤à¥‡&quot;]
</code></pre>
<!--
Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.
-->
<p>Rust fournit diffÃ©rentes maniÃ¨res d'interprÃ©ter les donnÃ©es brutes des chaÃ®nes
de caractÃ¨res que les ordinateurs stockent afin que chaque programme puisse
choisir l'interprÃ©tation dont il a besoin, peu importe dans quel langage humain
sont les donnÃ©es.</p>
<!--
A final reason Rust doesnâ€™t allow us to index into a `String` to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isnâ€™t possible to guarantee that performance with a `String`,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.
-->
<p>Une derniÃ¨re raison pour laquelle Rust ne nous autorise pas Ã  indexer une
<code>String</code> comme caractÃ¨re est que les opÃ©rations d'indexation sont censÃ©s prendre
un temps constant (O(1)). Mais il n'est pas possible de garantir cette
performance avec une <code>String</code>, car Rust devrait parcourir le contenu depuis le
dÃ©but jusqu'Ã  l'indice pour dÃ©terminer combien il y a de caractÃ¨res valides.</p>
<!--
### Slicing Strings
-->
<h3><a class="header" href="#les-slices-de-chaÃ®nes-de-caractÃ¨res-1" id="les-slices-de-chaÃ®nes-de-caractÃ¨res-1">Les slices de chaÃ®nes de caractÃ¨res</a></h3>
<!--
Indexing into a string is often a bad idea because itâ€™s not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. Therefore, Rust asks you to
be more specific if you really need to use indices to create string slices. To
be more specific in your indexing and indicate that you want a string slice,
rather than indexing using `[]` with a single number, you can use `[]` with a
range to create a string slice containing particular bytes:
-->
<p>L'utilisation des indices sur une chaÃ®ne de caractÃ¨res est souvent une mauvaise
idÃ©e car le type de retour de l'opÃ©ration n'est pas toujours Ã©videntÂ : une
valeur en octets, en caractÃ¨res, un groupe de graphÃ¨mes, ou une slice de chaÃ®ne
de caractÃ¨res. C'est pourquoi Rust vous demande d'Ãªtre plus prÃ©cis si vous avez
vraiment besoin d'utiliser des indices pour crÃ©er un dÃ©oupage de chaÃ®ne de
caractÃ¨res. Afin d'Ãªtre plus prÃ©cis sur l'utilisation des indices et que vous
souhaitez obtenir une slice de chaine de caractÃ¨res, vous pouvez utiliser <code>[]</code>
avec une intervalle d'indices pour crÃ©er une slice de chaÃ®ne de caractÃ¨res
contenant des octets bien prÃ©cis, plutÃ´t que d'utiliser <code>[]</code> avec un seul
nombreÂ :</p>
<!--
```rust
let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";

let s = &hello[0..4];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `s` will be a `&str` that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
`s` will be `Ğ—Ğ´`.
-->
<p>Ici, <code>s</code> sera un <code>&amp;str</code> qui contiendra les 4 premiers octets de la chaine de
caractÃ¨res. PrÃ©cÃ©demment, nous avions mentionnÃ© que chacun de ces caractÃ¨res
Ã©taient encodÃ©s sur 2 octets, ce qui veut dire que <code>s</code> vaudra <code>Ğ—Ğ´</code>.</p>
<!--
What would happen if we used `&hello[0..1]`? The answer: Rust would panic at
runtime in the same way as if an invalid index were accessed in a vector:
-->
<p>Que se serait-il passÃ© si nous avions utilisÃ© <code>&amp;hello[0..1]</code>Â ? RÃ©ponseÂ : Rust
aurait paniquÃ© au moment de l'exÃ©cution de la mÃªme faÃ§on que si nous
utiliserions un indice invalide pour accÃ©der Ã  un Ã©lÃ©ment d'un vecteurÂ :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'Ğ—' (bytes 0..2) of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'Ğ—' (bytes 0..2) of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
You should use ranges to create string slices with caution, because doing so
can crash your program.
-->
<p>Vous devriez utiliser les intervalles pour crÃ©er des slices avec prudence, car
cela peut provoquer un plantage de votre programme.</p>
<!--
### Methods for Iterating Over Strings
-->
<h3><a class="header" href="#les-mÃ©thodes-pour-parcourir-les-chaÃ®nes-de-caractÃ¨res" id="les-mÃ©thodes-pour-parcourir-les-chaÃ®nes-de-caractÃ¨res">Les mÃ©thodes pour parcourir les chaÃ®nes de caractÃ¨res</a></h3>
<!--
Fortunately, you can access elements in a string in other ways.
-->
<p>Heureusement, il existe d'autres maniÃ¨res d'accÃ©der aux Ã©lÃ©ments d'une chaine
de caractÃ¨res.</p>
<!--
If you need to perform operations on individual Unicode scalar values, the best
way to do so is to use the `chars` method. Calling `chars` on â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ separates
out and returns six values of type `char`, and you can iterate over the result
to access each element:
-->
<p>Si vous avez besoin de faire des opÃ©rations sur les valeurs scalaires Unicodes
une par une, la meilleure faÃ§on de procÃ©der est d'utiliser la mÃ©thode <code>chars</code>.
Utiliser <code>chars</code> sur â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ sÃ©pare et retourne six valeurs de type <code>char</code>, et
vous pouvez itÃ©rer sur le rÃ©sultat pour accÃ©der sur chaque Ã©lÃ©mentÂ :</p>
<!--
```rust
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the following:
-->
<p>Ce code va afficher ceciÂ :</p>
<!--
```text
à¤¨
à¤®
à¤¸
à¥
à¤¤
à¥‡
```
-->
<pre><code class="language-text">à¤¨
à¤®
à¤¸
à¥
à¤¤
à¥‡
</code></pre>
<!--
The `bytes` method returns each raw byte, which might be appropriate for your
domain:
-->
<p>La mÃ©thode <code>bytes</code> va retourner chaque octet brut, ce qui sera peut-Ãªtre plus
utile selon ce que vous voulez faireÂ :</p>
<!--
```rust
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
    println!("{}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the 18 bytes that make up this `String`:
-->
<p>Ce code va imprimer les 18 octets qui constituent cette <code>String</code>Â :</p>
<!--
```text
224
164
// --snip--
165
135
```
-->
<pre><code class="language-text">224
164
// -- Ã©lÃ©ments masquÃ©s ici --
165
135
</code></pre>
<!--
But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.
-->
<p>Rappelez-vous bien que des valeurs scalaires Unicode peuvent Ãªtre constituÃ©es de
plus d'un octet.</p>
<!--
Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
[crates.io](https://crates.io/) if this is the functionality you need.
-->
<p>L'obtention des groupes de graphÃ¨mes Ã  partir des chaines de caractÃ¨res est
complexe, donc cette fonctionnalitÃ© n'est pas fournie par la bibliothÃ¨que
standard. Des crates sont disponibles sur <a href="https://crates.io/">crates.io</a> si
c'est la fonctionnalitÃ© dont vous avez besoin.</p>
<!--
### Strings Are Not So Simple
-->
<h3><a class="header" href="#les-chaÃ®nes-de-caractÃ¨res-ne-sont-pas-si-simples" id="les-chaÃ®nes-de-caractÃ¨res-ne-sont-pas-si-simples">Les chaÃ®nes de caractÃ¨res ne sont pas si simples</a></h3>
<!--
To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of `String` data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.
-->
<p>Pour rÃ©sumer, les chaÃ®nes de caractÃ¨res sont complexes. De nombreux langages
de programmation ont fait diffÃ©rents choix sur la faÃ§on de prÃ©senter cette
complexitÃ© aux dÃ©veloppeurs. Rust a choisi d'appliquer par dÃ©faut la gestion
rigoureuse des donnÃ©es de <code>String</code> pour tous les programmes Rust, ce qui veut
dire que les dÃ©veloppeurs doivent rÃ©flÃ©chir davantage Ã  la gestion des donnÃ©es
UTF-8. Ce compromis rÃ©vÃ¨le davantage la complexitÃ© des chaÃ®nes de caractÃ¨res par
rapport Ã  ce que les autres langages de programmation laissent paraÃ®tre, mais vous
Ã©vite d'avoir Ã  gÃ©rer plus tard dans votre cycle de dÃ©veloppement des erreurs Ã 
cause de caractÃ¨res non ASCII.</p>
<!--
Letâ€™s switch to something a bit less complex: hash maps!
-->
<p>Changeons maintenant pour quelque chose de moins complexe : les tables de
hachageÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/88">Pull Request</a>.</p>
</blockquote>
<!--
## Storing Keys with Associated Values in Hash Maps
-->
<h2><a class="header" href="#stocker-des-clÃ©s-associÃ©es-Ã -des-valeurs-dans-des-tables-de-hachage" id="stocker-des-clÃ©s-associÃ©es-Ã -des-valeurs-dans-des-tables-de-hachage">Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></h2>
<!--
The last of our common collections is the *hash map*. The type `HashMap<K, V>`
stores a mapping of keys of type `K` to values of type `V`. It does this via a
*hashing function*, which determines how it places these keys and values into
memory. Many programming languages support this kind of data structure, but
they often use a different name, such as hash, map, object, hash table,
dictionary, or associative array, just to name a few.
-->
<p>La derniÃ¨re des collections les plus courantes est la <em>table de hachage (hash
map)</em>. Le type <code>HashMap&lt;K, V&gt;</code> stocke une association de clÃ©s de type <code>K</code> Ã  des
valeurs de type <code>V</code>. Elle fait cela via une <em>fonction de hachage</em>, qui dÃ©termine
comment elle va ranger ces clÃ©s et valeurs dans la mÃ©moire. De nombreux langages
de programmation prennent en charge ce genre de structure de donnÃ©e, mais elles
ont souvent un nom diffÃ©rent, comme hash, map, object, hash table, dictionary,
ou associative array, pour n'en nommer que quelques-uns.</p>
<!--
Hash maps are useful when you want to look up data not by using an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each teamâ€™s score in a hash map in which
each key is a teamâ€™s name and the values are each teamâ€™s score. Given a team
name, you can retrieve its score.
-->
<p>Les tables de hachage sont utiles lorsque vous voulez rechercher des donnÃ©es non
pas en utilisant des indices, comme vous pouvez le faire avec les vecteurs, mais
en utilisant une clÃ© qui peut Ãªtre de n'importe quel type. Par exemple, dans un
jeu, vous pouvez consigner le score de chaque Ã©quipe dans une table de hachage
dans laquelle chaque clÃ© est le nom d'une Ã©quipe et la valeur est le score de
l'Ã©quipe. Lorsque vous utilisez le nom d'une Ã©quipe, vous pouvez rÃ©cupÃ©rer son
score.</p>
<!--
Weâ€™ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on `HashMap<K, V>` by the standard library.
As always, check the standard library documentation for more information.
-->
<p>Nous allons passer en revue l'API de base des tables de hachage dans cette
section, mais bien d'autres fonctionnalitÃ©s se cachent dans les fonctions
dÃ©finies sur <code>HashMap&lt;K, V&gt;</code> par la bibliothÃ¨que standard. Comme d'habitude,
regardez la documentation de la bibliothÃ¨que standard pour plus d'informations.</p>
<!--
### Creating a New Hash Map
-->
<h3><a class="header" href="#crÃ©er-une-nouvelle-table-de-hachage" id="crÃ©er-une-nouvelle-table-de-hachage">CrÃ©er une nouvelle table de hachage</a></h3>
<!--
You can create an empty hash map with `new` and add elements with `insert`. In
Listing 8-20, weâ€™re keeping track of the scores of two teams whose names are
Blue and Yellow. The Blue team starts with 10 points, and the Yellow team
starts with 50.
-->
<p>Vous pouvez crÃ©er une table de hachage vide avec <code>new</code> et ajouter des Ã©lÃ©ments
avec <code>insert</code>. Dans l'encart 8-20, nous consignons les scores des deux Ã©quipes
qui s'appellent Bleu et Jaune. L'Ã©quipe Bleu commence avec 10 points, et
l'Ã©quipe Jaune commence avec 50.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut points = HashMap::new();

    points.insert(String::from("Bleu"), 10);
    points.insert(String::from("Jaune"), 50);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut points = HashMap::new();

    points.insert(String::from(&quot;Bleu&quot;), 10);
    points.insert(String::from(&quot;Jaune&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-20: Creating a new hash map and inserting some
keys and values</span>
-->
<p><span class="caption">Encart 8-20Â : crÃ©ation d'une nouvelle table de hachage et
insertion de quelques clÃ©s et valeurs</span></p>
<!--
Note that we need to first `use` the `HashMap` from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so itâ€™s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; thereâ€™s no built-in macro to construct them, for example.
-->
<p>Notez que nous devons d'abord utiliser <code>use</code> sur <code>HashMap</code> de la partie des
collections de la bibliothÃ¨que standard. De nos trois collections courantes,
cette derniÃ¨re est la moins utilisÃ©e, donc elle n'est pas prÃ©sente dans les
fonctionnalitÃ©s importÃ©es automatiquement dans la portÃ©e par l'Ã©tape
prÃ©liminaire. Les tables de hachages sont aussi moins gÃ©rÃ©es par la bibliothÃ¨que
standard ; il n'y a pas de macro intÃ©grÃ©e pour les construire, par exemple.</p>
<!--
Just like vectors, hash maps store their data on the heap. This `HashMap` has
keys of type `String` and values of type `i32`. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.
-->
<p>Exactement comme les vecteurs, les tables de hachage stockent leurs donnÃ©es sur
le tas. Cette <code>HashMap</code> a des clÃ©s de type <code>String</code> et des valeurs de type
<code>i32</code>. Et comme les vecteurs, les tables de hachage sont homogÃ¨nesÂ : toutes les
clÃ©s doivent Ãªtre du mÃªme type, et toutes valeurs doivent aussi toutes Ãªtre du
mÃªme type.</p>
<!--
Another way of constructing a hash map is by using iterators and the `collect`
method on a vector of tuples, where each tuple consists of a key and its value.
Weâ€™ll be going into more detail about iterators and their associated methods in
the [â€Processing a Series of Items with Iteratorsâ€ section of Chapter
13][iterators]<!-- ignore -- >. The `collect` method gathers data into a number
of collection types, including `HashMap`. For example, if we had the team names
and initial scores in two separate vectors, we could use the `zip` method to
create a vector of tuples where â€œBlueâ€ is paired with 10, and so forth. Then we
could use the `collect` method to turn that vector of tuples into a hash map,
as shown in Listing 8-21.
-->
<p>Une autre faÃ§on de construire une table de hachage est d'utiliser les itÃ©rateurs
et la mÃ©thode <code>collect</code> sur un vecteur de tuples, oÃ¹ chaque tuple reprÃ©sente une
clÃ© et sa valeur. Nous aborderons les itÃ©rateurs et leurs mÃ©thodes associÃ©es
dans <a href="ch13-02-iterators.html">une section du chapitre 13</a><!-- ignore -->. La mÃ©thode
<code>collect</code> regroupe les donnÃ©es dans quelques types de collections, dont
<code>HashMap</code>. Par exemple, si nous avions les noms des Ã©quipes et les scores
initiaux dans deux vecteurs sÃ©parÃ©s, nous pourrions utiliser la mÃ©thode <code>zip</code>
pour crÃ©er un vecteur de tuples oÃ¹ â€œBleuâ€ est associÃ© Ã  10, et ainsi de suite.
Ensuite nous pourrions utiliser la mÃ©thode <code>collect</code> pour transformer ce vecteur
de tuples en table de hachage, comme nous l'avons fait dans l'encart 8-21.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let equipes = vec![String::from("Bleu"), String::from("Jaune")];
    let points_initiaux = vec![10, 50];

    let mut points: HashMap<_, _> =
        equipes.into_iter().zip(points_initiaux.into_iter()).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let equipes = vec![String::from(&quot;Bleu&quot;), String::from(&quot;Jaune&quot;)];
    let points_initiaux = vec![10, 50];

    let mut points: HashMap&lt;_, _&gt; =
        equipes.into_iter().zip(points_initiaux.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-21: Creating a hash map from a list of teams
and a list of scores</span>
-->
<p><span class="caption">Encart 8-21Â : crÃ©ation d'une table de hachage Ã  partir
d'une liste d'Ã©quipe et une liste de scores</span></p>
<!--
The type annotation `HashMap<_, _>` is needed here because itâ€™s possible to
`collect` into many different data structures and Rust doesnâ€™t know which you
want unless you specify. For the parameters for the key and value types,
however, we use underscores, and Rust can infer the types that the hash map
contains based on the types of the data in the vectors. In Listing 8-21, the
key type will be `String` and the value type will be `i32`, just as the types
were in Listing 8-20.
-->
<p>L'annotation de type <code>HashMap&lt;_, _&gt;</code> est nÃ©cessaire ici car <code>collect</code> peut
gÃ©nÃ©rer plusieurs types de structures de donnÃ©es et Rust ne sait pas celle que
vous souhaitez si vous ne le prÃ©cisez pas. Mais pour les paramÃ¨tres qui
correspondent aux types de clÃ©s et de valeur, nous utilisons des tirets bas, et
Rust peut dÃ©duire les types que la table de hachage contient en fonction des
types de donnÃ©es prÃ©sentes dans les vecteurs. Dans l'encart 8-21, le type de la
clÃ© doit Ãªtre une <code>String</code> et le type de la valeur doit Ãªtre un <code>i32</code>, tout
comme l'Ã©taient les types dans l'encart 8-20.</p>
<!--
### Hash Maps and Ownership
-->
<h3><a class="header" href="#les-tables-de-hachage-et-la-possession" id="les-tables-de-hachage-et-la-possession">Les tables de hachage et la possession</a></h3>
<!--
For types that implement the `Copy` trait, like `i32`, the values are copied
into the hash map. For owned values like `String`, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.
-->
<p>Pour les types qui implÃ©mentent le trait <code>Copy</code>, comme <code>i32</code>, les valeurs sont
copiÃ©es dans la table de hachage. Pour les valeurs qui sont possÃ©dÃ©es comme
<code>String</code>, les valeurs seront dÃ©placÃ©es et la table de hachage sera la
propriÃ©taire de ces valeurs, comme dÃ©montrÃ© dans l'encart 8-22.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let nom_champ = String::from("Couleur favorite");
    let valeur_champ = String::from("Bleu");
    
    let mut table = HashMap::new();
    table.insert(nom_champ, valeur_champ);
    // nom_champ et valeur_champ ne sont plus en vigueur Ã  partir d'ici, essayez de
    // les utiliser et vous verrez l'erreur du compilateur que vous obtiendrezÂ !
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let nom_champ = String::from(&quot;Couleur favorite&quot;);
    let valeur_champ = String::from(&quot;Bleu&quot;);
    
    let mut table = HashMap::new();
    table.insert(nom_champ, valeur_champ);
    // nom_champ et valeur_champ ne sont plus en vigueur Ã  partir d'ici, essayez de
    // les utiliser et vous verrez l'erreur du compilateur que vous obtiendrezÂ !
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-22: Showing that keys and values are owned by
the hash map once theyâ€™re inserted</span>
-->
<p><span class="caption">Encart 8-22Â : dÃ©monstration que les clÃ©s et les valeurs
sont possÃ©dÃ©es par la table de hachage une fois qu'elles sont insÃ©rÃ©es</span></p>
<!--
We arenâ€™t able to use the variables `field_name` and `field_value` after
theyâ€™ve been moved into the hash map with the call to `insert`.
-->
<p>Nous ne pouvons plus utiliser les variables <code>nom_champ</code> et <code>valeur_champ</code> aprÃ¨s
qu'elles aient Ã©tÃ© dÃ©placÃ©es dans la table de hachage lors de l'appel Ã 
<code>insert</code>.</p>
<!--
If we insert references to values into the hash map, the values wonâ€™t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. Weâ€™ll talk more about these issues in
the [â€œValidating References with
Lifetimesâ€][validating-references-with-lifetimes]<!-- ignore -- > section in
Chapter 10.
-->
<p>Si nous utilisons des rÃ©fÃ©rences vers les valeurs dans la table de hachage, les
valeurs ne vont pas Ãªtre dÃ©placÃ©es dans la table de hachage. Les valeurs sur
lesquelles elle pointe resteront en vigueur tant que la table de hachage le sera
aussi. Nous verrons ces problÃ©matiques dans
<a href="ch10-03-lifetime-syntax.html">une section du chapitre 10</a><!-- ignore -->.</p>
<!--
### Accessing Values in a Hash Map
-->
<h3><a class="header" href="#accÃ©der-aux-valeurs-dans-une-table-de-hachage" id="accÃ©der-aux-valeurs-dans-une-table-de-hachage">AccÃ©der aux valeurs dans une table de hachage</a></h3>
<!--
We can get a value out of the hash map by providing its key to the `get`
method, as shown in Listing 8-23.
-->
<p>Nous pouvons obtenir une valeur d'une table de hachage en donnant sa clÃ© Ã  la
mÃ©thode <code>get</code>, comme dans l'encart 8-23.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut points = HashMap::new();

    points.insert(String::from("Bleu"), 10);
    points.insert(String::from("Jaune"), 50);

    let nom_equipe = String::from("Bleu");
    let points_bleu = points.get(&nom_equipe);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut points = HashMap::new();

    points.insert(String::from(&quot;Bleu&quot;), 10);
    points.insert(String::from(&quot;Jaune&quot;), 50);

    let nom_equipe = String::from(&quot;Bleu&quot;);
    let points_bleu = points.get(&amp;nom_equipe);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-23: Accessing the score for the Blue team
stored in the hash map</span>
-->
<p><span class="caption">Encart 8-23Â : rÃ©cupÃ©ration du score de l'Ã©quipe <code>Bleu</code>,
stockÃ© dans la table de hachage</span></p>
<!--
Here, `score` will have the value thatâ€™s associated with the Blue team, and the
result will be `Some(&10)`. The result is wrapped in `Some` because `get`
returns an `Option<&V>`; if thereâ€™s no value for that key in the hash map,
`get` will return `None`. The program will need to handle the `Option` in one
of the ways that we covered in Chapter 6.
-->
<p>Dans notre cas, <code>score</code> aura la valeur qui est associÃ©e Ã  l'Ã©quipe <code>Bleu</code>, et le
rÃ©sultat sera <code>Some(&amp;10)</code>. Le rÃ©sultat est encapsulÃ© dans un <code>Some</code> car <code>get</code>
retourne une <code>Option&lt;&amp;V&gt;</code>Â : s'il n'y a pas de valeur pour cette clÃ© dans la
table de hachage, <code>get</code> va retourner <code>None</code>. Le programme doit gÃ©rer le <code>Option</code>
d'une des maniÃ¨res dont nous avons parlÃ© dans le chapitre 6.</p>
<!--
We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a `for` loop:
-->
<p>Nous pouvons itÃ©rer sur chaque paire de clÃ©/valeur dans une table de hachage de
la mÃªme maniÃ¨re que nous le faisons avec les vecteurs, en utilisant une boucle
<code>for</code>Â :</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut points = HashMap::new();

    points.insert(String::from("Bleu"), 10);
    points.insert(String::from("Jaune"), 50);

    for (clee, valeur) in &points {
        println!("{}Â : {}", clee, valeur);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut points = HashMap::new();

    points.insert(String::from(&quot;Bleu&quot;), 10);
    points.insert(String::from(&quot;Jaune&quot;), 50);

    for (clee, valeur) in &amp;points {
        println!(&quot;{}Â : {}&quot;, clee, valeur);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print each pair in an arbitrary order:
-->
<p>Ce code va afficher chaque paire dans un ordre arbitraireÂ :</p>
<!--
```text
Yellow: 50
Blue: 10
```
-->
<pre><code class="language-text">JauneÂ : 50
BleuÂ : 10
</code></pre>
<!--
### Updating a Hash Map
-->
<h3><a class="header" href="#modifier-une-table-de-hachage" id="modifier-une-table-de-hachage">Modifier une table de hachage</a></h3>
<!--
Although the number of keys and values is growable, each key can only have one
value associated with it at a time. When you want to change the data in a hash
map, you have to decide how to handle the case when a key already has a value
assigned. You could replace the old value with the new value, completely
disregarding the old value. You could keep the old value and ignore the new
value, only adding the new value if the key *doesnâ€™t* already have a value. Or
you could combine the old value and the new value. Letâ€™s look at how to do each
of these!
-->
<p>Bien que le nombre de clÃ©s et de valeurs puisse augmenter, chaque clÃ© peut
avoir seulement une seule valeur associÃ©e Ã  elle au mÃªme moment. Lorsque vous
souhaitez changer les donnÃ©es dans une table de donnÃ©es, vous devez choisir
comment gÃ©rer le cas lorsque une clÃ© a dÃ©jÃ  une valeur qui lui est dÃ©jÃ 
associÃ©e. Vous pouvez soit remplacer l'ancienne valeur avec la nouvelle valeur,
en ignorant complÃ¨tement l'ancienne valeur. Vous pouvez garder l'ancienne valeur
et ignorer la nouvelle valeur, en insÃ©rant la nouvelle valeur uniquement si la
clÃ© <em>n'a pas</em> dÃ©jÃ  une valeur. Ou vous pouvez fusionner l'ancienne valeur et la
nouvelle. DÃ©couvrons dÃ¨s maintenant comment faire chacune de ces actionsÂ !</p>
<!--
#### Overwriting a Value
-->
<h4><a class="header" href="#rÃ©Ã©crire-une-valeur" id="rÃ©Ã©crire-une-valeur">RÃ©Ã©crire une valeur</a></h4>
<!--
If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-24 calls `insert` twice, the hash map will
only contain one key/value pair because weâ€™re inserting the value for the Blue
teamâ€™s key both times.
-->
<p>Si nous ajoutons une clÃ© et une valeur dans une table de hachage et que nous
ajoutons Ã  nouveau la mÃªme clÃ© avec une valeur diffÃ©rente, la valeur associÃ©e
Ã  cette clÃ© sera remplacÃ©e. MÃªme si le code dans l'encart 8-24 appelle deux
fois <code>insert</code>, la table de hachage contiendra un seul couple de clÃ©/valeur car
nous ajoutons la valeur pour l'Ã©quipe <code>Bleu</code> Ã  deux reprises.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut points = HashMap::new();
    
    points.insert(String::from("Bleu"), 10);
    points.insert(String::from("Bleu"), 25);
    
    println!("{:?}", points);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut points = HashMap::new();
    
    points.insert(String::from(&quot;Bleu&quot;), 10);
    points.insert(String::from(&quot;Bleu&quot;), 25);
    
    println!(&quot;{:?}&quot;, points);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-24: Replacing a value stored with a particular
key</span>
-->
<p><span class="caption">Encart 8-24Â : remplacement d'une valeur stockÃ©e sous une
clÃ© spÃ©cifique</span></p>
<!--
This code will print `{"Blue": 25}`. The original value of `10` has been
overwritten.
-->
<p>Ce code va afficher <code>{&quot;Bleu&quot;: 25}</code>. La valeur initiale <code>10</code> a Ã©tÃ© remplacÃ©e.</p>
<!--
#### Only Inserting a Value If the Key Has No Value
-->
<h4><a class="header" href="#ajouter-une-valeur-seulement-si-la-clÃ©-na-pas-dÃ©jÃ -de-valeur" id="ajouter-une-valeur-seulement-si-la-clÃ©-na-pas-dÃ©jÃ -de-valeur">Ajouter une valeur seulement si la clÃ© n'a pas dÃ©jÃ  de valeur</a></h4>
<!--
Itâ€™s common to check whether a particular key has a value and, if it doesnâ€™t,
insert a value for it. Hash maps have a special API for this called `entry`
that takes the key you want to check as a parameter. The return value of the
`entry` method is an enum called `Entry` that represents a value that might or
might not exist. Letâ€™s say we want to check whether the key for the Yellow team
has a value associated with it. If it doesnâ€™t, we want to insert the value 50,
and the same for the Blue team. Using the `entry` API, the code looks like
Listing 8-25.
-->
<p>Il est courant de vÃ©rifier qu'une clÃ© spÃ©cifique a dÃ©jÃ  une valeur, et si ce
n'est pas le cas, de lui associer une valeur. Les tables de hachage ont une API
spÃ©cifique pour ce cas-lÃ  qui s'appelle <code>entry</code> et qui prend en paramÃ¨tre la
clÃ© que vous voulez vÃ©rifier. La valeur de retour de la mÃ©thode <code>entry</code> est une
Ã©numÃ©ration qui s'appelle <code>Entry</code> qui reprÃ©sente une valeur qui existe ou non.
Imaginons que nous souhaitons vÃ©rifier si la clÃ© pour l'Ã©quipe <code>Jaune</code> a une
valeur qui lui est associÃ©e. Si ce n'est pas le cas, nous voulons lui associer
la valeur 50, et faire de mÃªme pour l'Ã©quipe <code>Bleu</code>. En utilisant l'API <code>entry</code>,
ce code va ressembler Ã  l'encart 8-25.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut points = HashMap::new();
    points.insert(String::from("Bleu"), 10);

    points.entry(String::from("Jaune")).or_insert(50);
    points.entry(String::from("Bleu")).or_insert(50);

    println!("{:?}", points);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut points = HashMap::new();
    points.insert(String::from(&quot;Bleu&quot;), 10);

    points.entry(String::from(&quot;Jaune&quot;)).or_insert(50);
    points.entry(String::from(&quot;Bleu&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, points);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-25: Using the `entry` method to only insert if
the key does not already have a value</span>
-->
<p><span class="caption">Encart 8-25Â : utilisation de la mÃ©thode <code>entry</code> pour
ajouter la clÃ© uniquement si elle n'a pas dÃ©jÃ  de valeur associÃ©e</span></p>
<!--
The `or_insert` method on `Entry` is defined to return a mutable reference to
the value for the corresponding `Entry` key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.
-->
<p>La mÃ©thode <code>or_insert</code> sur <code>Entry</code> est conÃ§ue pour retourner une rÃ©fÃ©rence
mutable vers la valeur <code>Entry</code> pour la clÃ© correspondante si cette clÃ© existe,
et sinon, d'ajouter son paramÃ¨tre comme nouvelle valeur pour cette clÃ© et
retourner une rÃ©fÃ©rence mutable vers la nouvelle valeur. Cette technique est
plus propre que d'Ã©crire la logique nous-mÃªmes et, de plus, elle fonctionne
mieux avec le vÃ©rificateur d'emprunt.</p>
<!--
Running the code in Listing 8-25 will print `{"Yellow": 50, "Blue": 10}`. The
first call to `entry` will insert the key for the Yellow team with the value
50 because the Yellow team doesnâ€™t have a value already. The second call to
`entry` will not change the hash map because the Blue team already has the
value 10.
-->
<p>L'exÃ©cution du code de l'encart 8-25 va afficher <code>{&quot;Jaune&quot;: 50, &quot;Bleu&quot;: 10}</code>.
Le premier appel Ã  <code>entry</code> va ajouter la clÃ© pour l'Ã©quipe <code>Jaune</code> avec la
valeur <code>50</code> car l'Ã©quipe <code>Jaune</code> n'a pas encore de valeur. Le second appel Ã 
<code>entry</code> ne vas pas changer la table de hachage car l'Ã©quipe <code>Bleu</code> a dÃ©jÃ  la
valeur <code>10</code>.</p>
<!--
#### Updating a Value Based on the Old Value
-->
<h4><a class="header" href="#modifier-une-valeur-en-fonction-de-lancienne-valeur" id="modifier-une-valeur-en-fonction-de-lancienne-valeur">Modifier une valeur en fonction de l'ancienne valeur</a></h4>
<!--
Another common use case for hash maps is to look up a keyâ€™s value and then
update it based on the old value. For instance, Listing 8-26 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times weâ€™ve
seen that word. If itâ€™s the first time weâ€™ve seen a word, weâ€™ll first insert
the value 0.
-->
<p>Une autre utilisation courante avec les tables de hachage est de regarder la
valeur d'une clÃ© et ensuite la modifier en fonction de l'ancienne valeur. Par
exemple, l'encart 8-26 contient du code qui compte combien de fois chaque mot
apparaÃ®t dans du texte. Nous utilisons une table de hachage avec les mots comme
clÃ©s et nous incrÃ©mentons la valeur pour compter combien de fois nous avons vu
ce mot. Si c'est la premiÃ¨re fois que nous voyons un mot, nous allons insÃ©rer la
valeur <code>0</code>.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let texte = "bonjour le monde, magnifique monde";

    let mut tableau = HashMap::new();

    for mot in texte.split_whitespace() {
        let compteur = tableau.entry(mot).or_insert(0);
        *compteur += 1;
    }

    println!("{:?}", tableau);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let texte = &quot;bonjour le monde, magnifique monde&quot;;

    let mut tableau = HashMap::new();

    for mot in texte.split_whitespace() {
        let compteur = tableau.entry(mot).or_insert(0);
        *compteur += 1;
    }

    println!(&quot;{:?}&quot;, tableau);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-26: Counting occurrences of words using a hash
map that stores words and counts</span>
-->
<p><span class="caption">Encart 8-26Â : comptage des occurrences des mots en
utilisant une table de hachage qui stocke les mots et leur quantitÃ©</span></p>
<!--
This code will print `{"world": 2, "hello": 1, "wonderful": 1}`. The
`or_insert` method actually returns a mutable reference (`&mut V`) to the value
for this key. Here we store that mutable reference in the `count` variable, so
in order to assign to that value, we must first dereference `count` using the
asterisk (`*`). The mutable reference goes out of scope at the end of the `for`
loop, so all of these changes are safe and allowed by the borrowing rules.
-->
<p>Ce code va afficher <code>{&quot;monde&quot;: 2, &quot;bonjour&quot;: 1, &quot;magnifique&quot;: 1, &quot;le&quot;: 1}</code>. La
mÃ©thode <code>or_insert</code> retourne une rÃ©fÃ©rence mutable (<code>&amp;mut V</code>) vers la valeur de
cette clÃ©. Nous avons dÃ©cidÃ© de stocker la rÃ©fÃ©rence mutable dans la variable
<code>compteur</code>, donc pour affecter une valeur, nous devons d'abord dÃ©rÃ©fÃ©rencer
<code>compteur</code> en utilisant l'astÃ©risque (<code>*</code>). La rÃ©fÃ©rence mutable sort de la
portÃ©e Ã  la fin de la boucle <code>for</code>, donc tous ces changements sont sÃ»rs et
autorisÃ©s par les rÃ¨gles d'emprunt.</p>
<!--
### Hashing Functions
-->
<h3><a class="header" href="#fonctions-de-hachages" id="fonctions-de-hachages">Fonctions de hachages</a></h3>
<!--
By default, `HashMap` uses a â€œcryptographically strongâ€[^siphash] hashing
function that can provide resistance to Denial of Service (DoS) attacks. This
is not the fastest hashing algorithm available, but the trade-off for better
security that comes with the drop in performance is worth it. If you profile
your code and find that the default hash function is too slow for your
purposes, you can switch to another function by specifying a different
*hasher*. A hasher is a type that implements the `BuildHasher` trait. Weâ€™ll
talk about traits and how to implement them in Chapter 10. You donâ€™t
necessarily have to implement your own hasher from scratch;
[crates.io](https://crates.io/) has libraries shared by other Rust users that
provide hashers implementing many common hashing algorithms.
-->
<p>Par dÃ©faut, <code>HashMap</code> utilise une fonction de hachage
â€œrobuste cryptographiquementâ€<sup class="footnote-reference"><a href="#siphash">1</a></sup> qui rÃ©siste aux attaques par DÃ©ni de
Service (DoS). Ce n'est pas l'algorithme de hachage le plus rapide qui existe,
mais le compromis entre une meilleure sÃ©curitÃ© et la baisse de performances en
vaut la peine. Si vous analysez la performance de votre code et que vous vous
rendez compte que la fonction de hachage par dÃ©faut est trop lente pour vos
besoins, vous pouvez changer pour une autre fonction en spÃ©cifiant un <em>hacheur</em>
diffÃ©rent. Un hacheur est un type qui implÃ©mente le trait <code>BuildHasher</code>. Nous
verrons les traits et comment les implÃ©menter au chapitre 10. Vous n'avez pas
forcÃ©ment besoin d'implÃ©menter votre propre hacheur Ã  partir de zÃ©ro;
<a href="https://crates.io/">crates.io</a> hÃ©berge des bibliothÃ¨ques partagÃ©es par d'autres
utilisateurs de Rust qui fournissent de nombreux algorithmes de hachage
rÃ©pandus.</p>
<!--
[^siphash]: [https://www.131002.net/siphash/siphash.pdf](https://www.131002.net/siphash/siphash.pdf)
-->
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-7" id="rÃ©sumÃ©-7">RÃ©sumÃ©</a></h2>
<!--
Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:
-->
<p>Les vecteurs, String, et tables de hachage vont vous apporter de nombreuses
fonctionnalitÃ©s nÃ©cessaires Ã  vos programmes lorsque vous avez besoin de
stocker, accÃ©der, et modifier des donnÃ©es. Voici quelques exercices pour
lesquels vous Ãªtes maintenant en mesure de rÃ©soudreÂ :</p>
<!--
* Given a list of integers, use a vector and return the mean (the average
  value), median (when sorted, the value in the middle position), and mode (the
  value that occurs most often; a hash map will be helpful here) of the list.
* Convert strings to pig latin. The first consonant of each word is moved to
  the end of the word and â€œayâ€ is added, so â€œfirstâ€ becomes â€œirst-fay.â€ Words
  that start with a vowel have â€œhayâ€ added to the end instead (â€œappleâ€ becomes
  â€œapple-hayâ€). Keep in mind the details about UTF-8 encoding!
* Using a hash map and vectors, create a text interface to allow a user to add
  employee names to a department in a company. For example, â€œAdd Sally to
  Engineeringâ€ or â€œAdd Amir to Sales.â€ Then let the user retrieve a list of all
  people in a department or all people in the company by department, sorted
  alphabetically.
-->
<ul>
<li>A partir d'une liste d'entier, utiliser un vecteur et retourner la moyenne, la
mÃ©diane (la valeur au milieu lorsque la liste est triÃ©e), et la valeur modale
(la valeur qui apparaÃ®t le plus souventÂ ; une table de hachage sera utile dans
ce cas) de la liste.</li>
<li>Convertir des chaÃ®nes de caractÃ¨res en LouchÃ©bem. La premiÃ¨re syllabe de
chaque mot est dÃ©placÃ©e Ã  la fin du mot et un suffixe argotique et substituÃ©e
par un <code>l</code> (L minuscule), ainsi â€œbonjourâ€ devient â€œ<em>l</em>onjour<em>bem</em>â€. Les mots
qui commencent par un L ou une voyelle remplacent la syllabe suivante par un L
et rÃ©tablit en fin de mot la consonne initiale avec un suffixe libre. Et
gardez en tÃªte les dÃ©tails Ã  propos de l'encodage UTF-8Â !</li>
<li>En utilisant une table de hachage et des vecteurs, crÃ©ez une interface
textuelle pour permettre Ã  un utilisateur d'ajouter des noms d'employÃ©s dans
un dÃ©partement d'une entreprise. Par exemple, â€œAjouter Sally au Bureau
d'Etudesâ€ ou â€œAjouter Amir au Service Commercialâ€. Ensuite, donnez la
possibilitÃ© Ã  l'utilisateur de rÃ©cupÃ©rer une liste de toutes les personnes
dans un dÃ©partement, ou tout le monde dans l'entreprise triÃ© par dÃ©partement,
et classÃ©s dans l'ordre alphabÃ©tique dans tous les cas.</li>
</ul>
<!--
The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!
-->
<p>La documentation de l'API de la bibliothÃ¨que standard dÃ©crit les mÃ©thodes qu'ont
les vecteurs, chaÃ®nes de caractÃ¨res et tables de hachage, ce qui vous sera bien
utile pour mener Ã  bien ces exercicesÂ !</p>
<!--
Weâ€™re getting into more complex programs in which operations can fail, so, itâ€™s
a perfect time to discuss error handling. Weâ€™ll do that next!
-->
<p>Nous nous lanÃ§ons dans des programmes de plus en plus complexes dans lesquels
les opÃ©rations peuvent Ã©chouer, c'est donc le moment idÃ©al pour voir comment
bien gÃ©rer les erreurs. C'est que nous allons faire au prochain chapitreÂ !</p>
<!--
[iterators]: ch13-02-iterators.html
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--1" id="-attention-peinture-fraÃ®che--1">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/91">Pull Request</a>.</p>
</blockquote>
<!--
# Error Handling
-->
<h1><a class="header" href="#la-gestion-des-erreurs" id="la-gestion-des-erreurs">La gestion des erreurs</a></h1>
<!--
Rustâ€™s commitment to reliability extends to error handling. Errors are a fact
of life in software, so Rust has a number of features for handling situations
in which something goes wrong. In many cases, Rust requires you to acknowledge
the possibility of an error and take some action before your code will compile.
This requirement makes your program more robust by ensuring that youâ€™ll
discover errors and handle them appropriately before youâ€™ve deployed your code
to production!
-->
<p>L'engagement de Rust pour la fiabilitÃ© concerne aussi la gestion des erreurs.
Les erreurs font partie de la vie des programmes informatiques, c'est pourquoi
Rust a des fonctionnalitÃ©s pour gÃ©rer les situations dans lesquelles quelque
chose dÃ©rape. Dans de nombreux cas, Rust exige que vous anticipiez les erreurs
possibles et que vous preniez des dispositions avant de pouvoir compiler votre
code. Cette exigence rend votre programme plus rÃ©siliant en s'assurant que vous
dÃ©tectiez et gÃ©rez les erreurs correctement avant mÃªme que vous ne dÃ©ployez
votre code en productionÂ !</p>
<!--
Rust groups errors into two major categories: *recoverable* and *unrecoverable*
errors. For a recoverable error, such as a file not found error, itâ€™s
reasonable to report the problem to the user and retry the operation.
Unrecoverable errors are always symptoms of bugs, like trying to access a
location beyond the end of an array.
-->
<p>Rust classe les erreurs dans deux catÃ©gories principales : les erreurs
<em>rÃ©cupÃ©rables</em> et <em>irrÃ©cupÃ©rables</em>. Les erreurs rÃ©cupÃ©rables, comme lorsque un
fichier n'est pas trouvable, il est prÃ©fÃ©rable de signaler le problÃ¨me Ã 
l'utilisateur et de relancer l'opÃ©ration. Les erreurs irrÃ©cupÃ©rables sont
toujours des symptÃ´mes de bogues, comme essayer d'accÃ©der Ã  un Ã©lÃ©ment en dehors
de l'intervalle de donnÃ©es d'un tableau.</p>
<!--
Most languages donâ€™t distinguish between these two kinds of errors and handle
both in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have
exceptions. Instead, it has the type `Result<T, E>` for recoverable errors and
the `panic!` macro that stops execution when the program encounters an
unrecoverable error. This chapter covers calling `panic!` first and then talks
about returning `Result<T, E>` values. Additionally, weâ€™ll explore
considerations when deciding whether to try to recover from an error or to stop
execution.
-->
<p>La plupart des langages de programmation ne font pas de distinction entre ces
deux types d'erreurs et les gÃ¨rent de la mÃªme maniÃ¨re, en utilisant des
fonctionnalitÃ©s comme les exceptions. Rust n'a pas d'exception. Ã€ la place, il
a les types <code>Result&lt;T, E&gt;</code> pour les erreurs rÃ©cupÃ©rables, et la macro <code>panic!</code>
qui arrÃªte l'exÃ©cution quand le programme se heurte Ã  des erreurs
irrÃ©cupÃ©rables. Nous allons commencer ce chapitre par expliquer l'utilisation de
<code>panic!</code>, puis ensuite nous allons voir les valeurs de retour <code>Result&lt;T, E&gt;</code>. De
plus, nous allons voir les Ã©lÃ©ments Ã  prendre en compte pour dÃ©cider si nous
devons essayer de rattraper une erreur ou alors arrÃªter l'exÃ©cution.</p>
<!--
## Unrecoverable Errors with `panic!`
-->
<h2><a class="header" href="#les-erreurs-irrÃ©cupÃ©rables-avec-panic" id="les-erreurs-irrÃ©cupÃ©rables-avec-panic">Les erreurs irrÃ©cupÃ©rables avec <code>panic!</code></a></h2>
<!--
Sometimes, bad things happen in your code, and thereâ€™s nothing you can do about
it. In these cases, Rust has the `panic!` macro. When the `panic!` macro
executes, your program will print a failure message, unwind and clean up the
stack, and then quit. This most commonly occurs when a bug of some kind has
been detected and itâ€™s not clear to the programmer how to handle the error.
-->
<p>Parfois, des choses se passent mal dans votre code, et vous ne pouvez rien y
faire. Pour ces cas-lÃ , Rust a la macro <code>panic!</code>. Quand la macro <code>panic!</code>
s'exÃ©cute, votre programme va afficher un message d'erreur, dÃ©rouler et nettoyer
la pile, et ensuite fermer le programme. Cela se produit frÃ©quemment lorsqu'un
bogue a Ã©tÃ© dÃ©tectÃ©, et que le dÃ©veloppeur n'a pas su comment gÃ©rer cette
erreur.</p>
<!--
> ### Unwinding the Stack or Aborting in Response to a Panic
>
> By default, when a panic occurs, the program starts *unwinding*, which
> means Rust walks back up the stack and cleans up the data from each function
> it encounters. But this walking back and cleanup is a lot of work. The
> alternative is to immediately *abort*, which ends the program without
> cleaning up. Memory that the program was using will then need to be cleaned
> up by the operating system. If in your project you need to make the resulting
> binary as small as possible, you can switch from unwinding to aborting upon a
> panic by adding `panic = 'abort'` to the appropriate `[profile]` sections in
> your *Cargo.toml* file. For example, if you want to abort on panic in release
> mode, add this:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```
-->
<blockquote>
<h3><a class="header" href="#dÃ©rouler-la-pile-ou-abandonner-suite-Ã -un-panic" id="dÃ©rouler-la-pile-ou-abandonner-suite-Ã -un-panic">DÃ©rouler la pile ou abandonner suite Ã  un <code>panic!</code></a></h3>
<p>Par dÃ©faut, quand un <code>panic</code> se produit, le programme commence par
<em>dÃ©rouler</em>, ce qui veut dire que Rust retourne en arriÃ¨re dans la pile et
nettoie les donnÃ©es de chaque fonction qu'il rencontre sur son passage. Mais
cette marche arriÃ¨re et le nettoyage demande beaucoup de travail. Une
alternative est <em>d'abandonner</em> immÃ©diatement, ce qui arrÃªte le programme sans
nettoyage. La mÃ©moire qu'utilisait le programme va devoir ensuite Ãªtre
nettoyÃ©e par le systÃ¨me d'exploitation. Si dans votre projet vous avez besoin
de construire un exÃ©cutable le plus petit possible, vous pouvez changer du
dÃ©vidage Ã  l'abandon lors d'un panic en ajoutant <code>panic = 'abort'</code> aux
sections <code>[profile]</code> correspondantes dans votre fichier <em>Cargo.toml</em>. Par
exemple, si vous souhaitez abandonner lors d'un panic en mode release, ajoutez
ceciÂ :</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<!--
Letâ€™s try calling `panic!` in a simple program:
-->
<p>Essayons d'appeler <code>panic!</code> dans un programme simpleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic,panics
fn main() {
    panic!("crash and burn");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<!--
When you run the program, youâ€™ll see something like this:
-->
<p>Lorsque vous lancez le programme, vous allez voir quelque chose comme ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
The call to `panic!` causes the error message contained in the last two lines.
The first line shows our panic message and the place in our source code where
the panic occurred: *src/main.rs:2:5* indicates that itâ€™s the second line,
fifth character of our *src/main.rs* file.
-->
<p>L'utilisation de <code>panic!</code> dÃ©clenche le message d'erreur prÃ©sent dans les deux
derniÃ¨res lignes. La premiÃ¨re ligne affiche notre message associÃ© au panic et
l'emplacement dans notre code source oÃ¹ se produit le panicÂ : <em>src/main.rs:2:5</em>
indique que c'est la seconde ligne et cinquiÃ¨me caractÃ¨re de notre fichier
<em>src/main.rs</em>.</p>
<!--
In this case, the line indicated is part of our code, and if we go to that
line, we see the `panic!` macro call. In other cases, the `panic!` call might
be in code that our code calls, and the filename and line number reported by
the error message will be someone elseâ€™s code where the `panic!` macro is
called, not the line of our code that eventually led to the `panic!` call. We
can use the backtrace of the functions the `panic!` call came from to figure
out the part of our code that is causing the problem. Weâ€™ll discuss what a
backtrace is in more detail next.
-->
<p>Dans cet exemple, la ligne indiquÃ©e fait partie de notre code, et si nous
allons voir cette ligne, nous verrons l'appel Ã  la macro <code>panic!</code>. Dans d'autres
cas, l'appel de <code>panic!</code> pourrait se produire dans du code que notre
code utilise. Le nom du fichier et la ligne indiquÃ©e par le message d'erreur
sera alors du code de quelqu'un d'autre oÃ¹ la macro <code>panic!</code> est appelÃ©e, et non
pas la ligne de notre code qui nous a menÃ© Ã  cet appel de <code>panic!</code>. Nous pouvons
utiliser le re-traÃ§age des fonctions qui appellent le <code>panic!</code> pour comprendre
la partie de notre code qui pose problÃ¨me. Nous allons maintenant parler plus
en dÃ©tail de ce qu'est le re-traÃ§age.</p>
<!--
### Using a `panic!` Backtrace
-->
<h3><a class="header" href="#utiliser-le-re-traÃ§age-de-panic" id="utiliser-le-re-traÃ§age-de-panic">Utiliser le re-traÃ§age de <code>panic!</code></a></h3>
<!--
Letâ€™s look at another example to see what itâ€™s like when a `panic!` call comes
from a library because of a bug in our code instead of from our code calling
the macro directly. Listing 9-1 has some code that attempts to access an
element by index in a vector.
-->
<p>Analysons un autre exemple pour voir ce qui se passe lors d'un appel de
<code>panic!</code> qui se produit dans une bibliothÃ¨que Ã  cause d'un bug dans notre code plutÃ´t
qu'un appel Ã  la macro directement. L'encart 9-1 montre du code qui essaye
d'accÃ©der Ã  un Ã©lÃ©ment d'un vecteur via son indiceÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic,panics
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-1: Attempting to access an element beyond the
end of a vector, which will cause a call to `panic!`</span>
-->
<p><span class="caption">Encart 9-1 : tentative d'accÃ¨s Ã  un Ã©lÃ©ment qui dÃ©passe de
l'intervalle d'un vecteur, ce qui provoque un <code>panic!</code></span></p>
<!--
Here, weâ€™re attempting to access the 100th element of our vector (which is at
index 99 because indexing starts at zero), but it has only 3 elements. In this
situation, Rust will panic. Using `[]` is supposed to return an element, but if
you pass an invalid index, thereâ€™s no element that Rust could return here that
would be correct.
-->
<p>Ici, nous essayons d'accÃ©der au centiÃ¨me Ã©lÃ©ment de notre vecteur (qui est Ã 
l'indice 99 car l'indexation commence Ã  zÃ©ro), mais le vecteur a seulement trois
Ã©lÃ©ments. Dans ce cas, Rust va paniquer. Utiliser <code>[]</code> est censÃ© retourner
un Ã©lÃ©ment, mais si vous lui donnez un indice invalide, Rust ne pourra pas
retourner un Ã©lÃ©ment acceptable dans ce cas.</p>
<!--
In C, attempting to read beyond the end of a data structure is undefined
behavior. You might get whatever is at the location in memory that would
correspond to that element in the data structure, even though the memory
doesnâ€™t belong to that structure. This is called a *buffer overread* and can
lead to security vulnerabilities if an attacker is able to manipulate the index
in such a way as to read data they shouldnâ€™t be allowed to that is stored after
the data structure.
-->
<p>En C, tenter de lire en dehors de la fin d'une structure de donnÃ©e suit un
comportement non dÃ©fini. Vous pourriez rÃ©cupÃ©rer quelque chose Ã  l'emplacement
mÃ©moire demandÃ© qui pourrait correspondre Ã  l'Ã©lÃ©ment demandÃ© de la structure
de donnÃ©es, mÃªme si cette partie de la mÃ©moire n'appartient pas Ã  cette
structure de donnÃ©es. C'est ce qu'on appelle une <em>sur-lecture de tampon</em> et cela
peut mener Ã  une faille de sÃ©curitÃ© si un attaquant a la possibilitÃ© de contrÃ´ler
l'indice de telle maniÃ¨re qu'il puisse lire les donnÃ©es qui ne devraient pas
Ãªtre lisibles en dehors de la structure de donnÃ©es.</p>
<!--
To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesnâ€™t exist, Rust will stop execution and refuse to
continue. Letâ€™s try it and see:
-->
<p>Afin de protÃ©ger votre programme de ce genre de vulnÃ©rabilitÃ©, si vous essayez
de lire un Ã©lÃ©ment Ã  un indice qui n'existe pas, Rust va arrÃªter l'exÃ©cution et
refuser de continuer. Essayez et vous verrezÂ :</p>
<!--
```console
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
This error points at a file we didnâ€™t write, *libcore/slice/mod.rs*. Thatâ€™s the
implementation of `slice` in the Rust source code. The code that gets run when
we use `[]` on our vector `v` is in *libcore/slice/mod.rs*, and that is where
the `panic!` is actually happening.
-->
<p>Cette erreur se rÃ©fÃ¨re Ã  un fichier que nous n'avons pas Ã©crit,
<em>libcore/slice/mod.rs</em>. C'est l'implÃ©mentation de <code>slice</code> dans la bibliothÃ¨que
standard. Le code qui est lancÃ© quand nous utilisons <code>[]</code> sur notre vecteur <code>v</code>
est dans <em>libcore/slice/mod.rs</em>, et c'est ici que le <code>panic!</code> se produit dans
notre cas.</p>
<!--
The next note line tells us that we can set the `RUST_BACKTRACE` environment
variable to get a backtrace of exactly what happened to cause the error. A
*backtrace* is a list of all the functions that have been called to get to this
point. Backtraces in Rust work as they do in other languages: the key to
reading the backtrace is to start from the top and read until you see files you
wrote. Thatâ€™s the spot where the problem originated. The lines above the lines
mentioning your files are code that your code called; the lines below are code
that called your code. These lines might include core Rust code, standard
library code, or crates that youâ€™re using. Letâ€™s try getting a backtrace by
setting the `RUST_BACKTRACE` environment variable to any value except 0.
Listing 9-2 shows output similar to what youâ€™ll see.
-->
<p>La ligne suivante nous informe que nous pouvons rÃ©gler la variable
d'environnement <code>RUST_BACKTRACE</code> pour obtenir le re-traÃ§age de ce qui s'est
exactement passÃ© pour mener Ã  cette erreur. Un <em>re-traÃ§age</em> consiste Ã  lister
toutes les fonctions qui ont Ã©tÃ© appelÃ©es pour arriver jusqu'Ã  ce point. Avec
Rust, le re-traÃ§age fonctionne comme il le fait dans d'autres langagesÂ : le
secret pour lire le re-traÃ§age est de commencer d'en haut et lire jusqu'Ã  ce
que vous voyiez les fichiers que vous avez Ã©cris. C'est l'endroit oÃ¹ s'est
produit le problÃ¨me. Les lignes avant celle qui mentionne vos fichiers
reprÃ©sentent le code qu'Ã  appelÃ© votre codeÂ ; les lignes qui suivent
reprÃ©sentent le code qui a appelÃ© votre code. Ces lignes peuvent Ãªtre du code
du coeur de Rust, du code de la bibliothÃ¨que standard, ou des crates que vous
utilisez. Essayons d'obtenir un re-traÃ§age en rÃ©glant la variable
d'environnement <code>RUST_BACKTRACE</code> Ã  n'importe quelle valeur autre que 0. L'encart
9-2 nous montre un retour similaire Ã  ce que vous devriez voirÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-- >
-->
<!--
```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:84
   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt
             at src/libstd/sys_common/backtrace.rs:61
   4: core::fmt::ArgumentV1::show_usize
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1426
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:65
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:50
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:193
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:210
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:471
  11: rust_begin_unwind
             at src/libstd/panicking.rs:375
  12: core::panicking::panic_fmt
             at src/libcore/panicking.rs:84
  13: core::panicking::panic_bounds_check
             at src/libcore/panicking.rs:62
  14: <usize as core::slice::SliceIndex<[T]>>::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806
  15: core::slice::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2657
  16: <alloc::vec::Vec<T> as core::ops::index::Index<I>>::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/vec.rs:1871
  17: panic::main
             at src/main.rs:4
  18: std::rt::lang_start::{{closure}}
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  19: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:52
  20: std::panicking::try::do_call
             at src/libstd/panicking.rs:292
  21: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:78
  22: std::panicking::try
             at src/libstd/panicking.rs:270
  23: std::panic::catch_unwind
             at src/libstd/panic.rs:394
  24: std::rt::lang_start_internal
             at src/libstd/rt.rs:51
  25: std::rt::lang_start
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  26: panic::main
```
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:84
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:61
   4: core::fmt::ArgumentV1::show_usize
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1426
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:65
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:50
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:193
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:210
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:471
  11: rust_begin_unwind
             at src/libstd/panicking.rs:375
  12: core::panicking::panic_fmt
             at src/libcore/panicking.rs:84
  13: core::panicking::panic_bounds_check
             at src/libcore/panicking.rs:62
  14: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806
  15: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2657
  16: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/vec.rs:1871
  17: panic::main
             at src/main.rs:4
  18: std::rt::lang_start::{{closure}}
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  19: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:52
  20: std::panicking::try::do_call
             at src/libstd/panicking.rs:292
  21: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:78
  22: std::panicking::try
             at src/libstd/panicking.rs:270
  23: std::panic::catch_unwind
             at src/libstd/panic.rs:394
  24: std::rt::lang_start_internal
             at src/libstd/rt.rs:51
  25: std::rt::lang_start
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  26: panic::main
</code></pre>
<!--
<span class="caption">Listing 9-2: The backtrace generated by a call to
`panic!` displayed when the environment variable `RUST_BACKTRACE` is set</span>
-->
<p><span class="caption">Encart 9-2: le re-traÃ§age gÃ©nÃ©rÃ© par l'appel de <code>panic!</code>
est affichÃ© quand la variable d'environnement <code>RUST_BACKTRACE</code> est dÃ©finie
</span></p>
<!--
Thatâ€™s a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using `cargo build` or `cargo run` without the `--release` flag,
as we have here.
-->
<p>Cela fait beaucoup de contenu ! Ce que vous voyez sur votre machine
peut Ãªtre diffÃ©rent en fonction de votre systÃ¨me d'exploitation et de votre
version de Rust. Pour avoir le re-traÃ§age avec ces informations, les instructions
de dÃ©boguage doivent Ãªtre activÃ©es. Les instructions de dÃ©boguage sont activÃ©es
par dÃ©faut quand on utilise <code>cargo build</code> ou <code>cargo run</code> sans le drapeau
<code>--release</code>, comme c'est le cas ici.</p>
<!--
In the output in Listing 9-2, line 17 of the backtrace points to the line in
our project thatâ€™s causing the problem: line 4 of *src/main.rs*. If we donâ€™t
want our program to panic, the location pointed to by the first line mentioning
a file we wrote is where we should start investigating. In Listing 9-1, where
we deliberately wrote code that would panic in order to demonstrate how to use
backtraces, the way to fix the panic is to not request an element at index 99
from a vector that only contains 3 items. When your code panics in the future,
youâ€™ll need to figure out what action the code is taking with what values to
cause the panic and what the code should do instead.
-->
<p>Dans l'encart 9-2, la ligne 17 du re-traÃ§age nous montre la ligne de notre projet
qui provoque le problÃ¨meÂ : la ligne 4 de <em>src/main.rs</em>. Si nous ne voulons pas
que notre programme panique, le premier endroit que nous devrions inspecter est
l'emplacement citÃ© par la premiÃ¨re ligne qui mentionne du code que nous avons
Ã©crit. Dans l'encart 9-1, oÃ¹ nous avons dÃ©libÃ©rÃ©ment Ã©crit du code qui panique
dans le but de montrer comment utiliser le re-traÃ§age, la solution pour ne pas
paniquer est de ne pas demander l'Ã©lÃ©ment Ã  l'indice 99 Ã  un vecteur lorsqu'il
n'en contient que 3. A l'avenir quand votre code paniquera, vous aurez besoin de
prendre des dispositions dans votre code pour les valeurs qui font paniquer et
de coder quoi faire lorsque cela se produit.</p>
<!--
Weâ€™ll come back to `panic!` and when we should and should not use `panic!` to
handle error conditions in the [â€œTo `panic!` or Not to
`panic!`â€][to-panic-or-not-to-panic]<!-- ignore -- > section later in this
chapter. Next, weâ€™ll look at how to recover from an error using `Result`.
-->
<p>Nous reviendrons sur le cas du <code>panic!</code> et sur les cas oÃ¹ nous devrions et ne
devrions pas utiliser <code>panic!</code> pour gÃ©rer les conditions d'erreur plus tard
Ã  <a href="ch09-03-to-panic-or-not-to-panic.html">la fin de ce chapitre</a><!-- ignore -->. Pour le
moment, nous allons voir comment gÃ©rer une erreur en utilisant <code>Result</code>.</p>
<!--
[to-panic-or-not-to-panic]:
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--2" id="-attention-peinture-fraÃ®che--2">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/99">Pull Request</a>.</p>
</blockquote>
<!--
## Recoverable Errors with `Result`
-->
<h2><a class="header" href="#des-erreurs-rÃ©cupÃ©rables-avec-result" id="des-erreurs-rÃ©cupÃ©rables-avec-result">Des erreurs rÃ©cupÃ©rables avec <code>Result</code></a></h2>
<!--
Most errors arenâ€™t serious enough to require the program to stop entirely.
Sometimes, when a function fails, itâ€™s for a reason that you can easily
interpret and respond to. For example, if you try to open a file and that
operation fails because the file doesnâ€™t exist, you might want to create the
file instead of terminating the process.
-->
<p>La plupart des erreurs ne sont pas assez graves au point d'arrÃªter complÃ¨tement
le programme. Parfois, lorsque une fonction Ã©choue, c'est pour une raison que
vous pouvez facilement comprendre et agir en consÃ©quence. Par exemple, si vous
essayez d'ouvrir un fichier et que l'opÃ©ration Ã©choue parce que le fichier
n'existe pas, vous pourriez vouloir crÃ©er le fichier plutÃ´t que d'arrÃªter le
processus.</p>
<!--
Recall from [â€œHandling Potential Failure with the `Result`
Typeâ€][handle_failure]<!-- ignore -- > in Chapter 2 that the `Result` enum is
defined as having two variants, `Ok` and `Err`, as follows:
-->
<p>Souvenez-vous de la section
â€œ<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">GÃ©rer les erreurs potentielles avec le type <code>Result</code></a><!-- ignore -->â€
du chapitre 2 lorsque l'Ã©numÃ©ration <code>Result</code> pouvait avoir deux variantes, <code>Ok</code>
et <code>Err</code>, comme ci-dessousÂ :</p>
<!--
[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type
-->
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `T` and `E` are generic type parameters: weâ€™ll discuss generics in more
detail in Chapter 10. What you need to know right now is that `T` represents
the type of the value that will be returned in a success case within the `Ok`
variant, and `E` represents the type of the error that will be returned in a
failure case within the `Err` variant. Because `Result` has these generic type
parameters, we can use the `Result` type and the functions that the standard
library has defined on it in many different situations where the successful
value and error value we want to return may differ.
-->
<p>Le <code>T</code> et <code>E</code> sont des paramÃ¨tres de type gÃ©nÃ©riquesÂ : nous allons parler plus
en dÃ©tail des gÃ©nÃ©riques au chapitre 10. Tout ce que vous avez besoin de savoir
pour le moment, c'est que <code>T</code> reprÃ©sente le type de valeur imbriquÃ©e dans la
variante <code>Ok</code> qui sera retournÃ©e dans le cas d'un succÃ¨s, et <code>E</code> reprÃ©sente le
type d'erreur imbriquÃ©e dans la variante <code>Err</code> qui sera retournÃ©e dans le cas
d'un Ã©chec. Comme <code>Result</code> a ces types de paramÃ¨tres gÃ©nÃ©riques, nous pouvons
utiliser le type <code>Result</code> et les fonctions que la bibliothÃ¨que standard qui lui
ont Ã©tÃ© associÃ©es pour diffÃ©rentes situations oÃ¹ la valeur de succÃ¨s et la
valeur d'erreur peuvent Ãªtre diffÃ©rentes.</p>
<!--
Letâ€™s call a function that returns a `Result` value because the function could
fail. In Listing 9-3 we try to open a file.
-->
<p>Utilisons une fonction qui retourne une valeur de type <code>Result</code> car la fonction
peut Ã©chouer. Dans l'encart 9-3 nous essayons d'ouvrir un fichierÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-3: Opening a file</span>
-->
<p><span class="caption">Encart 9-3Â : ouverture d'un fichier</span></p>
<!--
How do we know `File::open` returns a `Result`? We could look at the [standard
library API documentation](../std/index.html)<!-- ignore -- >, or we could ask
the compiler! If we give `f` a type annotation that we know is *not* the return
type of the function and then try to compile the code, the compiler will tell
us that the types donâ€™t match. The error message will then tell us what the
type of `f` *is*. Letâ€™s try it! We know that the return type of `File::open`
isnâ€™t of type `u32`, so letâ€™s change the `let f` statement to this:
-->
<p>Comment savons-nous que <code>File::open</code> retourne un <code>Result</code>Â ? Nous pouvons
regarder la
<a href="https://doc.rust-lang.org/std/index.html">documentation de l'API de la bibliothÃ¨que standard</a><!-- ignore -->,
ou nous pouvons demander au compilateurÂ ! Si nous faisons une annotation de type
Ã  <code>f</code> dont nous savons que le type de retour de la fonction n'est <em>pas</em> correcte
et que nous essayons ensuite de compiler le code, le compilateur va nous dire
que les types ne correspondent pas. Le message d'erreur va ensuite nous dire
ensuite <em>quel est le type</em> de <code>f</code>. Essayons celaÂ ! Nous savons que le retour de
<code>File::open</code> n'est pas du type <code>u32</code>, alors essayons de changer l'instruction
<code>let f</code> par ceciÂ :</p>
<!--
```rust,ignore,does_not_compile
# use std::fs::File;
# 
# fn main() {
    let f: u32 = File::open("hello.txt");
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre>
<!--
Attempting to compile now gives us the following output:
-->
<p>La compilation nous donne maintenant le rÃ©sultat suivantÂ :</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 -- > src/main.rs:4:18
  |
4 |     let f: u32 = File::open("hello.txt");
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `std::result::Result<std::fs::File, std::io::Error>`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `std::result::Result&lt;std::fs::File, std::io::Error&gt;`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This tells us the return type of the `File::open` function is a `Result<T, E>`.
The generic parameter `T` has been filled in here with the type of the success
value, `std::fs::File`, which is a file handle. The type of `E` used in the
error value is `std::io::Error`.
-->
<p>Cela nous dit que le retour de la fonction <code>File::open</code> est du type
<code>Result&lt;T, E&gt;</code>. Le paramÃ¨tre gÃ©nÃ©rique <code>T</code> a Ã©tÃ© remplacÃ© dans ce cas par le
type en cas de succÃ¨s, <code>std::fs::File</code>, qui permet d'interagir avec le fichier.
Le <code>E</code> utilisÃ© pour la valeur d'erreur est du type <code>std::io::Error</code>.</p>
<!--
This return type means the call to `File::open` might succeed and return a file
handle that we can read from or write to. The function call also might fail:
for example, the file might not exist, or we might not have permission to
access the file. The `File::open` function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the `Result` enum
conveys.
-->
<p>Ce type de retour veut dire que l'appel Ã  <code>File::open</code> peut rÃ©ussir et nous
retourner un manipulateur de fichier qui peut nous permettre de le lire ou
l'Ã©crire. L'utilisation de cette fonction peut aussi Ã©chouerÂ : par exemple, le
fichier peut ne pas exister, ou nous n'avons pas le droit d'accÃ©der au fichier.
La fonction <code>File::open</code> doit avoir un moyen de nous dire si son utilisation a
rÃ©ussi ou Ã©chouÃ© et en mÃªme temps nous fournir soit le manipulateur de fichier
soit des informations sur l'erreur. C'est exactement ces informations que
l'Ã©numÃ©ration <code>Result</code> se charge de nous transmettre.</p>
<!--
In the case where `File::open` succeeds, the value in the variable `f` will be
an instance of `Ok` that contains a file handle. In the case where it fails,
the value in `f` will be an instance of `Err` that contains more information
about the kind of error that happened.
-->
<p>Dans le cas oÃ¹ <code>File::open</code> rÃ©ussit, la valeur que nous obtenons dans la
variable <code>f</code> sera une instance de <code>Ok</code> qui contiendra un manipulateur de
fichier. Dans le cas oÃ¹ cela Ã©choue, la valeur dans <code>f</code> sera une instance de
<code>Err</code> qui contiendra plus d'information sur le type d'erreur qui a eu lieu.</p>
<!--
We need to add to the code in Listing 9-3 to take different actions depending
on the value `File::open` returns. Listing 9-4 shows one way to handle the
`Result` using a basic tool, the `match` expression that we discussed in
Chapter 6.
-->
<p>Nous avons besoin d'ajouter diffÃ©rentes actions dans le code de l'encart 9-3 en
fonction de la valeur que <code>File::open</code> a retournÃ©. L'encart 9-4 montre une faÃ§on
de gÃ©rer <code>Result</code> en utilisant un outil basique, l'expression <code>match</code> que nous
avons vu au chapitre 6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; panic!(&quot;Erreur lors de l'ouverture du fichierÂ : {:?}&quot;, erreur),
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-4: Using a `match` expression to handle the
`Result` variants that might be returned</span>
-->
<p><span class="caption">Encart 9-4: utilisation de l'expression <code>match</code> pour
gÃ©rer les variantes que <code>Result</code> pourrait retourner</span></p>
<!--
Note that, like the `Option` enum, the `Result` enum and its variants have been
brought into scope by the prelude, so we donâ€™t need to specify `Result::`
before the `Ok` and `Err` variants in the `match` arms.
-->
<p>Remarquez que comme l'Ã©numÃ©ration <code>Option</code>, l'Ã©numÃ©ration <code>Result</code> et ses
variantes ont Ã©tÃ© importÃ©s par l'Ã©tape prÃ©liminaire, donc vous n'avez pas
besoin de prÃ©ciser <code>Result::</code> devant les variantes <code>Ok</code> et <code>Err</code> dans les
branches du <code>match</code>.</p>
<!--
Here we tell Rust that when the result is `Ok`, return the inner `file` value
out of the `Ok` variant, and we then assign that file handle value to the
variable `f`. After the `match`, we can use the file handle for reading or
writing.
-->
<p>Ici nous indiquons Ã  Rust que quand le rÃ©sultat est <code>Ok</code>, il faut sortir la
valeur <code>fichier</code> de la variante <code>Ok</code>, et nous assignons ensuite cette valeur Ã 
la variable <code>f</code>. AprÃ¨s le <code>match</code>, nous pourrons ensuite utiliser le
manipulateur de fichier pour lire ou Ã©crire.</p>
<!--
The other arm of the `match` handles the case where we get an `Err` value from
`File::open`. In this example, weâ€™ve chosen to call the `panic!` macro. If
thereâ€™s no file named *hello.txt* in our current directory and we run this
code, weâ€™ll see the following output from the `panic!` macro:
-->
<p>L'autre branche du bloc <code>match</code> gÃ¨re le cas oÃ¹ nous obtenons un <code>Err</code> Ã  l'appel
de <code>File::open</code>. Dans cet exemple, nous avons choisi de faire appel Ã  la macro
<code>panic!</code>. S'il n'y a pas de fichier qui s'appelle <em>hello.txt</em> dans notre
rÃ©pertoire actuel et que nous exÃ©cutons ce code, nous allons voir la sortie
suivante suite Ã  l'appel de la macro <code>panic!</code>Â :</p>
<!--
```text
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-text">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
As usual, this output tells us exactly what has gone wrong.
-->
<p>Comme d'habitude, cette sortie nous explique avec prÃ©cision ce qui s'est mal
passÃ©.</p>
<!--
### Matching on Different Errors
-->
<h3><a class="header" href="#tester-les-diffÃ©rentes-erreurs" id="tester-les-diffÃ©rentes-erreurs">Tester les diffÃ©rentes erreurs</a></h3>
<!--
The code in Listing 9-4 will `panic!` no matter why `File::open` failed. What
we want to do instead is take different actions for different failure reasons:
if `File::open` failed because the file doesnâ€™t exist, we want to create the
file and return the handle to the new file. If `File::open` failed for any
other reasonâ€”for example, because we didnâ€™t have permission to open the fileâ€”we
still want the code to `panic!` in the same way as it did in Listing 9-4. Look
at Listing 9-5, which adds an inner `match` expression.
-->
<p>Le code dans l'encart 9-4 va faire un <code>panic!</code> peu importe la raison de l'Ã©chec
de <code>File::open</code>. Ce que nous voudrions plutÃ´t faire est de rÃ©gir diffÃ©remment en
fonction de diffÃ©rents cas d'erreursÂ : si <code>File::open</code> a Ã©chouÃ© parce que le
fichier n'existe pas, nous voulons crÃ©er le fichier et renvoyer le manipulateur
de fichier pour ce nouveau fichier. Si <code>File::open</code> Ã©choue pour toute autre
raison, par exemple si nous n'avons pas l'autorisation d'ouvrir le fichier,
nous voulons quand mÃªme que le code lance un <code>panic!</code> de la mÃªme maniÃ¨re qu'il
l'a fait dans l'encart 9-4. Dans l'encart 9-5, nous avons ajoutÃ© un nouveau cas
au bloc <code>match</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -- >
-->
<!--
```rust,ignore
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}
```
-->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; match erreur.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Erreur lors de la crÃ©ation du fichierÂ : {:?}&quot;, e),
            },
            autre_erreur =&gt; panic!(&quot;Erreur lors de l'ouverture du fichierÂ : {:?}&quot;, autre_erreur),
        },
    };
}
</code></pre>
<!--
<span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span>
-->
<p><span class="caption">Encart 9-5Â : gestion des diffÃ©rents cas d'erreurs avec des
actions diffÃ©rentes.</span></p>
<!--
The type of the value that `File::open` returns inside the `Err` variant is
`io::Error`, which is a struct provided by the standard library. This struct
has a method `kind` that we can call to get an `io::ErrorKind` value. The enum
`io::ErrorKind` is provided by the standard library and has variants
representing the different kinds of errors that might result from an `io`
operation. The variant we want to use is `ErrorKind::NotFound`, which indicates
the file weâ€™re trying to open doesnâ€™t exist yet. So we match on `f`, but we
also have an inner match on `error.kind()`.
-->
<p>La valeur de retour de <code>File::open</code> logÃ©e dans la variante <code>Err</code> est de type
<code>io::Error</code>, qui est une structure fournie par la bibliothÃ¨que standard. Cette
structure a une mÃ©thode <code>kind</code> que nous pouvons utiliser pour obtenir un retour
de type <code>io::ErrorKind</code>. L'Ã©numÃ©ration <code>io::ErrorKind</code> est fournie elle aussi
par la bibliothÃ¨que standard qui embarque des variantes qui reprÃ©sentent
diffÃ©rents types d'erreurs qui pourraient rÃ©sulter d'une opÃ©ration provenant du
module <code>io</code>. La variante que nous voulons utiliser est <code>ErrorKind::NotFound</code>,
qui nous informe que le fichier que nous essayons d'ouvrir n'existe pas encore.
Donc nous utilisons <code>match</code> sur <code>f</code>, mais nous avons dans celle-ci une autre
<code>match</code> sur <code>erreur.kind()</code>.</p>
<!--
The condition we want to check in the inner match is whether the value returned
by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is,
we try to create the file with `File::create`. However, because `File::create`
could also fail, we need a second arm in the inner `match` expression. When the
file canâ€™t be created, a different error message is printed. The second arm of
the outer `match` stays the same, so the program panics on any error besides
the missing file error.
-->
<p>Nous souhaitons vÃ©rifier dans le <code>match</code> interne si la valeur de retour de
<code>error.kind()</code> est la variante <code>NotFound</code> de l'Ã©numÃ©ration <code>ErrorKind</code>. Si c'est
le cas, nous essayons de crÃ©er le fichier avec <code>File::create</code>. Cependant, comme
<code>File::create</code> peut aussi Ã©chouer, nous avons besoin d'une seconde branche dans
le <code>match</code> Ã  l'intÃ©rieur. Lorsque le fichier ne peut pas Ãªtre crÃ©Ã©, un message
d'erreur diffÃ©rent est affichÃ©. La seconde branche du <code>match</code> principal reste
inchangÃ©, donc le programme panique lorsqu'on rencontre une autre erreur que
l'absence de fichier.</p>
<!--
Thatâ€™s a lot of `match`! The `match` expression is very useful but also very
much a primitive. In Chapter 13, youâ€™ll learn about closures; the `Result<T,
E>` type has many methods that accept a closure and are implemented using
`match` expressions. Using those methods will make your code more concise. A
more seasoned Rustacean might write this code instead of Listing 9-5:
-->
<p>Cela commence Ã  faire beaucoup de <code>match</code>Â ! L'expression <code>match</code> est trÃ¨s utile
mais est aussi assez primitif. Dans le chapitre 13, vous allez en apprendre plus
sur les fermeturesÂ ; le type <code>Result&lt;T, E&gt;</code> a de nombreuses mÃ©thodes qui
acceptent une fermeture et qui sont implÃ©mentÃ©s en utilisant des expressions
<code>match</code>. L'utilisation de ces mÃ©thodes vont rendre votre code plus concis. Un
RustacÃ© plus habituÃ© Ã©crira ce code plutÃ´t que celui de l'encart 9-5Â :</p>
<!--
```rust,ignore
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```
-->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
        if erreur.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
                panic!(&quot;Erreur lors de la crÃ©ation du fichierÂ : {:?}&quot;, erreur);
            })
        } else {
            panic!(&quot;Erreur lors de l'ouverture du fichierÂ : {:?}&quot;, erreur);
        }
    });
}
</code></pre>
<!--
Although this code has the same behavior as Listing 9-5, it doesnâ€™t contain any
`match` expressions and is cleaner to read. Come back to this example after
youâ€™ve read Chapter 13, and look up the `unwrap_or_else` method in the standard
library documentation. Many more of these methods can clean up huge nested
`match` expressions when youâ€™re dealing with errors.
-->
<p>Bien que ce code ait le mÃªme comportement que celui de l'encart 9-5, il ne
contient aucune expression <code>match</code> et est plus facile Ã  lire. Revenez sur cet
exemple aprÃ¨s avoir lu le chapitre 13, et renseignez-vous sur la mÃ©thode
<code>unwrap_or_else</code> dans la documentation de la bibliothÃ¨que standard. De
nombreuses mÃ©thodes de ce type peuvent clarifier de grosses expressions <code>match</code>
lorsque vous traitez les erreurs.</p>
<!--
### Shortcuts for Panic on Error: `unwrap` and `expect`
-->
<h3><a class="header" href="#raccourci-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect" id="raccourci-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect">Raccourci pour faire un Panic lors d'une erreurÂ : <code>unwrap</code> et <code>expect</code></a></h3>
<!--
Using `match` works well enough, but it can be a bit verbose and doesnâ€™t always
communicate intent well. The `Result<T, E>` type has many helper methods
defined on it to do various tasks. One of those methods, called `unwrap`, is a
shortcut method that is implemented just like the `match` expression we wrote in
Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return
the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will
call the `panic!` macro for us. Here is an example of `unwrap` in action:
-->
<p>L'utilisation de <code>match</code> fonctionne assez bien, mais elle peut Ãªtre un peu
verbeuse et ne communique pas forcÃ©ment bien son intention. Le type
<code>Result&lt;T, R&gt;</code> a de nombreuses mÃ©thodes qui lui ont Ã©tÃ© dÃ©finies pour diffÃ©rents
cas. Une de ces mÃ©thodes, qui s'appelle <code>unwrap</code>, a Ã©tÃ© implÃ©mentÃ©e comme
l'expression <code>match</code> que nous avons Ã©crit dans l'encart 9-4. Si la valeur de
<code>Result</code> est une variante de <code>Ok</code>, <code>unwrap</code> va retourner la valeur dans le
<code>Ok</code>. Si le <code>Result</code> est une variante de <code>Err</code>, <code>unwrap</code> va appeler la macro
<code>panic!</code> pour nous. Voici un exemple de <code>unwrap</code> Ã  l'actionÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<!--
If we run this code without a *hello.txt* file, weâ€™ll see an error message from
the `panic!` call that the `unwrap` method makes:
-->
<p>Si nous exÃ©cutons ce code sans le fichier <em>hello.txt</em>, nous allons voir un
message d'erreur suite Ã  l'appel Ã  <code>panic!</code> que la mÃ©thode <code>unwrap</code> a faitÂ :</p>
<!--
```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: "No such file or directory" } }',
src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<!--
Another method, `expect`, which is similar to `unwrap`, lets us also choose the
`panic!` error message. Using `expect` instead of `unwrap` and providing good
error messages can convey your intent and make tracking down the source of a
panic easier. The syntax of `expect` looks like this:
-->
<p>L'autre mÃ©thode, <code>expect</code>, qui ressemble Ã  <code>unwrap</code>, nous donne la possibilitÃ©
de dÃ©finir le message d'erreur du <code>panic!</code>. Utiliser <code>expect</code> plutÃ´t que
<code>unwrap</code> et lui fournir un bon message d'erreur permet de mieux exprimer le
problÃ¨me et faciliter la recherche de la source d'erreur. La syntaxe de <code>expect</code>
est la suivanteÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Echec Ã  l'ouverture de hello.txt&quot;);
}
</code></pre></pre>
<!--
We use `expect` in the same way as `unwrap`: to return the file handle or call
the `panic!` macro. The error message used by `expect` in its call to `panic!`
will be the parameter that we pass to `expect`, rather than the default
`panic!` message that `unwrap` uses. Hereâ€™s what it looks like:
-->
<p>Nous utilisons <code>expect</code> de la mÃªme maniÃ¨re que <code>unwrap</code>Â : pour retourner le
manipulateur de fichier ou appeler la macro <code>panic!</code>. Le message d'erreur
utilisÃ© par <code>expect</code> lors de son appel au <code>panic!</code> sera le paramÃ¨tre que nous
avons passÃ© Ã  <code>expect</code>, plutÃ´t que le message par dÃ©faut de <code>panic!</code>
qu'utilise <code>unwrap</code>. Voici ce que cela donneÂ :</p>
<!--
```text
thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: "No such file or directory" } }', src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at 'Echec Ã  l'ouverture de hello.txt: Error { repr: Os {
code: 2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<!--
Because this error message starts with the text we specified, `Failed to open
hello.txt`, it will be easier to find where in the code this error message is
coming from. If we use `unwrap` in multiple places, it can take more time to
figure out exactly which `unwrap` is causing the panic because all `unwrap`
calls that panic print the same message.
-->
<p>Comme ce message d'erreur commence par le texte que nous avons prÃ©cisÃ©, <code>Echec Ã  l'ouverture de hello.txt</code>, ce sera plus facile de trouver oÃ¹ se situe ce message
d'erreur dans le code. Si nous utilisons <code>unwrap</code> Ã  plusieurs endroits, cela
peut prendre plus de temps de comprendre exactement quel <code>unwrap</code> a causÃ© la
panique, car tous les appels aux <code>unwrap</code> vont afficher le mÃªme message.</p>
<!--
### Propagating Errors
-->
<h3><a class="header" href="#propager-les-erreurs" id="propager-les-erreurs">Propager les Erreurs</a></h3>
<!--
When youâ€™re writing a function whose implementation calls something that might
fail, instead of handling the error within this function, you can return the
error to the calling code so that it can decide what to do. This is known as
*propagating* the error and gives more control to the calling code, where there
might be more information or logic that dictates how the error should be
handled than what you have available in the context of your code.
-->
<p>Lorsque vous Ã©crivez une fonction dont l'implÃ©mentation utilise quelque chose
qui peut Ã©chouer, au lieu de gÃ©rer l'erreur dans cette fonction, vous pouvez
retourner cette erreur au code qui l'appelle pour qu'il dÃ©cide quoi faire. C'est
ce que l'on appelle <em>propager</em> l'erreur et donne ainsi plus de contrÃ´le au code
qui appelle la fonction, dans lequel il peut y avoir plus d'informations ou
d'instructions pour traiter l'erreur que dans le contexte de votre code.</p>
<!--
For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesnâ€™t exist or canâ€™t be read, this function will return those errors
to the code that called this function.
-->
<p>Par exemple, l'encart 9-6 montre une fonction qui lit le nom d'utilisateur Ã 
partir d'un fichier. Si ce fichier n'existe pas ou ne peut pas Ãªtre lu, cette
fonction va retourner ces erreurs au code qui a appelÃ© cette fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-6: A function that returns errors to the
calling code using `match`</span>
-->
<p><span class="caption">Encart 9-6Â : une fonction qui retourne les erreurs au
code qui l'appelle en utilisant <code>match</code></span></p>
<!--
This function can be written in a much shorter way, but weâ€™re going to start by
doing a lot of it manually in order to explore error handling; at the end,
weâ€™ll show the shorter way. Letâ€™s look at the return type of the function first:
`Result<String, io::Error>`. This means the function is returning a value of
the type `Result<T, E>` where the generic parameter `T` has been filled in
with the concrete type `String` and the generic type `E` has been filled in
with the concrete type `io::Error`. If this function succeeds without any
problems, the code that calls this function will receive an `Ok` value that
holds a `String`â€”the username that this function read from the file. If this
function encounters any problems, the code that calls this function will
receive an `Err` value that holds an instance of `io::Error` that contains
more information about what the problems were. We chose `io::Error` as the
return type of this function because that happens to be the type of the error
value returned from both of the operations weâ€™re calling in this functionâ€™s
body that might fail: the `File::open` function and the `read_to_string`
method.
-->
<p>Cette fonction peut Ãªtre Ã©crite de faÃ§on plus concise, mais nous avons dÃ©cidÃ© de
commencer par faire un maximum de choses manuellement pour dÃ©couvrir la gestion
d'erreursÂ ; mais Ã  la fin, nous verrons comment raccourcir le code. CommenÃ§ons par
regarder le type de retour de la fonctionÂ : <code>Result&lt;String, io::Error&gt;</code>. Cela
signifie que la fonction retourne une valeur de type <code>Result&lt;T, E&gt;</code> oÃ¹ le
paramÃ¨tre gÃ©nÃ©rique <code>T</code> a Ã©tÃ© remplacÃ© par le type <code>String</code> et le paramÃ¨tre
gÃ©nÃ©rique <code>E</code> a Ã©tÃ© remplacÃ© par le type <code>io::Error</code>. Si cette fonction rÃ©ussit
avec succÃ¨s, le code qui appelle cette fonction va obtenir une valeur <code>Ok</code> qui
contient un <code>String</code>, le nom d'utilisateur que cette fonction lit dans le
fichier. Si cette fonction rencontre un problÃ¨me, le code qui appelle cette
fonction va obtenir une valeur <code>Err</code> qui contient une instance de <code>io::Error</code>
qui donne plus d'informations sur la raison du problÃ¨me. Nous avons choisi
<code>io::Error</code> comme type de retour de cette fonction parce qu'il se trouve que
c'est le type d'erreur de retour pour toutes les opÃ©rations qui peuvent Ã©chouer
que l'on utilise dans le corps de cette fonctionÂ : la fonction <code>File::open</code> et
la mÃ©thode <code>read_to_string</code>.</p>
<!--
The body of the function starts by calling the `File::open` function. Then we
handle the `Result` value returned with a `match` similar to the `match` in
Listing 9-4, only instead of calling `panic!` in the `Err` case, we return
early from this function and pass the error value from `File::open` back to the
calling code as this functionâ€™s error value. If `File::open` succeeds, we store
the file handle in the variable `f` and continue.
-->
<p>Le corps de la fonction commence par appeler la fonction <code>File::open</code>. Ensuite,
nous gÃ©rons la valeur <code>Result</code> retournÃ©, avec un <code>match</code> similaire au <code>match</code>
dans l'encart 9-4, mais, au lieu d'appeler <code>panic!</code> dans le cas de <code>Err</code>, nous
retournons prÃ©maturÃ©ment le rÃ©sultat de la fonction avec la valeur d'erreur de
<code>File::open</code> au code appelant avec la valeur d'erreur de cette fonction. Si
<code>File::open</code> rÃ©ussit, nous enregistrons le manipulateur de fichier dans la
variable <code>f</code> et nous continuons.</p>
<!--
Then we create a new `String` in variable `s` and call the `read_to_string`
method on the file handle in `f` to read the contents of the file into `s`. The
`read_to_string` method also returns a `Result` because it might fail, even
though `File::open` succeeded. So we need another `match` to handle that
`Result`: if `read_to_string` succeeds, then our function has succeeded, and we
return the username from the file thatâ€™s now in `s` wrapped in an `Ok`. If
`read_to_string` fails, we return the error value in the same way that we
returned the error value in the `match` that handled the return value of
`File::open`. However, we donâ€™t need to explicitly say `return`, because this
is the last expression in the function.
-->
<p>Ensuite, nous crÃ©ons un nouveau <code>String</code> dans la variable <code>s</code> et nous appelons
la mÃ©thode <code>read_to_string</code> sur le manipulateur de fichier <code>f</code> pour extraire le
contenu du fichier dans <code>s</code>. La mÃ©thode <code>read_to_string</code> retourne aussi un
<code>Result</code> car elle peut Ã©chouer, mÃªme si <code>File::open</code> rÃ©ussit. Nous avons donc
besoin d'un nouveau <code>match</code> pour gÃ©rer ce <code>Result</code>Â : si <code>read_to_string</code>
rÃ©ussit, alors notre fonction a rÃ©ussi, et nous retournons le nom d'utilisateur
prÃ©sent dans le contenu du fichier qui est maintenant intÃ©grÃ© dans un <code>Ok</code>,
lui-mÃªme stockÃ© dans <code>s</code>. Si <code>read_to_string</code> Ã©choue, nous retournons la valeur
d'erreur de la mÃªme faÃ§on que nous avons retournÃ© la valeur d'erreur dans le
<code>match</code> qui gÃ©rait la valeur de retour de <code>File::open</code>. Cependant, nous n'avons
pas besoin d'Ã©crire explicitement <code>return</code>, car c'est la derniÃ¨re expression
de la fonction.</p>
<!--
The code that calls this code will then handle getting either an `Ok` value
that contains a username or an `Err` value that contains an `io::Error`. We
donâ€™t know what the calling code will do with those values. If the calling code
gets an `Err` value, it could call `panic!` and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We donâ€™t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.
-->
<p>Le code qui appelle ce code va devoir ensuite gÃ©rer les cas oÃ¹ il rÃ©cupÃ¨re une
valeur <code>Ok</code> qui contient un nom d'utilisateur, ou une valeur <code>Err</code> qui contient
une <code>io::Error</code>. Nous ne savons pas ce que va faire le code appelant avec ces
valeurs. Si le code appelant obtient une valeur <code>Err</code>, il peut appeler <code>panic!</code>
et faire planter le programme, utiliser un nom d'utilisateur par dÃ©faut, ou
chercher le nom d'utilisateur autre part que dans ce fichier, par exemple. Nous
n'avons pas assez d'informations sur ce que le code appelant a l'intention de
faire, donc nous remontons toutes les informations de succÃ¨s ou d'erreur vers le
haut pour qu'elles soient gÃ©rÃ©es correctement.</p>
<!--
This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator `?` to make this easier.
-->
<p>Cette faÃ§on de propager les erreurs est si courante en Rust que Rust fournit
l'opÃ©rateur du point d'interrogation <code>?</code> pour faciliter ceci.</p>
<!--
#### A Shortcut for Propagating Errors: the `?` Operator
-->
<h4><a class="header" href="#un-raccourci-pour-propager-les-erreurs--lopÃ©rateur-" id="un-raccourci-pour-propager-les-erreurs--lopÃ©rateur-">Un raccourci pour propager les erreursÂ : l'opÃ©rateur <code>?</code></a></h4>
<!--
Listing 9-7 shows an implementation of `read_username_from_file` that has the
same functionality as it had in Listing 9-6, but this implementation uses the
`?` operator.
-->
<p>L'encart 9-7 montre une implÃ©mentation de <code>read_username_from_file</code> qui a les
mÃªmes fonctionnalitÃ©s qu'elle a dans l'encart 9-6, mais cette implÃ©mentation
utilise l'opÃ©rateur point d'interrogationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-7: A function that returns errors to the
calling code using the `?` operator</span>
-->
<p><span class="caption">Encart 9-7Â : une fonction qui retourne les erreurs au code
appelant en utilisant l'opÃ©rateur <code>?</code></span></p>
<!--
The `?` placed after a `Result` value is defined to work in almost the same way
as the `match` expressions we defined to handle the `Result` values in Listing
9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will
get returned from this expression, and the program will continue. If the value
is an `Err`, the `Err` will be returned from the whole function as if we had
used the `return` keyword so the error value gets propagated to the calling
code.
-->
<p>Le <code>?</code> placÃ© aprÃ¨s une valeur <code>Result</code> est conÃ§u pour fonctionner presque de la
mÃªme maniÃ¨re que les expressions <code>match</code> que nous avons dÃ©fini pour gÃ©rer les
valeurs <code>Result</code> dans l'encart 9-6. Si la valeur du <code>Result</code> est un <code>Ok</code>, la
valeur dans le <code>Ok</code> sera retournÃ©e par cette expression et le programme
continuera. Si la valeur est une <code>Err</code>, la <code>Err</code> sera retournÃ©e par la fonction
comme si nous avions utilisÃ© le mot-clÃ© <code>result</code> afin que la valeur d'erreur
soit propagÃ©e au code appelant.</p>
<!--
There is a difference between what the `match` expression from Listing 9-6 does
and what the `?` operator does: error values that have the `?` operator called
on them go through the `from` function, defined in the `From` trait in the
standard library, which is used to convert errors from one type into another.
When the `?` operator calls the `from` function, the error type received is
converted into the error type defined in the return type of the current
function. This is useful when a function returns one error type to represent all
the ways a function might fail, even if parts might fail for many different
reasons. As long as each error type implements the `from` function to define how
to convert itself to the returned error type, the `?` operator takes care of the
conversion automatically.
-->
<p>Il y a une diffÃ©rence entre ce que fait l'expression <code>match</code> de l'encart 9-6 et
ce que fait l'opÃ©rateur <code>?</code>Â : les valeurs d'erreurs sur lesquelles sont
utilisÃ©es l'opÃ©rateur <code>?</code> passent par la fonction <code>from</code>, dÃ©finie dans le trait
<code>From</code> de la bibliothÃ¨que standard, qui est utilisÃ©e pour convertir les erreurs
d'un type Ã  un autre. Lorsque l'opÃ©rateur <code>?</code> utilise la fonction <code>from</code>, le
type d'erreur reÃ§u est converti dans le type d'erreur dÃ©clarÃ© dans le type de
retour de la fonction concernÃ©e. C'est utile lorsque une fonction retourne un
type d'erreur qui peut couvrir tous les cas d'Ã©chec de la fonction, mÃªme si
certaines de ses parties peuvent Ã©chouer pour diffÃ©rentes raisons. A partir du
moment que chaque type d'erreur implÃ©mente la fonction <code>from</code> pour expliquer
comment se convertir elle-mÃªme dans le type d'erreur retournÃ©, l'opÃ©rateur <code>?</code>
se charge de faire la conversion automatiquement.</p>
<!--
In the context of Listing 9-7, the `?` at the end of the `File::open` call will
return the value inside an `Ok` to the variable `f`. If an error occurs, the
`?` operator will return early out of the whole function and give any `Err`
value to the calling code. The same thing applies to the `?` at the end of the
`read_to_string` call.
-->
<p>Dans le cas de l'encart 9-7, le <code>?</code> Ã  la fin de l'appel Ã  <code>File::open</code> va
retourner la valeur Ã  l'intÃ©rieur d'un <code>Ok</code> Ã  la variable <code>f</code>. Si une erreur se
produit, l'opÃ©rateur <code>?</code> va retourner prÃ©maturÃ©ment la fonction et fournir une
valeur <code>Err</code> au code appelant. La mÃªme chose se produira au <code>?</code> Ã  ma fin de
l'appel Ã  <code>read_to_string</code>.</p>
<!--
The `?` operator eliminates a lot of boilerplate and makes this functionâ€™s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the `?`, as shown in Listing 9-8.
-->
<p>L'opÃ©rateur <code>?</code> Ã©pargne de l'Ã©criture de code et facilite l'implÃ©mentation de la
fonction. Nous pouvons mÃªme encore plus rÃ©duire ce code en enchaÃ®nant
immÃ©diatement les appels aux mÃ©thodes aprÃ¨s le <code>?</code> comme dans l'encart 9-8Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-8: Chaining method calls after the `?`
operator</span>
-->
<p><span class="caption">Encart 9-8Â : enchaÃ®nement des appels aux mÃ©thodes aprÃ¨s
l'opÃ©rateur <code>?</code></span></p>
<!--
Weâ€™ve moved the creation of the new `String` in `s` to the beginning of the
function; that part hasnâ€™t changed. Instead of creating a variable `f`, weâ€™ve
chained the call to `read_to_string` directly onto the result of
`File::open("hello.txt")?`. We still have a `?` at the end of the
`read_to_string` call, and we still return an `Ok` value containing the
username in `s` when both `File::open` and `read_to_string` succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.
-->
<p>Nous avons dÃ©placÃ© la crÃ©ation de la nouvelle <code>String</code> dans <code>s</code> au dÃ©but de la
fonctionÂ ; cette partie n'a pas changÃ©e. Au lieu de crÃ©er la variable <code>f</code>, nous
enchaÃ®nons directement l'appel Ã  <code>read_to_string</code> sur le rÃ©sultat de
<code>File::open(&quot;hello.txt&quot;)?</code>. Nous avons toujours le <code>?</code> Ã  la fin de l'appel Ã 
<code>read_to_string</code>, et nous retournons toujours une valeur <code>Ok</code> contenant le nom
d'utilisateur dans <code>s</code> lorsque <code>File::open</code> et <code>read_to_string</code> rÃ©ussissent
toutes les deux plutÃ´t que de retourner des erreurs. Cette fonctionnalitÃ© est
toujours la mÃªme que dans l'encart 9-6 et l'encart 9-7Â ; c'est juste une faÃ§on
diffÃ©rente et plus ergonomique de l'Ã©crire.</p>
<!--
Speaking of different ways to write this function, Listing 9-9 shows that
thereâ€™s a way to make this even shorter.
-->
<p>En parlant de diffÃ©rentes faÃ§ons d'Ã©crire cette fonction, l'encart 9-9 nous
montre qu'il y a une faÃ§on d'Ã©crire encore moins de code.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-9: Using `fs::read_to_string` instead of
opening and then reading the file</span>
-->
<p><span class="caption">Encart 9-9: utilisation de <code>fs::read_to_string</code> plutÃ´t que
d'ouvrir puis lire le fichier</span></p>
<!--
Reading a file into a string is a fairly common operation, so Rust provides the
convenient `fs::read_to_string` function that opens the file, creates a new
`String`, reads the contents of the file, puts the contents into that `String`,
and returns it. Of course, using `fs::read_to_string` doesnâ€™t give us the
opportunity to explain all the error handling, so we did it the longer way
first.
-->
<p>RÃ©cupÃ©rer le contenu d'un fichier dans une <code>String</code> est une opÃ©ration assez
courante, donc Rust fournir la fonction <code>fs::read_to_string</code> assez pratique, qui
ouvre le fichier, crÃ©e une nouvelle <code>String</code>, lit de contenu du fichier, envoie
le contenu dans cette <code>String</code>, et la retourne. Evidemment, l'utilisation de
<code>fs:read_to_string</code> ne nous offre pas l'occasion d'expliquer toute la gestion
des erreurs, donc nous utiliserons d'abord la faÃ§on qui est plus longue.</p>
<!--
#### The `?` Operator Can Be Used in Functions That Return `Result`
-->
<h4><a class="header" href="#lopÃ©rateur--peut-Ãªtre-utilisÃ©-dans-des-fonctions-qui-retournent-un-result" id="lopÃ©rateur--peut-Ãªtre-utilisÃ©-dans-des-fonctions-qui-retournent-un-result">L'opÃ©rateur <code>?</code> peut Ãªtre utilisÃ© dans des fonctions qui retournent un <code>Result</code></a></h4>
<!--
The `?` operator can be used in functions that have a return type of
`Result`, because it is defined to work in the same way as the `match`
expression we defined in Listing 9-6. The part of the `match` that requires a
return type of `Result` is `return Err(e)`, so the return type of the function
can be a `Result` to be compatible with this `return`.
-->
<p>L'opÃ©rateur <code>?</code> peut Ãªtre utilisÃ© dans des fonctions qui ont un type de retour
<code>Result</code>, car il est conÃ§u pour fonctionner de la mÃªme maniÃ¨re que l'expression
<code>match</code> que nous avons utilisÃ© dans l'encart 9-6. La partie du <code>match</code> qui
nÃ©cessite le type de retour <code>Result</code> est <code>return Err(e)</code>, donc le type de retour
de cette fonction peut Ãªtre <code>Result</code> pour Ãªtre compatible avec ce <code>return</code>.</p>
<!--
Letâ€™s look at what happens if we use the `?` operator in the `main` function,
which youâ€™ll recall has a return type of `()`:
-->
<p>Voyons ce que ce passe si nous utilisons l'opÃ©rateur <code>?</code> dans la fonction
<code>main</code>, pour laquelle vous devriez vous souvenir qu'elle a un type de retour
<code>()</code>Â :</p>
<!--
```rust,ignore,does_not_compile
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!--
When we compile this code, we get the following error message:
-->
<p>Lorsque nous compilons ce code, nous obtenons le message d'erreur suivantÂ :</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
 -- > src/main.rs:4:13
  |
3 | / fn main() {
4 | |     let f = File::open("hello.txt")?;
  | |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error points out that weâ€™re only allowed to use the `?` operator in a
function that returns `Result` or `Option` or another type that implements
`std::ops::Try`. When youâ€™re writing code in a function
that doesnâ€™t return one of these types, and you want to use `?` when you call other
functions that return `Result<T, E>`, you have two choices to fix this problem.
One technique is to change the return type of your function to be `Result<T,
E>` if you have no restrictions preventing that. The other technique is to use
a `match` or one of the `Result<T, E>` methods to handle the `Result<T, E>` in
whatever way is appropriate.
-->
<p>Cette erreur explique que nous sommes uniquement autorisÃ©s Ã  utiliser
l'opÃ©rateur <code>?</code> dans une fonction qui retourne <code>Result</code> ou <code>Option</code> ou un autre
type qui implÃ©mente <code>std::ops::Try</code>. Lorsque vous Ã©crivez du code dans une
fonction qui ne retourne pas un de ces types, et que vous souhaitez utiliser <code>?</code>
lorsque vous appelez d'autres fonctions qui retournent <code>Result&lt;T, E&gt;</code>, vous avez
deux faÃ§ons de rÃ©gler le problÃ¨me. La premiÃ¨re est de changer le type de retour
de votre fonction en <code>Result&lt;T, E&gt;</code> si vous pouvez le faire. L'autre solution
est d'utiliser un <code>match</code> ou une des mÃ©thodes de <code>Result&lt;T, E&gt;</code> pour gÃ©rer le
<code>Result&lt;T, E&gt;</code> de la maniÃ¨re la plus appropriÃ©e.</p>
<!--
The `main` function is special, and there are restrictions on what its return
type must be. One valid return type for main is `()`, and conveniently, another
valid return type is `Result<T, E>`, as shown here:
-->
<p>La fonction <code>main</code> est spÃ©ciale, et il y a des restrictions sur ce que doit Ãªtre
son type de retour. Une type de retour correct pour <code>main</code> est <code>()</code>, et il
existe aussi un autre type de retour acceptable qui est <code>Result&lt;T, E&gt;</code>, comme
ci-dessousÂ :</p>
<!--
```rust,ignore
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<!--
The `Box<dyn Error>` type is called a trait object, which weâ€™ll talk about in
the [â€œUsing Trait Objects that Allow for Values of Different
Typesâ€][trait-objects]<!-- ignore -- > section in Chapter 17. For now, you can
read `Box<dyn Error>` to mean â€œany kind of error.â€ Using `?` in a `main`
function with this return type is allowed.
-->
<p>Le type <code>Box&lt;dyn Error&gt;</code> est ce qu'on appelle un objet trait, que nous allons
voir dans une section du <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore -->. Pour
l'instant vous pouvez interprÃ©ter <code>Box&lt;dyn Error&gt;</code> en â€œtout type d'erreurâ€.
L'utilisation de <code>?</code> dans la fonction <code>main</code> avec ce type de retour est donc
autorisÃ©e.</p>
<!--
Now that weâ€™ve discussed the details of calling `panic!` or returning `Result`,
letâ€™s return to the topic of how to decide which is appropriate to use in which
cases.
-->
<p>Maintenant que nous avons vu les dÃ©tails pour utiliser <code>panic!</code> ou retourner
<code>Result</code>, voyons maintenant comment choisir ce qu'il faut faire en fonction des
cas.</p>
<!--
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--3" id="-attention-peinture-fraÃ®che--3">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/102">Pull Request</a>.</p>
</blockquote>
<!--
## To `panic!` or Not to `panic!`
-->
<h2><a class="header" href="#paniquer-ou-ne-pas-paniquer-telle-est-la-question-" id="paniquer-ou-ne-pas-paniquer-telle-est-la-question-">Paniquer ou ne pas paniquer, telle est la question ...</a></h2>
<!--
So how do you decide when you should call `panic!` and when you should return
`Result`? When code panics, thereâ€™s no way to recover. You could call `panic!`
for any error situation, whether thereâ€™s a possible way to recover or not, but
then youâ€™re making the decision on behalf of the code calling your code that a
situation is unrecoverable. When you choose to return a `Result` value, you
give the calling code options rather than making the decision for it. The
calling code could choose to attempt to recover in a way thatâ€™s appropriate for
its situation, or it could decide that an `Err` value in this case is
unrecoverable, so it can call `panic!` and turn your recoverable error into an
unrecoverable one. Therefore, returning `Result` is a good default choice when
youâ€™re defining a function that might fail.
-->
<p>Comment dÃ©cider si vous devez utiliser <code>panic!</code> ou si vous devez retourner un
<code>Result</code>Â ? Quand un code panique, il n'y a pas de moyen de rÃ©cupÃ©rer la
situation. Vous pourriez utiliser <code>panic!</code> pour n'importe quelle situation
d'erreur, peu importe s'il est possible de rÃ©cupÃ©rer la situation ou non, mais
vous prenez alors la dÃ©cision de tout arrÃªter Ã  la place du code qui appelle
votre code. Lorsque vous choisissez de retourner une valeur <code>Result</code>, vous
donnez plus de choix au code appelant plutÃ´t que de prendre des dÃ©cisions Ã  sa
place. Le code appelant peut choisir d'essayer de rÃ©cupÃ©rer l'erreur de maniÃ¨re
appropriÃ©e Ã  la situation, ou il peut dÃ©cider que dans ce cas une valeur <code>Err</code>
est irrÃ©cupÃ©rable, il va donc utiliser <code>panic!</code> et convertir votre erreur
rÃ©cupÃ©rable en erreur irrÃ©cupÃ©rable. Ainsi, retourner <code>Result</code> est un bon choix
par dÃ©faut lorsque vous dÃ©finissez une fonction qui peut Ã©chouer.</p>
<!--
In rare situations, itâ€™s more appropriate to write code that panics instead of
returning a `Result`. Letâ€™s explore why itâ€™s appropriate to panic in examples,
prototype code, and tests. Then weâ€™ll discuss situations in which the compiler
canâ€™t tell that failure is impossible, but you as a human can. The chapter will
conclude with some general guidelines on how to decide whether to panic in
library code.
-->
<p>Dans certaines situations, il est plus appropriÃ© d'Ã©crire du code qui panique
plutÃ´t que de retourner un <code>Result</code>. Nous allons voir pourquoi il est appropriÃ©
de paniquer dans les exemples, les prototypes, et les tests. Ensuite, nous
verrons des situations dans lesquelles vous savez qu'en tant qu'humain qu'un
code ne peut pas Ã©chouer mais que le compilateur ne peut pas le dÃ©duire par
lui-mÃªme. Puis nous allons conclure le chapitre par quelques lignes directrices
gÃ©nÃ©rales pour dÃ©cider s'il faut paniquer dans le code des librairies.</p>
<!--
### Examples, Prototype Code, and Tests
-->
<h3><a class="header" href="#les-exemples-prototypes-et-les-tests" id="les-exemples-prototypes-et-les-tests">Les exemples, prototypes, et les tests</a></h3>
<!--
When youâ€™re writing an example to illustrate some concept, having robust
error-handling code in the example as well can make the example less clear. In
examples, itâ€™s understood that a call to a method like `unwrap` that could
panic is meant as a placeholder for the way youâ€™d want your application to
handle errors, which can differ based on what the rest of your code is doing.
-->
<p>Lorsque vous Ã©crivez un exemple pour illustrer un concept, avoir un code de
gestion des erreurs trÃ¨s rÃ©silient peut nuire Ã  la clartÃ© de l'exemple. Dans
les exemples, il est courant d'utiliser une mÃ©thode comme <code>unwrap</code> (qui peut
faire un <code>panic!</code>) pour remplacer le code de gestion de l'erreur que vous
utiliseriez en temps normal dans votre application, et qui peut changer en
fonction de ce que le reste de votre code va faire.</p>
<!--
Similarly, the `unwrap` and `expect` methods are very handy when prototyping,
before youâ€™re ready to decide how to handle errors. They leave clear markers in
your code for when youâ€™re ready to make your program more robust.
-->
<p>De la mÃªme maniÃ¨re, les mÃ©thodes <code>unwrap</code> et <code>expect</code> sont trÃ¨s pratiques pour
coder des prototypes, avant mÃªme de dÃ©cider comment gÃ©rer les erreurs. Ce sont
des indicateurs clairs dans votre code pour plus tard quand vous serez prÃªt Ã 
rendre votre code plus rÃ©siliant aux Ã©checs.</p>
<!--
If a method call fails in a test, youâ€™d want the whole test to fail, even if
that method isnâ€™t the functionality under test. Because `panic!` is how a test
is marked as a failure, calling `unwrap` or `expect` is exactly what should
happen.
-->
<p>Si l'appel Ã  une mÃ©thode Ã©choue dans un test, nous voulons que tout le test
Ã©choue, mÃªme si cette mÃ©thode n'est pas la fonctionnalitÃ© que nous testons.
Comme <code>panic!</code> est la maniÃ¨re de le marquer un Ã©chec, utiliser <code>unwrap</code> ou
<code>expect</code> est exactement ce qui est nÃ©cessaire.</p>
<!--
### Cases in Which You Have More Information Than the Compiler
-->
<h3><a class="header" href="#les-cas-oÃ¹-vous-avez-plus-dinformations-que-le-compilateur" id="les-cas-oÃ¹-vous-avez-plus-dinformations-que-le-compilateur">Les cas oÃ¹ vous avez plus d'informations que le compilateur</a></h3>
<!--
It would also be appropriate to call `unwrap` when you have some other logic
that ensures the `Result` will have an `Ok` value, but the logic isnâ€™t
something the compiler understands. Youâ€™ll still have a `Result` value that you
need to handle: whatever operation youâ€™re calling still has the possibility of
failing in general, even though itâ€™s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that youâ€™ll never
have an `Err` variant, itâ€™s perfectly acceptable to call `unwrap`. Hereâ€™s an
example:
-->
<p>Vous pouvez utiliser <code>unwrap</code> lorsque vous avez une logique qui garantit que
<code>Result</code> sera toujours une valeur <code>Ok</code>, mais le compilateur n'est pas conÃ§u pour
comprendre ce genre de logique. Vous devrez toujours travailler avec des valeurs
de type <code>Result</code>Â : de maniÃ¨re gÃ©nÃ©rale, toutes les opÃ©rations que vous utilisez
peuvent toujours Ã©chouer, mÃªme si dans votre cas c'est logiquement impossible.
Si en inspectant manuellement le code vous vous rendez compte que vous n'aurez
jamais une variante <code>Err</code>, vous pouvez tout Ã  fait utiliser <code>unwrap</code>. Voici un
exempleÂ :</p>
<!--
```rust
# fn main() {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1".parse().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<!--
Weâ€™re creating an `IpAddr` instance by parsing a hardcoded string. We can see
that `127.0.0.1` is a valid IP address, so itâ€™s acceptable to use `unwrap`
here. However, having a hardcoded, valid string doesnâ€™t change the return type
of the `parse` method: we still get a `Result` value, and the compiler will
still make us handle the `Result` as if the `Err` variant is a possibility
because the compiler isnâ€™t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore *did* have a possibility of failure,
weâ€™d definitely want to handle the `Result` in a more robust way instead.
-->
<p>Nous crÃ©ons une instance de <code>IpAddr</code> en interprÃ©tant une chaÃ®ne de caractÃ¨res
codÃ©e en dur dans le code. Nous savons que <code>127.0.0.1</code> est une adresse IP
valide, donc il est acceptable d'utiliser <code>unwrap</code> ici. Toutefois, avoir une
chaÃ®ne de caractÃ¨res valide, codÃ©e en dur ne change jamais le type de retour de
la mÃ©thode <code>parse</code>Â : nous obtenons toujours une valeur de type <code>Result</code>, et le
compilateur va nous demander de gÃ©rer le <code>Result</code> au cas oÃ¹ nous obtenons la
variante <code>Err</code> car le compilateur n'est pas encore suffisamment intelligent pour
comprendre que cette chaÃ®ne de caractÃ¨res est toujours une adresse IP valide. Si
le texte de l'adresse IP provient de l'utilisateur plutÃ´t que d'Ãªtre codÃ© en dur
dans le programme fait qu'il y a dÃ©sormais une possibilitÃ© d'erreur, alors nous
devrions vouloir gÃ©rer le <code>Result</code> de maniÃ¨re plus rÃ©silient.</p>
<!--
### Guidelines for Error Handling
-->
<h3><a class="header" href="#recommandations-pour-gÃ©rer-les-erreurs" id="recommandations-pour-gÃ©rer-les-erreurs">Recommandations pour gÃ©rer les erreurs</a></h3>
<!--
Itâ€™s advisable to have your code panic when itâ€™s possible that your code
could end up in a bad state. In this context, a *bad state* is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
codeâ€”plus one or more of the following:
-->
<p>Il est recommandÃ© de faire paniquer votre code dÃ¨s qu'il s'exÃ©cutera dans de
mauvaises conditions. Dans ce cas, une <em>mauvaise condition</em> est lorsqu'un
postulat, une garantie, un contrat ou un invariant a Ã©tÃ© rompu, comme des
valeurs invalides, contradictoires ou manquantes qui sont fournies Ã  votre code,
ainsi qu'un ou plusieurs des Ã©lÃ©ments suivantsÂ :</p>
<!--
* The bad state is not something thatâ€™s *expected* to happen occasionally.
* Your code after this point needs to rely on not being in this bad state.
* Thereâ€™s not a good way to encode this information in the types you use.
-->
<ul>
<li>Ces mauvaises conditions ne sont pas <em>censÃ©es</em> apparaÃ®tre par intermittence.</li>
<li>AprÃ¨s cette instruction, votre code a besoin de ne pas Ãªtre dans ces
mauvaises conditions.</li>
<li>Il n'y a pas de bonne faÃ§on d'encoder l'information dans les types que vous
utilisez.</li>
</ul>
<!--
If someone calls your code and passes in values that donâ€™t make sense, the best
choice might be to call `panic!` and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, `panic!` is
often appropriate if youâ€™re calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.
-->
<p>Si quelqu'un utilise votre code et lui fournit des valeurs qui n'ont pas de
sens, la meilleure des choses Ã  faire et d'utiliser <code>panic!</code> et d'avertir la
personne qui utilise votre librairie du bogue dans leur code afin qu'il le
rÃ¨gle pendant la phase de dÃ©veloppement. De la mÃªme maniÃ¨re, <code>panic!</code> est
parfois appropriÃ© si vous appelez du code externe dont vous n'avez pas la main
dessus, et qu'il retourne de mauvaises conditions que vous ne pouvez pas
corriger.</p>
<!--
However, when failure is expected, itâ€™s more appropriate to return a `Result`
than to make a `panic!` call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a `Result` indicates that failure is an
expected possibility that the calling code must decide how to handle.
-->
<p>Cependant, lorsque un potentiel Ã©chec est prÃ©visible, il est plus appropriÃ© de
retourner un <code>Result</code> plutÃ´t que faire appel Ã  <code>panic!</code>. Il peut s'agir par
exemple d'un interprÃ©teur qui reÃ§oit des donnÃ©es erronÃ©es, ou une requÃªte HTTP
qui retourne un statut qui indique que vous avez atteint une limite de dÃ©bit.
Dans ces cas-ci, vous devriez indiquer qu'il est possible que cela puisse
Ã©chouer en retournant un <code>Result</code> afin que le code appelant puisse dÃ©cider quoi
faire pour gÃ©rer le problÃ¨me.</p>
<!--
When your code performs operations on values, your code should verify the
values are valid first and panic if the values arenâ€™t valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
`panic!` if you attempt an out-of-bounds memory access: trying to access memory
that doesnâ€™t belong to the current data structure is a common security problem.
Functions often have *contracts*: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug and
itâ€™s not a kind of error you want the calling code to have to explicitly
handle. In fact, thereâ€™s no reasonable way for calling code to recover; the
calling *programmers* need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.
-->
<p>Lorsque votre code effectue des opÃ©rations sur des valeurs, votre code devrait
d'abord vÃ©rifier que ces valeurs sont valides, et faire un <code>panic!</code> si les
valeurs ne sont pas correctes. C'est pour essentiellement des raisons de
sÃ©curitÃ©Â : tenter de travailler avec des donnÃ©es invalides peut exposer votre
code Ã  des vulnÃ©rabilitÃ©s. C'est la raison principale pour laquelle la
bibliothÃ¨que standard va faire un <code>panic!</code> si vous essayez d'accÃ©der d'accÃ©der Ã 
la mÃ©moire en dehors des limitesÂ : essayer d'accÃ©der Ã  de la mÃ©moire qui n'a
pas de rapport avec la structure des donnÃ©es actuelle est un problÃ¨me de
sÃ©curitÃ© frÃ©quent. Les fonctions ont parfois des <em>contrats</em>Â : leur comportement
est garanti uniquement si les donnÃ©es d'entrÃ©e remplissent des conditions
particuliÃ¨res. Paniquer lorsque le contrat est violÃ© est justifiÃ©, car une
violation de contrat signifie toujours un bogue du cÃ´tÃ© de l'appelant, et ce
n'est le genre d'erreur que vous voulez que le code appelant gÃ¨re explicitement.
En fait, il n'y a aucun moyen rationnel pour que le code appelant se corrigeÂ :
le <em>dÃ©veloppeur</em> du code appelant doit corriger le code. Les contrats pour les
fonctions, en particulier lorsque une violation va faire paniquer, doivent Ãªtre
expliquÃ©s dans la documentation de l'API des dites fonctions.</p>
<!--
However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rustâ€™s type system (and thus the type
checking the compiler does) to do many of the checks for you. If your function
has a particular type as a parameter, you can proceed with your codeâ€™s logic
knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an `Option`, your program expects to
have *something* rather than *nothing*. Your code then doesnâ€™t have to handle
two cases for the `Some` and `None` variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function wonâ€™t
even compile, so your function doesnâ€™t have to check for that case at runtime.
Another example is using an unsigned integer type such as `u32`, which ensures
the parameter is never negative.
-->
<p>Cependant, avoir beaucoup de vÃ©rifications d'erreurs dans toutes vos fonctions
risque d'Ãªtre verbeux et ennuyant. Heureusement, vous pouvez utiliser le systÃ¨me
de type de Rust (et donc la vÃ©rification de type que fait le compilateur) pour
assurer une partie des vÃ©rifications Ã  votre place. Si votre fonction a un
paramÃ¨tre d'un type prÃ©cis, vous pouvez continuer Ã  Ã©crire votre code en sachant
que le compilateur s'est dÃ©jÃ  assurÃ© que vous avez une valeur valide. Par
exemple, si vous obtenez un type de valeur plutÃ´t qu'une <code>Option</code>, votre
programme s'attend Ã  obtenir <em>quelque chose</em> plutÃ´t que <em>rien</em>. Votre code n'a
donc pas Ã  gÃ©rer les deux cas de variantes <code>Some</code> et <code>None</code>Â : il n'aura qu'une
seule possibilitÃ© de valeur. Du code qui essaye de ne rien fournir Ã  votre
fonction ne compilera mÃªme pas, donc votre fonction n'a pas besoin de vÃ©rifier
ce cas-ci lors de l'exÃ©cution. Un autre exemple est d'utiliser un type d'entier
sans signe comme <code>u32</code>, qui garantit que le paramÃ¨tre n'est jamais nÃ©gatif.</p>
<!--
### Creating Custom Types for Validation
-->
<h3><a class="header" href="#crÃ©er-des-types-personnalisÃ©s-pour-la-vÃ©rification" id="crÃ©er-des-types-personnalisÃ©s-pour-la-vÃ©rification">CrÃ©er des types personnalisÃ©s pour la vÃ©rification</a></h3>
<!--
Letâ€™s take the idea of using Rustâ€™s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the userâ€™s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of â€œToo highâ€ or â€œToo lowâ€ would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number thatâ€™s out of range versus when a user
types, for example, letters instead.
-->
<p>Allons plus loin dans l'idÃ©e d'utiliser le systÃ¨me de types de Rust pour
s'assurer d'avoir une valeur valide en crÃ©ant un type personnalisÃ© pour la
vÃ©rification. Souvenez-vous du jeu du plus ou du moins du chapitre 2 dans lequel
notre code demandait Ã  l'utilisateur de deviner un nombre entre 1 et 100. Nous
n'avons jamais validÃ© que le nombre saisi par l'utilisateur Ã©tait entre ces
nombres avant de le comparer Ã  notre nombre secretÂ ; nous avons seulement
vÃ©rifiÃ© que le nombre Ã©tait positif. Dans ce cas, les consÃ©quences ne sont pas
trÃ¨s gravesÂ : notre rÃ©sultat â€œC'est plusÂ !â€ ou â€œC'est moinsÂ !â€ sera toujours
correct. Mais ce serait une amÃ©lioration utile pour guider les suppositions de
l'utilisateur vers des valeurs valides et pour avoir des comportements
diffÃ©rents lorsqu'un utilisateur propose un nombre en dehors des limites ou, par
exemple, lorsqu'un utilisateur saisit des lettres Ã  la place.</p>
<!--
One way to do this would be to parse the guess as an `i32` instead of only a
`u32` to allow potentially negative numbers, and then add a check for the
number being in range, like so:
-->
<p>Une faÃ§on de faire cela serait stocker le nombre saisi dans un <code>i32</code> plutÃ´t que
dans un <code>u32</code> afin de permettre d'obtenir potentiellement des nombres nÃ©gatifs,
et ensuite vÃ©rifier que le nombre est dans la plage autorisÃ©e, comme ceciÂ :</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Devinez le nombreÂ !");
# 
#     let nombre_secret = rand::thread_rng().gen_range(1, 101);
# 
    loop {
        // -- partie masquÃ©e ici --

#         println!("Veuillez saisir un nombre.");
# 
#         let mut supposition = String::new();
# 
#         io::stdin()
#             .read_line(&mut supposition)
#             .expect("Echec de la lecture de la saisie");
# 
        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) => nombre,
            Err(_) => continue,
        };

        if supposition < 1 || supposition > 100 {
            println!("Le nombre secret est entre 1 et 100.");
            continue;
        }

        match supposition.cmp(&nombre_secret) {
            // -- partie masquÃ©e ici --
#             Ordering::Less => println!("C'est plusÂ !"),
#             Ordering::Greater => println!("C'est moinsÂ !"),
#             Ordering::Equal => {
#                 println!("GagnÃ©Â !");
#                 break;
#             }
#         }
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    loop {
        // -- partie masquÃ©e ici --

<span class="boring">        println!(&quot;Veuillez saisir un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Echec de la lecture de la saisie&quot;);
</span><span class="boring">
</span>        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        if supposition &lt; 1 || supposition &gt; 100 {
            println!(&quot;Le nombre secret est entre 1 et 100.&quot;);
            continue;
        }

        match supposition.cmp(&amp;nombre_secret) {
            // -- partie masquÃ©e ici --
<span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;GagnÃ©Â !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<!--
The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.
-->
<p>L'expression <code>if</code> vÃ©rifie si la valeur est en dehors des limites, et informe
l'utilisateur du problÃ¨me le cas Ã©chÃ©ant, puis utilise <code>continue</code> pour passer Ã 
la prochaine itÃ©ration de la boucle et ainsi demander un nouveau nombre Ã 
deviner. AprÃ¨s l'expression <code>if</code>, nous pouvons continuer avec la comparaison
entre <code>supposition</code> et le nombre secret tout en sachant que <code>supposition</code> est
entre 1 et 100.</p>
<!--
However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).
-->
<p>Cependant, ce n'est pas une solution idÃ©aleÂ : si c'Ã©tait absolument critique
que le programme travaille avec des valeurs entre 1 et 100, et qu'il aurait de
nombreuses fonctions qui reposent sur cette condition, cela pourrait Ãªtre
fastidieux (et cela impacterait potentiellement la performance) de faire une
vÃ©rification comme celle-ci dans chacune de ces fonctions.</p>
<!--
Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, itâ€™s safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-10 shows one way to define a
`Guess` type that will only create an instance of `Guess` if the `new` function
receives a value between 1 and 100.
-->
<p>A la place, nous pourrions construire un nouveau type et y intÃ©grer les
vÃ©rifications dans la fonction de crÃ©ation d'une instance de ce type plutÃ´t que
de rÃ©pÃ©ter partout les vÃ©rifications. Il est ainsi plus sÃ»r pour les fonctions
d'utiliser ce nouveau type dans leurs signatures et d'utiliser avec confiance
les valeurs qu'ils reÃ§oivent. L'entrÃ©e 9-10 montre une faÃ§on de dÃ©finir un type
<code>Supposition</code> qui ne crÃ©era une instance de <code>Supposition</code> que si la fonction
<code>new</code> reÃ§oit une valeur entre 1 et 100Â :</p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -- >
-->
<!--
```rust
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&self) -> i32 {
        self.valeur
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&amp;self) -&gt; i32 {
        self.valeur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-10: A `Guess` type that will only continue with
values between 1 and 100</span>
-->
<p><span class="caption">EntrÃ©e 9-10Â : un type <code>Supposition</code> qui ne va continuer
que si la valeur est entre 1 et 100</span></p>
<!--
First, we define a struct named `Guess` that has a field named `value` that
holds an `i32`. This is where the number will be stored.
-->
<p>PremiÃ¨rement, nous dÃ©finissons une structure qui s'appelle <code>Supposition</code> qui a
un champ <code>valeur</code> qui stocke un <code>i32</code>. C'est dans ce dernier que le nombre sera
stockÃ©.</p>
<!--
Then we implement an associated function named `new` on `Guess` that creates
instances of `Guess` values. The `new` function is defined to have one
parameter named `value` of type `i32` and to return a `Guess`. The code in the
body of the `new` function tests `value` to make sure itâ€™s between 1 and 100.
If `value` doesnâ€™t pass this test, we make a `panic!` call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a `Guess` with a `value` outside this range would
violate the contract that `Guess::new` is relying on. The conditions in which
`Guess::new` might panic should be discussed in its public-facing API
documentation; weâ€™ll cover documentation conventions indicating the possibility
of a `panic!` in the API documentation that you create in Chapter 14. If
`value` does pass the test, we create a new `Guess` with its `value` field set
to the `value` parameter and return the `Guess`.
-->
<p>DeuxiÃ¨mement, nous implÃ©mentons une fonction associÃ©e <code>new</code> sur <code>Supposition</code>
qui crÃ©e des instances de <code>Supposition</code>. La fonction <code>new</code> est conÃ§ue pour
recevoir un paramÃ¨tre <code>valeur</code> de type <code>i32</code> et retourner une <code>Supposition</code>. Le
code dans le corps de la fonction <code>new</code> teste <code>valeur</code> pour s'assurer qu'elle
est bien entre 1 et 100. Si <code>valeur</code> Ã©choue Ã  ce test, nous faisons appel Ã 
<code>panic!</code>, qui alertera le dÃ©veloppeur qui Ã©crit le code appelant qu'il a un
bogue qu'il doit rÃ©gler, car crÃ©er une <code>Supposition</code> avec <code>valeur</code> en dehors de
cette plage va violer le contrat sur lequel s'appuie <code>Supposition::new</code>. Les
conditions dans lesquels <code>Supposition::new</code> va paniquer devraient Ãªtre
expliquÃ©es dans la documentation sur l'API publiqueÂ ; nous verrons les
conventions pour indiquer l'Ã©ventualitÃ© d'un <code>panic!</code> dans la documentation de
l'API que vous allez crÃ©er au chapitre 14. Si <code>valeur</code> passe le test, nous
crÃ©ons une nouvelle <code>Supposition</code> avec son champ <code>valeur</code> qui prend la valeur du
paramÃ¨tre <code>valeur</code> et retourne cette <code>Supposition</code>.</p>
<!--
Next, we implement a method named `value` that borrows `self`, doesnâ€™t have any
other parameters, and returns an `i32`. This kind of method is sometimes called
a *getter*, because its purpose is to get some data from its fields and return
it. This public method is necessary because the `value` field of the `Guess`
struct is private. Itâ€™s important that the `value` field be private so code
using the `Guess` struct is not allowed to set `value` directly: code outside
the module *must* use the `Guess::new` function to create an instance of
`Guess`, thereby ensuring thereâ€™s no way for a `Guess` to have a `value` that
hasnâ€™t been checked by the conditions in the `Guess::new` function.
-->
<p>Ensuite, nous implÃ©mentons une mÃ©thode <code>valeur</code> qui emprunte <code>self</code>, elle n'a
aucun autre paramÃ¨tre, et retourne un <code>i32</code>. Ce genre de mÃ©thode est parfois
appelÃ© un <em>accesseur</em>, car son rÃ´le est d'accÃ©der aux donnÃ©es des champs et de
les retourner. Cette mÃ©thode publique est nÃ©cessaire car le champ <code>valeur</code> de la
structure <code>Supposition</code> est privÃ©. Il est important que le champ <code>valeur</code> soit
privÃ© pour que le code qui utilise la structure <code>Supposition</code> ne puisse pas
directement assigner une valeur Ã  <code>valeur</code>Â : le code en dehors du module <em>doit</em>
utiliser la fonction <code>Supposition::new</code> pour crÃ©er une instance de
<code>Supposition</code>, qui se charge de rendre impossible la crÃ©ation d'une
<code>Supposition</code> avec un champ <code>valeur</code> qui n'a pas Ã©tÃ© vÃ©rifiÃ© par les conditions
dans la fonction <code>Supposition:new</code>.</p>
<!--
A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a `Guess` rather than an
`i32` and wouldnâ€™t need to do any additional checks in its body.
-->
<p>Une fonction qui prend en paramÃ¨tre ou qui retourne des nombres uniquement entre
1 et 100 peut ensuite dÃ©clarer dans sa signature qu'elle prend en paramÃ¨tre ou
qu'elle retourne une <code>Supposition</code> plutÃ´t qu'un <code>i32</code> et n'aura pas besoin de
faire de vÃ©rifications supplÃ©mentaires dans son corps.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-8" id="rÃ©sumÃ©-8">RÃ©sumÃ©</a></h2>
<!--
Rustâ€™s error handling features are designed to help you write more robust code.
The `panic!` macro signals that your program is in a state it canâ€™t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The `Result` enum uses Rustâ€™s type system to indicate that
operations might fail in a way that your code could recover from. You can use
`Result` to tell code that calls your code that it needs to handle potential
success or failure as well. Using `panic!` and `Result` in the appropriate
situations will make your code more reliable in the face of inevitable problems.
-->
<p>Les fonctionnalitÃ©s de gestion d'erreurs de Rust sont conÃ§ues pour vous aider Ã 
Ã©crire du code plus rÃ©silient. La macro <code>panic!</code> signale que votre programme
fonctionne dans de mauvaises conditions qu'il ne peut pas gÃ©rer et vous permet
de dire au processus de s'arrÃªter au lieu d'essayer de continuer avec des
valeurs invalides ou incorrectes. L'Ã©numÃ©ration <code>Result</code> utilise le systÃ¨me de
type de Rust pour signaler que l'opÃ©ration peut Ã©chouer de sorte que votre code
puisse rattraper l'erreur. Vous pouvez utiliser <code>Result</code> pour dire au code qui
appelle votre code qu'il a besoin de gÃ©rer le rÃ©sultat et aussi les potentielles
erreurs. Utiliser <code>panic!</code> et <code>Result</code> de maniÃ¨re appropriÃ©e va rendre votre
code plus fiable face Ã  des problÃ¨mes inÃ©vitables.</p>
<!--
Now that youâ€™ve seen useful ways that the standard library uses generics with
the `Option` and `Result` enums, weâ€™ll talk about how generics work and how you
can use them in your code.
-->
<p>Maintenant que vous avez vu les pratiques utiles que la bibliothÃ¨que standard
utilise avec les Ã©numÃ©rations gÃ©nÃ©riques <code>Option</code> et <code>Result</code>, nous allons voir
comment les gÃ©nÃ©riques fonctionnent et comment vous pouvez les utiliser dans
votre code.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--4" id="-attention-peinture-fraÃ®che--4">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/106">Pull Request</a>.</p>
</blockquote>
<!--
# Generic Types, Traits, and Lifetimes
-->
<h1><a class="header" href="#les-types-gÃ©nÃ©riques-les-traits-et-les-durÃ©es-de-vies" id="les-types-gÃ©nÃ©riques-les-traits-et-les-durÃ©es-de-vies">Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></h1>
<!--
Every programming language has tools for effectively handling the duplication
of concepts. In Rust, one such tool is *generics*. Generics are abstract
stand-ins for concrete types or other properties. When weâ€™re writing code, we
can express the behavior of generics or how they relate to other generics
without knowing what will be in their place when compiling and running the code.
-->
<p>Tous les langages de programmation ont des outils pour gÃ©rer la duplication des
concepts. En Rust, un de ces outils est la <em>gÃ©nÃ©ricitÃ©</em>. La gÃ©nÃ©ricitÃ© permet
de remplacer des types concrets ou d'autres propriÃ©tÃ©s. Lorsque nous Ã©crivons du
code, nous pouvons exprimer le comportement des gÃ©nÃ©riques ou comment ils
interagissent avec d'autres gÃ©nÃ©riques sans savoir ce qu'il y aura Ã  leur place
lors de la compilation et de l'exÃ©cution du code.</p>
<!--
Similar to the way a function takes parameters with unknown values to run the
same code on multiple concrete values, functions can take parameters of some
generic type instead of a concrete type, like `i32` or `String`. In fact, weâ€™ve
already used generics in Chapter 6 with `Option<T>`, Chapter 8 with `Vec<T>`
and `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, youâ€™ll
explore how to define your own types, functions, and methods with generics!
-->
<p>De la mÃªme maniÃ¨re qu'une fonction prend des paramÃ¨tres avec des valeurs
inconnues pour exÃ©cuter le mÃªme code sur plusieurs valeurs concrÃ¨tes, les
fonctions peuvent prendre des paramÃ¨tres de certains types gÃ©nÃ©riques plutÃ´t
qu'un type concret comme le <code>i32</code>ou <code>String</code>. En fait, nous avons dÃ©jÃ  utilisÃ©
les gÃ©nÃ©riques au chapitre 6 avec <code>Option&lt;T&gt;</code>, au chapitre 8 avec <code>Vec&lt;T&gt;</code> et
<code>HashMap&lt;K, V&gt;</code>, et au chapitre 9 avec <code>Result&lt;T, E&gt;</code>. Dans ce chapitre, nous
allons voir comment dÃ©finir nos propres types, fonctions, et mÃ©thodes avec les
gÃ©nÃ©riquesÂ !</p>
<!--
First, weâ€™ll review how to extract a function to reduce code duplication. Next,
weâ€™ll use the same technique to make a generic function from two functions that
differ only in the types of their parameters. Weâ€™ll also explain how to use
generic types in struct and enum definitions.
-->
<p>Pour commencer, nous allons voir comment rÃ©cupÃ©rer une fonction pour rÃ©duire la
redondance de code. Ensuite, nous utiliserons la mÃªme technique pour construire
une fonction gÃ©nÃ©rique Ã  partir de deux fonctions qui se distinguent uniquement
par le type de leurs paramÃ¨tres. Nous allons aussi expliquer comment utiliser
les types gÃ©nÃ©riques dans les dÃ©finitions de structures et d'Ã©numÃ©rations.</p>
<!--
Then youâ€™ll learn how to use *traits* to define behavior in a generic way. You
can combine traits with generic types to constrain a generic type to only
those types that have a particular behavior, as opposed to just any type.
-->
<p>Ensuite, vous apprendrez comment utiliser les <em>traits</em> pour dÃ©finir un
comportement de maniÃ¨re gÃ©nÃ©rique. Vous pouvez combiner les traits avec des
types gÃ©nÃ©riques pour contraindre un type gÃ©nÃ©rique Ã  uniquement des types qui
ont un comportement particulier, et non pas accepter n'importe quel type.</p>
<!--
Finally, weâ€™ll discuss *lifetimes*, a variety of generics that give the
compiler information about how references relate to each other. Lifetimes allow
us to borrow values in many situations while still enabling the compiler to
check that the references are valid.
-->
<p>Enfin, nous verrons les <em>durÃ©es de vie</em>, un genre de gÃ©nÃ©rique qui indique au
compilateur comment les rÃ©fÃ©rences s'utilisent mutuellement. Les durÃ©es de vie
nous permettent d'emprunter des valeurs dans diffÃ©rentes situations tout en
donnant les Ã©lÃ©ments au compilateur pour vÃ©rifier que les rÃ©fÃ©rences sont
toujours valides.</p>
<!--
## Removing Duplication by Extracting a Function
-->
<h2><a class="header" href="#supprimer-les-doublons-en-extrayant-une-fonction" id="supprimer-les-doublons-en-extrayant-une-fonction">Supprimer les doublons en extrayant une fonction</a></h2>
<!--
Before diving into generics syntax, letâ€™s first look at how to remove
duplication that doesnâ€™t involve generic types by extracting a function. Then
weâ€™ll apply this technique to extract a generic function! In the same way that
you recognize duplicated code to extract into a function, youâ€™ll start to
recognize duplicated code that can use generics.
-->
<p>Avant de plonger dans la syntaxe des gÃ©nÃ©riques, nous allons regarder comment
supprimer les doublons, qui n'utilisent pas les types gÃ©nÃ©riques, en extrayant
une fonction. Ensuite, nous allons appliquer cette technique pour extraire une
fonction gÃ©nÃ©riqueÂ ! De la mÃªme maniÃ¨re que vous dÃ©tectez du code dupliquÃ© pour
l'extraire dans une fonction, vous allez commencer par reconnaÃ®tre du code
dupliquÃ© qui peut utiliser des gÃ©nÃ©riques.</p>
<!--
Consider a short program that finds the largest number in a list, as shown in
Listing 10-1.
-->
<p>Imaginons un petit programme qui trouve le nombre le gros dans une liste, comme
dans l'encart 10-1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_gros = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_gros {
            le_plus_gros = nombre;
        }
    }

    println!("Le nombre le plus gros est {}", le_plus_gros);
#     assert_eq!(le_plus_gros, 100);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_gros = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_gros {
            le_plus_gros = nombre;
        }
    }

    println!(&quot;Le nombre le plus gros est {}&quot;, le_plus_gros);
<span class="boring">    assert_eq!(le_plus_gros, 100);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span>
-->
<p><span class="caption">Encart 10-1Â : le code pour trouver le nombre le plus gros
dans une liste de nombres</span></p>
<!--
This code stores a list of integers in the variable `number_list` and places
the first number in the list in a variable named `largest`. Then it iterates
through all the numbers in the list, and if the current number is greater than
the number stored in `largest`, it replaces the number in that variable.
However, if the current number is less than or equal to the largest number seen
so far, the variable doesnâ€™t change, and the code moves on to the next number
in the list. After considering all the numbers in the list, `largest` should
hold the largest number, which in this case is 100.
-->
<p>Ce code enregistre une liste d'entiers dans la variable <code>liste_de_nombres</code> et
place le premier nombre de la liste dans une variable qui s'appelle
<code>le_plus_gros</code>. Ensuite, il parcourt tous les nombres dans la liste, et si le
nombre courant est plus grand que le nombre stockÃ© dans <code>le_plus_grand</code>, il
remplace le nombre dans cette variable. Cependant, si le nombre courant est
plus petit ou Ã©gal au nombre plus grand trouvÃ© prÃ©cÃ©demment, la variable ne
change pas, et le code passe au nombre suivant de la liste. AprÃ¨s avoir parcouru
tous les nombres de la liste, <code>le_plus_grand</code> devrait stocker le plus grand
nombre, qui est 100 dans notre cas.</p>
<!--
To find the largest number in two different lists of numbers, we can duplicate
the code in Listing 10-1 and use the same logic at two different places in the
program, as shown in Listing 10-2.
-->
<p>Pour trouver le nombre le plus grand dans deux diffÃ©rentes listes de nombres,
nous pourrions dupliquer le code de l'encart 10-1 et suivre la mÃªme logique Ã 
deux endroits diffÃ©rents du programme, comme dans l'encart 10-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-2: Code to find the largest number in *two*
lists of numbers</span>
-->
<p><span class="caption">Encart 10-2Â : le code pour trouver les plus grands
nombres dans <em>deux</em> listes de nombres</span></p>
<!--
Although this code works, duplicating code is tedious and error prone. We also
have to update the code in multiple places when we want to change it.
-->
<p>Bien que ce code fonctionne, la duplication de code est fastidieuse et source
d'erreurs. Nous devons aussi modifier le code dans plusieurs endroits si nous
souhaitons le modifier.</p>
<!--
To eliminate this duplication, we can create an abstraction by defining a
function that operates on any list of integers given to it in a parameter. This
solution makes our code clearer and lets us express the concept of finding the
largest number in a list abstractly.
-->
<p>Pour Ã©viter cette duplication, nous pouvons crÃ©er un niveau d'abstraction en
dÃ©finissant une fonction qui travaille avec n'importe quelle liste d'entier
qu'on lui donne en paramÃ¨tre. Cette solution rend notre code plus clair et nous
permet toujours de trouver le nombre le plus grand dans une liste de maniÃ¨re
abstraite.</p>
<!--
In Listing 10-3, we extracted the code that finds the largest number into a
function named `largest`. Unlike the code in Listing 10-1, which can find the
largest number in only one particular list, this program can find the largest
number in two different lists.
-->
<p>Dans l'encart 10-3, nous avons extrait le code qui trouve le nombre le plus
grand dans une fonction qui s'appelle <code>le_plus_grand</code>. Contrairement au code de
l'encart 10-1, qui pouvait trouver le nombre le plus grand dans seulement une
seule liste bien dÃ©finie, ce programme peut trouver le nombre le plus grand
nombre dans deux listes diffÃ©rentes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn le_plus_grand(liste: &[i32]) -> i32 {
    let mut le_plus_grand = liste[0];

    for &element in liste {
        if element > le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);
#     assert_eq!(resultat, 100);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);
#     assert_eq!(resultat, 6000);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 6000);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span>
-->
<p><span class="caption">Encart 10-3Â : du code abstrait qui trouve le plus grand
nombre dans deux listes</span></p>
<!--
The `largest` function has a parameter called `list`, which represents any
concrete slice of `i32` values that we might pass into the function. As a
result, when we call the function, the code runs on the specific values that we
pass in.
-->
<p>La fonction <code>le_plus_grand</code> a un paramÃ¨tre qui s'appelle <code>liste</code>, qui reprÃ©sente
une slice concrÃ¨te de valeurs <code>i32</code> que nous pouvons passer Ã  la fonction. Au
final, lorsque nous appelons la fonction, le code s'exÃ©cute sur des valeurs
prÃ©cises que nous lui avons fournis.</p>
<!--
In sum, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:
-->
<p>En rÃ©sumÃ©, voici les Ã©tapes que nous avons suivies pour changer le code de
l'encart 10-2 Ã  celui de l'encart 10-3Â :</p>
<!--
1. Identify duplicate code.
2. Extract the duplicate code into the body of the function and specify the
   inputs and return values of that code in the function signature.
3. Update the two instances of duplicated code to call the function instead.
-->
<ol>
<li>Identification du code dupliquÃ©.</li>
<li>Extraction du code dupliquÃ© dans le corps de la fonction et ajout de
prÃ©cisions sur les entrÃ©es et les valeurs de retour de ce code dans la
signature de la fonction.</li>
<li>Modification des deux instances du code dupliquÃ© pour appeler Ã  la place la
fonction.</li>
</ol>
<!--
Next, weâ€™ll use these same steps with generics to reduce code duplication in
different ways. In the same way that the function body can operate on an
abstract `list` instead of specific values, generics allow code to operate on
abstract types.
-->
<p>Ensuite, nous allons utiliser les mÃªmes Ã©tapes avec les gÃ©nÃ©riques pour rÃ©duire
la duplication de code de diffÃ©rentes faÃ§ons. De la mÃªme maniÃ¨re que le corps
d'une fonction peut opÃ©rer sur une <code>liste</code> abstraite plutÃ´t de valeurs
spÃ©cifiques, les gÃ©nÃ©riques permettent de travailler sur des types abstraits.</p>
<!--
For example, say we had two functions: one that finds the largest item in a
slice of `i32` values and one that finds the largest item in a slice of `char`
values. How would we eliminate that duplication? Letâ€™s find out!
-->
<p>Par exemple, imaginons que nous ayons deux fonctionsÂ : une qui trouve l'Ã©lÃ©ment
le plus grand dans une slice de valeurs <code>i32</code> et une qui trouve l'Ã©lÃ©ment le
plus grand dans une slice de valeurs <code>char</code>. Comment pourrions-nous Ã©viter la
duplicationÂ ? Voyons cela dÃ¨s maintenantÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--5" id="-attention-peinture-fraÃ®che--5">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/109">Pull Request</a>.</p>
</blockquote>
<!--
## Generic Data Types
-->
<h2><a class="header" href="#les-types-de-donnÃ©es-gÃ©nÃ©riques" id="les-types-de-donnÃ©es-gÃ©nÃ©riques">Les types de donnÃ©es gÃ©nÃ©riques</a></h2>
<!--
We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Letâ€™s
first look at how to define functions, structs, enums, and methods using
generics. Then weâ€™ll discuss how generics affect code performance.
-->
<p>Nous pouvons utiliser la gÃ©nÃ©ricitÃ© pour crÃ©er des dÃ©finitions pour des Ã©lÃ©ments
comme les signatures de fonctions ou de structures, que nous pouvons ensuite
utiliser sur de nombreux types de donnÃ©es concrets. CommenÃ§ons par regarder
comment dÃ©finir des fonctions, des structures, des Ã©numÃ©rations, et des mÃ©thodes
en utilisant la gÃ©nÃ©ricitÃ©. Ensuite nous verrons comment la gÃ©nÃ©ricitÃ© impacte
la performance du code.</p>
<!--
### In Function Definitions
-->
<h3><a class="header" href="#dans-la-dÃ©finition-dune-fonction" id="dans-la-dÃ©finition-dune-fonction">Dans la dÃ©finition d'une fonction</a></h3>
<!--
When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.
-->
<p>Lorsque nous dÃ©finissons une fonction en utilisant la gÃ©nÃ©ricitÃ©, nous utilisons
des gÃ©nÃ©riques dans la signature de la fonction oÃ¹ nous prÃ©cisons habituellement
les types de donnÃ©es des paramÃ¨tres et de valeur de retour. Faire ainsi rend
notre code plus flexible et apporte plus de fonctionnalitÃ©s au code appelant
notre fonction, tout en Ã©vitant la duplication de code.</p>
<!--
Continuing with our `largest` function, Listing 10-4 shows two functions that
both find the largest value in a slice.
-->
<p>Pour continuer avec notre fonction <code>le_plus_grand</code>, l'encart 10-4 nous montre
deux fonctions qui trouvent toutes les deux la valeur la plus grande dans une
slice.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
#     assert_eq!(result, &100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
#     assert_eq!(result, &'y');
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand_i32(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn le_plus_grand_caractere(liste: &amp;[char]) -&gt; char {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand_i32(&amp;liste_de_nombres);
    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, &amp;100);
</span>
    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand_caractere(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 'y');
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span>
-->
<p><span class="caption">Encart 10-4Â : deux fonctions qui se distinguent seulement
par leurs noms et le type dans leur signature</span></p>
<!--
The `largest_i32` function is the one we extracted in Listing 10-3 that finds
the largest `i32` in a slice. The `largest_char` function finds the largest
`char` in a slice. The function bodies have the same code, so letâ€™s eliminate
the duplication by introducing a generic type parameter in a single function.
-->
<p>La fonction <code>le_plus_grand_i32</code> est celle que nous avons extrait Ã  l'encart 10-3
lorsqu'elle trouvait le plus grand <code>i32</code> dans une slice. La fonction
<code>le_plus_grand_caractere</code> recherche le plus grand <code>char</code> dans une slice. Les
corps des fonctions ont le mÃªme code, donc essayons d'Ã©viter cette duplication
en utilisant un paramÃ¨tre de type gÃ©nÃ©rique dans une seule et unique fonction.</p>
<!--
To parameterize the types in the new function weâ€™ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But weâ€™ll use `T` because, by
convention, parameter names in Rust are short, often just a letter, and Rustâ€™s
type-naming convention is CamelCase. Short for â€œtype,â€ `T` is the default
choice of most Rust programmers.
-->
<p>Pour paramÃ©trer les types dans la nouvelle fonction que nous allons dÃ©finir,
nous avons besoin de donner un nom au type de paramÃ¨tre, comme nous l'avons
fait pour les valeurs de paramÃ¨tres des fonctions. Vous pouvez utiliser tout ce
que vous souhaitez pour nommer le type de paramÃ¨tres. Mais ici nous allons
utiliser <code>T</code> par convention car les noms de paramÃ¨tres en Rust sont courts,
parfois mÃªme une seule lettre, et la convention de nommage des types en Rust est
d'utiliser le CamelCase. Et ici la version courte de â€œtypeâ€ c'est <code>T</code> et c'est
le choix par dÃ©faut de nombreux dÃ©veloppeurs Rust.</p>
<!--
When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
`largest` function, place type name declarations inside angle brackets, `<>`,
between the name of the function and the parameter list, like this:
-->
<p>Lorsqu'on utilise un paramÃ¨tre dans le corps de la fonction, nous devons
dÃ©clarer le nom du paramÃ¨tre dans la signature afin que le compilateur puisse
savoir Ã  quoi ce rÃ©fÃ¨re ce nom. De la mÃªme maniÃ¨re, lorsqu'on utilise un nom de
type de paramÃ¨tre dans la signature d'une fonction, nous devons dÃ©clarer le nom
du type de paramÃ¨tre avant de pouvoir l'utiliser. Pour dÃ©clarer la fonction
gÃ©nÃ©rique <code>le_plus_grand</code>, il faut placer la dÃ©claration du nom du type entre
des chevrons <code>&lt;&gt;</code>, le tout entre le nom de la fonction et la liste des
paramÃ¨tres, comme ceciÂ :</p>
<!--
```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; &amp;T {
</code></pre>
<!--
We read this definition as: the function `largest` is generic over some type
`T`. This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a reference to a value of the
same type `T`.
-->
<p>Cette dÃ©finition se lit comme ceciÂ : la fonction <code>le_plus_grand</code> est gÃ©nÃ©rique
en fonction du type <code>T</code>. Cette fonction a un paramÃ¨tre qui s'appelle <code>liste</code>,
qui est une slice de valeurs de type <code>T</code>. Cette fonction <code>le_plus_grand</code> va
retourner une rÃ©fÃ©rence vers la valeur du mÃªme type <code>T</code>.</p>
<!--
Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code wonâ€™t
compile yet, but weâ€™ll fix it later in this chapter.
-->
<p>L'encart 10-5 nous montre la combinaison de la dÃ©finition de la fonction
<code>le_plus_grand</code> avec le type de donnÃ©es gÃ©nÃ©rique prÃ©sent dans sa signature.
L'encart montre aussi que nous pouvons appeler la fonction avec une slice soit
de valeurs <code>i32</code>, soit de valeurs <code>char</code>. Notez que ce code ne se compile pas
encore, mais nous allons y remÃ©dier plus tard dans ce chapitre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn largest<T>(list: &[T]) -> &T {
    let mut largest = list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; &amp;T {
    let mut le_plus_grand = liste[0];

    for element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-5: A definition of the `largest` function that
uses generic type parameters but doesnâ€™t compile yet</span>
-->
<p><span class="caption">Encart 10-5Â : une dÃ©finition de la fonction
<code>le_plus_grand</code> qui utilise des paramÃ¨tres de type gÃ©nÃ©riques, mais qui ne
compile pas encore</span></p>
<!--
If we compile this code right now, weâ€™ll get this error:
-->
<p>Si nous essayons de compiler ce code dÃ¨s maintenant, nous aurons l'erreur
suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The note mentions `std::cmp::PartialOrd`, which is a *trait*. Weâ€™ll talk about
traits in the next section. For now, this error states that the body of
`largest` wonâ€™t work for all possible types that `T` could be. Because we want
to compare values of type `T` in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
`std::cmp::PartialOrd` trait that you can implement on types (see Appendix C
for more on this trait). Youâ€™ll learn how to specify that a generic type has a
particular trait in the [â€œTraits as Parametersâ€][traits-as-parameters]<!--
ignore -- > section, but letâ€™s first explore other ways of using generic type
parameters.
-->
<p>La note cite <code>std::cmp::PartialOrd</code>, qui est un <em>trait</em>. Nous allons voir les
traits dans la prochaine section. Pour le moment, cette erreur nous informe que
le corps de <code>le_plus_grand</code> ne va pas fonctionner pour tous les types possibles
que <code>T</code> peut reprÃ©senter. Comme nous voulons comparer les valeurs de type <code>T</code>
dans le corps, nous pouvons utiliser uniquement des types dont les valeurs
peuvent Ãªtre triÃ©es dans l'ordre. Pour effectuer des comparaisons, la librairie
standard propose le trait <code>std::cmp::PartialOrd</code> que vous pouvez implÃ©menter sur
des types (voir l'Annexe C pour en savoir plus sur ce trait). Vous allez
apprendre Ã  indiquer qu'un type gÃ©nÃ©rique a un trait spÃ©cifique dans la section
<a href="ch10-02-traits.html#des-traits-en-param%C3%A8tres">â€œDes traits en paramÃ¨tresâ€</a><!-- ignore -->, mais d'abord
nous allons explorer d'autres maniÃ¨res d'utiliser les paramÃ¨tres de types
gÃ©nÃ©riques.</p>
<!--
### In Struct Definitions
-->
<h3><a class="header" href="#dans-la-dÃ©finition-des-structures" id="dans-la-dÃ©finition-des-structures">Dans la dÃ©finition des structures</a></h3>
<!--
We can also define structs to use a generic type parameter in one or more
fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>`
struct to hold `x` and `y` coordinate values of any type.
-->
<p>Nous pouvons aussi dÃ©finir des structures en utilisant des paramÃ¨tres de type
gÃ©nÃ©rique dans un ou plusieurs champs en utilisant la syntaxe <code>&lt;&gt;</code>. L'encart
10-6 nous montre comment dÃ©finir une structure <code>Point&lt;T&gt;</code> pour stocker des
valeurs de coordonnÃ©es <code>x</code> et <code>y</code> de n'importe quel type.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let entiers = Point { x: 5, y: 10 };
    let flottants = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y`
values of type `T`</span>
-->
<p><span class="caption">Encart 10-6Â : une structure <code>Point&lt;T&gt;</code> qui stocke les
valeurs <code>x</code> et <code>y</code> de type <code>T</code></span></p>
<!--
The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.
-->
<p>La syntaxe pour l'utilisation des gÃ©nÃ©riques dans les dÃ©finitions de structures
est similaire Ã  celle utilisÃ©e dans la dÃ©finition des fonctions. D'abord, on
dÃ©clare le nom du type de paramÃ¨tre entre des chevrons juste aprÃ¨s le nom de la
structure. Ensuite, on peut utiliser le type gÃ©nÃ©rique dans la dÃ©finition de la
structure oÃ¹ nous utilisions prÃ©cÃ©demment des types de donnÃ©es prÃ©cis.</p>
<!--
Note that because weâ€™ve used only one generic type to define `Point<T>`, this
definition says that the `Point<T>` struct is generic over some type `T`, and
the fields `x` and `y` are *both* that same type, whatever that type may be. If
we create an instance of a `Point<T>` that has values of different types, as in
Listing 10-7, our code wonâ€™t compile.
-->
<p>Notez que comme nous n'avons utilisÃ© qu'un seul type gÃ©nÃ©rique pour dÃ©finir
<code>Point&lt;T&gt;</code>, cette dÃ©finition dit que la structure <code>Point&lt;T&gt;</code> est gÃ©nÃ©rique en
fonction du type <code>T</code>, et les champs <code>x</code> et <code>y</code> sont <em>tous les deux</em> du mÃªme
type, quel que soit ce type. Si nous crÃ©ons une instance de <code>Point&lt;T&gt;</code> qui a des
valeurs de diffÃ©rents types, comme dans l'encart 10-7, notre code ne va pas se
compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
}
</code></pre>
<!--
<span class="caption">Listing 10-7: The fields `x` and `y` must be the same
type because both have the same generic data type `T`.</span>
-->
<p><span class="caption">Encart 10-7Â : les champs <code>x</code> et <code>y</code> doivent Ãªtre du mÃªme
type car ils ont tous les deux le mÃªme type de donnÃ©es gÃ©nÃ©rique <code>T</code>.</span></p>
<!--
In this example, when we assign the integer value 5 to `x`, we let the
compiler know that the generic type `T` will be an integer for this instance of
`Point<T>`. Then when we specify 4.0 for `y`, which weâ€™ve defined to have the
same type as `x`, weâ€™ll get a type mismatch error like this:
-->
<p>Dans cet exemple, lorsque nous assignons l'entier 5 Ã  <code>x</code>, nous laissons
entendre au compilateur que le type gÃ©nÃ©rique <code>T</code> sera un entier pour cette
instance de <code>Point&lt;T&gt;</code>. Ensuite, lorsque assignons 4.0 Ã  <code>y</code>, que nous avons
dÃ©fini comme ayant le mÃªme type que <code>x</code>, nous obtenons une erreur pour mauvais
type comme celle-ciÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 -- > src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
  |                                                ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
To define a `Point` struct where `x` and `y` are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of `Point` to be generic over types
`T` and `U` where `x` is of type `T` and `y` is of type `U`.
-->
<p>Pour dÃ©finir une structure <code>Point</code> oÃ¹ <code>x</code> et <code>y</code> sont tous les deux gÃ©nÃ©riques
mais peuvent avoir des types diffÃ©rents, nous pouvons utiliser les paramÃ¨tres
multiples de types gÃ©nÃ©riques. Par exemple, dans l'encart 10-8, nous pouvons
changer la dÃ©finition de <code>Point</code> pour Ãªtre gÃ©nÃ©rique en fonction des types <code>T</code>
et <code>U</code> oÃ¹ <code>x</code> est de type <code>T</code> et <code>y</code> est de type <code>U</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let deux_entiers = Point { x: 5, y: 10 };
    let deux_flottants = Point { x: 1.0, y: 4.0 };
    let un_entier_et_un_flottant = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so
that `x` and `y` can be values of different types</span>
-->
<p><span class="caption">Encart 10-8: un <code>Point&lt;T, U&gt;</code> gÃ©nÃ©rique en fonction de
deux types <code>x</code> et <code>y</code> qui peuvent Ãªtre des valeurs de diffÃ©rents types</span></p>
<!--
Now all the instances of `Point` shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.
-->
<p>Maintenant, toutes les instances de <code>Point</code> montrÃ©es ici sont validesÂ ! Vous
pouvez utiliser autant de paramÃ¨tres de type gÃ©nÃ©riques que vous souhaitez dans
la dÃ©claration de la dÃ©finition, mais en utiliser plus de quelques-uns rend
votre code difficile Ã  lire. Lorsque vous avez besoin de nombreux types
gÃ©nÃ©riques dans votre code, cela peut Ãªtre un signe que votre code a besoin
d'Ãªtre remaniÃ© dans des Ã©lÃ©ments plus petits.</p>
<!--
### In Enum Definitions
-->
<h3><a class="header" href="#dans-les-dÃ©finitions-dÃ©numÃ©rations" id="dans-les-dÃ©finitions-dÃ©numÃ©rations">Dans les dÃ©finitions d'Ã©numÃ©rations</a></h3>
<!--
As we did with structs, we can define enums to hold generic data types in their
variants. Letâ€™s take another look at the `Option<T>` enum that the standard
library provides, which we used in Chapter 6:
-->
<p>Comme nous l'avons fait avec les structures, nous pouvons dÃ©finir des
Ã©numÃ©rations qui utilisent des types de donnÃ©es gÃ©nÃ©riques dans leurs variantes.
CommenÃ§ons par regarder Ã  nouveau l'Ã©numÃ©ration <code>Option&lt;T&gt;</code> que fournit la
bibliothÃ¨que standard, et que nous avons utilisÃ© au chapitre 6Â :</p>
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This definition should now make more sense to you. As you can see, `Option<T>`
is an enum that is generic over type `T` and has two variants: `Some`, which
holds one value of type `T`, and a `None` variant that doesnâ€™t hold any value.
By using the `Option<T>` enum, we can express the abstract concept of having an
optional value, and because `Option<T>` is generic, we can use this abstraction
no matter what the type of the optional value is.
-->
<p>Cette dÃ©finition devrait avoir plus de sens pour vous. Comme vous pouvez le
constater, <code>Option&lt;T&gt;</code> est une Ã©numÃ©ration qui est gÃ©nÃ©rique en fonction du type
<code>T</code> et a deux variantesÂ : <code>Some</code>, qui contient une valeur de type <code>T</code>, et une
variante <code>None</code> qui ne contient aucune valeur. En utilisant l'Ã©numÃ©ration
<code>Option&lt;T&gt;</code>, nous pouvons exprimer le concept abstrait d'avoir une valeur
optionnelle, et comme <code>Option&lt;T&gt;</code> est gÃ©nÃ©rique, nous pouvons utiliser cette
abstraction peu importe le type de la valeur optionnelle.</p>
<!--
Enums can use multiple generic types as well. The definition of the `Result`
enum that we used in Chapter 9 is one example:
-->
<p>Les Ã©numÃ©rations peuvent utiliser aussi utiliser plusieurs types gÃ©nÃ©riques. La
dÃ©finition de l'Ã©numÃ©ration <code>Result</code> que nous avons utilisÃ© au chapitre 9 en est
un exempleÂ :</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result` enum is generic over two types, `T` and `E`, and has two variants:
`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type
`E`. This definition makes it convenient to use the `Result` enum anywhere we
have an operation that might succeed (return a value of some type `T`) or fail
(return an error of some type `E`). In fact, this is what we used to open a
file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when
the file was opened successfully and `E` was filled in with the type
`std::io::Error` when there were problems opening the file.
-->
<p>L'Ã©numÃ©ration <code>Result</code> est gÃ©nÃ©rique en fonction de deux types, <code>T</code> et <code>E</code>, et a
deux variantesÂ : <code>Ok</code>, qui contient une valeur de type <code>T</code>, et <code>Err</code>, qui
contient une valeur de type <code>E</code>. Cette dÃ©finition rend possible l'utilisation de
l'Ã©numÃ©ration <code>Result</code> n'importe oÃ¹ nous avons opÃ©ration qui peut rÃ©ussir (et
retourner une valeur du type <code>T</code>) ou Ã©chouer (et retourner une erreur du type
<code>E</code>). En fait, c'est ce qui est utilisÃ© pour ouvrir un fichier dans l'encart
9-3, oÃ¹ <code>T</code> contenait un type <code>std::fs::File</code> lorsque le fichier Ã©tait ouvert
avec succÃ¨s et <code>E</code> contenait un type <code>std::io::Error</code> lorsqu'il y avait des
problÃ¨mes pour ouvrir le fichier.</p>
<!--
When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.
-->
<p>Lorsque vous reconnaÃ®trez des cas dans votre code oÃ¹ vous aurez plusieurs
dÃ©finitions de structures ou d'Ã©numÃ©rations qui se distinguent uniquement par le
type de valeurs qu'elles stockent, vous pourrez Ã©viter les doublons en utilisant
des types gÃ©nÃ©riques Ã  la place.</p>
<!--
### In Method Definitions
-->
<h3><a class="header" href="#dans-la-dÃ©finition-des-mÃ©thodes" id="dans-la-dÃ©finition-des-mÃ©thodes">Dans la dÃ©finition des mÃ©thodes</a></h3>
<!--
We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the `Point<T>`
struct we defined in Listing 10-6 with a method named `x` implemented on it.
-->
<p>Nous pouvons implÃ©menter des mÃ©thodes sur des structures et des Ã©numÃ©rations
(comme nous l'avons fait dans le chapitre 5) et aussi utiliser des types
gÃ©nÃ©riques dans leurs dÃ©finitions. L'encart 10-9 montre la structure <code>Point&lt;T&gt;</code>
que nous avons dÃ©fini dans l'encart 10-6 avec une mÃ©thode qui s'appelle <code>x</code>
implÃ©mentÃ©e sur cette derniÃ¨re.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-9: Implementing a method named `x` on the
`Point<T>` struct that will return a reference to the `x` field of type
`T`</span>
-->
<p><span class="caption">Encart 10-9Â : implÃ©mentation d'une mÃ©thode <code>x</code> sur la
structure <code>Point&lt;T&gt;</code> qui va retourner une rÃ©fÃ©rence au champ <code>x</code>, de type <code>T</code>
</span></p>
<!--
Here, weâ€™ve defined a method named `x` on `Point<T>` that returns a reference
to the data in the field `x`.
-->
<p>Ici, nous avons dÃ©fini une mÃ©thode qui s'appelle <code>x</code> sur <code>Point&lt;T&gt;</code> qui retourne
une rÃ©fÃ©rence Ã  la donnÃ©e prÃ©sente dans le champ <code>x</code>.</p>
<!--
Note that we have to declare `T` just after `impl` so we can use it to specify
that weâ€™re implementing methods on the type `Point<T>`.  By declaring `T` as a
generic type after `impl`, Rust can identify that the type in the angle
brackets in `Point` is a generic type rather than a concrete type.
-->
<p>Notez que nous devons dÃ©clarer <code>T</code> juste aprÃ¨s <code>impl</code> afin de pouvoir l'utiliser
pour prÃ©ciser que nous implÃ©mentons des mÃ©thodes sur le type <code>Point&lt;T&gt;</code>. En
dÃ©clarant <code>T</code> comme un type gÃ©nÃ©rique aprÃ¨s <code>impl</code>, Rust peut comprendre que le
type entre les chevrons dans <code>Point</code> est un type gÃ©nÃ©rique plutÃ´t qu'un type
concret.</p>
<!--
We could, for example, implement methods only on `Point<f32>` instances rather
than on `Point<T>` instances with any generic type. In Listing 10-10 we use the
concrete type `f32`, meaning we donâ€™t declare any types after `impl`.
-->
<p>Nous pouvons par exemple implÃ©menter des mÃ©thodes uniquement sur des instances
de <code>Point&lt;f32&gt;</code> plutÃ´t que sur des instances de n'importe quel type <code>Point&lt;T&gt;</code>.
Dans l'encart 10-10, nous utilisons le type concret <code>f32</code>, ce qui veut dire que
nous n'avons pas besoin de dÃ©clarer un type aprÃ¨s <code>impl</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
# 
# impl<T> Point<T> {
#     fn x(&self) -> &T {
#         &self.x
#     }
# }
# 
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
# 
# fn main() {
#     let p = Point { x: 5, y: 10 };
# 
#     println!("p.x = {}", p.x());
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_depuis_lorigine(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-10: An `impl` block that only applies to a
struct with a particular concrete type for the generic type parameter `T`</span>
-->
<p><span class="caption">Encart 10-10Â : un bloc <code>impl</code> qui ne s'applique que sur
une structure d'un type concret particulier pour le paramÃ¨tre de type gÃ©nÃ©rique
<code>T</code>
</span></p>
<!--
This code means the type `Point<f32>` will have a method named
`distance_from_origin` and other instances of `Point<T>` where `T` is not of
type `f32` will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.
-->
<p>Ce code signifie que le type <code>Point&lt;f32&gt;</code> va avoir une mÃ©thode qui s'appelle
<code>distance_depuis_lorigine</code> et les autres instances de <code>Point&lt;T&gt;</code> oÃ¹ <code>T</code> n'est
pas du type <code>f32</code> n'auront pas cette mÃ©thode de dÃ©fini. Cette mÃ©thode calcule
la distance entre notre point et la coordonnÃ©e (0.0, 0.0) et utilise des
opÃ©rations mathÃ©matiques qui ne sont disponibles que pour les types de
flottants.</p>
<!--
Generic type parameters in a struct definition arenâ€™t always the same as those
you use in that structâ€™s method signatures. For example, Listing 10-11 defines
the method `mixup` on the `Point<T, U>` struct from Listing 10-8. The method
takes another `Point` as a parameter, which might have different types from the
`self` `Point` weâ€™re calling `mixup` on. The method creates a new `Point`
instance with the `x` value from the `self` `Point` (of type `T`) and the `y`
value from the passed-in `Point` (of type `W`).
-->
<p>Les paramÃ¨tres de type gÃ©nÃ©riques dans une dÃ©finition d'une structure ne sont
pas toujours les mÃªmes que ceux qui sont utilisÃ©s dans la signature des
mÃ©thodes de cette structure. Par exemple, l'encart 10-11 dÃ©finit la mÃ©thode
<code>melange</code> sur la structure <code>Point&lt;T, U&gt;</code> de l'encart 10-8. La mÃ©thode prend un
autre <code>Point</code> en paramÃ¨tre, qui peut avoir des types diffÃ©rents du <code>self</code>
<code>Point</code> sur lequel nous appelons <code>melange</code>. La mÃ©thode crÃ©e une nouvelle
instance de <code>Point</code> avec la valeur de <code>x</code> provenant du <code>self</code> <code>Point</code> (de type
<code>T</code>) et la valeur de <code>y</code> provenant du <code>Point</code> en paramÃ¨tre (de type <code>W</code>).</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn melange&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.melange(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn melange&lt;V, W&gt;(self, autre: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: autre.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.melange(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-11: A method that uses different generic types
from its structâ€™s definition</span>
-->
<p><span class="caption">Encart 10-11Â : une mÃ©thode qui utilise diffÃ©rents types
gÃ©nÃ©riques provenant de la dÃ©finition de la structure</span></p>
<!--
In `main`, weâ€™ve defined a `Point` that has an `i32` for `x` (with value `5`)
and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct
that has a string slice for `x` (with value `"Hello"`) and a `char` for `y`
(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,
which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable
will have a `char` for `y`, because `y` came from `p2`. The `println!` macro
call will print `p3.x = 5, p3.y = c`.
-->
<p>Dans le <code>main</code>, nous avons dÃ©fini un <code>Point</code> qui a un <code>i32</code> pour <code>x</code> (avec la
valeur <code>5</code>) et un <code>f64</code> pour <code>y</code> (avec la valeur 10.4). La variable <code>p2</code> est une
structure <code>Point</code> qui a une slice de chaine de caractÃ¨res pour <code>x</code> (avec la
valeur <code>&quot;Hello&quot;</code>) et un caractÃ¨re <code>char</code> pour <code>y</code> (avec la valeur <code>c</code>). L'appel
Ã  <code>melange</code> sur p1 avec l'argument <code>p2</code> nous donne <code>p3</code>, qui aura un <code>i32</code> pour
<code>x</code>, car <code>x</code> provient de <code>p1</code>. La variable <code>p3</code> aura un caractÃ¨re <code>char</code> pour
<code>y</code>, car <code>y</code> provient de <code>p2</code>. L'appel Ã  la macro <code>println!</code> va afficher
<code>p3.x = 5, p3.y = c</code>.</p>
<!--
The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with `impl` and some are declared with the method
definition. Here, the generic parameters `T` and `U` are declared after `impl`,
because they go with the struct definition. The generic parameters `V` and `W`
are declared after `fn mixup`, because theyâ€™re only relevant to the method.
-->
<p>Le but de cet exemple est de monter une situation dans laquelle des paramÃ¨tres
gÃ©nÃ©riques sont dÃ©clarÃ©s avec <code>impl</code> et d'autres sont dÃ©clarÃ©s dans la
dÃ©finition de la mÃ©thode. Ici, les paramÃ¨tres gÃ©nÃ©riques <code>T</code> et <code>U</code> sont
dÃ©clarÃ©s aprÃ¨s <code>impl</code>, car ils sont liÃ©s Ã  la dÃ©finition de la structure. Les
paramÃ¨tres gÃ©nÃ©riques <code>V</code> et <code>W</code> sont dÃ©clarÃ©s aprÃ¨s <code>fn melange</code>, car ils ne
sont liÃ©s qu'Ã  cette mÃ©thode.</p>
<!--
### Performance of Code Using Generics
-->
<h3><a class="header" href="#performance-du-code-utilisant-les-gÃ©nÃ©riques" id="performance-du-code-utilisant-les-gÃ©nÃ©riques">Performance du code utilisant les gÃ©nÃ©riques</a></h3>
<!--
You might be wondering whether there is a runtime cost when youâ€™re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesnâ€™t run any slower using generic types than it would
with concrete types.
-->
<p>Vous vous demandez peut-Ãªtre s'il y a un coÃ»t Ã  l'exÃ©cution lorsque vous
utilisez des paramÃ¨tres de type gÃ©nÃ©riques. La bonne nouvelle est que Rust
implÃ©mente les gÃ©nÃ©riques de maniÃ¨re Ã  ce que votre code ne s'exÃ©cute pas plus
lentement que vous utilisiez les types gÃ©nÃ©riques ou des types concrets.</p>
<!--
Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. *Monomorphization* is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.
-->
<p>Rust accomplit cela en pratiquant la monomorphisation Ã  la compilation du code
qui utilise les gÃ©nÃ©riques. La <em>monomorphisation</em> est un processus pour
transformer du code gÃ©nÃ©rique en code spÃ©cifique qui les remplace par des types
concrets qui sont utilisÃ©s au moment de la compilation.</p>
<!--
In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.
-->
<p>Dans ce processus, le compilateur fait l'inverse des Ã©tapes que nous avons suivi
pour crÃ©er la fonction gÃ©nÃ©rique de l'encart 10-5Â : le compilateur cherche tous
les endroits oÃ¹ le code gÃ©nÃ©rique est utilisÃ© et gÃ©nÃ¨re du code pour les types
concrets avec lequel le code gÃ©nÃ©rique est appelÃ©.</p>
<!--
Letâ€™s look at how this works with an example that uses the standard libraryâ€™s
`Option<T>` enum:
-->
<p>Regardons comment cela fonctionne avec un exemple qui utilise l'Ã©numÃ©ration
<code>Option&lt;T&gt;</code> de la bibliothÃ¨que standardÂ :</p>
<!--
```rust
let integer = Some(5);
let float = Some(5.0);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entier = Some(5);
let flotant = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<!--
When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in `Option<T>`
instances and identifies two kinds of `Option<T>`: one is `i32` and the other
is `f64`. As such, it expands the generic definition of `Option<T>` into
`Option_i32` and `Option_f64`, thereby replacing the generic definition with
the specific ones.
-->
<p>Lorsque Rust compile ce code, il applique la monomorphisation. Pendant ce
processus, le compilateur lit les valeurs qui ont Ã©tÃ© utilisÃ©es dans les
instances de <code>Option&lt;T&gt;</code> et en dÃ©duit les deux types de <code>Option&lt;T&gt;</code>Â : une est
<code>i32</code> et l'autre est <code>f64</code>. Ainsi, il dÃ©compose la dÃ©finition gÃ©nÃ©rique de
<code>Option&lt;T&gt;</code> en <code>Option_i32</code> et en <code>Option_f64</code>, remplaÃ§ant ainsi la dÃ©finition
gÃ©nÃ©rique par deux dÃ©finitions concrÃ¨tes.</p>
<!--
The monomorphized version of the code looks like the following. The generic
`Option<T>` is replaced with the specific definitions created by the compiler:
-->
<p>La version monomorphe du code ressemble Ã  ce qui suit. Le <code>Option&lt;T&gt;</code> gÃ©nÃ©rique
est remplacÃ© par deux dÃ©finitions concrÃ¨tes crÃ©Ã©es par le compilateurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<!--
Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rustâ€™s generics extremely efficient at
runtime.
-->
<p>Comme Rust compile le code gÃ©nÃ©rique dans du code qui prÃ©cise le type dans
chaque instance, l'utilisation des gÃ©nÃ©riques n'a pas de consÃ©quence sur les
performances de l'exÃ©cution. Quand le code s'exÃ©cute, il fonctionne comme il
devrait le faire si nous avions dupliquÃ© chaque dÃ©finition Ã  la main. Le
processus de monomorphisation rend les gÃ©nÃ©riques de Rust trÃ¨s performants au
moment de l'exÃ©cution.</p>
<!--
[traits-as-parameters]: ch10-02-traits.html#traits-as-parameters
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--6" id="-attention-peinture-fraÃ®che--6">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/115">Pull Request</a>.</p>
</blockquote>
<!--
## Traits: Defining Shared Behavior
-->
<h2><a class="header" href="#dÃ©finir-des-comportements-partagÃ©s-avec-les-traits" id="dÃ©finir-des-comportements-partagÃ©s-avec-les-traits">DÃ©finir des comportements partagÃ©s avec les traits</a></h2>
<!--
A *trait* tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic can be any type
that has certain behavior.
-->
<p>Un <em>trait</em> dÃ©crit une fonctionnalitÃ© qu'a un type particulier et qu'il peut
partager avec d'autres types, Ã  destination du compilateur Rust. Nous pouvons
utiliser les traits pour dÃ©finir un comportement partagÃ© de maniÃ¨re abstraite.
Nous pouvons lier ces traits Ã  un gÃ©nÃ©rique pour exprimer le fait qu'il puisse
Ãªtre de n'importe quel type Ã  condition qu'il ai un comportement donnÃ©.</p>
<!--
> Note: Traits are similar to a feature often called *interfaces* in other
> languages, although with some differences.
-->
<blockquote>
<p>Remarque : les traits sont similaires Ã  ce qu'on appelle parfois les
<em>interfaces</em> dans d'autres langages, malgrÃ© quelques diffÃ©rences.</p>
</blockquote>
<!--
### Defining a Trait
-->
<h3><a class="header" href="#dÃ©finir-un-trait" id="dÃ©finir-un-trait">DÃ©finir un trait</a></h3>
<!--
A typeâ€™s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.
-->
<p>Le comportement d'un type s'exprime via les mÃ©thodes que nous pouvons appeler
sur ce type. DiffÃ©rents types peuvent partager le mÃªme comportement si nous
pouvons appeler les mÃªmes mÃ©thodes sur tous ces types. DÃ©finir un trait est une
maniÃ¨re de grouper ensemble les signatures des mÃ©thodes pour dÃ©finir un
comportement nÃ©cessaire pour accomplir un objectif.</p>
<!--
For example, letâ€™s say we have multiple structs that hold various kinds and
amounts of text: a `NewsArticle` struct that holds a news story filed in a
particular location and a `Tweet` that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.
-->
<p>Par exemple, imaginons que nous avons plusieurs structures qui stockent
diffÃ©rents types et quantitÃ© de texteÂ : une structure <code>ArticleDePresse</code>, qui
contient un reportage dans un endroit donnÃ© et un <code>Tweet</code> qui peut avoir jusqu'Ã 
280 caractÃ¨res maximum et des mÃ©tadonnÃ©es qui indiquent si cela est un nouveau
tweet, un retweet, ou une rÃ©ponse Ã  un autre tweet.</p>
<!--
We want to make a media aggregator library that can display summaries of data
that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we
need a summary from each type, and we need to request that summary by calling a
`summarize` method on an instance. Listing 10-12 shows the definition of a
`Summary` trait that expresses this behavior.
-->
<p>Nous voulons construire une bibliothÃ¨que pour des agrÃ©gateurs de mÃ©dias qui peut
afficher le rÃ©sumÃ© des donnÃ©es stockÃ©es dans une instance de <code>ArticleDePresse</code>
ou de <code>Tweet</code>. Pour cela, nous avons besoin d'un rÃ©sumÃ© pour chaque type, et
nous pouvons demander ce rÃ©sumÃ© en appelant la mÃ©thode <code>resumer</code> sur une
instance. L'encart 10-12 nous montre la dÃ©finition d'un trait <code>Resumable</code> qui
dÃ©crit ce comportement.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumable {
    fn resumer(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-12: A `Summary` trait that consists of the
behavior provided by a `summarize` method</span>
-->
<p><span class="caption">Encart 10-12Â : un trait <code>Resumable</code> qui reprÃ©sente le
comportement fourni par une mÃ©thode <code>resumer</code></span></p>
<!--
Here, we declare a trait using the `trait` keyword and then the traitâ€™s name,
which is `Summary` in this case. Inside the curly brackets, we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is `fn summarize(&self) -> String`.
-->
<p>Ici, nous dÃ©clarons un trait en utilisant le mot-clÃ© <code>trait</code> et ensuite le nom
du trait, qui est <code>Resumable</code> dans notre cas. Entre les accolades, nous
dÃ©clarons la signature de la mÃ©thode qui dÃ©crit le comportement des types qui
implÃ©mentent ce trait, qui est dans notre cas <code>fn resumer(&amp;self) -&gt; String</code>.</p>
<!--
After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the `Summary` trait will have the method `summarize`
defined with this signature exactly.
-->
<p>A la fin de la signature de la mÃ©thode, au lieu de renseigner une implÃ©mentation
entre des accolades, nous utilisons un point-virgule. Chaque type qui implÃ©mente
ce trait doit renseigner son propre comportement dans le corps de la mÃ©thode. Le
compilateur va s'assurer que tous les types qui ont le trait <code>Resumable</code> auront
la mÃ©thode <code>resumer</code> dÃ©fini avec cette signature prÃ©cise.</p>
<!--
A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.
-->
<p>Un trait peut avoir plusieurs mÃ©thodes dans son corpsÂ : les signatures des
mÃ©thodes sont ajoutÃ©es ligne par ligne et chaque ligne se termine avec un
point-virgule.</p>
<!--
### Implementing a Trait on a Type
-->
<h3><a class="header" href="#implÃ©menter-un-trait-sur-un-type" id="implÃ©menter-un-trait-sur-un-type">ImplÃ©menter un trait sur un type</a></h3>
<!--
Now that weâ€™ve defined the desired behavior using the `Summary` trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the `Summary` trait on the `NewsArticle` struct that uses the
headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.
-->
<p>Maintenant que nous avons dÃ©fini le comportement souhaitÃ© du trait <code>Resumable</code>,
nous pouvons maintenant l'implÃ©menter sur les types de notre agrÃ©gateur de
mÃ©dias. L'encart 10-13 nous montre l'implÃ©mentation du trait <code>Resumable</code> sur la
structure <code>ArticleDePresse</code> qui utilise le titre, le nom de l'auteur, et le lieu
pour crÃ©er la valeur de retour de <code>resume</code>. Pour la structure <code>Tweet</code>, nous
dÃ©finissons <code>resumer</code> avec le nom d'utilisateur suivi par le texte entier du
tweet, en supposant que le contenu du tweet est dÃ©jÃ  limitÃ© Ã  280 caractÃ¨res.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct ArticleDePresse {
    pub titre: String,
    pub lieu: String,
    pub auteur: String,
    pub contenu: String,
}

impl Resumable for ArticleDePresse {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
    }
}

pub struct Tweet {
    pub nom_utilisateur: String,
    pub contenu: String,
    pub reponse: bool,
    pub retweet: bool,
}

impl Resumable for Tweet {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-13: Implementing the `Summary` trait on the
`NewsArticle` and `Tweet` types</span>
-->
<p><span class="caption">Encart 10-13Â : implÃ©mentation du trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code></span></p>
<!--
Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put the trait name that we want to
implement, then use the `for` keyword, and then specify the name of the type we
want to implement the trait for. Within the `impl` block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.
-->
<p>L'implÃ©mentation d'un trait sur un type est similaire Ã  l'implÃ©mentation d'une
mÃ©thode classique. La diffÃ©rence est que nous ajoutons le nom du trait que nous
voulons implÃ©menter aprÃ¨s le <code>impl</code>, et que nous utilisons ensuite le mot-clÃ©
<code>for</code> ainsi que le nom du type sur lequel nous souhaitons implÃ©menter le trait.
A l'intÃ©rieur du bloc <code>impl</code>, nous ajoutons les signatures des mÃ©thodes
prÃ©sentes dans la dÃ©finition du trait. Au lieu d'ajouter un point-virgule aprÃ¨s
chaque signature, nous plaÃ§ons les accolades et on remplit le corps de la
mÃ©thode avec le comportement spÃ©cifique que nous voulons que les mÃ©thodes du
trait suive pour type en particulier.</p>
<!--
After implementing the trait, we can call the methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods, like this:
-->
<p>AprÃ¨s avoir implÃ©mentÃ© le trait, nous pouvons appeler les mÃ©thodes de
l'instance de <code>ArticleDePresse</code> et <code>Tweet</code> comme si elles Ã©taient des mÃ©thodes
classiques, comme ceciÂ :</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweetÂ : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.
-->
<p>Ce code affichera <code>1 nouveau tweetÂ : jeanÂ : Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ </code>.</p>
<!--
Note that because we defined the `Summary` trait and the `NewsArticle` and
`Tweet` types in the same *lib.rs* in Listing 10-13, theyâ€™re all in the same
scope. Letâ€™s say this *lib.rs* is for a crate weâ€™ve called `aggregator` and
someone else wants to use our crateâ€™s functionality to implement the `Summary`
trait on a struct defined within their libraryâ€™s scope. They would need to
bring the trait into their scope first. They would do so by specifying `use
aggregator::Summary;`, which then would enable them to implement `Summary` for
their type. The `Summary` trait would also need to be a public trait for
another crate to implement it, which it is because we put the `pub` keyword
before `trait` in Listing 10-12.
-->
<p>Remarquez que comme nous avons dÃ©fini le trait <code>Resumable</code> et les types
<code>ArticleDePresse</code> et <code>Tweet</code> dans le mÃªme fichier <em>lib.rs</em> de l'encart 10-13,
ils sont tous dans la mÃªme portÃ©e. Disons que ce fichier <em>lib.rs</em> est utilisÃ©
pour une crate que nous avons appelÃ© <code>agregateur</code> et que quelqu'un d'autre
souhaite utiliser les fonctionnalitÃ©s de notre crate pour implÃ©menter le trait
<code>Resumable</code> sur une structure dÃ©finie dans la portÃ©e de sa propre bibliothÃ¨que.
Il aura d'abord besoin d'importer le trait dans sa portÃ©e. Il pourra le faire en
utilisant <code>use agregateur::Resumable;</code>, ce qui lui permettra ensuite
d'implÃ©menter <code>Resumable</code> sur le type souhaitÃ©. Le trait <code>Resumable</code> devra alors
Ãªtre un trait public aux autres crates pour qu'elles puissent l'implÃ©menter,
c'est pourquoi nous avons placÃ© le mot-clÃ© <code>pub</code> devant le <code>trait</code> dans l'encart
10-12.</p>
<!--
One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to our crate.
For example, we can implement standard library traits like `Display` on a
custom type like `Tweet` as part of our `aggregator` crate functionality,
because the type `Tweet` is local to our `aggregator` crate. We can also
implement `Summary` on `Vec<T>` in our `aggregator` crate, because the
trait `Summary` is local to our `aggregator` crate.
-->
<p>Il y a une limitation Ã  souligner avec l'implÃ©mentation des traits, c'est que
nous ne pouvons implÃ©menter un trait sur un type qu'Ã  condition que le trait ou
le type soit dÃ©fini localement dans notre crate. Par exemple, nous pouvons
implÃ©menter des traits de la bibliothÃ¨que standard comme <code>Display</code> sur un type
personnalisÃ© comme <code>Tweet</code> comme une fonctionnalitÃ© de notre crate <code>agregateur</code>,
car le type <code>Tweet</code> est dÃ©fini localement dans notre crate <code>agregateur</code>. Nous
pouvons aussi implÃ©menter <code>Resumable</code> sur <code>Vec&lt;T&gt;</code> dans notre crate
<code>agregateur</code>, car le trait <code>Resumable</code> est dÃ©fini localement dans notre crate
<code>agregateur</code>.</p>
<!--
But we canâ€™t implement external traits on external types. For example, we canâ€™t
implement the `Display` trait on `Vec<T>` within our `aggregator` crate,
because `Display` and `Vec<T>` are defined in the standard library and arenâ€™t
local to our `aggregator` crate. This restriction is part of a property of
programs called *coherence*, and more specifically the *orphan rule*, so named
because the parent type is not present. This rule ensures that other peopleâ€™s
code canâ€™t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldnâ€™t know which
implementation to use.
-->
<p>Mais nous ne pouvons pas implÃ©menter des traits externes sur des types externes.
Par exemple, nous ne pouvons pas implÃ©menter le trait <code>Display</code> sur <code>Vec&lt;T&gt;</code> Ã 
l'intÃ©rieur de notre crate <code>agregateur</code>, car <code>Display</code> et <code>Vec&lt;T&gt;</code> sont dÃ©finis
dans la bibliothÃ¨que standard et ne sont donc pas dÃ©finis localement dans notre
crate <code>agregateur</code>. Cette limitation fait partie d'une propriÃ©tÃ© des programmes
que l'on appelle la <em>cohÃ©rence</em>, et plus prÃ©cisÃ©ment la <em>rÃ¨gle de l'orphelin</em>,
qui s'appelle ainsi car le type parent n'est pas prÃ©sent. Cette rÃ¨gle s'assure
que le code des autres personnes ne casse pas votre code et rÃ©ciproquement.
Sans cette rÃ¨gle, deux crates peuvent implÃ©menter le mÃªme trait sur le mÃªme
type, et Rust ne saura pas laquelle utiliser.</p>
<!--
### Default Implementations
-->
<h3><a class="header" href="#limplÃ©mentation-par-dÃ©faut" id="limplÃ©mentation-par-dÃ©faut">L'implÃ©mentation par dÃ©faut</a></h3>
<!--
Sometimes itâ€™s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each methodâ€™s default behavior.
-->
<p>Il est parfois utile d'avoir un comportement par dÃ©faut pour toutes ou une
partie des mÃ©thodes d'un trait plutÃ´t que de demander l'implÃ©mentation de toutes
les mÃ©thodes sur chaque type. Ainsi, si nous implÃ©mentons le trait sur un type
particulier, nous pouvons garder ou rÃ©Ã©crire le comportement par dÃ©faut de
chaque mÃ©thode. </p>
<!--
Listing 10-14 shows how to specify a default string for the `summarize` method
of the `Summary` trait instead of only defining the method signature, as we did
in Listing 10-12.
-->
<p>L'encart 10-14 nous montre comment prÃ©ciser une String par dÃ©faut pour la
mÃ©thode <code>resumer</code> du trait <code>Resumable</code> plutÃ´t que de dÃ©finir uniquement la
signature de la mÃ©thode, comme nous l'avons fait dans l'encart 10-12.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumable {
    fn resumer(&amp;self) -&gt; String {
        String::from(&quot;(En savoir plus ...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-14: Definition of a `Summary` trait with a
default implementation of the `summarize` method</span>
-->
<p><span class="caption">Encart 10-14Â : dÃ©finition du trait <code>Resumable</code> avec une
implÃ©mentation par dÃ©faut de la mÃ©thode <code>resume</code></span></p>
<!--
To use a default implementation to summarize instances of `NewsArticle` instead
of defining a custom implementation, we specify an empty `impl` block with
`impl Summary for NewsArticle {}`.
-->
<p>Pour pouvoir utiliser l'implÃ©mentation par dÃ©faut du rÃ©sumÃ© des instances de
<code>ArticleDePresse</code> plutÃ´t que de devoir prÃ©ciser un implÃ©mentation personnalisÃ©e,
nous prÃ©cisons un bloc <code>impl</code> vide avec <code>impl Resumable for ArticleDePresse {}</code>.</p>
<!--
Even though weâ€™re no longer defining the `summarize` method on `NewsArticle`
directly, weâ€™ve provided a default implementation and specified that
`NewsArticle` implements the `Summary` trait. As a result, we can still call
the `summarize` method on an instance of `NewsArticle`, like this:
-->
<p>MÃªme si nous n'avons pas dÃ©fini directement la mÃ©thode <code>resumer</code> sur
<code>ArticleDePresse</code>, nous avons fourni une implÃ©mentation par dÃ©faut et prÃ©cisÃ©
que <code>ArticleDePresse</code> implÃ©mente le trait <code>Resumable</code>. Par consÃ©quent, nous
pouvons toujours appeler la mÃ©thode <code>resumer</code> sur une instance de
<code>ArticleDePresse</code>, comme ceciÂ :</p>
<!--
```rust,ignore
# use chapter10::{self, NewsArticle, Summary};
# 
# fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, ArticleDePresse, Resumable};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = ArticleDePresse {
        titre: String::from(&quot;Les Pinguins ont gagnÃ© la Stanley Cup ChampionshipÂ !&quot;),
        lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
        auteur: String::from(&quot;Iceburgh&quot;),
        contenu: String::from(
            &quot;Les Pinguins de Pittsburgh sont une nouvelle fois la meilleure\
            Ã©quipe de hockey de la NHL.&quot;
        ),
    };
    
    println!(&quot;Nouvel article disponibleÂ ! {}&quot;, article.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `New article available! (Read more...)`.
-->
<p>Ce code va afficher <code>Nouvel article disponibleÂ ! (En savoir plus ...)</code>.</p>
<!--
Creating a default implementation for `summarize` doesnâ€™t require us to change
anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesnâ€™t have a default
implementation.
-->
<p>La crÃ©ation d'une implÃ©mentation par dÃ©faut pour <code>resumer</code> n'a pas besoin que
nous modifions quelque chose dans l'implÃ©mentation de <code>Resumable</code> sur <code>Tweet</code>
dans l'encart 10-13. C'est parce que la syntaxe pour rÃ©Ã©crire l'implÃ©mentation
par dÃ©faut est la mÃªme que la syntaxe pour implÃ©menter une mÃ©thode d'un trait
qui n'a pas d'implÃ©mentation par dÃ©faut.</p>
<!--
Default implementations can call other methods in the same trait, even if those
other methods donâ€™t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the `Summary` trait to have a
`summarize_author` method whose implementation is required, and then define a
`summarize` method that has a default implementation that calls the
`summarize_author` method:
-->
<p>Les implÃ©mentations par dÃ©faut peuvent appeler d'autres mÃ©thodes du mÃªme trait,
mÃªme si ces autres mÃ©thodes n'ont pas d'implÃ©mentation par dÃ©faut. Ainsi, un
trait peut fournir de nombreuses fonctionnalitÃ©s utiles et n'avoir besoin que
le dÃ©veloppeur qui l'utilise n'en ai qu'une petite partie Ã  implÃ©menter. Par
exemple, nous pouvons dÃ©finir le trait <code>Resumable</code> pour avoir une mÃ©thode
<code>resumer_auteur</code> dont l'implÃ©mentation est nÃ©cessaire, et ensuite dÃ©finir une
mÃ©thode <code>resumer</code> qui a une implÃ©mentation par dÃ©faut qui appelle la mÃ©thode
<code>resumer_auteur</code>Â :</p>
<!--
```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize_author(&self) -> String {
#         format!("@{}", self.username)
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumable {
    fn resumer_auteur(&amp;self) -&gt; String;

    fn resumer(&amp;self) -&gt; String {
        format!(&quot;(Lire plus d'Ã©lÃ©ments de {} ...)&quot;, self.resumer_auteur())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.nom_utilisateur)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
To use this version of `Summary`, we only need to define `summarize_author`
when we implement the trait on a type:
-->
<p>Pour pouvoir utiliser cette version de <code>Resumable</code>, nous avons seulement besoin
de dÃ©finir <code>resumer_auteur</code> lorsqu'on implÃ©mente le trait sur le typeÂ :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize_author(&self) -> String;
# 
#     fn summarize(&self) -> String {
#         format!("(Read more from {}...)", self.summarize_author())
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lire plus d'Ã©lÃ©ments de {} ...)&quot;, self.resumer_auteur())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Resumable for Tweet {
    fn resumer_auteur(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nom_utilisateur)
    }
}
</code></pre>
<!--
After we define `summarize_author`, we can call `summarize` on instances of the
`Tweet` struct, and the default implementation of `summarize` will call the
definition of `summarize_author` that weâ€™ve provided. Because weâ€™ve implemented
`summarize_author`, the `Summary` trait has given us the behavior of the
`summarize` method without requiring us to write any more code.
-->
<p>AprÃ¨s avoir dÃ©fini <code>resumer_auteur</code>, nous pouvons appeler <code>resumer</code> sur des
instances de la structure <code>Tweet</code>, et l'implÃ©mentation par dÃ©faut de <code>resumer</code>
va appeler <code>resumer_auteur</code>, que nous avons dÃ©fini. Comme nous avons implÃ©mentÃ©
<code>resumer_auteur</code>, le trait <code>Resumable</code> nous a donnÃ© le comportement de la
mÃ©thode <code>resumer</code> sans avoir besoin d'Ã©crire aucune ligne de code
supplÃ©mentaire.</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweetÂ : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: (Read more from @horse_ebooks...)`.
-->
<p>Ce code affichera <code>1 nouveau tweetÂ : (Lire plus d'Ã©lÃ©ments de @jean ...)</code>.</p>
<!--
Note that it isnâ€™t possible to call the default implementation from an
overriding implementation of that same method.
-->
<p>Notez qu'il n'est pas possible d'appeler l'implÃ©mentation par dÃ©faut Ã  partir
d'une rÃ©Ã©criture de cette mÃªme mÃ©thode.</p>
<!--
### Traits as Parameters
-->
<h3><a class="header" href="#des-traits-en-paramÃ¨tres" id="des-traits-en-paramÃ¨tres">Des traits en paramÃ¨tres</a></h3>
<!--
Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.
-->
<p>Maintenant que vous savez comment dÃ©finir et implÃ©menter les traits, nous
pouvons regarder comment utiliser les traits pour dÃ©finir des fonctions qui
acceptent plusieurs types diffÃ©rents.</p>
<!--
For example, in Listing 10-13, we implemented the `Summary` trait on the
`NewsArticle` and `Tweet` types. We can define a `notify` function that calls
the `summarize` method on its `item` parameter, which is of some type that
implements the `Summary` trait. To do this, we can use the `impl Trait`
syntax, like this:
-->
<p>Par exemple, dans l'encart 10-13, nous implÃ©mentons le trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code>. Nous pouvons dÃ©finir une fonction <code>notifier</code>
qui va appeler la fonction <code>resumer</code> sur son paramÃ¨tre <code>element</code>, qui est d'un
type qui implÃ©mente le trait <code>Resumable</code>. Pour faire ceci, nous pouvons utiliser
la syntaxe <code>impl Trait</code>, comme ceciÂ :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notifier(element: impl Resumable) {
    println!(&quot;Flash-infoÂ ! {}&quot;, element.resumer());
}
</code></pre>
<!--
Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, wonâ€™t compile
because those types donâ€™t implement `Summary`.
-->
<p>Au lieu d'un type concret pour le paramÃ¨tre <code>element</code>, nous prÃ©cisons le mot-clÃ©
<code>impl</code> et le nom du trait. Ce paramÃ¨tre accepte n'importe quel type qui
implÃ©mente le trait spÃ©cifiÃ©. Dans le corps de <code>notifier</code>, nous pouvons appeler
toutes les mÃ©thodes sur <code>element</code> qui proviennent du trait <code>Resumable</code>, comme
<code>resumer</code>. Nous pouvons appeler <code>notifier</code> et passer une instance de
<code>ArticleDePresse</code> ou de <code>Tweet</code>. Le code qui appellera la fonction avec un autre
type, comme une <code>String</code> ou un <code>i32</code>, ne va pas se compiler car ces types
n'implÃ©mentent pas <code>Resumable</code>.</p>
<!--
#### Trait Bound Syntax
-->
<h4><a class="header" href="#la-syntaxe-du-trait-liÃ©" id="la-syntaxe-du-trait-liÃ©">La syntaxe du trait liÃ©</a></h4>
<!--
The `impl Trait` syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a *trait bound*; it looks like
this:
-->
<p>La syntaxe <code>impl Trait</code> fonctionne bien pour des cas simples, mais est en
rÃ©alitÃ© du sucre syntaxique pour une forme plus longue, qui s'appelle le
<em>trait liÃ©</em>Â ; qui ressemble Ã  ceciÂ :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element: &amp;T) {
    println!(&quot;Flash-infoÂ ! {}&quot;, element.resumer());
}
</code></pre>
<!--
This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.
-->
<p>Cette forme plus longue est Ã©quivalente Ã  l'exemple dans la section prÃ©cÃ©dente,
mais est plus verbeuse. Nous plaÃ§ons les traits liÃ©s dans la dÃ©claration des
paramÃ¨tres de type gÃ©nÃ©rique aprÃ¨s les double-points dans les chevrons.</p>
<!--
The `impl Trait` syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement `Summary`. Using the `impl
Trait` syntax looks like this:
-->
<p>La syntaxe <code>impl Trait</code> est pratique pour rendre du code plus concis dans des
cas simples. La syntaxe du trait liÃ© exprime plus de complexitÃ© dans certains
cas. Par exemple, nous pouvons avoir deux paramÃ¨tres qui implÃ©mentent
<code>Resumable</code>. En utilisant la syntaxe <code>impl Trait</code>, nous aurons ceciÂ :</p>
<!--
```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element1: &amp;impl Resumable, element2: &amp;impl Resumable) {
</code></pre>
<!--
If we wanted this function to allow `item1` and `item2` to have different
types, using `impl Trait` would be appropriate (as long as both types implement
`Summary`). If we wanted to force both parameters to have the same type, thatâ€™s
only possible to express using a trait bound, like this:
-->
<p>Si nous souhaitons permettre Ã  <code>element1</code> et <code>element2</code> d'avoir des types
diffÃ©rents, l'utilisation de <code>impl Trait</code> est appropriÃ© (du moment que chacun de
ces types implÃ©mentent <code>Resumable</code>). Mais si nous souhaitons forcer les deux
paramÃ¨tres d'Ãªtre du mÃªme type, cela n'est possible Ã  exprimer qu'avec un trait
liÃ©, comme ceciÂ :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element1: T, element2: T) {
</code></pre>
<!--
The generic type `T` specified as the type of the `item1` and `item2`
parameters constrains the function such that the concrete type of the value
passed as an argument for `item1` and `item2` must be the same.
-->
<p>Le type gÃ©nÃ©rique <code>T</code> renseignÃ© comme type des paramÃ¨tres <code>element1</code> et
<code>element2</code> contraint la fonction de maniÃ¨re Ã  ce que les types concrets des
valeurs passÃ©es en arguments pour <code>element1</code> et <code>element2</code> soient identiques.</p>
<!--
#### Specifying Multiple Trait Bounds with the `+` Syntax
-->
<h4><a class="header" href="#renseigner-plusieurs-traits-liÃ©s-avec-la-syntaxe-" id="renseigner-plusieurs-traits-liÃ©s-avec-la-syntaxe-">Renseigner plusieurs traits liÃ©s avec la syntaxe <code>+</code></a></h4>
<!--
We can also specify more than one trait bound. Say we wanted `notify` to use
display formatting on `item` as well as the `summarize` method: we specify in
the `notify` definition that `item` must implement both `Display` and
`Summary`. We can do so using the `+` syntax:
-->
<p>Nous pouvons aussi prÃ©ciser que nous attendons plus d'un trait liÃ©. Imaginons
que nous souhaitons que <code>notifier</code> utilise le formatage d'affichage sur
<code>element</code> ainsi que la mÃ©thode <code>resumer</code>Â : nous indiquons dans la dÃ©finition de
<code>notify</code> que <code>element</code> doit implÃ©menter <code>Affichable</code> et <code>Resumable</code>. Nous
pouvons faire ceci avec la syntaxe <code>+</code>Â :</p>
<!--
```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element: &amp;(impl Resumable + Affichable)) {
</code></pre>
<!--
The `+` syntax is also valid with trait bounds on generic types:
-->
<p>La syntaxe <code>+</code> fonctionne aussi avec les traits liÃ©s sur des types gÃ©nÃ©riquesÂ :</p>
<!--
```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable + Affichable&gt;(element: &amp;T) {
</code></pre>
<!--
With the two trait bounds specified, the body of `notify` can call `summarize`
and use `{}` to format `item`.
-->
<p>Avec les deux traits liÃ©s renseignÃ©s, le corps de <code>notifier</code> va appeler
<code>resumer</code> et utiliser <code>{}</code> pour formater <code>element</code>.</p>
<!--
#### Clearer Trait Bounds with `where` Clauses
-->
<h4><a class="header" href="#des-traits-liÃ©s-plus-clairs-avec-linstruction-where" id="des-traits-liÃ©s-plus-clairs-avec-linstruction-where">Des traits liÃ©s plus clairs avec l'instruction <code>where</code></a></h4>
<!--
Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the functionâ€™s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a `where` clause after the function
signature. So instead of writing this:
-->
<p>L'utilisation de trop nombreux traits liÃ©s a aussi ses dÃ©savantages. Chaque
gÃ©nÃ©rique a ses propres traits liÃ©s, donc les fonctions avec plusieurs
paramÃ¨tres de types gÃ©nÃ©riques peuvent aussi avoir de nombreuses informations de
traits liÃ©s entre le nom de la fonction et la liste de ses paramÃ¨tres, ce qui
rend la signature de la fonction difficile Ã  lire. Pour cette raison, Rust a une
syntaxe alternative pour renseigner les traits liÃ©s, dans une instruction
<code>where</code> aprÃ¨s la signature de la fonction. Donc, Ã  la place d'Ã©crire ceci ...</p>
<!--
```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```
-->
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<!--
we can use a `where` clause, like this:
-->
<p>... nous pouvons utiliser l'instruction <code>where</code>, comme ceciÂ :</p>
<!--
```rust,ignore
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
```
-->
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!--
This functionâ€™s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.
-->
<p>La signature de cette fonction est moins encombrÃ©eÂ : le nom de la fonction, la
liste des paramÃ¨tres, et le type de retour sont plus proches l'un de l'autre,
comme une fonction sans traits liÃ©s.</p>
<!--
### Returning Types that Implement Traits
-->
<h3><a class="header" href="#retourner-des-types-qui-implÃ©mentent-des-traits" id="retourner-des-types-qui-implÃ©mentent-des-traits">Retourner des types qui implÃ©mentent des traits</a></h3>
<!--
We can also use the `impl Trait` syntax in the return position to return a
value of some type that implements a trait, as shown here:
-->
<p>Nous pouvons aussi utiliser la syntaxe <code>impl Trait</code> Ã  la place du retour afin
de retourner une valeur d'un type qui implÃ©mente un trait, comme ci-dessousÂ :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable() -&gt; impl Resumable {
    Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
        reponse: false,
        retweet: false,
    }
}
</code></pre>
<!--
By using `impl Summary` for the return type, we specify that the
`returns_summarizable` function returns some type that implements the `Summary`
trait without naming the concrete type. In this case, `returns_summarizable`
returns a `Tweet`, but the code calling this function doesnâ€™t know that.
-->
<p>En utilisant <code>impl Resumable</code> pour le type de retour, nous indiquons que la
fonction <code>retourne_resumable</code>retourne un type qui implÃ©mente le trait
<code>Resumable</code> sans avoir Ã  Ã©crire le nom du type concret. Dans notre cas,
<code>retourne_resumable</code> retourne un <code>Tweet</code>, mais le code qui appellera cette
fonction ne le saura pas.</p>
<!--
The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The `impl Trait` syntax lets you
concisely specify that a function returns some type that implements the
`Iterator` trait without needing to write out a very long type.
-->
<p>La capacitÃ© de retourner un type qui est uniquement caractÃ©risÃ© par le trait
qu'il implÃ©mente est tout particuliÃ¨rement utile dans le cas des fermetures et
des itÃ©rateurs, que nous allons voir au chapitre 13. Les fermetures et les
itÃ©rateurs crÃ©ent des types que seul le compilateur est en mesure de comprendre
ou alors des types qui sont trÃ¨s longs Ã  dÃ©finir. La syntaxe <code>impl Trait</code> vous
permet de renseigner de maniÃ¨re concise qu'une fonction retourne un type
particulier qui implÃ©mente le trait <code>Iterator</code> sans avoir Ã  Ã©crire un trÃ¨s long
type.</p>
<!--
However, you can only use `impl Trait` if youâ€™re returning a single type. For
example, this code that returns either a `NewsArticle` or a `Tweet` with the
return type specified as `impl Summary` wouldnâ€™t work:
-->
<p>Cependant, vous pouvez seulement utiliser <code>impl Trait</code> si vous retournez un
seul type possible. Par exemple, ce code va retourner soit un <code>ArticleDePresse</code>,
soit un <code>Tweet</code>, alors que le type de retour avec <code>impl Resumable</code> ne va pas
fonctionnerÂ :</p>
<!--
```rust,ignore,does_not_compile
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}Â : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable(estArticle: bool) -&gt; impl Resumable {
    if estArticle {
        ArticleDePresse {
            titre: String::from(&quot;Les Pinguins ont gagnÃ© la Stanley Cup ChampionshipÂ !&quot;),
            lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
            auteur: String::from(&quot;Iceburgh&quot;),
            contenu: String::from(&quot;Les Pinguins de Pittsburgh sont une nouvelle fois la
            meilleure Ã©quipe de hockey de la NHL.&quot;),
        }
    } else {
        Tweet {
            nom_utilisateur: String::from(&quot;jean&quot;),
            contenu: String::from(&quot;Bien sÃ»r, les amis, comme vous le savez probablement dÃ©jÃ &quot;),
            reponse: false,
            retweet: false,
        }
    }
}
</code></pre>
<!--
Returning either a `NewsArticle` or a `Tweet` isnâ€™t allowed due to restrictions
around how the `impl Trait` syntax is implemented in the compiler. Weâ€™ll cover
how to write a function with this behavior in the [â€œUsing Trait Objects That
Allow for Values of Different
Typesâ€][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section of Chapter 17.
-->
<p>Retourner soit un <code>ArticleDePresse</code>, soit un <code>Tweet</code> n'est pas autorisÃ© Ã  cause
des restrictions sur comment la syntaxe <code>impl Trait</code> est implÃ©mentÃ©e dans le
compilateur. Nous allons voir comment Ã©crire une fonction avec ce comportement
dans une section du
<a href="ch17-02-trait-objects.html">chapitre 17</a><!--
ignore -->.</p>
<!--
### Fixing the `largest` Function with Trait Bounds
-->
<h3><a class="header" href="#rÃ©soudre-la-fonction-le_plus_grand-avec-les-traits-liÃ©s" id="rÃ©soudre-la-fonction-le_plus_grand-avec-les-traits-liÃ©s">RÃ©soudre la fonction <code>le_plus_grand</code> avec les traits liÃ©s</a></h3>
<!--
Now that you know how to specify the behavior you want to use using the generic
type parameterâ€™s bounds, letâ€™s return to Listing 10-5 to fix the definition of
the `largest` function that uses a generic type parameter! Last time we tried
to run that code, we received this error:
-->
<p>Maintenant que vous savez comment renseigner le comportement que vous souhaitez
utiliser en utilisant les paramÃ¨tres de types gÃ©nÃ©riques liÃ©s, retournons Ã 
l'encart 10-5 pour rÃ©soudre la dÃ©finition de la fonction <code>le_plus_grand</code> qui
utilise un paramÃ¨tre de type gÃ©nÃ©riqueÂ ! La derniÃ¨re fois qu'on a essayÃ© de
lancer ce code, nous avions l'erreur suivanteÂ :</p>
<!--
```text
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-text">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
In the body of `largest` we wanted to compare two values of type `T` using the
greater than (`>`) operator. Because that operator is defined as a default
method on the standard library trait `std::cmp::PartialOrd`, we need to specify
`PartialOrd` in the trait bounds for `T` so the `largest` function can work on
slices of any type that we can compare. We donâ€™t need to bring `PartialOrd`
into scope because itâ€™s in the prelude. Change the signature of `largest` to
look like this:
-->
<p>Dans le corps de <code>le_plus_grand</code> nous voulions comparer les deux valeurs du
type <code>T</code> en utilisant l'opÃ©rateur <em>plus grand que</em> (<code>&gt;</code>). Comme cet opÃ©rateur
est dÃ©fini comme une mÃ©thode par dÃ©faut dans le trait de la bibliothÃ¨que
standard <code>std::cmp::PartialOrd</code>, nous devons prÃ©ciser <code>PartialOrd</code> dans les
traits liÃ©s pour <code>T</code> afin que la fonction <code>le_plus_grand</code> puisse fonctionner sur
les slices de n'importe quel type que nous pouvons comparer. Nous n'avons pas
besoin d'importer <code>PartialOrd</code> dans la portÃ©e car il est importÃ© dans l'Ã©tape
prÃ©liminaire. Changez la signature de <code>le_plus_grand</code> par quelque chose comme
ceciÂ :</p>
<!--
```rust,ignore
fn largest<T: PartialOrd>(list: &[T]) -> T {
#     let mut largest = list[0];
# 
#     for &item in list {
#         if item > largest {
#             largest = item;
#         }
#     }
# 
#     largest
# }
# 
# fn main() {
#     let number_list = vec![34, 50, 25, 100, 65];
# 
#     let result = largest(&number_list);
#     println!("The largest number is {}", result);
# 
#     let char_list = vec!['y', 'm', 'a', 'q'];
# 
#     let result = largest(&char_list);
#     println!("The largest char is {}", result);
# }
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T: PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
<span class="boring">    let mut le_plus_grand = liste[0];
</span><span class="boring">
</span><span class="boring">    for &amp;element in liste {
</span><span class="boring">        if element &gt; le_plus_grand {
</span><span class="boring">            le_plus_grand = element;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    le_plus_grand
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let liste_de_nombres = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_nombres);
</span><span class="boring">    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
</span><span class="boring">
</span><span class="boring">    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_caracteres);
</span><span class="boring">    println!(&quot;Le plus grand caractÃ¨re est {}&quot;, resultat);
</span><span class="boring">}
</span></code></pre>
<!--
This time when we compile the code, we get a different set of errors:
-->
<p>Cette fois, lorsque nous allons compiler le code, nous aurons un ensemble
d'erreurs diffÃ©rentÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- > src/main.rs:2:23
  |
2 |     let mut le_plus_grand = liste[0];
  |                             ^^^^^^^^
  |                             |
  |                             cannot move out of here
  |                             move occurs because `liste[_]` has type `T`, which does not implement the `Copy` trait
  |                             help: consider borrowing here: `&liste[0]`

error[E0507]: cannot move out of a shared reference
 -- > src/main.rs:4:18
  |
4 |     for &element in liste {
  |         --------    ^^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `element` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `element`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The key line in this error is `cannot move out of type [T], a non-copy slice`.
With our non-generic versions of the `largest` function, we were only trying to
find the largest `i32` or `char`. As discussed in the [â€œStack-Only Data:
Copyâ€][stack-only-data-copy]<!-- ignore -- > section in Chapter 4, types like
`i32` and `char` that have a known size can be stored on the stack, so they
implement the `Copy` trait. But when we made the `largest` function generic,
it became possible for the `list` parameter to have types in it that donâ€™t
implement the `Copy` trait. Consequently, we wouldnâ€™t be able to move the
value out of `list[0]` and into the `largest` variable, resulting in this
error.
-->
<p>L'Ã©lement-clÃ© dans ces erreurs est <code>cannot move out of type [T], a non-copy slice</code>. Avec notre version non gÃ©nÃ©rique de la fonction <code>le_plus_grand</code>, nous
avions essayÃ© de trouver le plus grand <code>i32</code> ou <code>char</code>. Comme nous l'avons vu
dans la section
<a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">â€œDonnÃ©es uniquement sur la pileÂ : la copieâ€</a><!--
ignore --> du chapitre 4, les types comme <code>i32</code> et <code>char</code> ont une taille connue
et peuvent Ãªtre stockÃ©s sur la pile, donc ils implÃ©mentent le trait <code>Copy</code>. Par
consÃ©quent, nous ne pouvons pas forcÃ©ment dÃ©placer la valeur de <code>list[0]</code> dans
notre variable <code>le_plus_grand</code>, ce qui engendre cette erreur.</p>
<!--
To call this code with only those types that implement the `Copy` trait, we can
add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of
a generic `largest` function that will compile as long as the types of the
values in the slice that we pass into the function implement the `PartialOrd`
*and* `Copy` traits, like `i32` and `char` do.
-->
<p>Pour pouvoir appeler ce code avec seulement les types qui implÃ©mentent le trait
<code>Copy</code>, nous pouvons ajouter <code>Copy</code> aux traits liÃ©s de <code>T</code>Â ! L'encart 10-15 nous
montre le code complet d'une fonction gÃ©nÃ©rique <code>le_plus_grand</code> qui va se
compiler tant que les types valeurs dans la slice que nous passons dans la
fonction implÃ©mente les traits <code>PartialOrd</code> <em>et</em> <code>Copy</code>, comme le font <code>i32</code> et
<code>char</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn le_plus_grand<T: PartialOrd + Copy>(liste: &[T]) -> T {
    let mut le_plus_grand = liste[0];

    for &element in liste {
        if element > le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&liste_de_caracteres);
    println!("Le plus grand caractÃ¨re est {}", resultat);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-15: A working definition of the `largest`
function that works on any generic type that implements the `PartialOrd` and
`Copy` traits</span>
-->
<p><span class="caption">Encart 10-15Â : une dÃ©finition de la fonction
<code>le_plus_grand</code> qui fonctionne et s'applique sur n'importe quel type gÃ©nÃ©rique
qui implÃ©mente les traits <code>PartialOrd</code> et <code>Copy</code></span></p>
<!--
If we donâ€™t want to restrict the `largest` function to the types that implement
the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead
of `Copy`. Then we could clone each value in the slice when we want the
`largest` function to have ownership. Using the `clone` function means weâ€™re
potentially making more heap allocations in the case of types that own heap
data like `String`, and heap allocations can be slow if weâ€™re working with
large amounts of data.
-->
<p>Si nous ne souhaitons pas restreindre la fonction <code>le_plus_grand</code> aux types qui
implÃ©mentent le trait <code>Copy</code>, nous pouvons prÃ©ciser que <code>T</code> a le trait liÃ©
<code>Clone</code> plutÃ´t que <code>Copy</code>. Ainsi, nous pouvons cloner chaque valeur dans la
slice lorsque nous souhaitons que la fonction <code>le_plus_grand</code> en prenne
possession. L'utilisation de la fonction <code>clone</code> signifie que nous allons
potentiellement allouer plus d'espace sur le tas dans le cas des types qui
possÃ¨dent des donnÃ©es sur le tas, comme <code>String</code>, et les allocations sur le tas
peuvent Ãªtre lentes si nous travaillons avec des grandes quantitÃ©s de donnÃ©es.</p>
<!--
Another way we could implement `largest` is for the function to return a
reference to a `T` value in the slice. If we change the return type to `&T`
instead of `T`, thereby changing the body of the function to return a
reference, we wouldnâ€™t need the `Clone` or `Copy` trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
-->
<p>Une autre faÃ§on d'implÃ©menter <code>le_plus_grand</code> est de faire en sorte que la
fonction retourne une rÃ©fÃ©rence Ã  une valeur <code>T</code> de la slice. Si nous changeons
le type de retour en <code>&amp;T</code> Ã  la place de <code>T</code>, ainsi qu'adapter le corps de la
fonction afin de retourner une rÃ©fÃ©rence, nous n'aurions alors plus besoin des
traits liÃ©s <code>Clone</code> ou <code>Copy</code> et nous pourrions ainsi Ã©viter l'allocation sur
le tas. Essayez d'implÃ©menter cette solution alternative par vous-mÃªmeÂ !</p>
<!--
### Using Trait Bounds to Conditionally Implement Methods
-->
<h3><a class="header" href="#utiliser-les-traits-liÃ©s-pour-conditionner-limplÃ©mentation-des-mÃ©thodes" id="utiliser-les-traits-liÃ©s-pour-conditionner-limplÃ©mentation-des-mÃ©thodes">Utiliser les traits liÃ©s pour conditionner l'implÃ©mentation des mÃ©thodes</a></h3>
<!--
By using a trait bound with an `impl` block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type `Pair<T>` in Listing 10-16 always implements the
`new` function. But `Pair<T>` only implements the `cmp_display` method if its
inner type `T` implements the `PartialOrd` trait that enables comparison *and*
the `Display` trait that enables printing.
-->
<p>En utilisant un trait liÃ© avec un bloc <code>impl</code> qui utilise les paramÃ¨tres de type
gÃ©nÃ©rique, nous pouvons implÃ©menter des mÃ©thodes en fonction des types
qu'implÃ©mentent des traits particuliers. Par exemple, le type <code>Pair&lt;T&gt;</code> de
l'encart 10-16 implÃ©mente toujours la fonction <code>new</code>. Mais <code>Pair&lt;T&gt;</code> implÃ©mente
uniquement la mÃ©thode <code>affiche_comparaison</code> que si son type interne <code>T</code>
implÃ©mente le trait <code>PartialOrd</code> qui active la comparaison <em>et</em> le trait
<code>Display</code> qui permet l'affichage.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn affiche_comparaison(&self) {
        if self.x >= self.y {
            println!("Le plus grand Ã©lÃ©ment est x = {}", self.x);
        } else {
            println!("Le plus grand Ã©lÃ©ment est y = {}", self.y);
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span>
-->
<p><span class="caption">Encart 10-16Â : implÃ©mentation de mÃ©thodes sur un type
gÃ©nÃ©rique en fonction du trait liÃ©</span></p>
<!--
We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called *blanket implementations* and are extensively used in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:
-->
<p>Nous pouvons Ã©galement appliquer un trait sur un type qui applique un autre
trait. L'implÃ©mentation d'un trait sur n'importe quel type qui a un trait liÃ©
est appelÃ©e <em>implÃ©mentation gÃ©nÃ©rale</em> et est largement utilisÃ©e dans la
bibliothÃ¨que standard Rust. Par exemple, la bibliothÃ¨que standard implÃ©mente le
trait <code>ToString</code> sur tous les types qui implÃ©mentent le trait <code>Display</code>. Le bloc
<code>impl</code> de la bibliothÃ¨que standard ressemble au code suivantÂ :</p>
<!--
```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
Because the standard library has this blanket implementation, we can call the
`to_string` method defined by the `ToString` trait on any type that implements
the `Display` trait. For example, we can turn integers into their corresponding
`String` values like this because integers implement `Display`:
-->
<p>Comme la bibliothÃ¨que standard a cette implÃ©mentation gÃ©nÃ©rale, nous pouvons
appeler la mÃ©thode <code>to_string</code> dÃ©finie par le trait <code>ToString</code> sur n'importe
quel type qui implÃ©mente le trait <code>Display</code>. Par exemple, nous pouvons
transformer les entiers en leur Ã©quivalent dans une <code>String</code> comme ci-dessous
car les entiers implÃ©mentent <code>Display</code>Â :</p>
<!--
```rust
let s = 3.to_string();
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
Blanket implementations appear in the documentation for the trait in the
â€œImplementorsâ€ section.
-->
<p>Les implÃ©mentations gÃ©nÃ©rales sont dÃ©crites dans la documentation du trait, dans
la section â€œImplementorsâ€.</p>
<!--
Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didnâ€™t define the method. But Rust
moves these errors to compile time so weâ€™re forced to fix the problems before
our code is even able to run. Additionally, we donâ€™t have to write code that
checks for behavior at runtime because weâ€™ve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.
-->
<p>Les traits et les traits liÃ©s nous permettent d'Ã©crire du code qui utilise des
paramÃ¨tres de type gÃ©nÃ©rique pour rÃ©duire la duplication de code, mais aussi
pour indiquer au compilateur que nous voulons que le type gÃ©nÃ©rique ait un
comportement particulier. Le compilateur peut ensuite utiliser les informations
liÃ©es aux traits pour vÃ©rifier que tous les types concrets utilisÃ©s dans notre
code suivent le comportement souhaitÃ©. Dans les langages typÃ©s dynamiquement,
nous aurons une erreur Ã  l'exÃ©cution si nous appelions une mÃ©thode sur un type
qui n'implÃ©mentait pas la mÃ©thode. Mais Rust dÃ©cale l'apparition de ces erreurs
au moment de la compilation afin de nous forcer Ã  rÃ©soudre les problÃ¨mes avant
mÃªme que notre code soit capable de s'exÃ©cuter. De plus, nous n'avons pas besoin
d'Ã©crire un code qui vÃ©rifie le comportement lors de l'exÃ©cution car nous
l'avons dÃ©jÃ  vÃ©rifiÃ© au moment de la compilation. Cela permet d'amÃ©liorer les
performances sans avoir Ã  sacrifier la flexibilitÃ© des gÃ©nÃ©riques.</p>
<!--
Another kind of generic that weâ€™ve already been using is called *lifetimes*.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Letâ€™s look at how
lifetimes do that.
-->
<p>Un autre type de gÃ©nÃ©rique que nous avons dÃ©jÃ  utilisÃ© est la <em>durÃ©e de vie</em>.
PlutÃ´t que de s'assurer qu'un type a le comportement que nous voulons, la durÃ©e
de vie s'assure que les rÃ©fÃ©rences sont en vigueur aussi longtemps que nous
avons besoin qu'elles le soient. Nous allons voir Ã  la page suivante comment la
durÃ©e de vie fait cela.</p>
<!-- markdownlint-disable -->
<!--
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<!-- markdownlint-restore -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--7" id="-attention-peinture-fraÃ®che--7">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/120">Pull Request</a>.</p>
</blockquote>
<!--
## Validating References with Lifetimes
-->
<h2><a class="header" href="#la-conformitÃ©-des-rÃ©fÃ©rences-avec-les-durÃ©es-de-vies" id="la-conformitÃ©-des-rÃ©fÃ©rences-avec-les-durÃ©es-de-vies">La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></h2>
<!--
One detail we didnâ€™t discuss in the [â€œReferences and
Borrowingâ€][references-and-borrowing]<!-- ignore -- > section in Chapter 4 is
that every reference in Rust has a *lifetime*, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and
inferred, just like most of the time, types are inferred. We must annotate
types when multiple types are possible. In a similar way, we must annotate
lifetimes when the lifetimes of references could be related in a few different
ways. Rust requires us to annotate the relationships using generic lifetime
parameters to ensure the actual references used at runtime will definitely be
valid.
-->
<p>Il reste un dÃ©tail que nous n'avons pas abordÃ© dans la section <a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-et-lemprunt">â€œLes rÃ©fÃ©rences
et l'empruntâ€</a><!-- ignore --> du chapitre 4, c'est que
toutes les rÃ©fÃ©rences ont une <em>durÃ©e de vie</em> dans Rust, qui est la portÃ©e pour
laquelle cette rÃ©fÃ©rence est en vigueur. La plupart du temps, les durÃ©es de
vies sont implicites et sont dÃ©duit automatiquement, comme pour la plupart du
temps les types sont dÃ©duits. Nous devons renseigner le type lorsque plusieurs
types sont possibles. De la mÃªme maniÃ¨re, nous devons renseigner les durÃ©es de
vie lorsque les durÃ©es de vies des rÃ©fÃ©rences peuvent Ãªtre dÃ©duites de
diffÃ©rentes maniÃ¨res. Rust nÃ©cessite que nous renseignons ces relations en
utilisant des paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques pour s'assurer que les
rÃ©fÃ©rences utilisÃ©es au moment de la compilation restent bien en vigueur.</p>
<!--
The concept of lifetimes is somewhat different from tools in other programming
languages, arguably making lifetimes Rustâ€™s most distinctive feature. Although
we wonâ€™t cover lifetimes in their entirety in this chapter, weâ€™ll discuss
common ways you might encounter lifetime syntax so you can become familiar with
the concepts.
-->
<p>Le concept de la durÃ©e de vie est quelque chose de radicalement diffÃ©rent de ce
que l'on retrouve dans les outils des autres langages de programmation, Ã  un
tel point que la durÃ©e de vie est la fonctionnalitÃ© qui distingue Rust des
autres. Bien que nous ne puissions couvrir l'intÃ©gralitÃ© de la durÃ©e de vie dans
ce chapitre, nous allons voir les cas les plus courants oÃ¹ vous allez
rencontrer la syntaxe de la durÃ©e de vie, afin de vous familiariser avec ses
concepts.</p>
<!--
### Preventing Dangling References with Lifetimes
-->
<h3><a class="header" href="#eviter-les-rÃ©fÃ©rences-pendouillantes-avec-les-durÃ©es-de-vie" id="eviter-les-rÃ©fÃ©rences-pendouillantes-avec-les-durÃ©es-de-vie">Eviter les rÃ©fÃ©rences pendouillantes avec les durÃ©es de vie</a></h3>
<!--
The main aim of lifetimes is to prevent dangling references, which cause a
program to reference data other than the data itâ€™s intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.
-->
<p>L'objectif principal des durÃ©es de vies est d'Ã©viter les rÃ©fÃ©rences
pendouillantes qui font qu'un programme pointe des donnÃ©es autres que celles sur
lesquelles il Ã©tait censÃ© pointer. Admettons le programme de l'encart 10-17, qui
a une portÃ©e externe et une portÃ©e interne.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-17Â : tentative d'utiliser une rÃ©fÃ©rence vers
une valeur qui est sortie de la portÃ©e</span></p>
<!--
> Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
> without giving them an initial value, so the variable name exists in the
> outer scope. At first glance, this might appear to be in conflict with Rustâ€™s
> having no null values. However, if we try to use a variable before giving it
> a value, weâ€™ll get a compile-time error, which shows that Rust indeed does
> not allow null values.
-->
<blockquote>
<p>RemarqueÂ : Les exemples dans les encarts 10-17, 10-18 et 10-24 dÃ©clarent des
variables sans initialiser leur valeur, donc les noms de ces variables
existent dans la portÃ©e externe. A premiÃ¨re vue, cela semble Ãªtre en conflit
avec le fonctionnement de Rust qui n'utilise pas les valeurs nulles.
Cependant, si nous essayons d'utiliser une variable avant de lui donner une
valeur, nous aurons une erreur au moment de la compilation, qui confirme que
Rust ne fonctionne pas avec des valeurs nulles.</p>
</blockquote>
<!--
The outer scope declares a variable named `r` with no initial value, and the
inner scope declares a variable named `x` with the initial value of 5. Inside
the inner scope, we attempt to set the value of `r` as a reference to `x`. Then
the inner scope ends, and we attempt to print the value in `r`. This code wonâ€™t
compile because the value `r` is referring to has gone out of scope before we
try to use it. Here is the error message:
-->
<p>La portÃ©e externe dÃ©clare une variable <code>r</code> sans valeur initiale, et la portÃ©e
interne dÃ©clare une variable <code>x</code> avec la valeur initiale Ã  <code>5</code>. Au sein de la
portÃ©e interne, nous essayons d'assigner la valeur de <code>r</code> comme Ã©tant une
rÃ©fÃ©rence Ã  <code>x</code>. Puis la portÃ©e interne se ferme, et nous essayons d'afficher la
valeur dans <code>r</code>. Ce code ne va pas se compiler car la valeur <code>r</code> se rÃ©fÃ¨re Ã 
quelque chose qui est sortie de la portÃ©e avant que nous essayons de l'utiliser.
Voici le message d'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
<p>|
7  |             r = &amp;x;
|                 ^^ borrowed value does not live long enough
8  |         }
|         - <code>x</code> dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
|                           - borrow later used here</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0597</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The variable `x` doesnâ€™t â€œlive long enough.â€ The reason is that `x` will be out
of scope when the inner scope ends on line 7. But `r` is still valid for the
outer scope; because its scope is larger, we say that it â€œlives longer.â€ If
Rust allowed this code to work, `r` would be referencing memory that was
deallocated when `x` went out of scope, and anything we tried to do with `r`
wouldnâ€™t work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.
-->
<p>La variable <code>x</code> n'existe plus (â€œdoes not live long enoughâ€). La raison Ã  cela
est que <code>x</code> est sortie de la portÃ©e lorsque la portÃ©e interne s'est fermÃ©e Ã  la
ligne 7. Mais <code>r</code> reste en vigueur dans la portÃ©e externeÂ ; car sa portÃ©e est
plus grande, on dit qu'il â€œvit plus longtempsâ€. Si Rust avait permis Ã  ce code de
s'exÃ©cuter, <code>r</code> pointerait sur de la mÃ©moire dÃ©sallouÃ©e dÃ¨s que <code>x</code> est sortie
de la portÃ©e, ainsi tout ce que nous pourrions faire avec <code>r</code> ne fonctionnerait
pas correctement. Mais comment Rust dÃ©tecte que ce code est invalideÂ ? Il
utilise le vÃ©rificateur d'emprunt.</p>
<!--
### The Borrow Checker
-->
<h3><a class="header" href="#le-vÃ©rificateur-demprunt" id="le-vÃ©rificateur-demprunt">Le vÃ©rificateur d'emprunt</a></h3>
<!--
The Rust compiler has a *borrow checker* that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.
-->
<p>Le compilateur de Rust embarque un <em>vÃ©rificateur d'emprunt</em> (borrow checker) qui
compare les portÃ©es pour dÃ©terminer si les emprunts sont valides. L'encart 10-18
montre le mÃªme code que l'encart 10-17, mais avec des commentaires qui montrent
les durÃ©es de vies des variables.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-18: Annotations of the lifetimes of `r` and
`x`, named `'a` and `'b`, respectively</span>
-->
<p><span class="caption">Encart 10-18Â : commentaires pour montrer les durÃ©es de vie
de <code>r</code> et <code>x</code>, qui s'appellent respectivement <code>'a</code> et <code>'b</code></span></p>
<!--
Here, weâ€™ve annotated the lifetime of `r` with `'a` and the lifetime of `x`
with `'b`. As you can see, the inner `'b` block is much smaller than the outer
`'a` lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory
with a lifetime of `'b`. The program is rejected because `'b` is shorter than
`'a`: the subject of the reference doesnâ€™t live as long as the reference.
-->
<p>Ici, nous avons montrÃ© la durÃ©e de vie de <code>r</code> avec <code>'a</code> et la durÃ©e de vie de
<code>x</code> avec <code>'b</code>. Comme vous pouvez le constater, le bloc interne <code>'b</code> est bien
plus petit que le bloc externe <code>'a</code>. Au moment de la compilation, Rust compare
les tailles des deux durÃ©es de vies et constate que <code>r</code> a la durÃ©e de vie <code>'a</code>
mais fait rÃ©fÃ©rence Ã  de la mÃ©moire qui a une durÃ©e de vie de <code>'b</code>. Ce programme
est refusÃ© car <code>'b</code> est plus court que <code>'a</code>Â : l'Ã©lÃ©ment pointÃ© par la rÃ©fÃ©rence
n'existe pas aussi longtemps que la rÃ©fÃ©rence.</p>
<!--
Listing 10-19 fixes the code so it doesnâ€™t have a dangling reference and
compiles without any errors.
-->
<p>L'encart 10-19 rÃ©sout le code afin qu'il n'ai plus de rÃ©fÃ©rence pendouillante et
qu'il se compile sans erreur.</p>
<!--
```rust
# fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span>
-->
<p><span class="caption">Encart 10-19Â : la rÃ©fÃ©rence est valide puisque la donnÃ©e a
une durÃ©e de vie plus longue que la rÃ©fÃ©rence</span></p>
<!--
Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. This
means `r` can reference `x` because Rust knows that the reference in `r` will
always be valid while `x` is valid.
-->
<p>Ici, <code>x</code> a la durÃ©e de vie <code>'b</code>, qui est plus grand dans ce cas que <code>'a</code>. Cela
signifie que <code>r</code> peut rÃ©fÃ©rencer <code>x</code> car Rust sait que la rÃ©fÃ©rence prÃ©sente
dans <code>r</code> sera toujours valide du moment que <code>x</code> est en vigueur.</p>
<!--
Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, letâ€™s explore generic
lifetimes of parameters and return values in the context of functions.
-->
<p>Maintenant que vous savez oÃ¹ se situent les durÃ©es de vie des rÃ©fÃ©rences et
comment Rust analyse les durÃ©es de vies pour s'assurer que les rÃ©fÃ©rences soient
toujours en vigueur, dÃ©couvrons les durÃ©es de vies gÃ©nÃ©riques des paramÃ¨tres et
des valeurs de retour dans le cas des fonctions.</p>
<!--
### Generic Lifetimes in Functions
-->
<h3><a class="header" href="#les-durÃ©es-de-vies-gÃ©nÃ©riques-dans-les-fonctions" id="les-durÃ©es-de-vies-gÃ©nÃ©riques-dans-les-fonctions">Les durÃ©es de vies gÃ©nÃ©riques dans les fonctions</a></h3>
<!--
Letâ€™s write a function that returns the longer of two string slices. This
function will take two string slices and return a string slice. After weâ€™ve
implemented the `longest` function, the code in Listing 10-20 should print `The
longest string is abcd`.
-->
<p>Ecrivons une fonction qui retourne la plus longue des slice d'une chaÃ®ne de
caractÃ¨res. Cette fonction va prendre en argument deux slices de chaÃ®ne de
caractÃ¨res et retourner une slice d'une chaÃ®ne de caractÃ¨res. AprÃ¨s avoir
implÃ©mentÃ© la fonction <code>la_plus_longue</code>, le code de l'encart 10-20 devrait
afficher <code>La plus grande chaÃ®ne est abcd</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let resultat = la_plus_longue(string1.as_str(), string2);
    println!("La plus grande chaÃ®ne est {}", resultat);
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let resultat = la_plus_longue(string1.as_str(), string2);
    println!(&quot;La plus grande chaÃ®ne est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-20: A `main` function that calls the `longest`
function to find the longer of two string slices</span>
-->
<p><span class="caption">Encart 10-20Â : une fonction <code>main</code> qui appelle la
fonction <code>la_plus_longue</code> pour trouver la plus grande des deux slices de chaÃ®ne
de caractÃ¨res
</span></p>
<!--
Note that we want the function to take string slices, which are references,
because we donâ€™t want the `longest` function to take ownership of its
parameters. Refer to the [â€œString Slices as
Parametersâ€][string-slices-as-parameters]<!-- ignore -- > section in Chapter 4
for more discussion about why the parameters we use in Listing 10-20 are the
ones we want.
-->
<p>Remarquez que nous souhaitons que la fonction prenne deux slices de chaÃ®nes de
caractÃ¨res, qui sont des rÃ©fÃ©rences, car nous ne voulons pas que la fonction
<code>la_plus_longue</code> prenne possession de ses paramÃ¨tres. Rendez-vous Ã  la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res-en-param%C3%A8tres">â€œLes slices de chaÃ®nes de caractÃ¨res en
paramÃ¨tresâ€</a><!-- ignore --> du chapitre 4 pour
savoir pourquoi nous utilisons ce type de paramÃ¨tre dans l'encart 10-20.</p>
<!--
If we try to implement the `longest` function as shown in Listing 10-21, it
wonâ€™t compile.
-->
<p>Si nous essayons d'implÃ©menter la fonction <code>la_plus_longue</code> comme dans l'encart
10-21, cela ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La plus grande chaÃ®ne est {}", resultat);
# }
# 
fn la_plus_longue(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande chaÃ®ne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-21: An implementation of the `longest`
function that returns the longer of two string slices but does not yet
compile</span>
-->
<p><span class="caption">Encart 10-21Â : une implÃ©mentation de la fonction
<code>la_plus_longue</code> qui retourne la plus longue des deux slices de chaÃ®nes de
caractÃ¨res, mais ne se compile pas encore</span></p>
<!--
Instead, we get the following error that talks about lifetimes:
-->
<p>A la place, nous obtenons l'erreur suivante qui nous parle de durÃ©es de vieÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
<p>|
9 | fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
|                                        ^ expected lifetime parameter
|
= help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from <code>x</code> or <code>y</code></p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0106</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                        ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The help text reveals that the return type needs a generic lifetime parameter
on it because Rust canâ€™t tell whether the reference being returned refers to
`x` or `y`. Actually, we donâ€™t know either, because the `if` block in the body
of this function returns a reference to `x` and the `else` block returns a
reference to `y`!
-->
<p>La partie â€œhelpâ€ nous explique que le type de retour a besoin d'un paramÃ¨tre de
durÃ©e de vie gÃ©nÃ©rique car Rust ne sait pas si la rÃ©fÃ©rence retournÃ©e est liÃ©e Ã 
<code>x</code> ou Ã  <code>y</code>. Pour le moment, nous ne le savons pas nous non plus, car le bloc
<code>if</code> dans le corps de cette fonction retourne une rÃ©fÃ©rence Ã  <code>x</code> et le bloc
<code>else</code> retourne une rÃ©fÃ©rence Ã  <code>y</code>Â !</p>
<!--
When weâ€™re defining this function, we donâ€™t know the concrete values that will
be passed into this function, so we donâ€™t know whether the `if` case or the
`else` case will execute. We also donâ€™t know the concrete lifetimes of the
references that will be passed in, so we canâ€™t look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker canâ€™t determine this either, because it
doesnâ€™t know how the lifetimes of `x` and `y` relate to the lifetime of the
return value. To fix this error, weâ€™ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.
-->
<p>Lorsque nous dÃ©finissons cette fonction, nous ne connaissons pas les valeurs
concrÃ¨tes qui vont passer dans cette fonction, donc nous ne savons pas si nous
allons exÃ©cuter le cas du <code>if</code> ou du <code>else</code>. Nous ne connaissons pas non plus les
durÃ©es de vie des rÃ©fÃ©rences qui vont passer dans la fonction, donc nous ne
pouvons pas vÃ©rifier les portÃ©es comme nous l'avons fait dans les encarts 10-18
et 10-19 pour dÃ©terminer quelle rÃ©fÃ©rence que nous allons retourner sera
toujours en vigueur. Le vÃ©rificateur d'emprunt ne va pas pouvoir non plus
dÃ©terminer cela, car il ne sait comment les durÃ©es de vie de <code>x</code> et de <code>y</code> sont
reliÃ©es Ã  la durÃ©e de vie de la valeur de retour. Pour rÃ©soudre cette erreur,
nous allons ajouter des paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques qui dÃ©finissent
la relation entre les rÃ©fÃ©rences, afin que le vÃ©rificateur d'emprunt puisse
faire cette analyse.</p>
<!--
### Lifetime Annotation Syntax
-->
<h3><a class="header" href="#la-syntaxe-pour-annoter-les-durÃ©es-de-vies" id="la-syntaxe-pour-annoter-les-durÃ©es-de-vies">La syntaxe pour annoter les durÃ©es de vies</a></h3>
<!--
Lifetime annotations donâ€™t change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.
-->
<p>L'annotation des durÃ©es de vie ne change pas la longueur de leur durÃ©e de vie.
Comme une fonction accepte n'importe quel type lorsque la signature utilise un
paramÃ¨tre de type gÃ©nÃ©rique, les fonctions peuvent accepter des rÃ©fÃ©rences avec
n'importe quelle durÃ©e de vie en prÃ©cisant un paramÃ¨tre de durÃ©e de vie
gÃ©nÃ©rique. L'annotation des durÃ©es de vie dÃ©crit la relation des durÃ©es de vies
de plusieurs rÃ©fÃ©rences entre elles sans influencer les durÃ©es de vie.</p>
<!--
Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (`'`) and are usually all lowercase and
very short, like generic types. Most people use the name `'a`. We place
lifetime parameter annotations after the `&` of a reference, using a space to
separate the annotation from the referenceâ€™s type.
-->
<p>L'annotation des durÃ©es de vies a une syntaxe un peu inhabituelleÂ : le nom des
paramÃ¨tres de durÃ©es de vies doit commencer par une apostrophe (<code>'</code>) et sont
habituellement en minuscule et trÃ¨s court, comme les types gÃ©nÃ©riques. La
plupart des personnes utilisent le nom <code>'a</code>. Nous plaÃ§ons le paramÃ¨tre de type
aprÃ¨s le <code>&amp;</code> d'une rÃ©fÃ©rence, en utilisant un espace pour sÃ©parer l'annotation
du type de la rÃ©fÃ©rence.</p>
<!--
Here are some examples: a reference to an `i32` without a lifetime parameter, a
reference to an `i32` that has a lifetime parameter named `'a`, and a mutable
reference to an `i32` that also has the lifetime `'a`.
-->
<p>Voici quelques exemplesÂ : une rÃ©fÃ©rence Ã  un <code>i32</code> sans paramÃ¨tre de durÃ©e de
vie, une rÃ©fÃ©rence Ã  un <code>i32</code> qui a un paramÃ¨tre de durÃ©e de vie <code>'a</code>, et une
rÃ©fÃ©rence mutable Ã  un <code>i32</code> qui a aussi la durÃ©e de vie <code>'a</code>.</p>
<!--
```rust,ignore
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```
-->
<pre><code class="language-rust ignore">&amp;i32        // une rÃ©fÃ©rence
&amp;'a i32     // une rÃ©fÃ©rence avec une durÃ©e de vie explicite
&amp;'a mut i32 // une rÃ©fÃ©rence mutable avec une durÃ©e de vie explicite
</code></pre>
<!--
One lifetime annotation by itself doesnâ€™t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, letâ€™s say we have a function with
the parameter `first` that is a reference to an `i32` with lifetime `'a`. The
function also has another parameter named `second` that is another reference to
an `i32` that also has the lifetime `'a`. The lifetime annotations indicate
that the references `first` and `second` must both live as long as that generic
lifetime.
-->
<p>Une annotation de durÃ©e de vie toute seule n'a pas vraiment de sens, car les
annotations sont faites pour indiquer Ã  Rust quels paramÃ¨tres de durÃ©e de vie
gÃ©nÃ©riques de plusieurs rÃ©fÃ©rences sont liÃ©s aux autres. Par exemple, disons que
nous avons une fonction avec le paramÃ¨tre <code>premier</code> qui est une rÃ©fÃ©rence Ã  un
<code>i32</code> avec la durÃ©e de vie <code>'a</code>. La fonction a aussi un autre paramÃ¨tre <code>second</code>
qui est une autre rÃ©fÃ©rence Ã  un <code>i32</code> qui a aussi la durÃ©e de vie <code>'a</code>. Les
annotations de durÃ©e de vie indiquent que les rÃ©fÃ©rences <code>premier</code> et <code>second</code>
doivent tous les deux exister aussi longtemps que la durÃ©e de vie gÃ©nÃ©rique.</p>
<!--
### Lifetime Annotations in Function Signatures
-->
<h3><a class="header" href="#les-annotations-de-durÃ©e-de-vie-dans-les-signatures-des-fonctions" id="les-annotations-de-durÃ©e-de-vie-dans-les-signatures-des-fonctions">Les annotations de durÃ©e de vie dans les signatures des fonctions</a></h3>
<!--
Now letâ€™s examine lifetime annotations in the context of the `longest`
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. The constraint we want to express in this signature is that all the
references in the parameters and the return value must have the same lifetime.
Weâ€™ll name the lifetime `'a` and then add it to each reference, as shown in
Listing 10-22.
-->
<p>Maintenant, examinons les annotations de durÃ©e de vie dans contexte de la
fonction <code>la_plus_longue</code>. Comme avec les paramÃ¨tres de type gÃ©nÃ©riques, nous
devons dÃ©clarer les paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques dans des chevrons
entre le nom de la fonction et la liste des paramÃ¨tres. Nous souhaitons
contraindre toutes les rÃ©fÃ©rences dans les paramÃ¨tres de cette fonction ainsi
que sa valeur de retour aient tous la mÃªme durÃ©e de vie. Nous allons appeler la
durÃ©e de vie <code>'a</code> et ensuite l'ajouter Ã  chaque rÃ©fÃ©rence, comme nous le faisons
dans l'encart 10-22.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La plus grande chaÃ®ne est {}", resultat);
# }
# 
fn la_plus_longue<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande chaÃ®ne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-22: The `longest` function definition
specifying that all the references in the signature must have the same lifetime
`'a`</span>
-->
<p><span class="caption">Encart 10-22Â : dÃ©finition de la fonction <code>la_plus_longue</code>
qui indique que toutes les rÃ©fÃ©rences prÃ©sentes dans la signature doivent avoir
la mÃªme durÃ©e de vie <code>'a</code></span></p>
<!--
This code should compile and produce the result we want when we use it with the
`main` function in Listing 10-20.
-->
<p>Le code devrait se compiler et devrait produire le rÃ©sultat que nous souhaitions
lorsque nous l'utilisions dans la fonction <code>main</code> de l'encart 10-20.</p>
<!--
The function signature now tells Rust that for some lifetime `'a`, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime `'a`. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime `'a`.
In practice, it means that the lifetime of the reference returned by the
`longest` function is the same as the smaller of the lifetimes of the
references passed in. These constraints are what we want Rust to enforce.
Remember, when we specify the lifetime parameters in this function signature,
weâ€™re not changing the lifetimes of any values passed in or returned. Rather,
weâ€™re specifying that the borrow checker should reject any values that donâ€™t
adhere to these constraints. Note that the `longest` function doesnâ€™t need to
know exactly how long `x` and `y` will live, only that some scope can be
substituted for `'a` that will satisfy this signature.
-->
<p>La signature de la fonction indique maintenant Ã  Rust que pour la durÃ©e de vie
<code>'a</code>, la fonction prend deux paramÃ¨tres, les deux Ã©tant des slices de chaÃ®ne de
caractÃ¨re qui vivent aussi longtemps que la durÃ©e de vie <code>'a</code>. La signature de
la fonction indique Ã©galement Ã  Rust que la slice de chaÃ®ne de caractÃ¨re qui est
retournÃ©e par la fonction vivra au moins aussi longtemps que la durÃ©e de vie
<code>'a</code>. Dans la pratique, cela veut dire que durÃ©e de vie de la rÃ©fÃ©rence
retournÃ©e par la fonction <code>la_plus_longue</code> est la mÃªme que celle de la plus
petite des durÃ©es de vies des rÃ©fÃ©rences qu'on lui donne. Ces restrictions sont
celles que nous voulons que Rust fasse respecter. Souvenez-vous, lorsque nous
prÃ©cisons les paramÃ¨tres de durÃ©e de vie dans la signature de cette fonction,
nous ne changons pas les durÃ©es de vies des valeurs qui lui sont envoyÃ©es ou
qu'elle retourne. Ce que nous faisons, c'est plutÃ´t indiquer au vÃ©rificateur
d'emprunt qu'il doit rejeter toute valeur qui ne rÃ©pond pas Ã  ces conditions.
Notez que la fonction <code>la_plus_longue</code> n'a pas besoin de savoir exactement
combien de temps <code>x</code> et <code>y</code> vont exister, mais seulement que cette portÃ©e peut
Ãªtre substituÃ©e par <code>'a</code>, qui satisfera cette signature.</p>
<!--
When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help. However, when a function has references to or from
code outside that function, it becomes almost impossible for Rust to figure out
the lifetimes of the parameters or return values on its own. The lifetimes
might be different each time the function is called. This is why we need to
annotate the lifetimes manually.
-->
<p>Lorsqu'on prÃ©cise les durÃ©es de vie dans les fonctions, les annotations se
placent dans la signature de la fonction, pas dans le corps de la fonction. Rust
peut analyser le code Ã  l'intÃ©rieur du corps sans aucune aide. Cependant,
lorsqu'une fonction a des rÃ©fÃ©rences vers du code externe ou que ce code
rÃ©utilise une rÃ©fÃ©rence retournÃ©e par cette fonction, il devient presque
impossible pour Rust de dÃ©duire tout seul les durÃ©es de vie des paramÃ¨tres ou
des valeurs de retour. Les durÃ©es de vies peuvent Ãªtre diffÃ©rentes Ã  chaque fois
que la fonction est appelÃ©e. C'est pourquoi nous avons besoin d'indiquer les
durÃ©es de vie manuellement.</p>
<!--
When we pass concrete references to `longest`, the concrete lifetime that is
substituted for `'a` is the part of the scope of `x` that overlaps with the
scope of `y`. In other words, the generic lifetime `'a` will get the concrete
lifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because
weâ€™ve annotated the returned reference with the same lifetime parameter `'a`,
the returned reference will also be valid for the length of the smaller of the
lifetimes of `x` and `y`.
-->
<p>Lorsque nous donnons une rÃ©fÃ©rence concrÃ¨te Ã  <code>la_plus_longue</code>, la durÃ©e de vie
concrÃ¨te qui est modÃ©lisÃ©e par <code>'a</code> est la partie de la portÃ©e de <code>x</code> qui se
chevauche avec la portÃ©e de <code>y</code>. Autrement dit, la durÃ©e vie gÃ©nÃ©rique <code>'a</code> aura
la durÃ©e de vie concrÃ¨te qui est Ã©gale Ã  la plus petite des durÃ©es de vies entre
<code>x</code> et <code>y</code>. Comme nous avons marquÃ© la rÃ©fÃ©rence retournÃ©e avec le mÃªme
paramÃ¨tre de durÃ©e de vie <code>'a</code>, la rÃ©fÃ©rence retournÃ©e sera toujours en vigueur
pour la durÃ©e de la plus petite des durÃ©es de vies de <code>x</code> et de <code>y</code>.</p>
<!--
Letâ€™s look at how the lifetime annotations restrict the `longest` function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.
-->
<p>Regardons comment les annotations de durÃ©e de vie restreignent la fonction
<code>la_plus_longue</code> en y passant des rÃ©fÃ©rences qui ont des durÃ©es de vies
concrÃ¨tement diffÃ©rentes. L'encart 10-23 en est un exemple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let string1 = String::from("une longue chaÃ®ne est longue");

    {
        let string2 = String::from("xyz");
        let resultat = la_plus_longue(string1.as_str(), string2.as_str());
        println!("La chaÃ®ne la plus longue est {}", resultat);
    }
}
# 
# fn la_plus_longue<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;une longue chaÃ®ne est longue&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let resultat = la_plus_longue(string1.as_str(), string2.as_str());
        println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
    }
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-23: Using the `longest` function with
references to `String` values that have different concrete lifetimes</span>
-->
<p><span class="caption">Encart 10-23Â : utilisation de la fonction <code>la_plus_longue</code>
sur des rÃ©fÃ©rences Ã  des valeurs <code>String</code> qui ont concrÃ¨tement des durÃ©es de vie
diffÃ©rentes</span></p>
<!--
In this example, `string1` is valid until the end of the outer scope, `string2`
is valid until the end of the inner scope, and `result` references something
that is valid until the end of the inner scope. Run this code, and youâ€™ll see
that the borrow checker approves of this code; it will compile and print `The
longest string is long string is long`.
-->
<p>Dans cet exemple, <code>string1</code> est en vigueur jusqu'Ã  la fin de la portÃ©e externe,
<code>string2</code> n'est valide que jusqu'Ã  la fin de la portÃ©e interne, et <code>resultat</code>
est une rÃ©fÃ©rence vers quelque chose qui est en vigueur jusqu'Ã  la fin de la
portÃ©e interne. Lorsque vous lancez ce code, vous constaterez que le
vÃ©rificateur d'emprunt accepte ce codeÂ ; il va se compiler et afficher
<code>La chaÃ®ne la plus longue est une longue chaÃ®ne est longue</code>.</p>
<!--
Next, letâ€™s try an example that shows that the lifetime of the reference in
`result` must be the smaller lifetime of the two arguments. Weâ€™ll move the
declaration of the `result` variable outside the inner scope but leave the
assignment of the value to the `result` variable inside the scope with
`string2`. Then weâ€™ll move the `println!` that uses `result` outside the inner
scope, after the inner scope has ended. The code in Listing 10-24 will not
compile.
-->
<p>Maintenant, essayons un exemple qui fait en sorte que la durÃ©e de vie de la
rÃ©fÃ©rence dans <code>resultat</code> sera plus petite que celles des deux arguments. Nous
allons dÃ©placer la dÃ©claration de la variable <code>resultat</code> Ã  l'extÃ©rieur de la
portÃ©e interne mais on va laisser l'affectation de la valeur de la variable
<code>resultat</code> Ã  l'intÃ©rieur de la portÃ©e de <code>string2</code>. Nous allons ensuite dÃ©placer
le <code>println!</code>, qui utilise <code>resultat</code>, Ã  l'extÃ©rieur de la portÃ©e interne, aprÃ¨s
que la portÃ©e soit terminÃ©e. Le code de l'encart 10-24 ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let string1 = String::from("une longue chaÃ®ne est longue");
    let resultat;
    {
        let string2 = String::from("xyz");
        resultat = la_plus_longue(string1.as_str(), string2.as_str());
    }
    println!("La chaÃ®ne la plus longue est {}", resultat);
}
# 
# fn la_plus_longue<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;une longue chaÃ®ne est longue&quot;);
    let resultat;
    {
        let string2 = String::from(&quot;xyz&quot;);
        resultat = la_plus_longue(string1.as_str(), string2.as_str());
    }
    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-24: Attempting to use `result` after `string2`
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-24Â : tentative d'utilisation de <code>resultat</code> aprÃ¨s
<code>string2</code>, qui est sortie de la portÃ©e</span></p>
<!--
When we try to compile this code, weâ€™ll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous aurons cette erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
<p>|
6 |         result = la_plus_longue(string1.as_str(), string2.as_str());
|                                                   ^^^^^^^ borrowed value does not live long enough
7 |     }
|     - <code>string2</code> dropped here while still borrowed
8 |     println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
|                                                 -------- borrow later used here</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0597</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = la_plus_longue(string1.as_str(), string2.as_str());
  |                                                   ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
  |                                                 -------- borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error shows that for `result` to be valid for the `println!` statement,
`string2` would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter `'a`.
-->
<p>L'erreur explique que pour que <code>resultat</code> soit en vigueur pour l'instruction
<code>println!</code>, <code>string2</code> doit toujours Ãªtre valide jusqu'Ã  la fin de la portÃ©e
externe. Rust en a dÃ©duit cela car nous avons prÃ©cisÃ© les durÃ©es de vie des
paramÃ¨tres de la fonction et des valeurs de retour en utilisant le mÃªme
paramÃ¨tre de durÃ©e de vie <code>'a</code>.</p>
<!--
As humans, we can look at this code and see that `string1` is longer than
`string2` and therefore `result` will contain a reference to `string1`.
Because `string1` has not gone out of scope yet, a reference to `string1` will
still be valid for the `println!` statement. However, the compiler canâ€™t see
that the reference is valid in this case. Weâ€™ve told Rust that the lifetime of
the reference returned by the `longest` function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.
-->
<p>En tant qu'humain, nous pouvons lire ce code et constater que <code>string1</code> est plus
grand que <code>string2</code> et ainsi que <code>resultat</code> contiendra une rÃ©fÃ©rence vers
<code>string1</code>. Comme <code>string1</code> n'est pas encore sorti de portÃ©e, une rÃ©fÃ©rence vers
<code>string1</code> sera toujours valide pour l'instruction <code>println!</code>. Cependant, le
compilateur ne peut pas dÃ©duire que la rÃ©fÃ©rence est valide dans notre cas. Nous
avons dit Ã  Rust que la durÃ©e de vie de la rÃ©fÃ©rence qui est retournÃ©e par la
fonction <code>la_plus_longue</code> est la mÃªme que la plus petite des durÃ©es de vie des
rÃ©fÃ©rences qu'on lui passe en argument. C'est pourquoi le vÃ©rificateur d'emprunt
rejette le code de l'encart 10-24 car il a potentiellement une rÃ©fÃ©rence
invalide.</p>
<!--
Try designing more experiments that vary the values and lifetimes of the
references passed in to the `longest` function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if youâ€™re right!
-->
<p>Essayez d'expÃ©rimenter d'autres situations en variant les valeurs et durÃ©es de
vie des rÃ©fÃ©rences passÃ©es en argument de la fonction <code>la_plus_longue</code>, et
aussi comment on utilise la rÃ©fÃ©rence retournÃ©e. Faites des hypothÃ¨ses si ces
situations vont passer ou non le vÃ©rificateur d'emprunt avant que vous
compiliezÂ ; et vÃ©rifiez ensuite si vous avez raisonÂ !</p>
<!--
### Thinking in Terms of Lifetimes
-->
<h3><a class="header" href="#penser-en-termes-de-durÃ©es-de-vie" id="penser-en-termes-de-durÃ©es-de-vie">Penser en termes de durÃ©es de vie</a></h3>
<!--
The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
`longest` function to always return the first parameter rather than the longest
string slice, we wouldnâ€™t need to specify a lifetime on the `y` parameter. The
following code will compile:
-->
<p>La faÃ§on dont vous avez Ã  prÃ©ciser les paramÃ¨tres de durÃ©es de vie dÃ©pend de ce
que fait votre fonction. Par exemple, si nous changions l'implÃ©mentation de la
fonction <code>la_plus_longue</code> pour qu'elle retourne systÃ©matiquement le premier
paramÃ¨tre plutÃ´t que la slice de chaÃ®ne de caractÃ¨res la plus longue, nous
n'aurions pas besoin de renseigner une durÃ©e de vie sur le paramÃ¨tre <code>y</code>. Le
code suivant se compileÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "efghijklmnopqrstuvwxyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La chaÃ®ne la plus longue est {}", resultat);
# }
# 
fn la_plus_longue<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<!--
In this example, weâ€™ve specified a lifetime parameter `'a` for the parameter
`x` and the return type, but not for the parameter `y`, because the lifetime of
`y` does not have any relationship with the lifetime of `x` or the return value.
-->
<p>Dans cet exemple, nous avons prÃ©cisÃ© un paramÃ¨tre de durÃ©e de vie <code>'a</code> sur le
paramÃ¨tre <code>x</code> et sur le type de retour, mais pas sur le paramÃ¨tre <code>y</code>, car la
durÃ©e de vie de <code>y</code> n'a pas de lien avec la durÃ©e de vie de <code>x</code> ou de la valeur
de retour.</p>
<!--
When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does *not* refer to one of the parameters, it must refer
to a value created within this function, which would be a dangling reference
because the value will go out of scope at the end of the function. Consider
this attempted implementation of the `longest` function that wonâ€™t compile:
-->
<p>Lorsqu'on retourne une rÃ©fÃ©rence Ã  partir d'une fonction, le paramÃ¨tre de la
durÃ©e de vie pour le type de retour doit correspondre Ã  une des durÃ©es des
paramÃ¨tres. Si la rÃ©fÃ©rence retournÃ©e ne se rÃ©fÃ¨re <em>pas</em> Ã  un de ses paramÃ¨tres,
elle se rÃ©fÃ¨re probablement Ã  une valeur crÃ©e Ã  l'intÃ©rieur de cette fonction,
et elle deviendra une rÃ©fÃ©rence pendouillante car sa valeur va sortir de la
portÃ©e Ã  la fin de la fonction. Imaginons cette tentative d'implÃ©mentation de
la fonction <code>la_plus_longue</code> qui ne se compile pasÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue(string1.as_str(), string2);
#     println!("La chaÃ®ne la plus longue est {}", resultat);
# }
# 
fn la_plus_longue<'a>(x: &str, y: &str) -> &'a str {
    let resultat = String::from("trÃ¨s longue chaÃ®ne");
    resultat.as_str()
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let resultat = String::from(&quot;trÃ¨s longue chaÃ®ne&quot;);
    resultat.as_str()
}
</code></pre>
<!--
Here, even though weâ€™ve specified a lifetime parameter `'a` for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:
-->
<p>Ici, mÃªme si nous avons prÃ©cisÃ© un paramÃ¨tre de durÃ©e de vie <code>'a</code> sur le type de
retour, cette implÃ©mentation va Ã©chouer Ã  la compilation car la durÃ©e de vie de
la valeur de retour n'est pas du tout liÃ©e Ã  la durÃ©e de vie des paramÃ¨tres.
Voici le message d'erreur que nous obtenonsÂ :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `resultat`
  --> src/main.rs:11:5
<p>|
11 |     resultat.as_str()
|     --------^^^^^^^^^
|     |
|     returns a value referencing data owned by the current function
|     <code>resultat</code> is borrowed here</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0515</code>.
error: could not compile <code>chapter10</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `resultat`
  --&gt; src/main.rs:11:5
   |
11 |     resultat.as_str()
   |     --------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `resultat` is borrowed here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The problem is that `result` goes out of scope and gets cleaned up at the end
of the `longest` function. Weâ€™re also trying to return a reference to `result`
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust wonâ€™t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.
-->
<p>Le problÃ¨me est que <code>resultat</code> sort de la portÃ©e et est effacÃ©e Ã  la fin de la
fonction <code>la_plus_longue</code>. Nous avons aussi essayÃ© de retourner une rÃ©fÃ©rence
vers <code>resultat</code> Ã  partir de la fonction. Il n'existe aucune faÃ§on d'Ã©crire les
paramÃ¨tres de durÃ©e de vie de telle maniÃ¨re que cela changerait la rÃ©fÃ©rence
pendouillante, et Rust ne nous laissera pas crÃ©er une rÃ©fÃ©rence pendouillante.
Dans notre cas, la meilleure solution est de retourner un type de donnÃ©e dont on
va prendre possession plutÃ´t qu'une rÃ©fÃ©rence, ainsi le code appelant sera
responsable du nettoyage de la valeur.</p>
<!--
Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once theyâ€™re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.
-->
<p>Enfin, la syntaxe de la durÃ©e de vie sert Ã  interconnecter les durÃ©es de vie de
plusieurs paramÃ¨tres ainsi que les valeurs de retour des fonctions. Une fois
interconnectÃ©s, Rust a assez d'informations pour autoriser les opÃ©rations
sÃ©curisÃ©es dans la mÃ©moire et refuser les opÃ©rations qui pourraient crÃ©er des
pointeurs pendouillants ou alors enfreindre la sÃ©curitÃ© de la mÃ©moire.</p>
<!--
### Lifetime Annotations in Struct Definitions
-->
<h3><a class="header" href="#lajout-des-durÃ©es-de-vies-dans-les-dÃ©finitions-des-structures" id="lajout-des-durÃ©es-de-vies-dans-les-dÃ©finitions-des-structures">L'ajout des durÃ©es de vies dans les dÃ©finitions des structures</a></h3>
<!--
So far, weâ€™ve only defined structs to hold owned types. Itâ€™s possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the structâ€™s definition. Listing 10-25 has a
struct named `ImportantExcerpt` that holds a string slice.
-->
<p>Jusqu'Ã  prÃ©sent, nous avons dÃ©fini des structures pour contenir des types qui
sont possÃ©dÃ©s par elles-mÃªmes. Il est possible qu'une structure puisse contenir
des rÃ©fÃ©rences, mais dans ce cas nous devons prÃ©ciser une durÃ©e de vie sur
chaque rÃ©fÃ©rence dans la dÃ©finition de la structure. L'encart 10-25 montre une
structure <code>ExtraitImportant</code> qui stocke une slice de chaÃ®ne de caractÃ¨res.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct ExtraitImportant<'a> {
    partie: &'a str,
}

fn main() {
    let roman = String::from("Appelez-moi IsmaÃ«l. Il y a quelques annÃ©es ...");
    let premiere_phrase = roman.split('.')
        .next()
        .expect("Impossible de trouver un '.'");
    let i = ExtraitImportant { partie: premiere_phrase };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct ExtraitImportant&lt;'a&gt; {
    partie: &amp;'a str,
}

fn main() {
    let roman = String::from(&quot;Appelez-moi IsmaÃ«l. Il y a quelques annÃ©es ...&quot;);
    let premiere_phrase = roman.split('.')
        .next()
        .expect(&quot;Impossible de trouver un '.'&quot;);
    let i = ExtraitImportant { partie: premiere_phrase };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span>
-->
<p><span class="caption">Encart 10-25Â : une structure qui stocke une rÃ©fÃ©rence,
par consÃ©quent sa dÃ©finition a besoin d'une annotation de durÃ©e de vie</span></p>
<!--
This struct has one field, `part`, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of `ImportantExcerpt` canâ€™t outlive the reference
it holds in its `part` field.
-->
<p>Cette structure a un champ, <code>partie</code>, qui stocke une slice de chaÃ®ne de
caractÃ¨res, qui est une rÃ©fÃ©rence. Comme pour les types de donnÃ©es gÃ©nÃ©riques,
nous dÃ©clarons le nom du paramÃ¨tre de durÃ©e de vie gÃ©nÃ©rique entre des chevrons
aprÃ¨s le nom de la structure pour que nous puissions utiliser le paramÃ¨tre de
durÃ©e de vie dans le corps de la dÃ©finition de la structure. Cette annotation
signifie qu'une instance de <code>ExtraitImportant</code> ne peut pas vivre plus longtemps
que la rÃ©fÃ©rence qu'elle stocke dans son champ <code>partie</code>.</p>
<!--
The `main` function here creates an instance of the `ImportantExcerpt` struct
that holds a reference to the first sentence of the `String` owned by the
variable `novel`. The data in `novel` exists before the `ImportantExcerpt`
instance is created. In addition, `novel` doesnâ€™t go out of scope until after
the `ImportantExcerpt` goes out of scope, so the reference in the
`ImportantExcerpt` instance is valid.
-->
<p>La fonction <code>main</code> crÃ©e ici une instance de la structure <code>ExtraitImportant</code> qui
stocke une rÃ©fÃ©rence vers la premiÃ¨re phrase de la <code>String</code> possÃ©dÃ©e par la
variable <code>roman</code>. Les donnÃ©es dans <code>roman</code> existent avant que l'instance de
<code>ExtraitImportant</code> soit crÃ©e. De plus, <code>roman</code> ne sort pas de la portÃ©e avant
que l'instance de <code>ExtraitImportant</code> sorte de la portÃ©e, donc la rÃ©fÃ©rence dans
l'instance de <code>ExtraitImportant</code> est toujours valide.</p>
<!--
### Lifetime Elision
-->
<h3><a class="header" href="#lÃ©lision-des-durÃ©es-de-vie" id="lÃ©lision-des-durÃ©es-de-vie">L'Ã©lision des durÃ©es de vie</a></h3>
<!--
Youâ€™ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, which is shown again in Listing
10-26, that compiled without lifetime annotations.
-->
<p>Vous avez appris que toute rÃ©fÃ©rence a une durÃ©e de vie et que vous devez
renseigner des paramÃ¨tres de durÃ©e de vie sur des fonctions ou des structures
qui utilisent des rÃ©fÃ©rences. Cependant, dans le chapitre 4 nous avions une
fonction dans l'encart 4-9, qui est montrÃ©e Ã  nouveau dans l'encart 10-26, qui
compilait sans informations de durÃ©e de vie.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
fn premier_mot(s: &str) -> &str {
    let octets = s.as_bytes();

    for (i, &element) in octets.iter().enumerate() {
        if element == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // first_word works on slices of `String`s
#     let word = premier_mot(&my_string[..]);
# 
#     let my_string_literal = "hello world";
# 
#     // first_word works on slices of string literals
#     let word = premier_mot(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = premier_mot(my_string_literal);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;str) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = premier_mot(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = premier_mot(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = premier_mot(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span>
-->
<p><span class="caption">Encart 10-26Â : une fonction que nous avons dÃ©fini dans
l'encart 4-9 qui se compilait sans avoir d'indications sur la durÃ©e de vie, mÃªme
si les paramÃ¨tres et le type de retour sont des rÃ©fÃ©rences</span></p>
<!--
The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldnâ€™t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:
-->
<p>La raison pour laquelle cette fonction se compile sans annotation de durÃ©e de
vie est historiqueÂ : dans les premiÃ¨res versions de Rust (avant la 1.0), ce code
ne se serait pas compilÃ© parce que chaque rÃ©fÃ©rence devait avoir une durÃ©e de
vie explicite. A l'Ã©poque, la signature de la fonction devait Ãªtre Ã©crite
ainsiÂ :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compilerâ€™s code so
the borrow checker could infer the lifetimes in these situations and wouldnâ€™t
need explicit annotations.
-->
<p>AprÃ¨s avoir Ã©crit une grande quantitÃ© de code Rust, l'Ã©quipe de Rust s'est rendu
compte que les dÃ©veloppeurs Rust saisissaient toujours les mÃªmes durÃ©es de vie
encore et encore dans des situations spÃ©cifiques. Ces situations Ã©taient
prÃ©visibles et suivaient des schÃ©mas prÃ©dÃ©terminÃ©s. Les dÃ©veloppeurs ont
programmÃ© ces schÃ©mas dans le code du compilateur afin que le vÃ©rificateur
d'emprunt puisse deviner les durÃ©es de vie dans ces situations et n'auront plus
besoin d'annotations explicites.</p>
<!--
This piece of Rust history is relevant because itâ€™s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.
-->
<p>Cette partie de l'histoire de Rust est intÃ©ressante car il est possible que
d'autres modÃ¨les prÃ©dÃ©terminÃ©s Ã©mergent et soient ajoutÃ©s au compilateur. A
l'avenir, il est possible qu'encore moins d'annotations de durÃ©e de vie soient
nÃ©cessaires.</p>
<!--
The patterns programmed into Rustâ€™s analysis of references are called the
*lifetime elision rules*. These arenâ€™t rules for programmers to follow; theyâ€™re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you donâ€™t need to write the lifetimes explicitly.
-->
<p>Les schÃ©mas programmÃ©s dans l'analyse des rÃ©fÃ©rences de Rust s'appellent les
<em>rÃ¨gles d'Ã©lision des durÃ©es de vie</em>. Ce ne sont pas des rÃ¨gles que les
dÃ©veloppeurs doivent suivreÂ ; c'est un jeu de cas particuliers que le
compilateur va essayer de comparer Ã  votre code, et s'il y a une correspondance
alors vous n'aurez pas besoin d'Ã©crire explicitement les durÃ©es de vie.</p>
<!--
The elision rules donâ€™t provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler wonâ€™t guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.
-->
<p>Les rÃ¨gles d'Ã©lision ne permettent pas de faire des dÃ©ductions complÃ¨tes. Si
Rust applique les rÃ¨gles de faÃ§on stricte, mais qu'il existe toujours une
ambiguÃ¯tÃ© quant Ã  la durÃ©e de vie des rÃ©fÃ©rences, le compilateur ne devinera pas
quel devrait Ãªtre la durÃ©e de vie des autres rÃ©fÃ©rences. Dans ce cas, au lieu de
tenter de deviner, le compilateur va vous afficher une erreur que vous devrez
rÃ©soudre en prÃ©cisant les durÃ©es de vie qui clarifieront les liens entre chaque
rÃ©fÃ©rence.</p>
<!--
Lifetimes on function or method parameters are called *input lifetimes*, and
lifetimes on return values are called *output lifetimes*.
-->
<p>Les durÃ©es de vies sur les fonctions ou les paramÃ¨tres des fonctions sont
appelÃ©es les <em>durÃ©es de vie des entrÃ©es</em>, et les durÃ©es de vie sur les valeurs
de retour sont appelÃ©es les <em>durÃ©es de vie des sorties</em>.</p>
<!--
The compiler uses three rules to figure out what lifetimes references have when
there arenâ€™t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it canâ€™t
figure out lifetimes, the compiler will stop with an error. These rules apply
to `fn` definitions as well as `impl` blocks.
-->
<p>Le compilateur utilise trois rÃ¨gles pour dÃ©terminer quelles seraient les durÃ©es
de vie des rÃ©fÃ©rences si cela n'est pas indiquÃ© explicitement. La premiÃ¨re rÃ¨gle
s'applique sur les durÃ©es de vie des entrÃ©es, et la seconde et troisiÃ¨me rÃ¨gle
s'appliquent sur les durÃ©es de vie des sorties. Si le compilateur arrive Ã  la
fin des trois rÃ¨gles et qu'il y a encore des rÃ©fÃ©rences pour lesquelles il ne
peut pas savoir leur durÃ©e de vie, le compilateur s'arrÃªte avec une erreur. Ces
rÃ¨gles s'appliquent sur les dÃ©finitions des <code>fn</code> ainsi que sur celles des blocs
<code>impl</code>.</p>
<!--
The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two
separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so
on.
-->
<p>La premiÃ¨re rÃ¨gle dit que chaque paramÃ¨tre qui est une rÃ©fÃ©rence a sa propre
durÃ©e de vie. Autrement dit, une fonction avec un seul paramÃ¨tre va avoir un
seul paramÃ¨tre de durÃ©e de vieÂ : <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>Â ; une fonction avec
deux paramÃ¨tres va avoir deux paramÃ¨tres de durÃ©e de vie sÃ©parÃ©esÂ :
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>Â ; et ainsi de suite.</p>
<!--
The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32)
-> &'a i32`.
-->
<p>La seconde rÃ¨gle dit que s'il y a exactement un seul paramÃ¨tre de durÃ©e de vie
d'entrÃ©e, cette durÃ©e de vie est assignÃ©e Ã  tous les paramÃ¨tres de durÃ©e de vie
des sortiesÂ : <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<!--
The third rule is if there are multiple input lifetime parameters, but one of
them is `&self` or `&mut self` because this is a method, the lifetime of `self`
is assigned to all output lifetime parameters. This third rule makes methods
much nicer to read and write because fewer symbols are necessary.
-->
<p>La troisiÃ¨me rÃ¨gle est que lorsque nous avons plusieurs paramÃ¨tres de durÃ©e de
vie, mais qu'un d'entre eux est <code>&amp;self</code> ou <code>&amp;mut self</code> parce que c'est une
mÃ©thode, la durÃ©e de vie de <code>self</code> sera associÃ©e Ã  tous les paramÃ¨tres de durÃ©e
de vie des sorties. Cette troisiÃ¨me rÃ¨gle rend les mÃ©thodes plus faciles Ã  lire
et Ã  Ã©crire car il y a moins de caractÃ¨res nÃ©cessaires.</p>
<!--
Letâ€™s pretend weâ€™re the compiler. Weâ€™ll apply these rules to figure out what
the lifetimes of the references in the signature of the `first_word` function
in Listing 10-26 are. The signature starts without any lifetimes associated
with the references:
-->
<p>Imaginons que nous soyons le compilateur. Nous allons appliquer ces rÃ¨gles pour
dÃ©duire quelles seront les durÃ©es de vie des rÃ©fÃ©rences dans la signature de la
fonction <code>premier_mot</code> de l'encart 10-26.</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. Weâ€™ll call it `'a` as usual, so now the signature is
this:
-->
<p>Ensuite, le compilateur applique la premiÃ¨re rÃ¨gle, qui dit que chaque rÃ©fÃ©rence
a sa propre durÃ©e de vie. Appellons-la <code>'a</code> comme d'habitude, donc maintenant la
signature devient ceciÂ :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<!--
The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:
-->
<p>La seconde rÃ¨gle s'applique car il y a exactement une durÃ©e de vie d'entrÃ©e ici.
La seconde rÃ¨gle dit que la durÃ©e de vie du seul paramÃ¨tre d'entrÃ©e est affectÃ©e
Ã  la durÃ©e de vie des sorties, donc la signature est maintenant ceciÂ :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.
-->
<p>Maintenant, toutes les rÃ©fÃ©rences de cette signature de fonction ont des
durÃ©es de vie, et le compilateur peut continuer son analyse sans avoir besoin
que le dÃ©veloppeur renseigne les durÃ©es de vie dans les signatures de ces
fonctions.</p>
<!--
Letâ€™s look at another example, this time using the `longest` function that had
no lifetime parameters when we started working with it in Listing 10-21:
-->
<p>Voyons un autre exemple, qui utilise cette fois la fonction <code>la_plus_longue</code> qui
n'avait pas de paramÃ¨tres de durÃ©e de vie lorsque nous avons commencÃ© Ã 
l'utiliser dans l'encart 10-21Â :</p>
<!--
```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Letâ€™s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:
-->
<p>Appliquons la premiÃ¨re rÃ¨gleÂ : chaque rÃ©fÃ©rence a sa propre durÃ©e de vie. Cette
fois, nous avons avons deux rÃ©fÃ©rences au lieu d'une seule, donc nous avons deux
durÃ©es de vieÂ :</p>
<!--
```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<!--
You can see that the second rule doesnâ€™t apply because there is more than one
input lifetime. The third rule doesnâ€™t apply either, because `longest` is a
function rather than a method, so none of the parameters are `self`. After
working through all three rules, we still havenâ€™t figured out what the return
typeâ€™s lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldnâ€™t figure out all the lifetimes of the references in the signature.
-->
<p>Vous pouvez constater que la seconde rÃ¨gle ne s'applique pas car il y a plus
qu'une seule durÃ©e de vie. La troisiÃ¨me ne s'applique pas non plus, car
<code>la_plus_longue</code> est une fonction et non pas une mÃ©thode, donc aucun de ses
paramÃ¨tres ne sont <code>self</code>. AprÃ¨s avoir utilisÃ© ces trois rÃ¨gles, nous n'avons
pas pu en dÃ©duire la durÃ©e de vie de la valeur de retour. C'est pourquoi nous
obtenons une erreur en essayant de compiler le code dans l'encart 10-21Â : le
compilateur a utilisÃ© les rÃ¨gles d'Ã©lision des durÃ©es de vie mais n'est pas
capable d'en dÃ©duire toutes les durÃ©es de vie des rÃ©fÃ©rences prÃ©sentes dans la
signature.</p>
<!--
Because the third rule really only applies in method signatures, weâ€™ll look at
lifetimes in that context next to see why the third rule means we donâ€™t have to
annotate lifetimes in method signatures very often.
-->
<p>Comme la troisiÃ¨me rÃ¨gle ne s'applique que sur les signatures des mÃ©thodes, nous
allons examiner les durÃ©es de vie dans ce contexte pour comprendre pourquoi la
troisiÃ¨me rÃ¨gle signifie que nous n'avons pas souvent besoin d'annoter les
durÃ©es de vie dans les signatures des mÃ©thodes.</p>
<!--
### Lifetime Annotations in Method Definitions
-->
<h3><a class="header" href="#informations-de-durÃ©e-de-vie-dans-les-dÃ©finitions-des-mÃ©thodes" id="informations-de-durÃ©e-de-vie-dans-les-dÃ©finitions-des-mÃ©thodes">Informations de durÃ©e de vie dans les dÃ©finitions des mÃ©thodes</a></h3>
<!--
When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether theyâ€™re related to the struct
fields or the method parameters and return values.
-->
<p>Lorsque nous implÃ©mentons des mÃ©thodes sur une structure avec des durÃ©es de vie,
nous utilisons la mÃªme syntaxe que les paramÃ¨tres de type gÃ©nÃ©riques que nous
avons vu dans l'encart 10-11. L'endroit oÃ¹ nous dÃ©clarons et utilisons les
paramÃ¨tres de durÃ©e de vie dÃ©pend de s'ils sont reliÃ©s aux champs des structures
ou aux paramÃ¨tres de la mÃ©thode et les valeurs de retour.</p>
<!--
Lifetime names for struct fields always need to be declared after the `impl`
keyword and then used after the structâ€™s name, because those lifetimes are part
of the structâ€™s type.
-->
<p>Les noms des durÃ©es de vie pour les champs de structure ont toujours besoin
d'Ãªtre dÃ©clarÃ©s aprÃ¨s le mot-clÃ© <code>impl</code> et sont ensuite utilisÃ©s aprÃ¨s le nom de
la structure, car ces durÃ©es vie font partie du type de la structure.</p>
<!--
In method signatures inside the `impl` block, references might be tied to the
lifetime of references in the structâ€™s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
arenâ€™t necessary in method signatures. Letâ€™s look at some examples using the
struct named `ImportantExcerpt` that we defined in Listing 10-25.
-->
<p>Sur les signatures des mÃ©thodes Ã  l'intÃ©rieur du bloc <code>impl</code>, les rÃ©fÃ©rences
peuvent avoir la durÃ©e de vie des rÃ©fÃ©rences des champs de la structure, ou
elles peuvent Ãªtre indÃ©pendantes. De plus, les rÃ¨gles d'Ã©lision des durÃ©es de
vie le font parfois, ce qui fait que l'ajout des durÃ©es de vie n'est parfois pas
nÃ©cessaire dans les signatures des mÃ©thodes. Voyons quelques exemples en
utilisant la structure <code>ExtraitImportant</code> que nous avons dÃ©fini dans l'encart
10-25.</p>
<!--
First, weâ€™ll use a method named `level` whose only parameter is a reference to
`self` and whose return value is an `i32`, which is not a reference to anything:
-->
<p>PremiÃ¨rement, nous allons utiliser une mÃ©thode <code>niveau</code> dont le seul paramÃ¨tre
est une rÃ©fÃ©rence Ã  <code>self</code> et dont la valeur de retour sera un <code>i32</code>, qui n'est
pas une rÃ©fÃ©renceÂ :</p>
<!--
```rust
# struct ExtraitImportant<'a> {
#     partie: &'a str,
# }
# 
impl<'a> ExtraitImportant<'a> {
    fn niveau(&self) -> i32 {
        3
    }
}
# 
# impl<'a> ExtraitImportant<'a> {
#     fn annoncer_et_retourner_partie(&self, annonce: &str) -> &str {
#         println!("Votre attention s'il vous plaÃ®tÂ : {}", annonce);
#         self.partie
#     }
# }
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ExtraitImportant {
#         partie: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn niveau(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Votre attention s'il vous plaÃ®tÂ : {}&quot;, annonce);
</span><span class="boring">        self.partie
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
The lifetime parameter declaration after `impl` and its use after the type name
are required, but weâ€™re not required to annotate the lifetime of the reference
to `self` because of the first elision rule.
-->
<p>La dÃ©claration du paramÃ¨tre de durÃ©e de vie aprÃ¨s <code>impl</code> et son utilisation
aprÃ¨s le nom du type sont nÃ©cessaires, mais nous n'avons pas Ã  prÃ©ciser la durÃ©e
de vie de la rÃ©fÃ©rence Ã  <code>self</code> grÃ¢ce Ã  la premiÃ¨re rÃ¨gle d'Ã©lision.</p>
<!--
Here is an example where the third lifetime elision rule applies:
-->
<p>Voici un exemple oÃ¹ la troisiÃ¨me rÃ¨gle d'Ã©lision des durÃ©es de vie s'appliqueÂ :</p>
<!--
```rust
# struct ExtraitImportant<'a> {
#     partie: &'a str,
# }
# 
# impl<'a> ExtraitImportant<'a> {
#     fn niveau(&self) -> i32 {
#         3
#     }
# }
# 
impl<'a> ExtraitImportant<'a> {
    fn annoncer_et_retourner_partie(&self, annonce: &str) -> &str {
        println!("Votre attention s'il vous plaÃ®tÂ : {}", annonce);
        self.partie
    }
}
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ExtraitImportant {
#         partie: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn niveau(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
        println!(&quot;Votre attention s'il vous plaÃ®tÂ : {}&quot;, annonce);
        self.partie
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both `&self` and `announcement` their own lifetimes. Then, because
one of the parameters is `&self`, the return type gets the lifetime of `&self`,
and all lifetimes have been accounted for.
-->
<p>Il y a deux durÃ©es de vies des entrÃ©es, donc Rust applique la premiÃ¨re rÃ¨gle
d'Ã©lision des durÃ©es de vie et donne Ã  chacun de <code>&amp;self</code> et <code>annonce</code> leur
propre durÃ©e de vie. Ensuite, comme un des paramÃ¨tres est <code>&amp;self</code>, le type de
retour obtient la durÃ©e de vie de <code>&amp;self</code>, et ainsi toutes les durÃ©es de vie ont
Ã©tÃ© calculÃ©es.</p>
<!--
### The Static Lifetime
-->
<h3><a class="header" href="#la-durÃ©e-de-vie-statique" id="la-durÃ©e-de-vie-statique">La durÃ©e de vie statique</a></h3>
<!--
One special lifetime we need to discuss is `'static`, which means that this
reference *can* live for the entire duration of the program. All string
literals have the `'static` lifetime, which we can annotate as follows:
-->
<p>Une durÃ©e de vie particuliÃ¨re que nous devons aborder est <code>'static</code>, qui
signifie que cette rÃ©fÃ©rence <em>peut</em> vivre pendant la totalitÃ© de la durÃ©e du
programme. Tous les littÃ©raux de chaÃ®nes de caractÃ¨res ont la durÃ©e de vie
<code>'static</code>, que nous pouvons Ã©crire comme ceciÂ :</p>
<!--
```rust
let s: &'static str = "I have a static lifetime.";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;J'ai une durÃ©e de vie statique.&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The text of this string is stored directly in the programâ€™s binary, which
is always available. Therefore, the lifetime of all string literals is
`'static`.
-->
<p>Le texte de cette chaÃ®ne de caractÃ¨res est stockÃ© directement dans le binaire du
programme, qui est toujours disponible. C'est pourquoi la durÃ©e de vie de tous
les littÃ©raux de chaÃ®nes de caractÃ¨res est <code>'static</code>.</p>
<!--
You might see suggestions to use the `'static` lifetime in error messages. But
before specifying `'static` as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not. You might consider whether you want it to live that long, even
if it could. Most of the time, the problem results from attempting to create a
dangling reference or a mismatch of the available lifetimes. In such cases, the
solution is fixing those problems, not specifying the `'static` lifetime.
-->
<p>Il se peut que voyez des suggestions pour utiliser la durÃ©e de vie <code>'static</code>
dans les messages d'erreur. Mais avant d'utiliser <code>'static</code> comme durÃ©e de vie
pour une rÃ©fÃ©rence, demandez-vous si la rÃ©fÃ©rence en question vit bien pendant
toute la vie de votre programme, ou non. Vous devriez vous demander si vous
voulez qu'elle vive aussi longtemps, mÃªme si si c'Ã©tait possible. La plupart du
temps, le problÃ¨me rÃ©sulte d'une tentative de crÃ©ation d'une rÃ©fÃ©rence
pendouillante ou d'une inadÃ©quation des durÃ©es de vie disponibles. Dans de ces
cas-lÃ , la solution est de rÃ©soudre ces problÃ¨mes, et non pas de renseigner la
durÃ©e de vie comme Ã©tant <code>'static</code>.</p>
<!--
## Generic Type Parameters, Trait Bounds, and Lifetimes Together
-->
<h2><a class="header" href="#les-paramÃ¨tres-de-type-gÃ©nÃ©riques-les-traits-liÃ©s-et-les-durÃ©es-de-vies-ensemble" id="les-paramÃ¨tres-de-type-gÃ©nÃ©riques-les-traits-liÃ©s-et-les-durÃ©es-de-vies-ensemble">Les paramÃ¨tres de type gÃ©nÃ©riques, les traits liÃ©s, et les durÃ©es de vies ensemble</a></h2>
<!--
Letâ€™s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!
-->
<p>Regardons briÃ¨vement la syntaxe pour renseigner tous les paramÃ¨tres de type
gÃ©nÃ©riques, les traits liÃ©s, et les durÃ©es de vies sur une seule fonctionÂ !</p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let resultat = la_plus_longue_avec_annonce(
#         string1.as_str(),
#         string2,
#         "Aujourd'hui, c'est l'anniversaire de quelqu'unÂ !",
#     );
#     println!("La chaÃ®ne la plus longue est {}", resultat);
# }
# 
use std::fmt::Display;

fn la_plus_longue_avec_annonce<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("AnnonceÂ ! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue_avec_annonce(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Aujourd'hui, c'est l'anniversaire de quelqu'unÂ !&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;La chaÃ®ne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn la_plus_longue_avec_annonce&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;AnnonceÂ ! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
This is the `longest` function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named `ann` of the generic
type `T`, which can be filled in by any type that implements the `Display`
trait as specified by the `where` clause. This extra parameter will be printed
before the function compares the lengths of the string slices, which is why the
`Display` trait bound is necessary. Because lifetimes are a type of generic,
the declarations of the lifetime parameter `'a` and the generic type parameter
`T` go in the same list inside the angle brackets after the function name.
-->
<p>C'est la fonction <code>la_plus_longue</code> de l'encart 10-22 qui retourne la plus grande
de deux slices de chaÃ®nes de caractÃ¨res. Mais maintenant elle a un paramÃ¨tre
supplÃ©mentaire <code>ann</code> de type gÃ©nÃ©rique <code>T</code>, qui peut Ãªtre remplacÃ© par n'importe
quel type qui implÃ©mente le trait <code>Display</code> comme le prÃ©cise la clause <code>where</code>.
Ce paramÃ¨tre supplÃ©mentaire sera affichÃ© avant que la fonction compare les
longueurs des slices de chaÃ®nes de caractÃ¨res, c'est pourquoi le trait liÃ©
<code>Display</code> est nÃ©cessaire. Comme les durÃ©es de vie sont un type de gÃ©nÃ©riques,
les dÃ©clarations du paramÃ¨tre de durÃ©e de vie <code>'a</code> et le paramÃ¨tre de type
gÃ©nÃ©rique <code>T</code> vont dans la mÃªme liste Ã  l'intÃ©rieur des chevrons aprÃ¨s le nom de
la fonction.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-9" id="rÃ©sumÃ©-9">RÃ©sumÃ©</a></h2>
<!--
We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, youâ€™re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, theyâ€™ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code wonâ€™t have any dangling references. And all of this
analysis happens at compile time, which doesnâ€™t affect runtime performance!
-->
<p>Nous avons vu beaucoup de choses dans ce chapitreÂ ! Maintenant que vous en savez
plus sur les paramÃ¨tres de type gÃ©nÃ©riques, les traits et les traits liÃ©s, et
les paramÃ¨tres de durÃ©e de vie gÃ©nÃ©riques, vous pouvez maintenant Ã©crire du code
en Ã©vitant les doublons qui va bien fonctionner dans de nombreuses situations.
Les paramÃ¨tres de type gÃ©nÃ©riques vous permet d'appliquer du code Ã  diffÃ©rents
types. Les traits et les traits liÃ©s s'assurent que bien que les types soient
gÃ©nÃ©riques, ils auront un comportement particulier sur lequel le code peut
compter. Vous avez appris comment utiliser les indications de durÃ©e de vie pour
s'assurer que ce code flexible n'aura pas de rÃ©fÃ©rences pendouillantes. Et
toutes ces vÃ©rifications se font au moment de la compilation, ce qui n'influe
pas sur les performances au moment de l'exÃ©cution du programmeÂ !</p>
<!--
Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the [Rust Reference][reference]. But next, youâ€™ll learn how to write tests in
Rust so you can make sure your code is working the way it should.
-->
<p>Croyez-le ou non, mais il y a encore des choses Ã  apprendre sur les sujets que
nous avons traitÃ©s dans ce chapitreÂ : le chapitre 17 expliquera les objets de
trait, qui est une faÃ§on d'utiliser les traits. Il existe aussi des scÃ©narios
plus complexes qui nÃ©cessitent des indications de durÃ©e de vie ainsi que
d'utiliser, uniquement pour ces ces scÃ©narios avancÃ©s, certaines fonctionnalitÃ©s
avancÃ©es du systÃ¨me de typeÂ ; pour ces cas-lÃ , vous devriez consulter la
<a href="https://doc.rust-lang.org/reference/index.html">RÃ©fÃ©rence de Rust</a>. Maintenant, nous allons voir au chapitre suivant
comment Ã©crire des tests en Rust afin que vous puissiez vous assurer que votre
code fonctionne comme il devrait le faire.</p>
<!--
[references-and-borrowing]:
ch04-02-references-and-borrowing.html#references-and-borrowing
[string-slices-as-parameters]:
ch04-03-slices.html#string-slices-as-parameters
[reference]: ../reference/index.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--8" id="-attention-peinture-fraÃ®che--8">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/123">Pull Request</a>.</p>
</blockquote>
<!--
# Writing Automated Tests
-->
<h1><a class="header" href="#ecrire-des-tests-automatisÃ©s" id="ecrire-des-tests-automatisÃ©s">Ecrire des tests automatisÃ©s</a></h1>
<!--
In his 1972 essay â€œThe Humble Programmer,â€ Edsger W. Dijkstra said that
â€œProgram testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.â€ That doesnâ€™t mean we
shouldnâ€™t try to test as much as we can!
-->
<p>Dans son essai de 1972 â€œThe Humble Programmerâ€, Edsger W. Dijkstra a dit qu'un
â€œtest de programme peut Ãªtre une maniÃ¨re trÃ¨s efficace de prouver la prÃ©sence de
bogues, mais qu'il est totalement inadÃ©quat pour prouver leur absenceâ€. Mais
cela ne veut pas dire que nous ne devrions pas tester notre programme autant que
faire se peutÂ !</p>
<!--
Correctness in our programs is the extent to which our code does what we intend
it to do. Rust is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Rustâ€™s type
system shoulders a huge part of this burden, but the type system cannot catch
every kind of incorrectness. As such, Rust includes support for writing
automated software tests within the language.
-->
<p>L'exactitude de nos programmes est le niveau de conformitÃ© de notre code par
rapport Ã  ce que nous voulons qu'il fasse. Rust est conÃ§u dans un grand souci
d'exactitude des programmes, mais l'exactitude est complexe et difficile Ã 
confirmer. Le systÃ¨me de type de Rust endosse une grande partie de cette charge,
mais le systÃ¨me de type ne peut pas dÃ©tecter tous les genres d'erreurs. Ainsi,
Rust embarque des fonctionnalitÃ©s pour Ã©crire des tests automatisÃ©s de logiciels
Ã  l'intÃ©rieur du langage.</p>
<!--
As an example, say we write a function called `add_two` that adds 2 to whatever
number is passed to it. This functionâ€™s signature accepts an integer as a
parameter and returns an integer as a result. When we implement and compile
that function, Rust does all the type checking and borrow checking that youâ€™ve
learned so far to ensure that, for instance, we arenâ€™t passing a `String` value
or an invalid reference to this function. But Rust *canâ€™t* check that this
function will do precisely what we intend, which is return the parameter plus 2
rather than, say, the parameter plus 10 or the parameter minus 50! Thatâ€™s where
tests come in.
-->
<p>Par exemple, imaginons que nous Ã©crivons une fonction <code>ajouter_deux</code> qui ajoute
2 Ã  n'importe quel nombre qu'on lui envoie. La signature de cette fonction
prend un entier en paramÃ¨tre et retourne un entier comme rÃ©sultat. Lorsque nous
implÃ©mentons et compilons cette fonction, Rust fait toutes les vÃ©rifications de
type et d'emprunt que vous avez appris prÃ©cÃ©demment afin de s'assurer que, par
exemple, nous ne passions pas une valeur de type <code>String</code> ou une rÃ©fÃ©rence
invalide Ã  cette fonction. Mais Rust <em>ne peut pas</em> vÃ©rifier que cette fonction
va faire prÃ©cisÃ©ment ce que nous avions prÃ©vu qu'elle fasse, qui en l'occurence
est de retourner le paramÃ¨tre incrÃ©mentÃ© de 2 plutÃ´t que d'ajouter 10 ou
d'enlever 50, par exempleÂ ! C'est pour cette situation que les tests sont
utiles.</p>
<!--
We can write tests that assert, for example, that when we pass `3` to the
`add_two` function, the returned value is `5`. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.
-->
<p>Nous pouvons Ã©crire des tests qui vÃ©rifient, par exemple, que lorsque nous
donnons <code>3</code> Ã  la fonction <code>ajouter_deux</code>, elle retourne bien <code>5</code>. Nous pouvons
lancer ces tests Ã  chaque fois que nous modifions notre code pour s'assurer
qu'aucun comportement existant et satisfaisant n'ai changÃ©.</p>
<!--
Testing is a complex skill: although we canâ€™t cover every detail about how to
write good tests in one chapter, weâ€™ll discuss the mechanics of Rustâ€™s testing
facilities. Weâ€™ll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.
-->
<p>Les tests restent une discipline complexeÂ : bien que nous ne puissions couvrir
chaque dÃ©tail sur l'Ã©criture de bons tests en un seul chapitre, nous allons
dÃ©couvrir de la mÃ©canique des moyens de test de Rust. Nous allons voir les
annotations et les macros que vous pourrez utiliser lorsque vous Ã©crirez vos
tests, le comportement par dÃ©faut et les options disponibles pour lancer vos
tests, et comment organiser les tests en tests unitaires et tests d'intÃ©gration.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--9" id="-attention-peinture-fraÃ®che--9">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/124">Pull Request</a>.</p>
</blockquote>
<!--
## How to Write Tests
-->
<h2><a class="header" href="#comment-Ã©crire-des-tests" id="comment-Ã©crire-des-tests">Comment Ã©crire des tests</a></h2>
<!--
Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:
-->
<p>Les tests sont des fonctions Rust qui vÃ©rifient que le code qui n'est pas un
test se comporte bien de la maniÃ¨re attendue. Les corps des fonctions de test
effectuent gÃ©nÃ©ralement ces trois actionsÂ :</p>
<!--
1. Set up any needed data or state.
2. Run the code you want to test.
3. Assert the results are what you expect.
-->
<ol>
<li>Initialiser toutes les donnÃ©es ou les Ã©tats,</li>
<li>Lancer le code que vous voulez tester,</li>
<li>VÃ©rifier que les rÃ©sultats correspondent bien Ã  ce que vous souhaitez.</li>
</ol>
<!--
Letâ€™s look at the features Rust provides specifically for writing tests that
take these actions, which include the `test` attribute, a few macros, and the
`should_panic` attribute.
-->
<p>DÃ©couvrons les fonctionnalitÃ©s spÃ©cifiques qu'offre Rust pour Ã©crire des tests
qui font ces actions, dans lesquelles on retrouve l'attribut <code>test</code>, quelques
macros, et l'attribut <code>should_panic</code>.</p>
<!--
### The Anatomy of a Test Function
-->
<h3><a class="header" href="#lanatomie-dune-fonction-de-test" id="lanatomie-dune-fonction-de-test">L'anatomie d'une fonction de test</a></h3>
<!--
At its simplest, a test in Rust is a function thatâ€™s annotated with the `test`
attribute. Attributes are metadata about pieces of Rust code; one example is
the `derive` attribute we used with structs in Chapter 5. To change a function
into a test function, add `#[test]` on the line before `fn`. When you run your
tests with the `cargo test` command, Rust builds a test runner binary that runs
the functions annotated with the `test` attribute and reports on whether each
test function passes or fails.
-->
<p>Dans la forme la plus simple, un test en Rust est une fonction qui est marquÃ©e
avec l'attribut <code>test</code>. Les attributs sont des mÃ©tadonnÃ©es sur des parties de
code RustÂ ; un exemple est l'attribut <code>derive</code> que nous avons utilisÃ© sur les
structures au chapitre 5. Pour transformer une fonction en une fonction de test,
il faut ajouter <code>#[test]</code> dans la ligne avant le <code>fn</code>. Lorsque vous lancez vos
tests avec commande <code>cargo test</code>, Rust construit un binaire d'exÃ©cution de tests
qui exÃ©cute les fonctions marquÃ©es avec l'attribut <code>test</code> et fait un rapport sur
quelles fonctions ont rÃ©ussi ou Ã©chouÃ©.</p>
<!--
When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you donâ€™t have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!
-->
<p>Lorsque nous crÃ©ons une nouvelle bibliothÃ¨que avec Cargo, un module de tests
qui contient une fonction de test est automatiquement crÃ©Ã© pour nous. Ce module
vous aide Ã  dÃ©marrer l'Ã©criture de vos tests afin que vous n'ayez pas Ã  chercher
la structure et la syntaxe exacte d'une fonction de test Ã  chaque fois que vous
dÃ©butez un nouveau projet. Vous pouvez ajouter autant de fonctions de test et
autant de modules de test que vous le souhaitezÂ !</p>
<!--
Weâ€™ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then weâ€™ll write some
real-world tests that call some code that weâ€™ve written and assert that its
behavior is correct.
-->
<p>Nous allons dÃ©couvrir quelques aspects du fonctionnement des tests en
expÃ©rimentant avec ce que modÃ¨le a gÃ©nÃ©rÃ© pour nous, mais qui ne teste aucun
code pour le moment. Ensuite, nous Ã©crirons quelques tests plus proches de la
rÃ©alitÃ©, qui utilisera du code que nous avons Ã©crit et qui validera son bon
comportement.</p>
<!--
Letâ€™s create a new library project called `adder`:
-->
<p>CommenÃ§ons par crÃ©er un nouveau projet de bibliothÃ¨que que nous appellerons
<code>addition</code>Â :</p>
<!--
```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```
-->
<pre><code class="language-console">$ cargo new addition --lib
     Created library `addition` project
$ cd addition
</code></pre>
<!--
The contents of the *src/lib.rs* file in your `adder` library should look like
Listing 11-1.
-->
<p>Le contenu de votre fichier <em>src/lib.rs</em> dans votre bibliothÃ¨que <code>addition</code>
devrait ressembler Ã  l'encart 11-1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-1: The test module and function generated
automatically by `cargo new`</span>
-->
<p><span class="caption">Encart 11-1Â : le module de test et la fonction gÃ©nÃ©rÃ©es
automatiquement par <code>cargo new</code></span></p>
<!--
For now, letâ€™s ignore the top two lines and focus on the function to see how it
works. Note the `#[test]` annotation before the `fn` line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the `tests` module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the `#[test]` attribute.
-->
<p>Pour l'instant, ignorons les deux premiÃ¨res lignes et concentrons-nous sur la
fonction pour voir comment elle fonctionne. Remarquez l'annotation <code>#[test]</code>
avant la ligne <code>fn</code>Â : cet attribut indique que c'est une fonction de test, donc
l'exÃ©cuteur de tests sait qu'il doit considÃ©rer cette fonction comme Ã©tant un
test. Nous pouvons aussi avoir des fonctions qui ne font pas de tests dans le
module <code>tests</code> afin de rÃ©gler des scÃ©narios en commun ou pour procÃ©der Ã  des
opÃ©rations en commun, c'est pourquoi nous devons indiquer quelles fonctions sont
des tests en utilisant l'attribut <code>#[test]</code>.</p>
<!--
The function body uses the `assert_eq!` macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Letâ€™s run
it to see that this test passes.
-->
<p>Le corps de la fonction utilise la macro <code>assert_eq!</code> pour vÃ©rifier que 2 + 2
vaut bien 4. Cette vÃ©rification sert d'exemple pour expliquer le format d'un
test classique. LanÃ§ons-le pour vÃ©rifier si ce test est validÃ©.</p>
<!--
The `cargo test` command runs all tests in our project, as shown in Listing
11-2.
-->
<p>La commande <code>cargo test</code> lance tous les tests prÃ©sents dans votre projet, comme
le montre l'encart 11-2.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
<span class="caption">Listing 11-2: The output from running the automatically
generated test</span>
-->
<p><span class="caption">Encart 11-2Â : le rÃ©sultat du lancement des tests sur le
test gÃ©nÃ©rÃ© automatiquement</span></p>
<!--
Cargo compiled and ran the test. After the `Compiling`, `Finished`, and
`Running` lines is the line `running 1 test`. The next line shows the name
of the generated test function, called `it_works`, and the result of running
that test, `ok`. The overall summary of running the tests appears next. The
text `test result: ok.` means that all the tests passed, and the portion that
reads `1 passed; 0 failed` totals the number of tests that passed or failed.
-->
<p>Cargo a compilÃ© et lancÃ© le test. AprÃ¨s les lignes <code>Compiling</code>, <code>Finished</code>, et
<code>Running</code>, on trouve la ligne <code>running 1 test</code>. La ligne suivante montre le nom
de fonction de test <code>it_works</code>, qui a Ã©tÃ© gÃ©nÃ©rÃ© prÃ©cÃ©demment, et le rÃ©sultat de
l'exÃ©cution de ce test, <code>ok</code>. Le rÃ©sumÃ© gÃ©nÃ©ral de l'exÃ©cution des tests
s'affiche ensuite. Le texte <code>test result: ok.</code> signifie que tous les tests ont
rÃ©ussi, et la partie <code>1 passed; 0 failed</code> compte le nombre total de tests qui
ont rÃ©ussi ou Ã©chouÃ©.</p>
<!--
Because we donâ€™t have any tests weâ€™ve marked as ignored, the summary shows `0
ignored`. We also havenâ€™t filtered the tests being run, so the end of the
summary shows `0 filtered out`. Weâ€™ll talk about ignoring and filtering out
tests in the next section, [â€œControlling How Tests Are
Run.â€][controlling-how-tests-are-run]<!-- ignore -- >
-->
<p>Comme nous n'avons aucun test que nous avons marquÃ© comme ignorÃ©, le rÃ©sumÃ©
affiche <code>0 ignored</code>. Nous n'avons pas non plus filtrÃ© les tests qui ont Ã©tÃ©
exÃ©cutÃ©s, donc la fin du rÃ©sumÃ© affiche <code>0 filtered out</code>. Nous verrons comment
ignorer et filtrer les tests dans la prochaine section, <a href="ch11-02-running-tests.html">â€œContrÃ´ler comment les
tests sont exÃ©cutÃ©sâ€</a><!-- ignore -->.</p>
<!--
The `0 measured` statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
[the documentation about benchmark tests][bench] to learn more.
-->
<p>La statistique <code>0 measured</code> sert pour des tests de benchmark qui mesurent les
performances. Les tests de benchmark ne sont disponibles pour le moment que dans
la version expÃ©rimentale de Rust (nighly), au moment de cette Ã©criture.
Rendez-vous sur <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">la documentation sur les tests de benchmark</a> pour en
savoir plus.</p>
<!--
[bench]: ../unstable-book/library-features/test.html
-->
<!--
The next part of the test output, which starts with `Doc-tests adder`, is for
the results of any documentation tests. We donâ€™t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! Weâ€™ll
discuss how to write documentation tests in the [â€œDocumentation Comments as
Testsâ€][doc-comments]<!-- ignore -- > section of Chapter 14. For now, weâ€™ll
ignore the `Doc-tests` output.
-->
<p>La partie suivante du rÃ©sultat du test, qui commence par <code>Doc-tests addition</code>,
concerne les rÃ©sultats de tous les tests prÃ©sents dans la documentation. Nous
n'avons pas de tests dans la documentation pour le moment, mais Rust peut
compiler tous les exemples de code qui sont prÃ©sents dans la documentation de
notre API. Cette fonctionnalitÃ© nous aide Ã  garder synchronisÃ© notre
documentation et notre codeÂ ! Nous verrons comment Ã©crire nos tests dans la
documentation dans une section du chapitre 14. Pour le moment, nous allons
ignorer la partie <code>Doc-tests</code> du rÃ©sultat.</p>
<!--
Letâ€™s change the name of our test to see how that changes the test output.
Change the `it_works` function to a different name, such as `exploration`, like
so:
-->
<p>Changeons le nom de notre test pour voir comment cela change le rÃ©sultat du
test. Changeons le nom de la fonction <code>it_works</code> pour un nom diffÃ©rent, comme
<code>exploration</code> ci-dessousÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Then run `cargo test` again. The output now shows `exploration` instead of
`it_works`:
-->
<p>Lancez ensuite Ã  nouveau <code>cargo test</code>. Le rÃ©sultat affiche dÃ©sormais
<code>exploration</code> plutÃ´t que <code>it_works</code>Â :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Letâ€™s add another test, but this time weâ€™ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the `panic!` macro. Enter the new test, `another`, so your
*src/lib.rs* file looks like Listing 11-3.
-->
<p>Ajoutons un autre test, mais cette fois nous allons construire un test qui
Ã©choueÂ ! Les tests Ã©chouent lorsque quelque chose dans la fonction de test
panique. Chaque test est lancÃ© dans une nouvelle tÃ¢che, et lorsque la tÃ¢che
principale voit qu'une tÃ¢che de test est mort, le test est considÃ©rÃ©
comme Ã©chouÃ©. Nous avons vu la faÃ§on la plus simple de faire paniquer au
chapitre 9, qui consiste Ã  appeler la macro <code>panic!</code>. Ecrivez ce nouveau test,
<code>un_autre</code>, de sorte que votre fichier <code>src/lib.rs</code> ressemble Ã  ceciÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,panics
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!("Fait Ã©chouer ce test");
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust panics">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!(&quot;Fait Ã©chouer ce test&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust panics"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!(&quot;Fait Ã©chouer ce test&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 11-3: Adding a second test that will fail because
we call the `panic!` macro</span>
-->
<p><span class="caption">Encart 11-3Â : ajout d'un second test qui va Ã©chouer car
nous appelons la macro <code>panic!</code></span></p>
<!--
Run the tests again using `cargo test`. The output should look like Listing
11-4, which shows that our `exploration` test passed and `another` failed.
-->
<p>Lancez Ã  nouveau les tests en utilisant <code>cargo test</code>. Le rÃ©sultat devrait
ressembler Ã  l'encart 11-4, qui va afficher que notre test <code>exploration</code> a
rÃ©ussi et que <code>un_autre</code> va Ã©chouer.</p>
<!--
```text
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait Ã©chouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait Ã©chouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
<span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span>
-->
<p><span class="caption">Encart 11-4Â : les rÃ©sultats de tests lorsque un test
rÃ©ussit et un autre test Ã©choue</span></p>
<!--
Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
`another` failed because it `panicked at 'Make this test fail'`, which happened
on line 10 in the *src/lib.rs* file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; weâ€™ll talk more about ways to run tests in
the [â€œControlling How Tests Are Runâ€][controlling-how-tests-are-run]<!-- ignore
-- > section.
-->
<p>A la place du <code>ok</code>, la ligne <code>test tests:un_autre</code> affiche <code>FAILED</code>. Deux
nouvelles sections apparaissent entre la liste des tests et le rÃ©sumÃ©Â : la
premiÃ¨re section affiche les raisons dÃ©taillÃ©es de chaque Ã©chec de test. Dans
notre cas, <code>un_autre</code> a Ã©chouÃ© car il a paniquÃ© Ã  'Fait Ã©chouer ce test', qui
est placÃ© Ã  la ligne 10 du fichier <em>src/lib.rs</em>. La partie suivante liste
simplement les noms de tous les tests qui ont Ã©chouÃ©, ce qui est utile lorsqu'il
y a de nombreux tests et beaucoup de dÃ©tails provenant des tests qui Ã©chouent.
Nous pouvons utiliser le nom d'un test qui Ã©choue pour lancer uniquement ce test
afin de dÃ©boguer plus facilementÂ ; nous allons voir plus de faÃ§ons de lancer
des tests dans la <a href="ch11-02-running-tests.html">section suivante</a><!-- ignore
-->.</p>
<!--
The summary line displays at the end: overall, our test result is `FAILED`.
We had one test pass and one test fail.
-->
<p>La ligne de rÃ©sumÃ© s'affiche Ã  la finÂ : au final, le rÃ©sultat de nos tests est
au statut <code>FAILED</code> (Ã©chouÃ©). Nous avons un test rÃ©ussi et un test Ã©chouÃ©.</p>
<!--
Now that youâ€™ve seen what the test results look like in different scenarios,
letâ€™s look at some macros other than `panic!` that are useful in tests.
-->
<p>Maintenant que vous avez vu Ã  quoi ressemblent les rÃ©sultats de tests dans
diffÃ©rents scÃ©narios, voyons d'autres macros que <code>panic!</code> qui nous serons utiles
pour les tests.</p>
<!--
### Checking Results with the `assert!` Macro
-->
<h3><a class="header" href="#vÃ©rifier-les-rÃ©sultats-avec-la-macro-assert" id="vÃ©rifier-les-rÃ©sultats-avec-la-macro-assert">VÃ©rifier les rÃ©sultats avec la macro <code>assert!</code></a></h3>
<!--
The `assert!` macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to `true`. We give the
`assert!` macro an argument that evaluates to a Boolean. If the value is
`true`, `assert!` does nothing and the test passes. If the value is `false`,
the `assert!` macro calls the `panic!` macro, which causes the test to fail.
Using the `assert!` macro helps us check that our code is functioning in the
way we intend.
-->
<p>La macro <code>assert!</code>, fournie par la bibliothÃ¨que standard, est utile lorsque vous
voulez vous assurer qu'une condition dans un test vaut <code>true</code>. Nous fournissons
Ã  la macro <code>assert!</code> un argument qui donne un BoolÃ©en une fois interprÃ©tÃ©. Si la
valeur est <code>true</code>, <code>assert!</code> ne fait rien et le test est rÃ©ussi. Si la valeur
est <code>false</code>, la macro <code>assert!</code> appelle la macro <code>panic!</code>, qui fait Ã©chouer le
test. L'utilisation de la macro <code>assert!</code> nous aide Ã  vÃ©rifier que notre code
fonctionne bien comme nous le souhaitions.</p>
<!--
In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`
method, which are repeated here in Listing 11-5. Letâ€™s put this code in the
*src/lib.rs* file and write some tests for it using the `assert!` macro.
-->
<p>Dans le chapitre 5, dans l'encart 5-15, nous avons utilisÃ© une structure
<code>Rectangle</code> et une mÃ©thode <code>peut_contenir</code>, qui sont recopiÃ©s dans l'encart 11-5
ci-dessous. Ajoutons ce code dans le fichier <em>src/lib.rs</em> et Ã©crivons quelques
tests en utilisant la macro <code>assert!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur > other.largeur && self.hauteur > other.hauteur
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-5: Using the `Rectangle` struct and its
`can_hold` method from Chapter 5</span>
-->
<p><span class="caption">Encart 11-5Â : utilisation de la structure <code>Rectangle</code> et
sa mÃ©thode <code>peut_contenir</code> du chapitre 5</span></p>
<!--
The `can_hold` method returns a Boolean, which means itâ€™s a perfect use case
for the `assert!` macro. In Listing 11-6, we write a test that exercises the
`can_hold` method by creating a `Rectangle` instance that has a width of 8 and
a height of 7 and asserting that it can hold another `Rectangle` instance that
has a width of 5 and a height of 1.
-->
<p>La mÃ©thode <code>peut_contenir</code> retourne un BoolÃ©en, ce qui veut dire que c'est un
cas parfait pour tester la macro <code>assert!</code>. Dans l'encart 11-6, nous Ã©crivons un
test qui s'applique sur la mÃ©thode <code>peut_contenir</code> en crÃ©ant une instance de
<code>Rectangle</code> qui a une largeur de 8 et une hauteur de 7, et qui vÃ©rifie qu'il
peut contenir une autre instance de <code>Rectangle</code> qui a une largeur de 6 et une
hauteur de 1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&le_petit));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&amp;le_petit));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-6: A test for `can_hold` that checks whether a
larger rectangle can indeed hold a smaller rectangle</span>
-->
<p><span class="caption">Encart 11-6Â : un test pour <code>peut_contenir</code> qui vÃ©rifie le
cas oÃ¹ un grand rectangle peut contenir un plus petit rectangle</span></p>
<!--
Note that weâ€™ve added a new line inside the `tests` module: `use super::*;`.
The `tests` module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the [â€œPaths for Referring to an Item in the Module
Treeâ€][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -- >
section. Because the `tests` module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
`tests` module.
-->
<p>Remarquez que nous avons ajoutÃ© une nouvelle ligne Ã  l'intÃ©rieur du module
<code>test</code>Â : <code>use super::*;</code>. Le module <code>tests</code> est un module classique qui suit les
rÃ¨gles de visibilitÃ© que nous avons vu au chapitre 7 dans la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">â€œLes
chemins pour dÃ©signer un Ã©lÃ©ment dans l'arborescence de
moduleâ€</a><!-- ignore -->.
Comme le module <code>tests</code> est un module interne, nous avons besoin de ramener le
code Ã  tester qui se trouve dans son module parent dans la portÃ©e du module Ã 
l'intÃ©rieur. Nous utilisons ici un opÃ©rateur global afin que tout ce que nous
avons dÃ©fini dans le module parent soit disponible dans le module <code>tests</code>.</p>
<!--
Weâ€™ve named our test `larger_can_hold_smaller`, and weâ€™ve created the two
`Rectangle` instances that we need. Then we called the `assert!` macro and
passed it the result of calling `larger.can_hold(&smaller)`. This expression
is supposed to return `true`, so our test should pass. Letâ€™s find out!
-->
<p>Nous avons nommÃ© notre test <code>un_grand_peut_contenir_un_petit</code>, et nous avons
crÃ©Ã© les deux instances <code>Rectangle</code> que nous avions besoin. Ensuite, nous avons
appelÃ© la macro <code>assert!</code> et nous lui avons passÃ© le rÃ©sultat de l'appel Ã 
<code>le_grand.peut_contenir(&amp;le_petit)</code>. Cette expression est censÃ©e retourner
<code>true</code>, donc notre test devrait rÃ©ussir. VÃ©rifions celaÂ !</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
It does pass! Letâ€™s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:
-->
<p>Il a rÃ©ussiÂ ! Ajoutons maintenant un autre test, qui vÃ©rifie cette fois qu'un
petit rectangle ne peut contenir un rectangle plus grandÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&le_grand));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
<span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span>    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&amp;le_grand));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Because the correct result of the `can_hold` function in this case is `false`,
we need to negate that result before we pass it to the `assert!` macro. As a
result, our test will pass if `can_hold` returns `false`:
-->
<p>Comme dans cas le rÃ©sultat correct de la fonction <code>peut_contenir</code> doit Ãªtre
<code>false</code>, nous devons faire un nÃ©gatif de cette fonction avant de l'envoyer Ã  la
macro <code>assert!</code>. Cela aura pour effet de faire rÃ©ussir notre test si
<code>peut_contenir</code> retourne <code>false</code>Â :</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Two tests that pass! Now letâ€™s see what happens to our test results when we
introduce a bug in our code. Letâ€™s change the implementation of the `can_hold`
method by replacing the greater than sign with a less than sign when it
compares the widths:
-->
<p>VoilÃ  deux tests qui rÃ©ussissentÂ ! Maintenant, voyons ce qu'il se passe dans les
rÃ©sultats de nos tests lorsque nous introduisons un bogue dans notre code.
Changeons l'implÃ©mentation de la mÃ©thode <code>peut_contenir</code> en remplaÃ§ant
l'opÃ©rateur <em>plus grand que</em> par un <em>plus petit que</em> au moment de la comparaison
des largeursÂ :</p>
<!--
```rust,not_desired_behavior
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
// -- partie masquÃ©e ici --
impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur < other.largeur && self.hauteur > other.hauteur
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_grand_peut_contenir_un_petit() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
#     }
# 
#     #[test]
#     fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(!le_petit.peut_contenir(&le_grand));
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --
impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &lt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_grand_peut_contenir_un_petit() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!le_petit.peut_contenir(&amp;le_grand));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Running the tests now produces the following:
-->
<p>Le lancement des tests donne maintenant le rÃ©sultat suivantÂ :</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&amp;le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our tests caught the bug! Because `larger.width` is 8 and `smaller.width` is
5, the comparison of the widths in `can_hold` now returns `false`: 8 is not
less than 5.
-->
<p>Nos tests ont repÃ©rÃ© le bogueÂ ! Comme <code>le_grand.largeur</code> est 8 et
<code>le_petit.largeur</code> est 5, la comparaison des largeurs dans <code>peut_contenir</code>
retourne maintenant <code>false</code>Â : 8 n'est pas plus petit que 5.</p>
<!--
### Testing Equality with the `assert_eq!` and `assert_ne!` Macros
-->
<h3><a class="header" href="#tester-lÃ©galitÃ©-avec-les-macros-assert_eq-et-assert_ne" id="tester-lÃ©galitÃ©-avec-les-macros-assert_eq-et-assert_ne">Tester l'Ã©galitÃ© avec les macros <code>assert_eq!</code> et <code>assert_ne!</code></a></h3>
<!--
A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure theyâ€™re equal. You
could do this using the `assert!` macro and passing it an expression using the
`==` operator. However, this is such a common test that the standard library
provides a pair of macrosâ€”`assert_eq!` and `assert_ne!`â€”to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. Theyâ€™ll also print the two values if the assertion
fails, which makes it easier to see *why* the test failed; conversely, the
`assert!` macro only indicates that it got a `false` value for the `==`
expression, not the values that lead to the `false` value.
-->
<p>Une faÃ§on courante de tester des fonctionnalitÃ©s est de comparer le rÃ©sultat du
code Ã  tester par rapport Ã  une valeur que vous souhaitez que le code retourne,
afin de vous assurer qu'elles soient bien Ã©gales. Vous pouvez faire cela avec la
macro <code>assert!</code> et en lui passant une expression qui utilise l'opÃ©rateur <code>==</code>.
Cependant, c'est un test si courant que la bibliothÃ¨que standard fournit une
paire de macros (<code>assert_eq!</code> et <code>assert_ne!</code>) pour procÃ©der Ã  ce test plus
facilement. Les macros comparent respectivement l'Ã©galitÃ© ou la non Ã©galitÃ© de
deux arguments. Elles vont aussi afficher les deux valeurs si la vÃ©rification
Ã©choue, ce qui va nous aider Ã  comprendre <em>pourquoi</em> le test a Ã©chouÃ©Â ;
paradoxalement, la macro <code>assert!</code> indique seulement qu'elle a obtenu une valeur
<code>false</code> de l'expression avec le <code>==</code>, mais n'affiche pas les valeurs qui l'ont
menÃ© Ã  la valeur <code>false</code>.</p>
<!--
In Listing 11-7, we write a function named `add_two` that adds `2` to its
parameter and returns the result. Then we test this function using the
`assert_eq!` macro.
-->
<p>Dans l'encart 11-7, nous Ã©crivons une fonction <code>ajouter_deux</code> qui ajoute <code>2</code> Ã 
son paramÃ¨tre et retourne le rÃ©sultat. Ensuite, nous testons cette fonction en
utilisant la macro <code>assert_eq!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-7: Testing the function `add_two` using the
`assert_eq!` macro</span>
-->
<p><span class="caption">Encart 11-7Â : test de la fonction <code>ajouter_deux</code> en
utilisant la macro <code>assert_eq!</code>.</span></p>
<!--
Letâ€™s check that it passes!
-->
<p>VÃ©rifions si cela fonctionneÂ !</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
The first argument we gave to the `assert_eq!` macro, `4`, is equal to the
result of calling `add_two(2)`. The line for this test is `test
tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed!
-->
<p>Le premier argument que nous avons donnÃ© Ã  la macro <code>assert_eq!</code>, <code>4</code>, est bien
Ã©gal au rÃ©sultat de l'appel Ã  <code>ajouter_deux</code>. La ligne correspondant Ã  ce test
est <code>test tests::cela_ajoute_deux ... ok</code>, et le texte <code>ok</code> indique que notre
test a rÃ©ussiÂ !</p>
<!--
Letâ€™s introduce a bug into our code to see what it looks like when a test that
uses `assert_eq!` fails. Change the implementation of the `add_two` function to
instead add `3`:
-->
<p>Ajoutons un bogue dans notre code pour voir ce qu'il se passe lorsque un test
qui utilise <code>assert_eq!</code> Ã©choue. Changez l'implÃ©mentation de la fonction
<code>ajouter_deux</code> pour ajouter plutÃ´t <code>3</code>Â :</p>
<!--
```rust,not_desired_behavior
pub fn ajouter_deux(a: i32) -> i32 {
    a + 3
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn cela_ajoute_deux() {
#         assert_eq!(4, ajouter_deux(2));
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn cela_ajoute_deux() {
</span><span class="boring">        assert_eq!(4, ajouter_deux(2));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Run the tests again:
-->
<p>Lancez Ã  nouveau les testsÂ :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our test caught the bug! The `it_adds_two` test failed, displaying the message
`` assertion failed: `(left == right)` `` and showing that `left` was `4` and
`right` was `5`. This message is useful and helps us start debugging: it means
the `left` argument to `assert_eq!` was `4` but the `right` argument, where we
had `add_two(2)`, was `5`.
-->
<p>Notre test a dÃ©tectÃ© le bogueÂ ! Le test <code>cela_ajoute_deux</code> a Ã©chouÃ©, ce qui a
affichÃ© le message <code>assertion failed: `(left == right)`</code> qui nous explique
qu'Ã  gauche nous avions <code>4</code> et qu'Ã  droite nous avions <code>5</code>. Ce message utile
nous aide au dÃ©boguageÂ : cela veut dire que l'argument de gauche de <code>assert_eq!</code>
valait <code>4</code> mais que l'argument de droite, oÃ¹ nous avions <code>ajouter_deux(2)</code>,
valait <code>5</code>.</p>
<!--
Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called `expected` and `actual`,
and the order in which we specify the arguments matters. However, in Rust,
theyâ€™re called `left` and `right`, and the order in which we specify the value
we expect and the value that the code under test produces doesnâ€™t matter. We
could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which
would result in a failure message that displays `` assertion failed: `(left ==
right)` `` and that `left` was `5` and `right` was `4`.
-->
<p>Notez que dans certains langages et environnements de test, les paramÃ¨tres des
fonctions qui vÃ©rifient que deux valeurs soient Ã©gales sont appelÃ©s <code>attendu</code> et
<code>effectif</code>, et l'ordre dans lesquels nous renseignons les arguments est
important. Cependant, dans Rust, on les appelle <code>gauche</code> et <code>droite</code>, et l'ordre
dans lesquels nous renseignons la valeur que nous attendons et la valeur que
produit le code Ã  tester n'est pas important. Nous pouvons Ã©crire la
vÃ©rification de ce test dans la forme <code>assert_eq!(ajouter_deux(2), 4)</code>, ce qui
donnera un message d'Ã©chec qui affichera <code>assertion failed: `(left == right)`</code> et que gauche vaudra <code>5</code> et droit vaudra <code>4</code>.</p>
<!--
The `assert_ne!` macro will pass if the two values we give it are not equal and
fail if theyâ€™re equal. This macro is most useful for cases when weâ€™re not sure
what a value *will* be, but we know what the value definitely *wonâ€™t* be if our
code is functioning as we intend. For example, if weâ€™re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.
-->
<p>Cette macro <code>assert_ne!</code> va rÃ©ussir si les deux valeurs que nous lui donnons ne
sont pas Ã©gales et va Ã©chouer si elles sont Ã©gales. Cette macro est utile dans
les cas oÃ¹ nous ne sommes pas sÃ»r de ce que <em>devrait</em> valoir une valeur, mais
que nous savons ce que la valeur ne devrait surtout <em>pas</em> Ãªtre si notre code
fonctionne comme nous le souhaitons. Par exemple, si nous testons une fonction
qui doit transformer sa valeur d'entrÃ©e de maniÃ¨re Ã  ce qu'elle dÃ©pend du jour
de la semaine oÃ¹ nous lanÃ§ons nos tests, la meilleure faÃ§on de vÃ©rifier serait
que la sortie de la fonction ne soit pas Ã©gale Ã  son entrÃ©e.</p>
<!--
Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators
`==` and `!=`, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the `PartialEq` and `Debug` traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, youâ€™ll need to implement `PartialEq` to assert that values of
those types are equal or not equal. Youâ€™ll need to implement `Debug` to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum
definition. See Appendix C, [â€œDerivable Traits,â€][derivable-traits]<!-- ignore
-- > for more details about these and other derivable traits.
-->
<p>Sous la surface, les macros <code>assert_eq!</code> et <code>assert_ne!</code> utilisent
respectivement les opÃ©rateurs <code>==</code> et <code>!=</code>. Lorsque les vÃ©rifications Ã©chouent,
ces macros affichent leurs arguments en utilisant le formatage de dÃ©boguage, ce
qui veut dire que les valeurs comparÃ©es doivent implÃ©menter les traits
<code>PartialEq</code> et <code>Debug</code>. Tous les types de primitives et la plupart des types de
la bibliothÃ¨que standard implÃ©mentent ces traits. Concernant les structures et
les Ã©numÃ©rations que vous dÃ©finissez, vous allez avoir besoin de leur
implÃ©menter <code>Debug</code> pour afficher les valeurs lorsque les vÃ©rifications
Ã©chouent. Comme ces traits sont des traits dÃ©rivables, comme nous l'avons Ã©voquÃ©
dans l'encart 5-12 du chapitre 5, il suffit gÃ©nÃ©ralement de simplement ajouter
l'annotation <code>#[derive(PartialEq, Debug)]</code> sur les dÃ©finitions de vos structures
ou Ã©numÃ©rations. Rendez-vous Ã  <a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore -->
pour en savoir plus sur ces derniers et les autres traits dÃ©rivables.</p>
<!--
### Adding Custom Failure Messages
-->
<h3><a class="header" href="#ajouter-des-messages-dÃ©chec-personnalisÃ©s" id="ajouter-des-messages-dÃ©chec-personnalisÃ©s">Ajouter des messages d'Ã©chec personnalisÃ©s</a></h3>
<!--
You can also add a custom message to be printed with the failure message as
optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any
arguments specified after the one required argument to `assert!` or the two
required arguments to `assert_eq!` and `assert_ne!` are passed along to the
`format!` macro (discussed in Chapter 8 in the [â€œConcatenation with the `+`
Operator or the `format!`
Macroâ€][concatenation-with-the--operator-or-the-format-macro]<!-- ignore -- >
section), so you can pass a format string that contains `{}` placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, youâ€™ll have a better idea of what
the problem is with the code.
-->
<p>Vous pouvez aussi ajouter un message personnalisÃ© qui peut Ãªtre affichÃ© avec le
message d'Ã©chec comme un argument optionnel aux macros <code>assert!</code>, <code>assert_eq!</code>,
et <code>assert_ne!</code>. Tous les arguments renseignÃ©s aprÃ¨s celui qui est obligatoire
dans <code>assert!</code> ou les deux arguments obligatoires de <code>assert_eq!</code> et
<code>assert_ne!</code> sont envoyÃ©s Ã  la macro <code>format!</code> (que nous avons vu dans une
section du
<a href="ch08-02-strings.html">chapitre
8</a><!-- ignore -->), ainsi
vous pouvez une chaine de caractÃ¨res de formatage qui contient des espaces
rÃ©servÃ©s <code>{}</code> et les valeurs iront dans ces espaces rÃ©servÃ©s. Les messages
personnalisÃ©s sont utiles pour documenter ce que fait une vÃ©rificationÂ ;
lorsqu'un test Ã©choue, vous aurez une idÃ©e plus prÃ©cise du problÃ¨me avec ce
code.</p>
<!--
For example, letâ€™s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:
-->
<p>Par exemple, disons que nous avons une fonction qui accueille les gens par leur
nom et que nous voulons tester que le nom que nous envoyons Ã  la fonction
apparaÃ®t dans le rÃ©sultatÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub fn accueil(nom: &str) -> String {
    format!("Salut, {}Â !", nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(resultat.contains("Carole"));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub fn accueil(nom: &amp;str) -&gt; String {
    format!(&quot;Salut, {}Â !&quot;, nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(resultat.contains(&quot;Carole&quot;));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
The requirements for this program havenâ€™t been agreed upon yet, and weâ€™re
pretty sure the `Hello` text at the beginning of the greeting will change. We
decided we donâ€™t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
`greeting` function, weâ€™ll just assert that the output contains the text of the
input parameter.
-->
<p>Les spÃ©cifications de ce programme n'ont pas Ã©tÃ© validÃ©es entiÃ¨rement pour le
moment, et on est quasiment sÃ»r que le texte <code>Salut</code> au dÃ©but va changer. Nous
avons dÃ©cidÃ© que nous ne devrions pas Ã  avoir Ã  changer le test si les
spÃ©cifications changent, donc plutÃ´t que de vÃ©rifier l'Ã©galitÃ© exacte de la
valeur retournÃ©e par la fonction <code>accueil</code>, nous allons uniquement vÃ©rifier que
le rÃ©sultat contient le texte correspondant au paramÃ¨tre d'entrÃ©e de la
fonction.</p>
<!--
Letâ€™s introduce a bug into this code by changing `greeting` to not include
`name` to see what this test failure looks like:
-->
<p>Introduisons un bogue dans ce code en changeant <code>accueil</code> pour de ne pas
ajouter <code>nom</code> afin voir ce que donne l'Ã©chec de ce test :</p>
<!--
```rust,not_desired_behavior
pub fn accueil(name: &str) -> String {
    String::from("SalutÂ !")
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn accueil_contient_le_nom() {
#         let resultat = accueil("Carole");
#         assert!(resultat.contains("Carole"));
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn accueil(name: &amp;str) -&gt; String {
    String::from(&quot;SalutÂ !&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn accueil_contient_le_nom() {
</span><span class="boring">        let resultat = accueil(&quot;Carole&quot;);
</span><span class="boring">        assert!(resultat.contains(&quot;Carole&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Running this test produces the following:
-->
<p>L'exÃ©cution du test va donner ceci :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains("Carole")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(&quot;Carole&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the `greeting` function. Letâ€™s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the `greeting` function:
-->
<p>Ce rÃ©sultat indique simplement que la vÃ©rification a Ã©chouÃ©, et Ã  quel endroit.
Le message d'Ã©chec serait plus utile dans notre cas s'il affichait la valeur
que nous obtenons de la fonction <code>accueil</code>. Changeons la fonction de test, pour
lui donner un message d'erreur personnalisÃ©, qui est une chaÃ®ne de caractÃ¨res
de formatage avec un espace rÃ©servÃ© qui contiendra la valeur que la valeur que
nous avons obtenue de la fonction <code>accueil</code> :</p>
<!--
```rust,ignore
# pub fn accueil(nom: &str) -> String {
#     String::from("SalutÂ !")
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(
            resultat.contains("Carole"),
            "Le message d'accueil ne contient pas le nom, il vautÂ `{}`",
            resultat
        );
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub fn accueil(nom: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;SalutÂ !&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(
            resultat.contains(&quot;Carole&quot;),
            &quot;Le message d'accueil ne contient pas le nom, il vautÂ `{}`&quot;,
            resultat
        );
    }
<span class="boring">}
</span></code></pre>
<!--
Now when we run the test, weâ€™ll get a more informative error message:
-->
<p>Maintenant, lorsque nous lanÃ§ons Ã  nouveau le test, nous obtenons un message
d'Ã©chec plus explicite :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vautÂ `SalutÂ !`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vautÂ `SalutÂ !`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.
-->
<p>Nous pouvons voir la valeur que nous avons obtenue lors de la lecture du
rÃ©sultat du test, ce qui va nous aider Ã  dÃ©boguer ce qui s'est passÃ© Ã  la
place de ce que nous voulions qu'il se passe.</p>
<!--
### Checking for Panics with `should_panic`
-->
<h3><a class="header" href="#vÃ©rifier-le-fonctionnement-des-paniques-avec-should_panic" id="vÃ©rifier-le-fonctionnement-des-paniques-avec-should_panic">VÃ©rifier le fonctionnement des paniques avec <code>should_panic</code></a></h3>
<!--
In addition to checking that our code returns the correct values we expect,
itâ€™s also important to check that our code handles error conditions as we
expect. For example, consider the `Guess` type that we created in Chapter 9,
Listing 9-10. Other code that uses `Guess` depends on the guarantee that `Guess`
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a `Guess` instance with a value outside that
range panics.
-->
<p>En plus de vÃ©rifier que notre code retourne bien les valeurs que nous
souhaitons, il est aussi important de vÃ©rifier que notre code gÃ¨re bien les cas
d'erreurs comme nous le souhaitons. Par exemple, utilisons le type <code>Supposition</code>
que nous avons crÃ©Ã© au chapitre 9, dans l'encart 9-10. Les autres codes qui
utilisent <code>Supposition</code> reposent sur la garantie que les instances de
<code>Supposition</code> contiennent uniquement des valeurs entre 1 et 100. Nous pouvons
Ã©crire un test qui s'assure que la crÃ©ation d'une instance de <code>Supposition</code>
avec une valeur en dehors de cette intervalle va faire paniquer le programme.</p>
<!--
We do this by adding another attribute, `should_panic`, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesnâ€™t panic.
-->
<p>Nous allons vÃ©rifier cela en ajoutant un autre attribut, <code>should_panic</code>, Ã  notre
fonction de test. Cet attribut fait rÃ©ussir le test si le code Ã  l'intÃ©rieur
de la fonction fait paniquer ; le test va Ã©chouer si le code Ã  l'intÃ©rieur de
la fonction ne panique pas.</p>
<!--
Listing 11-8 shows a test that checks that the error conditions of `Guess::new`
happen when we expect them to.
-->
<p>L'encart 11-8 nous montre un test qui vÃ©rifie que les conditions d'erreur de
<code>Supposition::new</code> fonctionne bien comme nous l'avons prÃ©vu.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-8: Testing that a condition will cause a
`panic!`</span>
-->
<p><span class="caption">Encart 11-8 : tester qu'une condition va faire un <code>panic</code>
</span></p>
<!--
We place the `#[should_panic]` attribute after the `#[test]` attribute and
before the test function it applies to. Letâ€™s look at the result when this test
passes:
-->
<p>Nous plaÃ§ons l'attribut <code>#[should_panic]</code> aprÃ¨s l'attribut <code>#[test]</code> et avant
la fonction de test sur laquelle il s'applique. Voyons le rÃ©sultat lorsque ce
test rÃ©ussit :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::plus_grand_que_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::plus_grand_que_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Looks good! Now letâ€™s introduce a bug in our code by removing the condition
that the `new` function will panic if the value is greater than 100:
-->
<p>Ca fonctionne ! Maintenant, ajoutons un bogue dans notre code en enlevant
la condition dans laquelle la fonction <code>new</code> panique lorsque la valeur est
plus grande que 100 :</p>
<!--
```rust,not_desired_behavior
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
When we run the test in Listing 11-8, it will fail:
-->
<p>Lorsque nous lanÃ§ons le test de l'encart 11-8, il va Ã©chouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::plus_grand_que_100 ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::plus_grand_que_100 ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We donâ€™t get a very helpful message in this case, but when we look at the test
function, we see that itâ€™s annotated with `#[should_panic]`. The failure we got
means that the code in the test function did not cause a panic.
-->
<p>Dans ce cas, nous n'obtenons pas de message trÃ¨s utile, mais lorsque nous
regardons la fonction de test, nous constatons qu'elle est marquÃ©e avec
<code>#[should_panic]</code>. L'Ã©chec que nous obtenons signifie que le code dans la
fonction de test n'a pas fait paniquer.</p>
<!--
Tests that use `should_panic` can be imprecise because they only indicate that
the code has caused some panic. A `should_panic` test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make `should_panic` tests more precise, we can add an optional `expected`
parameter to the `should_panic` attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for `Guess` in Listing 11-9 where the `new` function panics with
different messages depending on whether the value is too small or too large.
-->
<p>Les tests qui utilisent <code>should_panic</code> ne sont parfois pas assez explicites car
ils indiquent seulement que le code a paniquÃ©. Un test <code>should_panic</code> peut
rÃ©ussir, mÃªme si le test panique pour une raison diffÃ©rente Ã  cette que nous
attendions. Pour rendre les tests <code>should_panic</code> plus prÃ©cis, nous pouvons
ajouter un paramÃ¨tre optionnel <code>expected</code> Ã  l'attribut <code>should_panic</code>. Le
systÃ¨me de test va s'assurer que le message d'Ã©chec contient bien le texte
renseignÃ©. Par exemple, imaginons le code modifiÃ© de <code>Supposition</code> dans
l'encart 11-9 oÃ¹ la fonction <code>new</code> panique avec des messages diffÃ©rents si la
valeur est trop petite ou trop grande.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.",
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100")]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.&quot;,
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100&quot;)]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-9: Testing that a condition will cause a
`panic!` with a particular panic message</span>
-->
<p><span class="caption">Encart 11-9 : on vÃ©rifie qu'une situation va provoquer un
<code>panic!</code> avec un message de panique bien prÃ©cis</span></p>
<!--
This test will pass because the value we put in the `should_panic` attributeâ€™s
`expected` parameter is a substring of the message that the `Guess::new`
function panics with. We could have specified the entire panic message that we
expect, which in this case would be `Guess value must be less than or equal to
100, got 200.` What you choose to specify in the expected parameter for
`should_panic` depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the `else if value > 100` case.
-->
<p>Ce test va rÃ©ussir car la valeur que nous insÃ©rons dans l'attribut <code>expected</code>
de <code>should_panic</code> est une partie du message de panique de la fonction
<code>Supposition::new</code>. Nous aurions pu renseigner le message de panique en entier
que nous attendions, qui dans ce cas est <code>La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons 200.</code>. Ce que vous choisissez de renseigner dans
le paramÃ¨tre <code>expected</code> de <code>should_panic</code> dÃ©pend de la mesure dans laquelle le
message de panique est unique ou dynamique et de la prÃ©cision de votre test que
vous souhaitez appliquer. Dans ce cas, un extrait du message de panique est
suffisant pour s'assurer que le code de la fonction de test s'exÃ©cute dans le
cas du <code>else if valeur &gt; 100</code>.</p>
<!--
To see what happens when a `should_panic` test with an `expected` message
fails, letâ€™s again introduce a bug into our code by swapping the bodies of the
`if value < 1` and the `else if value > 100` blocks:
-->
<p>Pour voir ce qui se passe lorsqu'un test <code>should_panic</code> qui a un message
<code>expected</code> qui Ã©choue, essayons Ã  nouveau d'introduire un bogue dans notre code
en permutant les corps des blocs de <code>if valeur &lt; 1</code> et de
<code>else if valeur &gt; 100</code> :</p>
<!--
```rust,ignore,not_desired_behavior
# pub struct Supposition {
#     valeur: i32,
# }
# 
# impl Supposition {
#     pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.",
                valeur
            );
        }
# 
#         Supposition { valeur }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic(expected = "La supposition doit Ãªtre plus petite ou Ã©gale Ã  100")]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Supposition {
</span><span class="boring">    pub fn new(valeur: i32) -&gt; Supposition {
</span>        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons {}.&quot;,
                valeur
            );
        }
<span class="boring">
</span><span class="boring">        Supposition { valeur }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100&quot;)]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This time when we run the `should_panic` test, it will fail:
-->
<p>Cette fois, lorsque nous lanÃ§ons le test avec <code>should_panic</code>, il devrait
Ã©chouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::plus_grand_que_100 ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `"La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200."`,
 expected substring: `"La supposition doit Ãªtre plus petite ou Ã©gale Ã  100"`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::plus_grand_que_100 ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `&quot;La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.&quot;`,
 expected substring: `&quot;La supposition doit Ãªtre plus petite ou Ã©gale Ã  100&quot;`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string `'Guess value must be
less than or equal to 100'`. The panic message that we did get in this case was
`Guess value must be greater than or equal to 1, got 200.` Now we can start
figuring out where our bug is!
-->
<p>Le message d'Ã©chec nous informe que ce test a paniquÃ© comme prÃ©vu, mais que le
message de panique n'inclus pas la chaÃ®ne de caractÃ¨res prÃ©vue <code>'La supposition doit Ãªtre plus petite ou Ã©gale Ã  100'</code>. Le message de panique que nous avons
obtenu dans ce cas Ã©tait <code>La supposition doit Ãªtre plus grande ou Ã©gale Ã  1, et nous avons 200.</code>. Maintenant, on comprend mieux oÃ¹ est le bogue !</p>
<!--
### Using `Result<T, E>` in Tests
-->
<h3><a class="header" href="#utiliser-resultt-e-dans-les-tests" id="utiliser-resultt-e-dans-les-tests">Utiliser <code>Result&lt;T, E&gt;</code> dans les tests</a></h3>
<!--
So far, weâ€™ve written tests that panic when they fail. We can also write tests
that use `Result<T, E>`! Hereâ€™s the test from Listing 11-1, rewritten to use
`Result<T, E>` and return an `Err` instead of panicking:
-->
<p>PrÃ©cÃ©demment, nous avons Ã©crit des tests qui paniquent lorsqu'ils Ã©chouent.
Nous pouvons Ã©galement Ã©crire des tests qui utilisent <code>Result&lt;T, E&gt;</code> ! Voici
le test de l'encart 11-1, rÃ©Ã©cris pour utiliser <code>Result&lt;T, E&gt;</code> et retourner
une <code>Err</code> au lieu de paniquer :</p>
<!--
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("deux plus deux ne vaut pas quatre"))
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;deux plus deux ne vaut pas quatre&quot;))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `it_works` function now has a return type, `Result<(), String>`. In the
body of the function, rather than calling the `assert_eq!` macro, we return
`Ok(())` when the test passes and an `Err` with a `String` inside when the test
fails.
-->
<p>La fonction <code>it_works</code> a maintenant un type de retour, <code>Result&lt;(), String&gt;</code>.
Dans le corps de la fonction, plutÃ´t que d'appeler la macro <code>assert_eq!</code>, nous
retournons <code>Ok(())</code> lorsque le test rÃ©ussit et une <code>Err</code> avec une <code>String</code> Ã 
l'intÃ©rieur lorsque le test Ã©choue.</p>
<!--
Writing tests so they return a `Result<T, E>` enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an `Err` variant.
-->
<p>Ecrire vos tests afin qu'ils retournent un <code>Result&lt;T, E&gt;</code> vous permet
d'utiliser l'opÃ©rateur <em>point d'interrogation</em> dans le corps des tests, ce
qui est un outil facile Ã  utiliser pour Ã©crire des tests qui peuvent Ã©chouer
si n'importe quelle opÃ©ration en son sein retourne une variante de <code>Err</code>.</p>
<!--
You canâ€™t use the `#[should_panic]` annotation on tests that use `Result<T,
E>`. Instead, you should return an `Err` value directly when the test should
fail.
-->
<p>Vous ne pouvez pas utiliser l'annotation <code>#[should_panic]</code> sur les tests qui
utilisent <code>Result&lt;T, E&gt;</code>. Mais Ã  la place, vous devez retourner directement
une valeur <code>Err</code> lorsque le test Ã©choue.</p>
<!--
Now that you know several ways to write tests, letâ€™s look at what is happening
when we run our tests and explore the different options we can use with `cargo
test`.
-->
<p>Maintenant que vous avez appris diffÃ©rentes maniÃ¨res d'Ã©crire des tests, voyons
ce qui se passe lorsque nous lanÃ§ons nos tests et explorons les diffÃ©rentes
options que nous pouvons utiliser avec <code>cargo test</code>.</p>
<!--
[concatenation-with-the--operator-or-the-format-macro]:
ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro
[controlling-how-tests-are-run]:
ch11-02-running-tests.html#controlling-how-tests-are-run
[derivable-traits]: appendix-03-derivable-traits.html
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--10" id="-attention-peinture-fraÃ®che--10">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/126">Pull Request</a>.</p>
</blockquote>
<!--
## Controlling How Tests Are Run
-->
<h2><a class="header" href="#gÃ©rer-lexÃ©cution-des-tests" id="gÃ©rer-lexÃ©cution-des-tests">GÃ©rer l'exÃ©cution des tests</a></h2>
<!--
Just as `cargo run` compiles your code and then runs the resulting binary,
`cargo test` compiles your code in test mode and runs the resulting test
binary. You can specify command line options to change the default behavior of
`cargo test`. For example, the default behavior of the binary produced by
`cargo test` is to run all the tests in parallel and capture output generated
during test runs, preventing the output from being displayed and making it
easier to read the output related to the test results.
-->
<p>Comme <code>cargo run</code> qui compile votre code et qui exÃ©cute ensuite le binaire qui
en rÃ©sulte, <code>cargo test</code> compile votre code en mode test et lance le binaire de
tests qu'il produit. Vous pouvez rajouter des options en ligne de commande pour
changer le comportement par dÃ©faut de <code>cargo test</code>. Par exemple, le
comportement par dÃ©faut des binaires produits par <code>cargo test</code> est de lancer
tous les tests en parallÃ¨le et de capturer la sortie pendant l'exÃ©cution des
tests, ce qui Ã©vite la sortie d'Ãªtre affichÃ©e sur l'Ã©cran pendant ce temps et
facilite la lecture de la sortie concernant le rÃ©sultat de l'exÃ©cution des
tests.</p>
<!--
Some command line options go to `cargo test`, and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that
go to `cargo test` followed by the separator `--` and then the ones that go to
the test binary. Running `cargo test --help` displays the options you can use
with `cargo test`, and running `cargo test -- --help` displays the options you
can use after the separator `--`.
-->
<p>Certaines options de la ligne de commande s'appliquent Ã  <code>cargo test</code>, et
certaines au binaire de tests qui en rÃ©sulte. Pour sÃ©parer ces types
d'arguments, il faut lister les arguments qui s'appliquent Ã  <code>cargo test</code>,
suivis du sÃ©parateur <code>--</code>, puis d'ajouter ceux qui s'appliquent au binaire
de tests. L'exÃ©cution de <code>cargo test --help</code> affiche les options que vous
pouvez utiliser sur <code>cargo test</code>, et l'exÃ©cution de <code>cargo test -- --help</code>
affiche les options que vous pouvez utiliser aprÃ¨s le sÃ©parateur <code>--</code>.</p>
<!--
### Running Tests in Parallel or Consecutively
-->
<h3><a class="header" href="#lancer-les-tests-en-parallÃ¨le-ou-en-sÃ©quence" id="lancer-les-tests-en-parallÃ¨le-ou-en-sÃ©quence">Lancer les tests en parallÃ¨le ou en sÃ©quence</a></h3>
<!--
When you run multiple tests, by default they run in parallel using threads.
This means the tests will finish running faster so you can get feedback quicker
on whether or not your code is working. Because the tests are running at the
same time, make sure your tests donâ€™t depend on each other or on any shared
state, including a shared environment, such as the current working directory or
environment variables.
-->
<p>Lorsque vous lancez de nombreux tests, par dÃ©faut ils s'exÃ©cutent en parallÃ¨le
dans des tÃ¢ches. Cela veut dire que tous les tests vont finir de s'exÃ©cuter plus
rapidement afin que vous sachiez si votre code fonctionne ou non. Comme mes
tests s'exÃ©cutent en mÃªme temps, il faut s'assurer que vos tests ne dÃ©pendent
pas l'un de l'autre ou sur un Ã©tat partagÃ©, y compris un environnement partagÃ©,
comme le dossier de travail actuel ou des variables d'environnement.</p>
<!--
For example, say each of your tests runs some code that creates a file on disk
named *test-output.txt* and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file between when another test writes and reads the
file. The second test will then fail, not because the code is incorrect but
because the tests have interfered with each other while running in parallel.
One solution is to make sure each test writes to a different file; another
solution is to run the tests one at a time.
-->
<p>Par exemple, disons que chacun de vos tests exÃ©cute du code qui crÃ©e un fichier
<em>test-sortie.txt</em> sur le disque-dur et qu'il Ã©crit quelques donnÃ©es dans ce
fichier. Ensuite, chaque test lit les donnÃ©es de ce fichier et vÃ©rifie que le
fichier contient une valeur prÃ©cise, qui est diffÃ©rente dans chaque test. Comme
les tests sont lancÃ©s en mÃªme temps, un test risque d'Ã©craser le contenu du
fichier entre le moment oÃ¹ un autre test lit et Ã©crit sur ce fichier. Le second
test va ensuite Ã©chouer, non pas parce que le code est incorrecte mais parce
que les tests se sont perturbÃ©s mutuellement pendant qu'ils s'exÃ©cutaient en
parallÃ¨le. Une solution serait de s'assurer que chaque test Ã©crit dans un
fichier diffÃ©rent ; une autre serait de lancer les tests l'un aprÃ¨s l'autre.</p>
<!--
If you donâ€™t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the `--test-threads` flag
and the number of threads you want to use to the test binary. Take a look at
the following example:
-->
<p>Si vous ne souhaitez pas exÃ©cuter les tests en parallÃ¨le ou si vous voulez un
contrÃ´le plus prÃ©cis du nombre de tÃ¢ches utilisÃ©s, vous pouvez envoyer le
drapeau <code>--test-threads</code> ainsi que le nombre de tÃ¢ches que vous souhaitez
utiliser sur le binaire de test. Regardez cet exemple :</p>
<!--
```console
$ cargo test -- --test-threads=1
```
-->
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<!--
We set the number of test threads to `1`, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests wonâ€™t interfere with each other if they share
state.
-->
<p>Nous avons rÃ©glÃ© le nombre de tÃ¢ches Ã  <code>1</code>, ce qui indique au programme de ne
pas utiliser le parallÃ©lisme. ExÃ©cuter ces tests en utilisant une seule tÃ¢che va
prendre plus de temps que de les lancer en parallÃ¨le, mais les tests ne vont pas
s'influencer mutuellement s'ils partagent le mÃªme Ã©tat.</p>
<!--
### Showing Function Output
-->
<h3><a class="header" href="#afficher-la-sortie-de-la-fonction" id="afficher-la-sortie-de-la-fonction">Afficher la sortie de la fonction</a></h3>
<!--
By default, if a test passes, Rustâ€™s test library captures anything printed to
standard output. For example, if we call `println!` in a test and the test
passes, we wonâ€™t see the `println!` output in the terminal; weâ€™ll see only the
line that indicates the test passed. If a test fails, weâ€™ll see whatever was
printed to standard output with the rest of the failure message.
-->
<p>Par dÃ©faut, si un test rÃ©ussit, la bibliothÃ¨que de test de Rust rÃ©cupÃ¨re tout
ce qui est affichÃ© sur la sortie standard. Par exemple, si nous appelons
<code>println!</code> dans un test et que le test rÃ©ussit, nous ne verrons pas la sortie
correspondant au <code>println!</code> dans le terminal ; on verra seulement la ligne qui
indique que le test a rÃ©ussi. Si un test Ã©choue, nous verrons ce qui a Ã©tÃ©
affichÃ© sur la sortie standard avec le reste des messages d'erreur.</p>
<!--
As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.
-->
<p>Par exemple, l'encart 11-10 a une fonction stupide qui affiche la valeur de ses
paramÃ¨tres et retourne 10, ainsi qu'un test qui rÃ©ussit et un test qui Ã©choue.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,panics
fn affiche_et_retourne_10(a: i32) -> i32 {
    println!("J'ai obtenu la valeur {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ce_test_reussit() {
        let valeur = affiche_et_retourne_10(4);
        assert_eq!(10, valeur);
    }

    #[test]
    fn ce_test_echoue() {
        let valeur = affiche_et_retourne_10(8);
        assert_eq!(5, valeur);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust panics">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn affiche_et_retourne_10(a: i32) -&gt; i32 {
    println!(&quot;J'ai obtenu la valeur {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ce_test_reussit() {
        let valeur = affiche_et_retourne_10(4);
        assert_eq!(10, valeur);
    }

    #[test]
    fn ce_test_echoue() {
        let valeur = affiche_et_retourne_10(8);
        assert_eq!(5, valeur);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-10: Tests for a function that calls
`println!`</span>
-->
<p><span class="caption">Encart 11-10 : tests d'une fonction qui fait appel Ã 
<code>println!</code></span></p>
<!--
When we run these tests with `cargo test`, weâ€™ll see the following output:
-->
<p>Lorsque nous lanÃ§ons ces tests avec <code>cargo test</code>, nous voyons cette sortie :</p>
<!--
```console
$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

failures:

---- tests::ce_test_echoue stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

failures:

---- tests::ce_test_echoue stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Note that nowhere in this output do we see `I got the value 4`, which is what
is printed when the test that passes runs. That output has been captured. The
output from the test that failed, `I got the value 8`, appears in the section
of the test summary output, which also shows the cause of the test failure.
-->
<p>Remarquez que nous n'avons jamais vu <code>J'ai obtenu la valeur 4</code> dans cette
sortie, qui est ce qui est affichÃ© lors de l'exÃ©cution du test qui rÃ©ussit.
Cette sortie a Ã©tÃ© capturÃ©e. La sortie pour le test qui a Ã©chouÃ©,
<code>J'ai obtenu la valeur 8</code>, s'affiche dans la section de la sortie
correspondante au rÃ©sumÃ© des tests, qui affiche aussi les causes de l'Ã©chec
du test.</p>
<!--
If we want to see printed values for passing tests as well, we can tell Rust
to also show the output of successful tests at the end with `--show-output`.
-->
<p>Si nous voulons aussi voir les valeurs affichÃ©es pour les tests rÃ©ussis, nous
pouvons demander Ã  Rust d'afficher Ã©galement la sortie des tests fructueux en
lui rajoutant Ã  la fin <code>--show-output</code>.</p>
<!--
```console
$ cargo test -- --show-output
```
-->
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<!--
When we run the tests in Listing 11-10 again with the `--show-output` flag, we
see the following output:
-->
<p>Lorsque nous lanÃ§ons Ã  nouveau les tests de l'encart 11-10 avec le drapeau
<code>--show-output</code>, nous voyons la sortie suivante :</p>
<!--
```console
$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

successes:

---- tests::ce_test_reussit stdout ----
J'ai obtenu la valeur 4


successes:
    tests::ce_test_reussit

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

successes:

---- tests::ce_test_reussit stdout ----
J'ai obtenu la valeur 4


successes:
    tests::ce_test_reussit

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
### Running a Subset of Tests by Name
-->
<h3><a class="header" href="#exÃ©cuter-un-sous-ensemble-de-tests-en-fonction-de-son-nom" id="exÃ©cuter-un-sous-ensemble-de-tests-en-fonction-de-son-nom">ExÃ©cuter un sous-ensemble de tests en fonction de son nom</a></h3>
<!--
Sometimes, running a full test suite can take a long time. If youâ€™re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing `cargo test` the name
or names of the test(s) you want to run as an argument.
-->
<p>Parfois, lancer une suite de tests entiÃ¨re peut prendre beaucoup de temps. Si
vous travaillez sur du code d'un pÃ©rimÃ¨tre bien dÃ©fini, vous pourriez avoir
besoin d'exÃ©cuter uniquement les tests relatifs Ã  ce code. Vous pouvez choisir
quels tests exÃ©cuter en envoyant le ou les noms des test(s) que vous souhaitez
exÃ©cuter en argument de <code>cargo test</code>.</p>
<!--
To demonstrate how to run a subset of tests, weâ€™ll create three tests for our
`add_two` function, as shown in Listing 11-11, and choose which ones to run.
-->
<p>Dans le but de dÃ©montrer comment lancer un sous-ensemble de tests, nous allons
crÃ©er trois tests pour notre fonction <code>ajouter_deux</code> dans l'encart 11-11, et
choisir lesquels nous allons exÃ©cuter.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ajouter_deux_a_deux() {
        assert_eq!(4, ajouter_deux(2));
    }

    #[test]
    fn ajouter_deux_a_trois() {
        assert_eq!(5, ajouter_deux(3));
    }

    #[test]
    fn cent() {
        assert_eq!(102, ajouter_deux(100));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ajouter_deux_a_deux() {
        assert_eq!(4, ajouter_deux(2));
    }

    #[test]
    fn ajouter_deux_a_trois() {
        assert_eq!(5, ajouter_deux(3));
    }

    #[test]
    fn cent() {
        assert_eq!(102, ajouter_deux(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-11: Three tests with three different
names</span>
-->
<p><span class="caption">Encart 11-11 : trois tests avec trois noms diffÃ©rents
</span></p>
<!--
If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:
-->
<p>Si nous exÃ©cutons les tests sans ajouter d'arguments, comme nous l'avons vu
prÃ©cÃ©demment, tous les tests vont s'exÃ©cuter en parallÃ¨le :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/adder-92948b65e88960b4

running 3 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok
test tests::cent ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/adder-92948b65e88960b4

running 3 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok
test tests::cent ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
#### Running Single Tests
-->
<h4><a class="header" href="#exÃ©cuter-des-tests-individuellement" id="exÃ©cuter-des-tests-individuellement">ExÃ©cuter des tests individuellement</a></h4>
<!--
We can pass the name of any test function to `cargo test` to run only that test:
-->
<p>Nous pouvons donner le nom de n'importe quelle fonction de test Ã  <code>cargo test</code>
afin d'exÃ©cuter uniquement ce test :</p>
<!--
```console
$ cargo test cent
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::cent ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

```
-->
<pre><code class="language-console">$ cargo test cent
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::cent ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

</code></pre>
<!--
Only the test with the name `one_hundred` ran; the other two tests didnâ€™t match
that name. The test output lets us know we had more tests than what this
command ran by displaying `2 filtered out` at the end of the summary line.
-->
<p>Le test avec le nom <code>cent</code> est le seul exÃ©cutÃ© ; les deux autres tests ne
correspondent pas Ã  ce nom. La sortie du test nous indique que nous avons
d'autres tests en plus de celui que cette commande a exÃ©cutÃ© en affichant
<code>2 filtered out</code> Ã  la fin de la ligne de rÃ©sumÃ©.</p>
<!--
We canâ€™t specify the names of multiple tests in this way; only the first value
given to `cargo test` will be used. But there is a way to run multiple tests.
-->
<p>Nous ne pouvons pas renseigner plusieurs noms de tests de cette maniÃ¨re ; il
n'y a que la premiÃ¨re valeur fournie Ã  <code>cargo test</code> qui sera utilisÃ©e. Mais
il existe un moyen d'exÃ©cuter plusieurs tests.</p>
<!--
#### Filtering to Run Multiple Tests
-->
<h4><a class="header" href="#filtrer-pour-exÃ©cuter-plusieurs-tests" id="filtrer-pour-exÃ©cuter-plusieurs-tests">Filtrer pour exÃ©cuter plusieurs tests</a></h4>
<!--
We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our testsâ€™ names contain `add`, we can
run those two by running `cargo test add`:
-->
<p>Nous pouvons renseigner qu'une partie d'un nom de test, et tous les tests dont
les noms correspondent Ã  cette valeur vont Ãªtre exÃ©cutÃ©s. Par exemple, comme
deux de nos noms de tests contiennent <code>ajouter</code>, nous pouvons exÃ©cuter ces deux
en lanÃ§ant <code>cargo test ajouter</code> :</p>
<!--
```console
$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

```
-->
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

</code></pre>
<!--
This command ran all tests with `add` in the name and filtered out the test
named `one_hundred`. Also note that the module in which a test appears becomes
part of the testâ€™s name, so we can run all the tests in a module by filtering
on the moduleâ€™s name.
-->
<p>Cette commande a lancÃ© tous les tests qui contiennent <code>ajouter</code> dans leur nom
et a filtrÃ© le test <code>cent</code>. Notez aussi que le module dans lequel un test est
prÃ©sent fait partie du nom du test, ainsi nous pouvons exÃ©cuter tous les tests
d'un module en filtrant avec le nom du module.</p>
<!--
### Ignoring Some Tests Unless Specifically Requested
-->
<h3><a class="header" href="#ignorer-certains-tests-sauf-sils-sont-demandÃ©s-explicitement" id="ignorer-certains-tests-sauf-sils-sont-demandÃ©s-explicitement">Ignorer certains tests sauf s'ils sont demandÃ©s explicitement</a></h3>
<!--
Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of `cargo test`. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the `ignore` attribute to exclude them, as shown
here:
-->
<p>Parfois, certains tests spÃ©cifiques peuvent prendre beaucoup de temps Ã 
s'exÃ©cuter, de sorte que vous voulez les exclure de la majoritÃ© des exÃ©cutions
de <code>cargo test</code>. PlutÃ´t que de lister en argument tous les tests que vous
souhaitez exÃ©cuter, vous pouvez plutÃ´t faire une annotation sur les tests qui
prennent du temps en utilisant l'attribut <code>ignore</code> pour les exclure, comme
ci-dessous :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn test_long() {
    // du code qui prend une heure Ã  s'exÃ©cuter
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn test_long() {
    // du code qui prend une heure Ã  s'exÃ©cuter
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now
when we run our tests, `it_works` runs, but `expensive_test` doesnâ€™t:
-->
<p>AprÃ¨s <code>#[test]</code>, nous avons ajoutÃ© la ligne <code>#[ignore]</code> pour le test que nous
souhaitons exclure. Maintenant lorsque nous exÃ©cutons nos tests, <code>it_works</code>
s'exÃ©cute, mais pas <code>test_long</code> :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test test_long ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test test_long ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
The `expensive_test` function is listed as `ignored`. If we want to run only
the ignored tests, we can use `cargo test -- --ignored`:
-->
<p>La fonction <code>test_long</code> est listÃ©e comme <code>ignored</code>. Si nous voulons exÃ©cuter
uniquement les tests ignorÃ©s, nous pouvons utiliser <code>cargo test -- --ignored</code> :</p>
<!--
```console
$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test test_long ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test test_long ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
By controlling which tests run, you can make sure your `cargo test` results
will be fast. When youâ€™re at a point where it makes sense to check the results
of the `ignored` tests and you have time to wait for the results, you can run
`cargo test -- --ignored` instead.
-->
<p>En gÃ©rant quels tests sont exÃ©cutÃ©s, vous pouvez vous assurer que vos rÃ©sultats
de <code>cargo test</code> seront rapides. Lorsque vous arrivez Ã  un stade oÃ¹ il est
justifiÃ© de vÃ©rifier le rÃ©sultat des tests <code>ignored</code> et que vous avez le temps
d'attendre ces rÃ©sultats, vous pouvez lancer Ã  la place
<code>cargo test -- --ignored</code>.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--11" id="-attention-peinture-fraÃ®che--11">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/128">Pull Request</a>.</p>
</blockquote>
<!--
## Test Organization
-->
<h2><a class="header" href="#lorganisation-des-tests" id="lorganisation-des-tests">L'organisation des tests</a></h2>
<!--
As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: *unit tests* and
*integration tests*. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.
-->
<p>Comme nous l'avons Ã©voquÃ© au dÃ©but du chapitre, le test est une discipline
complexe, et diffÃ©rentes personnes utilisent des terminologies et organisations
diffÃ©rentes. La communautÃ© Rust a conÃ§u les tests dans deux catÃ©gories
principalesÂ : <em>les tests unitaires</em> et <em>les tests d'intÃ©gration</em>. Les tests
unitaires sont petits et plus prÃ©cis, et tester un module isolÃ© Ã  la fois, et
peuvent tester les interfaces privÃ©es. Les tests d'intÃ©gration sont uniquement
externes Ã  notre bibliothÃ¨que et consomme notre code exactement de la mÃªme
maniÃ¨re que tout autre code externe le ferait, en utilisant uniquement
l'interface publique et Ã©ventuellement en utilisant plusieurs modules dans un
test.</p>
<!--
Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.
-->
<p>L'Ã©criture de ces deux types de tests est importante pour s'assurer que chaque
Ã©lÃ©ment de notre bibliothÃ¨que fait bien ce que vous attendiez d'eux, de
maniÃ¨re isolÃ©e et conjuguÃ©e avec d'autres.</p>
<!--
### Unit Tests
-->
<h3><a class="header" href="#les-tests-unitaires" id="les-tests-unitaires">Les tests unitaires</a></h3>
<!--
The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isnâ€™t working as
expected. Youâ€™ll put unit tests in the *src* directory in each file with the
code that theyâ€™re testing. The convention is to create a module named `tests`
in each file to contain the test functions and to annotate the module with
`cfg(test)`.
-->
<p>Le but des tests unitaires est de tester chaque Ã©lÃ©ment du code de maniÃ¨re
sÃ©parÃ©e du reste du code pour identifier rapidement oÃ¹ le code fonctionne
fonctionne ou non comme prÃ©vu. Vous devriez insÃ©rer les tests unitaires dans le
dossier <em>src</em> de chaque fichier, Ã  cÃ´tÃ© du code qu'ils testent. La convention
est de crÃ©er un module <code>tests</code> dans chaque fichier qui contient les fonctions
de test et de marquer le module avec <code>cfg(test)</code>.</p>
<!--
#### The Tests Module and `#[cfg(test)]`
-->
<h4><a class="header" href="#les-modules-de-tests-et-cfgtest" id="les-modules-de-tests-et-cfgtest">Les modules de tests et <code>#[cfg(test)]</code></a></h4>
<!--
The `#[cfg(test)]` annotation on the tests module tells Rust to compile and run
the test code only when you run `cargo test`, not when you run `cargo build`.
This saves compile time when you only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. Youâ€™ll
see that because integration tests go in a different directory, they donâ€™t need
the `#[cfg(test)]` annotation. However, because unit tests go in the same files
as the code, youâ€™ll use `#[cfg(test)]` to specify that they shouldnâ€™t be
included in the compiled result.
-->
<p>L'annotation <code>#[cfg(test)]</code> sur les modules de tests indiquent Ã  Rust de
compiler et d'exÃ©cuter le code de test seulement lorsque vous lancez
<code>cargo test</code>, et non pas lorsque vous lancez <code>cargo build</code>. Cela diminue la
durÃ©e de compilation lorsque vous souhaitez uniquement compiler la bibliothÃ¨que
et cela rÃ©duit la taille dans l'artefact compilÃ© qui en rÃ©sulte car les tests
n'y sont pas intÃ©grÃ©s. Vous verrez plus tard que comme les tests d'intÃ©gration
se placent dans un rÃ©pertoire diffÃ©rent, ils n'ont pas besoin de l'annotation
<code>#[cfg(test)]</code>. Cependant, comme les tests unitaires vont dans les mÃªmes
fichiers que le code, vous devriez utiliser <code>#[cfg(test)]</code> pour marquer qu'ils
ne devraient pas Ãªtre inclus dans les rÃ©sultats de compilation.</p>
<!--
Recall that when we generated the new `adder` project in the first section of
this chapter, Cargo generated this code for us:
-->
<p>Souvenez-vous, lorsque nous avons gÃ©nÃ©rÃ© le nouveau projet <code>addition</code> dans la
premiÃ¨re section de ce chapitre, Cargo a gÃ©nÃ©rÃ© ce code pour nousÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
This code is the automatically generated test module. The attribute `cfg`
stands for *configuration* and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is `test`, which is provided by Rust for compiling and
running tests. By using the `cfg` attribute, Cargo compiles our test code only
if we actively run the tests with `cargo test`. This includes any helper
functions that might be within this module, in addition to the functions
annotated with `#[test]`.
-->
<p>Ce code est le module de test gÃ©nÃ©rÃ© automatiquement. L'attribut <code>cfg</code> est
l'abrÃ©viation de <em>configuration</em> et indique Ã  rust que l'Ã©lÃ©ment suivant ne
doit Ãªtre intÃ©grÃ© que dans une certaine option de configuration donnÃ©e. Dans
ce cas, l'option de configuration est <code>test</code>, qui est fourni par Rust pour la
compilation et l'exÃ©cution des tests. En utilisant l'attribut <code>cfg</code>, Cargo
compile notre code de tests uniquement si nous avons exÃ©cutÃ© les tests avec
<code>cargo test</code>. Cela inclut toutes les fonctions auxiliaires qui pourraient se
trouver dans ce module, en plus des fonctions marquÃ©es d'un <code>#[test]</code>.</p>
<!--
#### Testing Private Functions
-->
<h4><a class="header" href="#tester-des-fonctions-privÃ©es" id="tester-des-fonctions-privÃ©es">Tester des fonctions privÃ©es</a></h4>
<!--
Thereâ€™s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rustâ€™s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function `internal_adder`.
-->
<p>Il existe un dÃ©bat dans communautÃ© des testeurs au sujet de la nÃ©cessitÃ© ou non
de tester directement les fonctions privÃ©es, et d'autres langages rendent
difficile, voir impossible, de tester les fonctions privÃ©es. Quelle que soit
votre approche des tests, les rÃ¨gles de protection de Rust vous permettent de
tester des fonctions privÃ©es. Imaginons le code de l'encart 11-12 qui contient
la fonction privÃ©e <code>addition_interne</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub fn ajouter_deux(a: i32) -> i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub fn ajouter_deux(a: i32) -&gt; i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-12: Testing a private function</span>
-->
<p><span class="caption">Encart 11-12Â : test d'une fonction privÃ©e</span></p>
<!--
Note that the `internal_adder` function is not marked as `pub`, but because
tests are just Rust code and the `tests` module is just another module, you can
bring `internal_adder` into a testâ€™s scope and call it. If you donâ€™t think
private functions should be tested, thereâ€™s nothing in Rust that will compel
you to do so.
-->
<p>Remarquez que la fonction <code>addition_interne</code> n'est pas marquÃ©e comme <code>pub</code>, car
comme les tests sont uniquement du code Rust et que le module <code>test</code> est
simplement un autre module, vous pouvez importer <code>addition_interne</code> dans la
portÃ©e des tests et l'utiliser. Si vous pensez qu'une fonction privÃ©e ne doit
pas Ãªtre testÃ©e, il n'y a rien qui vous y force avec Rust.</p>
<!--
### Integration Tests
-->
<h3><a class="header" href="#les-tests-dintÃ©gration" id="les-tests-dintÃ©gration">Les tests d'intÃ©gration</a></h3>
<!--
In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your libraryâ€™s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a *tests* directory.
-->
<p>En Rust, les tests d'intÃ©gration sont exclusivement externes Ã  votre
bibliothÃ¨que. Ils consomment votre bibliothÃ¨que de la mÃªme maniÃ¨re que n'importe
quel autre code, ce qui signifie qu'ils ne peuvent appeler uniquement les
fonctions qui font partie de l'interface de programmation applicative (API)
publique de votre bibliothÃ¨que. Leur but est de tester si les multiples parties
de votre bibliothÃ¨que fonctionnent correctement ensemble. Les portions de code
qui fonctionnent bien toutes seules pourraient rencontrer des problÃ¨mes une fois
imbriquÃ©es avec d'autres, donc les tests qui couvrent l'intÃ©gration du code est
aussi important. Pour crÃ©er des tests d'intÃ©gration, vous avez d'abord besoin
d'un dossier <em>tests</em>.</p>
<!--
#### The *tests* Directory
-->
<h4><a class="header" href="#le-dossier-tests" id="le-dossier-tests">Le dossier <em>tests</em></a></h4>
<!--
We create a *tests* directory at the top level of our project directory, next
to *src*. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.
-->
<p>Nous crÃ©ons un dossier <em>tests</em> au niveau le plus haut de notre dossier de
projet, juste Ã  cÃ´tÃ© de <em>src</em>. Cargo sait qu'il doit rechercher les fichiers de
test d'intÃ©gration dans ce dossier. Nous pouvons ensuite construire autant de
fichiers de test que nous souhaitons dans ce dossier, et Cargo va compiler
chacun des fichiers comme une crate individuelle.</p>
<!--
Letâ€™s create an integration test. With the code in Listing 11-12 still in the
*src/lib.rs* file, make a *tests* directory, create a new file named
*tests/integration_test.rs*, and enter the code in Listing 11-13.
-->
<p>CommenÃ§ons Ã  crÃ©er un test d'intÃ©gration. Avec le code de l'encart 11-12
toujours prÃ©sent dans le fichier <em>src/lib.rs</em>, crÃ©ons un dossier <em>tests</em>, puis
un nouveau fichier <em>tests/test_integration.rs</em>, et insÃ©rez-y le code de l'encart
11-13.</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">FichierÂ : tests/test_integration.rs</span></p>
<!--
```rust,ignore
use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
<span class="caption">Listing 11-13: An integration test of a function in the
`adder` crate</span>
-->
<p><span class="caption">Encart 11-13Â : un test d'intÃ©gration d'une fonction
prÃ©sente dans la crate <code>addition</code></span></p>
<!--
Weâ€™ve added `use adder` at the top of the code, which we didnâ€™t need in the
unit tests. The reason is that each file in the `tests` directory is a separate
crate, so we need to bring our library into each test crateâ€™s scope.
-->
<p>Nous avons ajoutÃ© <code>use addition</code> en haut du code, ce que nous n'avions pas
besoin de faire dans les tests unitaires. La raison Ã  cela est que chaque
fichier dans le dossier <code>tests</code> est une crate sÃ©parÃ©e, donc nous devons importer
notre bibliothÃ¨que dans la portÃ©e de chaque crate de test.</p>
<!--
We donâ€™t need to annotate any code in *tests/integration_test.rs* with
`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files
in this directory only when we run `cargo test`. Run `cargo test` now:
-->
<p>Nous n'avons pas besoin de marquer du code avec <code>#[cfg(test)]</code> dans
<em>tests/test_integration.rs</em>. Cargo traite le dossier <code>tests</code> de maniÃ¨re
particuliÃ¨re et compile les fichiers prÃ©sents dans ce dossier uniquement si nous
lanÃ§ons <code>cargo test</code>. Lancez dÃ¨s maintenant <code>cargo test</code>Â :</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as weâ€™ve been
seeing: one line for each unit test (one named `internal` that we added in
Listing 11-12) and then a summary line for the unit tests.
-->
<p>Les trois sections de la sortie concernent les tests unitaires, les tests
d'intÃ©gration, et les tests de documentation. La premiÃ¨re section Ã  propos des
tests unitaires est la mÃªme que nous avons dÃ©jÃ  vuÂ : une ligne pour chaque test
unitaire (celui qui s'appelle <code>interne</code> que nous avons insÃ©rÃ© dans l'encart
11-12) et ensuite une ligne de rÃ©sumÃ© des tests unitaires.</p>
<!--
The integration tests section starts with the line `Running
target/debug/deps/integration_test-ce99bcc2479f4607` (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the `Doc-tests adder` section starts.
-->
<p>La section des tests d'intÃ©gration commence avec la ligne <code>Running target/debug/deps/test_integration-ce99bcc2479f4607</code> (le hachage Ã  la fin de
votre sortie pourrait Ãªtre diffÃ©rent). Ensuite, il y a une ligne pour chaque
fonction de test prÃ©sente dans ce test d'intÃ©gration et une ligne de rÃ©sumÃ© pour
les rÃ©sultats des tests d'intÃ©gration, juste avant que la section
<code>Doc-tests addition</code> commence.</p>
<!--
Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test fileâ€™s section. Each
integration test file has its own section, so if we add more files in the
*tests* directory, there will be more integration test sections.
-->
<p>De la mÃªme faÃ§on que plus vous ajoutez de fonctions de tests unitaires et plus
vous avez des lignes de rÃ©sultats dans la section des tests unitaires, plus
vous ajoutez des fonctions de tests aux fichiers de tests d'intÃ©gration et plus
vous aurez des lignes de rÃ©sultat Ã  cette section correspondante aux fichiers
de test d'intÃ©gration. Chaque fichier de test d'intÃ©gration a sa propre section,
donc si nous ajoutons plus de fichiers dans le dossier <em>tests</em>, il y aura plus
de sections de tests d'intÃ©gration.</p>
<!--
We can still run a particular integration test function by specifying the test
functionâ€™s name as an argument to `cargo test`. To run all the tests in a
particular integration test file, use the `--test` argument of `cargo test`
followed by the name of the file:
-->
<p>Nous pouvons aussi exÃ©cuter une fonction de test d'intÃ©gration prÃ©cise en
utilisant le nom de la fonction de test comme argument Ã  <code>cargo test</code>. Pour
exÃ©cuter tous les tests d'un fichier de tests d'intÃ©gration prÃ©cis, utilisez
l'argument <code>--test</code> de <code>cargo test</code> suivi du nom du fichierÂ :</p>
<!--
```console
$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
This command runs only the tests in the *tests/integration_test.rs* file.
-->
<p>Cette commande exÃ©cute seulement les tests dans le fichier
<em>tests/test_integration.rs</em>.</p>
<!--
#### Submodules in Integration Tests
-->
<h4><a class="header" href="#les-sous-modules-des-tests-dintÃ©gration" id="les-sous-modules-des-tests-dintÃ©gration">Les sous-modules des tests d'intÃ©gration</a></h4>
<!--
As you add more integration tests, you might want to make more than one file in
the *tests* directory to help organize them; for example, you can group the
test functions by the functionality theyâ€™re testing. As mentioned earlier, each
file in the *tests* directory is compiled as its own separate crate.
-->
<p>Au fur et Ã  mesure que vous ajouterez des tests d'intÃ©gration, vous pourriez
avoir besoin de les diviser en plusieurs fichiers dans le dossier <em>tests</em> pour
vous aider Ã  les organiserÂ ; par exemple, vous pouvez regrouper les fonctions
de test par fonctionnalitÃ©s qu'elles testent. Comme mentionnÃ© prÃ©cÃ©demment,
chaque fichier dans le dossier <em>tests</em> est compilÃ© comme Ã©tant sa propre crate
sÃ©parÃ©e de tous les autres.</p>
<!--
Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the *tests* directory donâ€™t share the same
behavior as files in *src* do, as you learned in Chapter 7 regarding how to
separate code into modules and files.
-->
<p>Le fait que chaque fichier de test d'intÃ©gration soit sa propre crate est utile
pour crÃ©er des portÃ©es sÃ©parÃ©es qui ressemblent Ã  la maniÃ¨re dont les
dÃ©veloppeurs vont consommer votre crate. Cependant, cela veut aussi dire que
les fichiers dans le dossier <em>tests</em> n'ont pas le mÃªme comportement que le
ferraient les fichiers dans <em>src</em>, comme vous l'avez appris au chapitre 7 Ã 
propos de la maniÃ¨re de sÃ©parer le code dans des modules et des fichiers.</p>
<!--
The different behavior of files in the *tests* directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the [â€œSeparating
Modules into Different Filesâ€][separating-modules-into-files]<!-- ignore -- >
section of Chapter 7 to extract them into a common module. For example, if we
create *tests/common.rs* and place a function named `setup` in it, we can add
some code to `setup` that we want to call from multiple test functions in
multiple test files:
-->
<p>Ce comportement diffÃ©rent des fichiers dans le dossier <em>tests</em> est encore plus
remarquable lorsque vous avez un jeu de fonctions d'aide qui s'avÃ¨rent utiles
pour plusieurs fichiers de test d'intÃ©gration et que vous essayez de suivre les
Ã©tapes de la section <a href="ch07-05-separating-modules-into-different-files.html">â€œSÃ©parer les modules dans diffÃ©rents
fichiersâ€</a><!-- ignore --> du chapitre 7 afin de
les extraire dans un module en commun. Par exemple, si nous crÃ©ons
<em>tests/commun.rs</em> et que nous y plaÃ§ons une fonction <code>parametrage</code> Ã 
l'intÃ©rieur, nous pourrions ajouter du code Ã  <code>parametrage</code> que nous voudrions
appeler Ã  partir de diffÃ©rentes fonctions de test dans diffÃ©rents fichiers de
testÂ :</p>
<!--
<span class="filename">Filename: tests/common.rs</span>
-->
<p><span class="filename">FichierÂ : tests/commun.rs</span></p>
<!--
```rust
pub fn parametrage() {
    // code de paramÃ©trage spÃ©cifique Ã  vos tests de votre bibliothÃ¨que ici
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parametrage() {
    // code de paramÃ©trage spÃ©cifique Ã  vos tests de votre bibliothÃ¨que ici
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parametrage() {
    // code de paramÃ©trage spÃ©cifique Ã  vos tests de votre bibliothÃ¨que ici
}
<span class="boring">}
</span></code></pre></pre>
<!--
When we run the tests again, weâ€™ll see a new section in the test output for the
*common.rs* file, even though this file doesnâ€™t contain any test functions nor
did we call the `setup` function from anywhere:
-->
<p>Lorsque nous lanÃ§ons les tests Ã  nouveau, nous allons voir une nouvelle section
dans la sortie des tests, correspondant au fichier <em>commun.rs</em>, mÃªme si ce
fichier ne contient aucune fonction de test et que nous n'avons utilisÃ© nulle
part la fonction <code>parametrage</code>Â :</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/addition-92948b65e88960b4

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Having `common` appear in the test results with `running 0 tests` displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.
-->
<p>Nous ne voulons pas que <code>commun</code> apparaisse dans les rÃ©sultats, ni que cela
affiche <code>running 0 tests</code>. Nous voulons juste partager du code avec les autres
fichiers de test d'intÃ©gration.</p>
<!--
To avoid having `common` appear in the test output, instead of creating
*tests/common.rs*, weâ€™ll create *tests/common/mod.rs*. This is an alternate
naming convention that Rust also understands. Naming the file this way tells
Rust not to treat the `common` module as an integration test file. When we move
the `setup` function code into *tests/common/mod.rs* and delete the
*tests/common.rs* file, the section in the test output will no longer appear.
Files in subdirectories of the *tests* directory donâ€™t get compiled as separate
crates or have sections in the test output.
-->
<p>Pour Ã©viter que <code>commun</code> s'affiche sur la sortie de test, au lieu de crÃ©er le
fichier <em>tests/commun.rs</em>, nous allons crÃ©er <em>tests/commun/mod.rs</em>. Cela est
une convention de nommage alternative que Rust comprends aussi. Nommer le
fichier ainsi indique Ã  Rust de ne pas traiter le module <code>commun</code> comme un
fichier de test d'intÃ©gration. Lorsque nous dÃ©plaÃ§ons le code de la fonction
<code>parametrage</code> dans <em>tests/commun/mod.rs</em> et que nous supprimons le fichier
<em>tests/commun.rs</em>, la section dans la sortie des tests ne va plus s'afficher.
Les fichiers dans les sous-rÃ©pertoires du dossier <em>tests</em> ne seront pas
compilÃ©s comme Ã©tant une crate sÃ©parÃ©e et n'auront pas de sections dans la
sortie des tests.</p>
<!--
After weâ€™ve created *tests/common/mod.rs*, we can use it from any of the
integration test files as a module. Hereâ€™s an example of calling the `setup`
function from the `it_adds_two` test in *tests/integration_test.rs*:
-->
<p>AprÃ¨s avoir crÃ©Ã© <em>tests/commun/mod.rs</em>, nous pouvons l'utiliser Ã  partir de
n'importe quel fichier de test d'intÃ©gration comme un module. Voici un
exemple d'appel Ã  la fonction <code>parametrage</code> Ã  partir du test
<code>cela_ajoute_deux</code> dans <em>tests/test_integration.rs</em>Â :</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">FichierÂ : tests/integration_test.rs</span></p>
<!--
```rust,ignore
use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
Note that the `mod common;` declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then in the test function, we can call the
`common::setup()` function.
-->
<p>Remarquez que la dÃ©claration <code>mod commun;</code> est la mÃªme que la dÃ©claration d'un
module que nous avons dÃ©montrÃ© dans l'encart 7-21. Ensuite, dans la fonction
de tests, nous pouvons appeler la fonction <code>commun::parametrage</code>.</p>
<!--
#### Integration Tests for Binary Crates
-->
<h4><a class="header" href="#tests-dintÃ©gration-pour-les-crates-binaires" id="tests-dintÃ©gration-pour-les-crates-binaires">Tests d'intÃ©gration pour les crates binaires</a></h4>
<!--
If our project is a binary crate that only contains a *src/main.rs* file and
doesnâ€™t have a *src/lib.rs* file, we canâ€™t create integration tests in the
*tests* directory and bring functions defined in the *src/main.rs* file into
scope with a `use` statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.
-->
<p>Si notre projet est une crate binaire qui contient uniquement un fichier
<em>src/main.rs</em> et n'a pas de fichier <em>src/lib.rs</em>, nous ne pouvons pas crÃ©er
de tests d'intÃ©gration dans le dossier <em>tests</em> et importer les fonctions
dÃ©finies dans le fichier <em>src/main.rs</em> dans notre portÃ©e avec une instruction
<code>use</code>. Seules les crates de bibliothÃ¨que exposent des fonctions que les autres
crates peuvent utiliserÂ ; les crates binaires sont conÃ§ues pour Ãªtre exÃ©cutÃ©es
de maniÃ¨re isolÃ©e.</p>
<!--
This is one of the reasons Rust projects that provide a binary have a
straightforward *src/main.rs* file that calls logic that lives in the
*src/lib.rs* file. Using that structure, integration tests *can* test the
library crate with `use` to make the important functionality available.
If the important functionality works, the small amount of code in the
*src/main.rs* file will work as well, and that small amount of code doesnâ€™t
need to be tested.
-->
<p>C'est une des raisons pour lesquelles les projets Rust qui fournissent un
binaire ont un simple fichier <em>src/main.rs</em> qui fait appel Ã  la logique
prÃ©sente dans le fichier <em>src/lib.rs</em>. En utilisant cette structure, les tests
d'intÃ©gration <em>peuvent</em> tester la crate de bibliothÃ¨que avec le <code>use</code> pour
importer les importantes fonctionnalitÃ©s disponibles. Si les fonctionnalitÃ©s
importantes fonctionnent, la petite portion de code dans le fichier
<em>src/main.rs</em> va fonctionner, et cette petite partie de code n'a pas besoin
d'Ãªtre testÃ©e.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-10" id="rÃ©sumÃ©-10">RÃ©sumÃ©</a></h2>
<!--
Rustâ€™s testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the libraryâ€™s public API to test the code
in the same way external code will use it. Even though Rustâ€™s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.
-->
<p>Les fonctionnalitÃ©s de test de Rust permettent de spÃ©cifier comment le code
doit fonctionner pour garantir qu'il va continuer Ã  fonctionner comme vous le
souhaitez, mÃªme si vous faites des changements. Les tests unitaires permettent
de tester sÃ©parÃ©ment diffÃ©rentes parties d'une bibliothÃ¨que et peuvent tester
l'implÃ©mentation des Ã©lÃ©ments privÃ©s. Les tests d'intÃ©gration vÃ©rifient que de
nombreuses parties de la bibliothÃ¨que fonctionnent correctement ensemble, et
ils utilisent l'API publique de la bibliothÃ¨que pour tester le code, de la mÃªme
maniÃ¨re  que le ferait du code externe qui l'utiliserait. MÃªme si le systÃ¨me de
type de Rust et les rÃ¨gles de possession aident Ã  prÃ©venir certains types de
bogues, les tests restent toujours importants pour rÃ©duire les bogues de
logique concernant le comportement attendu de votre code.</p>
<!--
Letâ€™s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!
-->
<p>Et maintenant, combinons le savoir que vous avez accumulÃ© dans ce chapitre et
dans les chapitres prÃ©cÃ©dents en travaillant sur un nouveau projetÂ !</p>
<!--
[separating-modules-into-files]:
ch07-05-separating-modules-into-different-files.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--12" id="-attention-peinture-fraÃ®che--12">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/130">Pull Request</a>.</p>
</blockquote>
<!--
# An I/O Project: Building a Command Line Program
-->
<h1><a class="header" href="#un-projet-dentrÃ©esortie--construire-un-programme-en-ligne-de-commande" id="un-projet-dentrÃ©esortie--construire-un-programme-en-ligne-de-commande">Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></h1>
<!--
This chapter is a recap of the many skills youâ€™ve learned so far and an
exploration of a few more standard library features. Weâ€™ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.
-->
<p>Ce chapitre est un rÃ©sumÃ© de toutes les nombreuses compÃ©tences que vous avez
appris prÃ©cÃ©demment et une dÃ©couverte de quelques fonctionnalitÃ©s
supplÃ©mentaires de la bibliothÃ¨que standard. Nous allons construire un outil en
ligne de commande qui interagit avec des fichiers et les entrÃ©es/sorties de la
ligne de commande pour mettre en pratique certains concepts Rust que vous avez
maintenant en votre connaissance.</p>
<!--
Rustâ€™s speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, weâ€™ll
make our own version of the classic command line tool `grep` (**g**lobally
search a **r**egular **e**xpression and **p**rint). In the simplest use case,
`grep` searches a specified file for a specified string. To do so, `grep` takes
as its arguments a filename and a string. Then it reads the file, finds lines
in that file that contain the string argument, and prints those lines.
-->
<p>Les fonctionnalitÃ©s de rapiditÃ©, sÃ©curitÃ©, de sortie binaire unique, et du
support multi-plateforme de Rust en font le langage idÃ©al pour crÃ©er des outils
en ligne de commande, donc pour notre projet, nous allons construire notre
version de l'outil en ligne de commande <code>grep</code> (qui signifie <strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint, soit <em>recherche globale et
affichage d'une expression rÃ©guliÃ¨re</em>). Dans des cas d'usage trÃ¨s simple,
<code>grep</code> recherche une chaÃ®ne de caractÃ¨re prÃ©cise dans un fichier prÃ©cis. Pour
faire ainsi, <code>grep</code> prend en argument un nom de fichier et une chaÃ®ne de
caractÃ¨res. Ensuite, il lit le fichier, trouve les lignes de ce fichier qui
contient la chaÃ®ne de caractÃ¨res envoyÃ© en argument, et affiche ces lignes.</p>
<!--
Along the way, weâ€™ll show how to make our command line tool use features of the
terminal that many command line tools use. Weâ€™ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
Weâ€™ll also print error messages to the standard error console stream (`stderr`)
instead of standard output (`stdout`), so, for example, the user can redirect
successful output to a file while still seeing error messages onscreen.
-->
<p>Sur la route, nous allons vous montrer comment utiliser dans votre outil en
ligne de commande les fonctionnalitÃ©s des terminaux que de nombreux outils en
ligne de commande utilisent. Nous allons lire la valeur d'une variable
d'environnement pour permettre Ã  l'utilisation de configurer le comportement de
notre outil. Nous allons aussi afficher des messages d'erreur vers le flux
d'erreur standard de la console (<code>stderr</code>) plutÃ´t que la sortie standard
(<code>stdout</code>), pour, par exemple, que l'utilisateur puisse rediriger la sortie
fructueuse vers un fichier, tout en affichant les messages d'erreur Ã  l'Ã©cran.</p>
<!--
One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of `grep`, called `ripgrep`. By comparison, our
version of `grep` will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project such as
`ripgrep`.
-->
<p>Un membre de la communautÃ© Rust, Andrew Gallant, a dÃ©jÃ  crÃ©Ã© une version
complÃ¨te et trÃ¨s performante de <code>grep</code>, qu'il a appelÃ© <code>ripgrep</code>. En
comparaison, notre version de <code>grep</code> sera plutÃ´t simple, mais ce chapitre va
vous donner les connaissances de base dont vous avez besoin pour apprÃ©hender
un projet rÃ©el comme <code>ripgrep</code>.</p>
<!--
Our `grep` project will combine a number of concepts youâ€™ve learned so far:
-->
<p>Notre projet <code>grep</code> va combiner un certain nombre de concepts que vous avez
acquis jusqu'Ã  prÃ©sentÂ :</p>
<!--
* Organizing code (using what you learned about modules in [Chapter 7][ch7]<!--
  ignore -- >)
* Using vectors and strings (collections, [Chapter 8][ch8]<!-- ignore -- >)
* Handling errors ([Chapter 9][ch9]<!-- ignore -- >)
* Using traits and lifetimes where appropriate ([Chapter 10][ch10]<!-- ignore
  -- >)
* Writing tests ([Chapter 11][ch11]<!-- ignore -- >)
-->
<ul>
<li>Organiser le code (en utilisant ce que vous avez appris sur les modules au
<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">chapitre 7</a><!-- ignore -->)</li>
<li>Utiliser les vecteurs et les chaÃ®nes de caractÃ¨res (les collections du
<a href="ch08-00-common-collections.html">chapitre 8</a><!-- ignore -->)</li>
<li>GÃ©rer les erreurs (<a href="ch09-00-error-handling.html">chapitre 9</a><!-- ignore -->)</li>
<li>Utiliser les traits et les durÃ©es de vie lorsque c'est appropriÃ© (
<a href="ch10-00-generics.html">chapitre 10</a><!-- ignore -->)</li>
<li>Ecrire les tests (<a href="ch11-00-testing.html">chapitre 11</a><!-- ignore -->)</li>
</ul>
<!--
Weâ€™ll also briefly introduce closures, iterators, and trait objects, which
Chapters [13][ch13]<!-- ignore -- > and [17][ch17]<!-- ignore -- > will cover in
detail.
-->
<p>Nous vous prÃ©senterons aussi briÃ¨vement les fermetures, les itÃ©rateurs, et les
objets de trait, que les chapitres <a href="ch13-00-functional-features.html">13</a><!-- ignore --> et
<a href="ch17-00-oop.html">17</a><!-- ignore --> vont traiter en dÃ©tails.</p>
<!--
[ch7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[ch8]: ch08-00-common-collections.html
[ch9]: ch09-00-error-handling.html
[ch10]: ch10-00-generics.html
[ch11]: ch11-00-testing.html
[ch13]: ch13-00-functional-features.html
[ch17]: ch17-00-oop.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--13" id="-attention-peinture-fraÃ®che--13">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/133">Pull Request</a>.</p>
</blockquote>
<!--
## Accepting Command Line Arguments
-->
<h2><a class="header" href="#rÃ©cupÃ©rer-les-arguments-de-la-ligne-de-commande" id="rÃ©cupÃ©rer-les-arguments-de-la-ligne-de-commande">RÃ©cupÃ©rer les arguments de la ligne de commande</a></h2>
<!--
Letâ€™s create a new project with, as always, `cargo new`. Weâ€™ll call our project
`minigrep` to distinguish it from the `grep` tool that you might already have
on your system.
-->
<p>CrÃ©ons un nouveau projet comme Ã  l'accoutumÃ©e avec <code>cargo new</code>. Appelons
notre projet <code>minigrep</code> pour le distinguer de l'outil <code>grep</code> que vous avez
probablement dÃ©jÃ  sur votre systÃ¨me.</p>
<!--
```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```
-->
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<!--
The first task is to make `minigrep` accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with `cargo run`, a string to search for, and a path to a file to
search in, like so:
-->
<p>La premiÃ¨re tÃ¢che est de faire en sorte que <code>minigrep</code> utilise ses deux
arguments en ligne de commandeÂ : le nom du fichier et la chaÃ®ne de caractÃ¨res Ã 
rechercher. Autrement dit, nous voulons pouvoir exÃ©cuter notre programme avec
<code>cargo run</code>, une chaÃ®ne de caractÃ¨res Ã  rechercher, et un chemin vers un
fichier dans lequel chercher, comme ceciÂ :</p>
<!--
```console
$ cargo run searchstring example-filename.txt
```
-->
<pre><code class="language-console">$ cargo run chaine_a_chercher fichier-exemple.txt
</code></pre>
<!--
Right now, the program generated by `cargo new` cannot process arguments we
give it. Some existing libraries on [crates.io](https://crates.io/) can help
with writing a program that accepts command line arguments, but because youâ€™re
just learning this concept, letâ€™s implement this capability ourselves.
-->
<p>Pour l'instant, le programme gÃ©nÃ©rÃ© par <code>cargo new</code> ne peut pas traiter les
arguments que nous lui donnons. Certaines bibliothÃ¨ques existent sur
<a href="https://crates.io/">crates.io</a> qui peuvent vous aider Ã  Ã©crire un programme
qui prend des arguments en ligne de commande, mais comme vous apprenez
juste ce concept, implÃ©mentons cette capacitÃ© par nous-mÃªmes.</p>
<!--
### Reading the Argument Values
-->
<h3><a class="header" href="#lire-les-valeurs-des-arguments" id="lire-les-valeurs-des-arguments">Lire les valeurs des arguments</a></h3>
<!--
To enable `minigrep` to read the values of command line arguments we pass to
it, weâ€™ll need a function provided in Rustâ€™s standard library, which is
`std::env::args`. This function returns an iterator of the command line
arguments that were given to `minigrep`. Weâ€™ll cover iterators fully in
[Chapter 13][ch13]<!-- ignore -- >. For now, you only need to know two details
about iterators: iterators produce a series of values, and we can call the
`collect` method on an iterator to turn it into a collection, such as a vector,
containing all the elements the iterator produces.
-->
<p>Pour permettre Ã  <code>minigrep</code> de lire les valeurs des arguments de la ligne de
commande que nous lui envoyons, nous allons avoir besoin d'une fonction fournie
par la bibliothÃ¨que standard de Rust, qui est <code>std::env::args</code>. Cette fonction
retourne un itÃ©rateur des arguments de la ligne de commande qui ont Ã©tÃ© donnÃ©s
Ã  <code>minigrep</code>. Nous verrons les itÃ©rateurs plus prÃ©cisÃ©ment au
<a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->. Pour l'instant, vous avez juste Ã  savoir
deux choses Ã  propos des itÃ©rateursÂ : les itÃ©rateurs engendrent une sÃ©rie de
valeurs, et nous pouvons appeler la mÃ©thode <code>collect</code> sur un itÃ©rateur pour le
transformer en collection, comme les vecteurs, qui contiennent tous les
Ã©lÃ©ments qu'un itÃ©rateur engendrent.</p>
<!--
Use the code in Listing 12-1 to allow your `minigrep` program to read any
command line arguments passed to it and then collect the values into a vector.
-->
<p>Utilisez le code de l'encart 12-1 pour permettre Ã  votre programme <code>minigrep</code>
de lire tous les arguments qui lui sont envoyÃ©s et ensuite collecter les
valeurs dans un vecteur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span>
-->
<p><span class="caption">Encart 12-1Â : Collecter les arguments de la ligne de
commande dans un vecteur et les afficher</span></p>
<!--
First, we bring the `std::env` module into scope with a `use` statement so we
can use its `args` function. Notice that the `std::env::args` function is
nested in two levels of modules. As we discussed in [Chapter
7][ch7-idiomatic-use]<!-- ignore -- >, in cases where the desired function is
nested in more than one module, itâ€™s conventional to bring the parent module
into scope rather than the function. By doing so, we can easily use other
functions from `std::env`. Itâ€™s also less ambiguous than adding `use
std::env::args` and then calling the function with just `args`, because `args`
might easily be mistaken for a function thatâ€™s defined in the current module.
-->
<p>D'abord, nous importons le module <code>std::env</code> dans la portÃ©e avec une
instruction <code>use</code> afin que nous puissions utiliser sa fonction <code>args</code>. Notez
que la fonction <code>std::env::args</code> est imbriquÃ©e sur deux niveaux de modules.
Comme nous l'avons vu dans le <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html">chapitre 7</a><!-- ignore -->,
il est courant d'importer le module parent dans la portÃ©e plutÃ´t que la
fonction. En faisant ainsi, nous pouvons facilement utiliser les autres
fonctions de <code>std::env</code>. C'est aussi moins ambigÃ¼ que d'importer uniquement
<code>std::env::args</code> et ensuite d'appeler la fonction avec seulement <code>args</code>, car
<code>args</code> peu facilement Ãªtre confondu avec une fonction qui est dÃ©finie dans le
module courant.</p>
<!--
> ### The `args` Function and Invalid Unicode
>
> Note that `std::env::args` will panic if any argument contains invalid
> Unicode. If your program needs to accept arguments containing invalid
> Unicode, use `std::env::args_os` instead. That function returns an iterator
> that produces `OsString` values instead of `String` values. Weâ€™ve chosen to
> use `std::env::args` here for simplicity, because `OsString` values differ
> per platform and are more complex to work with than `String` values.
-->
<blockquote>
<h3><a class="header" href="#la-fonction-args-et-lunicode-invalide" id="la-fonction-args-et-lunicode-invalide">La fonction <code>args</code> et l'unicode invalide</a></h3>
<p>Notez que <code>std::env::args</code> va paniquer si un des arguments contient de
l'unicode invalide. Si votre programme a besoin d'utiliser des arguments qui
contiennent de l'unicode invalide, utilisez plutÃ´t <code>std::env::args_os</code> Ã  la
place. Cette fonction retourne un itÃ©rateur qui engendre des valeurs <code>OsString</code>
plutÃ´t que des valeurs <code>String</code>. Nous avons choisi d'utiliser ici
<code>std::env::args</code> par simplicitÃ©, car les valeurs <code>OsString</code> diffÃ¨rent selon
la plateforme et c'est plus complexe de travailler avec par rapport aux
valeurs de type <code>String</code>.</p>
</blockquote>
<!--
On the first line of `main`, we call `env::args`, and we immediately use
`collect` to turn the iterator into a vector containing all the values produced
by the iterator. We can use the `collect` function to create many kinds of
collections, so we explicitly annotate the type of `args` to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, `collect` is one function you do often need to annotate because Rust
isnâ€™t able to infer the kind of collection you want.
-->
<p>Dans la premiÃ¨re ligne du <code>main</code>, nous appelons <code>env::args</code>, et nous utilisons
immÃ©diatement <code>collect</code> pour retourner un itÃ©rateur dans un vecteur qui
contient toutes les valeurs engendrÃ©es par l'itÃ©rateur. Nous pouvons utiliser
la fonction <code>collect</code> pour crÃ©er n'importe quel genre de collection, donc nous
avons annotÃ© explicitement le type de <code>args</code> pour prÃ©ciser que nous attendions
d'un vecteur de chaÃ®nes de caractÃ¨res. Bien que nous n'ayons que trÃ¨s
rarement d'annoter les types en Rust, <code>collect</code> est une fonction que vous
aurez souvent besoin d'annoter car Rust n'est pas capable de dÃ©duire le type
de collection vous attendiez.</p>
<!--
Finally, we print the vector using the debug formatter, `:?`. Letâ€™s try running
the code first with no arguments and then with two arguments:
-->
<p>Enfin, nous affichons le vecteur en utilisant la chaÃ®ne de formatage <code>:?</code>.
Essayons d'abord de lancer le code sans arguments, puis ensuite avec deux
argumentsÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
["target/debug/minigrep"]
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[&quot;target/debug/minigrep&quot;]
</code></pre>
<!--
```console
$ cargo run aiguille botte_de_foin
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep aiguille botte_de_foin`
["target/debug/minigrep", "aiguille", "botte_de_foin"]
```
-->
<pre><code class="language-console">$ cargo run aiguille botte_de_foin
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep aiguille botte_de_foin`
[&quot;target/debug/minigrep&quot;, &quot;aiguille&quot;, &quot;botte_de_foin&quot;]
</code></pre>
<!--
Notice that the first value in the vector is `"target/debug/minigrep"`, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
Itâ€™s often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, weâ€™ll ignore it and save only the two arguments we need.
-->
<p>Remarquez que la premiÃ¨re valeur dans le vecteur est
<code>&quot;target/debug/minigrep&quot;</code>, qui est le nom de notre binaire. Cela correspond
au fonctionnement de la liste d'arguments en C, qui laissent les programmes
utiliser le nom sous lequel ils ont Ã©tÃ© invoquÃ©s dans leur exÃ©cution. C'est
parfois pratique pour avoir accÃ¨s au nom du programme dans le cas oÃ¹ vous
souhaitez l'afficher dans des messages, ou changer le comportement du programme
en fonction de ce que l'alias de la ligne de commande utilisÃ© pour invoquer le
programme. Mais pour les besoins de ce chapitre, nous allons l'ignorer et
rÃ©cupÃ©rer uniquement les deux arguments dont nous avons besoin.</p>
<!--
### Saving the Argument Values in Variables
-->
<h3><a class="header" href="#enregistrer-les-valeurs-des-arguments-dans-des-variables" id="enregistrer-les-valeurs-des-arguments-dans-des-variables">Enregistrer les valeurs des arguments dans des variables</a></h3>
<!--
Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2.
-->
<p>L'affichage des valeurs du vecteur des arguments nous a dÃ©montrÃ© que le
programme peut avoir accÃ¨s aux valeurs envoyÃ©es en arguments d'une ligne de
commande. Maintenant, nous avons besoin d'enregistrer les valeurs des deux
arguments dans des variables afin que nous puissions utiliser les valeurs pour
le reste du programme. C'est que nous faisons dans l'encart 12-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let recherche = &args[1];
    let nom_fichier = &args[2];

    println!("On rechercheÂ : {}", recherche);
    println!("Dans le fichierÂ : {}", nom_fichier);
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    println!(&quot;On rechercheÂ : {}&quot;, recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, nom_fichier);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span>
-->
<p><span class="caption">Encart 12-2Â : CrÃ©ation de variables pour rÃ©cupÃ©rer la
les arguments recherche et nom_fichier</span></p>
<!--
As we saw when we printed the vector, the programâ€™s name takes up the first
value in the vector at `args[0]`, so weâ€™re starting at index `1`. The first
argument `minigrep` takes is the string weâ€™re searching for, so we put a
reference to the first argument in the variable `query`. The second argument
will be the filename, so we put a reference to the second argument in the
variable `filename`.
-->
<p>Comme nous l'avons vu lorsque nous avons affichÃ© le vecteur, le nom du
programme prend la premiÃ¨re valeur dans le vecteur, dans <code>args[0]</code>, donc nous
allons commencer Ã  l'indice <code>1</code>. Le premier argument que prend <code>minigrep</code> est
la chaÃ®ne de caractÃ¨res de nous recherchons, donc nous insÃ©rons la rÃ©fÃ©rence
vers le premier argument dans la variable <code>recherche</code>. Le second argument sera
le nom du fichier, donc nous insÃ©rons une rÃ©fÃ©rence vers le second argument
dans la variable <code>nom_fichier</code>.</p>
<!--
We temporarily print the values of these variables to prove that the code is
working as we intend. Letâ€™s run this program again with the arguments `test`
and `sample.txt`:
-->
<p>Nous affichons temporairement les valeurs de ces variables pour prouver que le
code fonctionne bien comme nous le souhaitons. LanÃ§ons Ã  nouveau ce programme
avec les arguments <code>test</code> et <code>example.txt</code>Â :</p>
<!--
```console
$ cargo run test exemple.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test exemple.txt`
On rechercheÂ : test
Dans le fichierÂ : exemple.txt
```
-->
<pre><code class="language-console">$ cargo run test exemple.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test exemple.txt`
On rechercheÂ : test
Dans le fichierÂ : exemple.txt
</code></pre>
<!--
Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later weâ€™ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, weâ€™ll ignore that situation and work on adding file-reading
capabilities instead.
-->
<p>TrÃ¨s bien, notre programme fonctionneÂ ! Les valeurs des arguments dont nous
avons besoin sont enregistrÃ©es dans les bonnes variables. Plus tard, nous
allons ajouter de la gestion d'erreurs pour pallier aux potentielles situations
d'erreurs, comme lorsque l'utilisateur ne fournit pas d'argumentsÂ ; pour le
moment, nous allons ignorer ces situations et continuer Ã  travailler pour
l'ajout d'une capacitÃ© de lecture de fichier, Ã  la place.</p>
<!--
[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--14" id="-attention-peinture-fraÃ®che--14">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/135">Pull Request</a>.</p>
</blockquote>
<!--
## Reading a File
-->
<h2><a class="header" href="#lire-un-fichier" id="lire-un-fichier">Lire un fichier</a></h2>
<!--
Now weâ€™ll add functionality to read the file that is specified in the
`filename` command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure `minigrep` is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
*poem.txt* at the root level of your project, and enter the poem â€œIâ€™m Nobody!
Who are you?â€
-->
<p>Maintenant, nous allons ajouter une fonctionnalitÃ© pour lire le fichier qui est
renseignÃ© dans l'argument <code>nom_fichier</code> de la ligne de commande. D'abord, nous
avons besoin d'un fichier d'exemple pour le testerÂ : le meilleur type de
fichier pour s'assurer que <code>minigrep</code> fonctionne est un fichier avec une petite
quantitÃ© de texte sur plusieurs lignes avec quelques mots rÃ©pÃ©tÃ©s. L'encart 12-3
prÃ©sente un poÃ¨me en Anglais de Emily Dickinson qui fonctionnera bien pour ce
testÂ ! CrÃ©ez un fichier <em>poem.txt</em> Ã  la racine de votre projet, et saisissez ce
poÃ¨me â€œIâ€™m Nobody! Who are you?â€.</p>
<!--
<span class="filename">Filename: poem.txt</span>
-->
<p><span class="filename">Filename: poem.txt</span></p>
<!--
```text
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```
-->
<pre><code class="language-text">Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
<span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test
case</span>
-->
<p><span class="caption">Encart 12-3Â : Un poÃ¨me Anglais d'Emily Dickinson qui fait
un bon sujet d'essai</span></p>
<!--
With the text in place, edit *src/main.rs* and add code to read the file, as
shown in Listing 12-4.
-->
<p>Une fois ce texte enregistrÃ©, Ã©ditez le <em>src/main.rs</em> et ajoutez-y le code pour
lire le fichier, comme indiquÃ© dans l'encart 12-4.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
use std::env;
use std::fs;

fn main() {
    // -- partie masquÃ©e ici --
#     let args: Vec<String> = env::args().collect();
# 
#     let recherche = &args[1];
#     let nom_fichier = &args[2];
# 
#     println!("On rechercheÂ : {}", recherche);
    println!("Dans le fichierÂ : {}", nom_fichier);

    let contenu = fs::read_to_string(nom_fichier)
        .expect("Quelque chose s'est mal passÃ© lors de la lecture du fichier");

    println!("Dans le texteÂ :\n{}", contenu);
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;
use std::fs;

fn main() {
    // -- partie masquÃ©e ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let recherche = &amp;args[1];
</span><span class="boring">    let nom_fichier = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, recherche);
</span>    println!(&quot;Dans le fichierÂ : {}&quot;, nom_fichier);

    let contenu = fs::read_to_string(nom_fichier)
        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texteÂ :\n{}&quot;, contenu);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span>
-->
<p><span class="caption">Encart 12-4Â : Lecture du contenu du fichier renseignÃ© en
second argument</span></p>
<!--
First, we add another `use` statement to bring in a relevant part of the
standard library: we need `std::fs` to handle files.
-->
<p>PremiÃ¨rement, nous ajoutons une autre instruction <code>use</code> pour importer une
partie significative de la bibliothÃ¨que standardÂ : nous avons besoin de
<code>std::fs</code> pour manipuler les fichiers.</p>
<!--
In `main`, weâ€™ve added a new statement: `fs::read_to_string` takes the
`filename`, opens that file, and returns a `Result<String>` of the fileâ€™s
contents.
-->
<p>Dans le <code>main</code>, nous avons ajoutÃ© une nouvelle instructionÂ :
<code>fs::read_to_string</code> qui prend le <code>nom_fichier</code>, ouvre ce fichier, et retourne
un <code>Result&lt;String&gt;</code> du contenu du fichier.</p>
<!--
After that statement, weâ€™ve again added a temporary `println!` statement that
prints the value of `contents` after the file is read, so we can check that the
program is working so far.
-->
<p>AprÃ¨s cette instruction, nous avons ajoutÃ© Ã  nouveau une instruction <code>println!</code>
qui affiche la valeur de <code>contenu</code> aprÃ¨s la lecture de ce fichier, afin que
nous puissions vÃ©rifier que ce programme fonctionne correctement.</p>
<!--
Letâ€™s run this code with any string as the first command line argument (because
we havenâ€™t implemented the searching part yet) and the *poem.txt* file as the
second argument:
-->
<p>ExÃ©cutons ce code avec n'importe quelle chaÃ®ne de caractÃ¨res dans le premier
argument de la ligne de commande (car nous n'avons pas encore implÃ©mentÃ© la
partie de recherche pour l'instant), ainsi que le fichier <em>poem.txt</em> en
second argumentÂ :</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
On rechercheÂ : the
Dans le fichierÂ : poem.txt
Dans le texteÂ :
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
On rechercheÂ : the
Dans le fichierÂ : poem.txt
Dans le texteÂ :
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Great! The code read and then printed the contents of the file. But the code
has a few flaws. The `main` function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that weâ€™re not handling errors as well
as we could. The program is still small, so these flaws arenâ€™t a big problem,
but as the program grows, it will be harder to fix them cleanly. Itâ€™s good
practice to begin refactoring early on when developing a program, because itâ€™s
much easier to refactor smaller amounts of code. Weâ€™ll do that next.
-->
<p>TrÃ¨s bienÂ ! Notre code lit et affiche ensuite le contenu du fichier. Mais le
code a quelques dÃ©fauts. La fonction <code>main</code> a plusieurs responsabilitÃ©sÂ :
gÃ©nÃ©ralement, les rÃ´les des fonctions sont plus claires et faciles Ã  entretenir
si chaque fonction est en charge d'une seule tÃ¢che. L'autre problÃ¨me est que
nous ne gÃ©rons pas les erreurs correctement. Le programme est encore trÃ¨s
modeste, donc ces imperfections ne sont pas un gros problÃ¨me, mais dÃ¨s que le
programme va grossir, il sera plus difficile de les corriger proprement. Le
remaniement du code trÃ¨s tÃ´t lors du dÃ©veloppement d'un logiciel est une bonne
pratique, car c'est beaucoup plus facile de remanier des petites portions de
code. C'est ce que nous allons faire dÃ¨s maintenant.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--15" id="-attention-peinture-fraÃ®che--15">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/137">Pull Request</a>.</p>
</blockquote>
<!--
## Refactoring to Improve Modularity and Error Handling
-->
<h2><a class="header" href="#remanier-le-code-pour-amÃ©liorer-sa-modularitÃ©-et-la-gestion-des-erreurs" id="remanier-le-code-pour-amÃ©liorer-sa-modularitÃ©-et-la-gestion-des-erreurs">Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></h2>
<!--
To improve our program, weâ€™ll fix four problems that have to do with the
programâ€™s structure and how itâ€™s handling potential errors.
-->
<p>Pour amÃ©liorer notre programme, nous allons rÃ©soudre quatre problÃ¨mes liÃ©s
Ã  la structure du programme et comment il gÃ¨re de potentielles erreurs.</p>
<!--
First, our `main` function now performs two tasks: it parses arguments and
reads files. For such a small function, this isnâ€™t a major problem. However, if
we continue to grow our program inside `main`, the number of separate tasks the
`main` function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. Itâ€™s best to separate functionality so each
function is responsible for one task.
-->
<p>PremiÃ¨rement, notre fonction <code>main</code> assure deux tÃ¢chesÂ : elle interprÃ¨te les
arguments et elle lit des fichiers. Pour une fonction aussi petite, ce n'est
pas un problÃ¨me majeur. Cependant, si nous continuons Ã  faire grossir notre
programme dans le <code>main</code>, le nombre des diffÃ©rentes tÃ¢ches qu'assure la
fonction <code>main</code> va continuer Ã  s'agrandir. Plus une fonction assure des
tÃ¢ches diffÃ©rentes, plus cela devient difficile de la comprendre, de la tester,
et d'y faire des changements sans casser ses autres constituants. Cela est
mieux de sÃ©parer les fonctionnalitÃ©s afin que chaque fonction n'assure qu'une
seule tÃ¢che.</p>
<!--
This issue also ties into the second problem: although `query` and `filename`
are configuration variables to our program, variables like `contents` are used
to perform the programâ€™s logic. The longer `main` becomes, the more variables
weâ€™ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. Itâ€™s best to group the
configuration variables into one structure to make their purpose clear.
-->
<p>Cette problÃ©matique est aussi liÃ©e au second problÃ¨meÂ : bien que <code>recherche</code> et
<code>nom_fichier</code> soient des variables de configuration de notre programme, les
variables telles que <code>contenu</code> sont utilisÃ©es pour appuyer la logique du
programme. Plus <code>main</code> est grand, plus nous aurons des variables Ã  importer
dans la portÃ©eÂ ; plus nous avons des variables dans notre portÃ©e, plus il sera
difficile de se souvenir Ã  quoi elles servent. Il est prÃ©fÃ©rable de regrouper
les variables de configuration dans une structure pour clarifier leur usage.</p>
<!--
The third problem is that weâ€™ve used `expect` to print an error message when
reading the file fails, but the error message just prints `Something went wrong
reading the file`. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, weâ€™d print the `Something went wrong reading
the file` error message, which wouldnâ€™t give the user any information!
-->
<p>Le troisiÃ¨me problÃ¨me est que nous avons utilisÃ© <code>expect</code> pour afficher un
message d'erreur lorsque la lecture du fichier Ã©choue, mais le message affiche
uniquement <code>Quelque chose s'est mal passÃ© lors de la lecture du fichier</code>. Lire
un fichier peut Ã©chouer pour de nombreuses raisonsÂ : par exemple, le fichier
peut ne pas exister, ou nous n'avons pas le droit de l'ouvrir. Pour le moment,
quelle que soit la raison, nous affichons le message d'erreur <code>Quelque chose s'est mal passÃ© lors de la lecture du fichier</code>, ce qui ne donne aucune
information Ã  l'utilisateurÂ !</p>
<!--
Fourth, we use `expect` repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, theyâ€™ll get an `index out
of bounds` error from Rust that doesnâ€™t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
weâ€™re printing messages that will be meaningful to our end users.
-->
<p>QuatriÃ¨mement, nous utilisons <code>expect</code> Ã  rÃ©pÃ©tition pour gÃ©rer les diffÃ©rentes
erreurs, et si l'utilisateur lance notre programme sans renseigner d'arguments,
il va avoir une erreur <code>index out of bounds</code> provenant de Rust, qui n'explique
pas clairement le problÃ¨me. Il serait plus judicieux que tout le code de gestion
des erreurs se trouve au mÃªme endroit afin que les futurs mainteneurs n'aient
qu'un seul endroit Ã  consulter dans le code si la logique de gestion des
erreurs doit Ãªtre modifiÃ©e. Avoir tout le code de gestion des erreurs dans un
seul endroit va aussi garantir que nous affichons des messages qui ont du sens
pour les utilisateurs.</p>
<!--
Letâ€™s address these four problems by refactoring our project.
-->
<p>Corrigeons ces quatre problÃ¨mes en remaniant notre projet.</p>
<!--
### Separation of Concerns for Binary Projects
-->
<h3><a class="header" href="#sÃ©paration-des-tÃ¢ches-des-projets-de-binaires" id="sÃ©paration-des-tÃ¢ches-des-projets-de-binaires">SÃ©paration des tÃ¢ches des projets de binaires</a></h3>
<!--
The organizational problem of allocating responsibility for multiple tasks to
the `main` function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when `main` starts getting large. The
process has the following steps:
-->
<p>Le problÃ¨me de l'organisation de la rÃ©partition des tÃ¢ches multiples dans la
fonction <code>main</code> est commun Ã  de nombreux projets binaires. En consÃ©quence, la
communautÃ© Rust a dÃ©veloppÃ© une procÃ©dure Ã  utiliser comme ligne conductrice
pour partager les tÃ¢ches d'un programme binaire lorsque <code>main</code> commence Ã 
grossir. Le processus se dÃ©compose selon les Ã©tapes suivantesÂ :</p>
<!--
* Split your program into a *main.rs* and a *lib.rs* and move your programâ€™s
  logic to *lib.rs*.
* As long as your command line parsing logic is small, it can remain in
  *main.rs*.
* When the command line parsing logic starts getting complicated, extract it
  from *main.rs* and move it to *lib.rs*.
-->
<ul>
<li>Diviser votre programme dans un <em>main.rs</em> et un <em>lib.rs</em> et dÃ©placer la
logique de votre programme dans <em>lib.rs</em>.</li>
<li>Tant que votre logique d'interprÃ©tation de la ligne de commande est peu
volumineuse, elle peut rester dans le <em>main.rs</em></li>
<li>Lorsque la logique d'interprÃ©tation de la ligne de commande commence Ã  devenir
compliquÃ©e, il faut la dÃ©placer du <em>main.rs</em> vers le <em>lib.rs</em>.</li>
</ul>
<!--
The responsibilities that remain in the `main` function after this process
should be limited to the following:
-->
<p>Les fonctionnalitÃ©s qui restent dans la fonction <code>main</code> aprÃ¨s cette procÃ©dure
seront les suivantesÂ :</p>
<!--
* Calling the command line parsing logic with the argument values
* Setting up any other configuration
* Calling a `run` function in *lib.rs*
* Handling the error if `run` returns an error
-->
<ul>
<li>Appeler la logique d'interprÃ©tation de ligne de commande avec les valeurs des
arguments</li>
<li>RÃ©gler toutes les autres configurations</li>
<li>Appeler une fonction <code>run</code> de <em>lib.rs</em></li>
<li>GÃ©rer l'erreur si <code>run</code> retourne une erreur</li>
</ul>
<!--
This pattern is about separating concerns: *main.rs* handles running the
program, and *lib.rs* handles all the logic of the task at hand. Because you
canâ€™t test the `main` function directly, this structure lets you test all of
your programâ€™s logic by moving it into functions in *lib.rs*. The only code
that remains in *main.rs* will be small enough to verify its correctness by
reading it. Letâ€™s rework our program by following this process.
-->
<p>Cette structure permet de sÃ©parer les responsabilitÃ©sÂ : <em>main.rs</em> se charge de
lancer le programme, et <em>lib.rs</em> renferme toute la logique des tÃ¢ches Ã 
accomplir. Comme vous ne pouvez pas directement tester la fonction <code>main</code>, cette
structure vous permet de tester toute la logique de votre programme en les
dÃ©plaÃ§ant dans des fonctions dans <em>lib.rs</em>. Le seul code qui restera dans le
<em>main.rs</em> sera suffisamment petit pour s'assurer qu'il soit correcte en le
lisant. LanÃ§ons-nous dans le remaniement de notre programme en suivant cette
procÃ©dure.</p>
<!--
#### Extracting the Argument Parser
-->
<h4><a class="header" href="#extraction-de-linterprÃ©teur-des-arguments" id="extraction-de-linterprÃ©teur-des-arguments">Extraction de l'interprÃ©teur des arguments</a></h4>
<!--
Weâ€™ll extract the functionality for parsing arguments into a function that
`main` will call to prepare for moving the command line parsing logic to
*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new
function `parse_config`, which weâ€™ll define in *src/main.rs* for the moment.
-->
<p>Nous allons dÃ©placer la fonctionnalitÃ© de l'interprÃ©tation des arguments dans
une fonction que <code>main</code> va appeler afin de prÃ©parer le dÃ©placement de la logique
de l'interprÃ©teur dans <em>src/lib.rs</em>. L'encart 12-5 montre le nouveau dÃ©but du
<code>main</code> qui appelle une nouvelle fonction <code>interpreter_config</code>, que nous allons
dÃ©finir dans <em>src/main.rs</em> pour le moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
# 
#     println!("Searching for {}", query);
#     println!("In file {}", filename);
# 
#     let contents = fs::read_to_string(filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (recherche, nom_fichier) = interpreter_config(&amp;args);

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

fn interpreter_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    (recherche, nom_fichier)
}
</code></pre>
<!--
<span class="caption">Listing 12-5: Extracting a `parse_config` function from
`main`</span>
-->
<p><span class="caption">Encart 12-5Â : Extraction d'une fonction
<code>interpreter_config</code> Ã  partir de <code>main</code></span></p>
<!--
Weâ€™re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable `query` and the
argument value at index 2 to the variable `filename` within the `main`
function, we pass the whole vector to the `parse_config` function. The
`parse_config` function then holds the logic that determines which argument
goes in which variable and passes the values back to `main`. We still create
the `query` and `filename` variables in `main`, but `main` no longer has the
responsibility of determining how the command line arguments and variables
correspond.
-->
<p>Nous continuons Ã  rÃ©cupÃ©rer les arguments de la ligne de commande dans un
vecteur, mais au lieu d'assigner la valeur de l'argument d'indice 1 Ã  la
variable <code>recherche</code> et la valeur de l'argument d'indice 2 Ã  la variable
<code>nom_fichier</code> dans la fonction <code>main</code>, nous passons le vecteur entier Ã  la
fonction <code>interpreter_config</code>. La fonction <code>interpreter_config</code> renferme la
logique qui dÃ©termine quel argument va dans quelle variable et renvoie les
valeurs au <code>main</code>. Nous continuons Ã  crÃ©er les variables <code>recherche</code> et
<code>nom_fichier</code> dans le <code>main</code>, mais <code>main</code> n'a plus la responsabilitÃ© de
dÃ©terminer quelles sont les variables qui correspondent aux arguments de la
ligne de commande.</p>
<!--
This rework may seem like overkill for our small program, but weâ€™re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. Itâ€™s good to check your progress
often, to help identify the cause of problems when they occur.
-->
<p>Ce remaniement peut sembler excessif pour notre petit programme, mais nous
remanions avec de maniÃ¨re incrÃ©mentale par de petites Ã©tapes. AprÃ¨s avoir fait
ces changements, lancez Ã  nouveau le programme pour vÃ©rifier que l'envoi des
arguments fonctionne toujours. C'est une bonne chose de vÃ©rifier souvent lorsque
vous avancez, pour vous aider Ã  mieux identifier les causes de problÃ¨mes
lorsqu'ils apparaissent.</p>
<!--
#### Grouping Configuration Values
-->
<h4><a class="header" href="#grouper-les-valeurs-de-configuration" id="grouper-les-valeurs-de-configuration">Grouper les valeurs de configuration</a></h4>
<!--
We can take another small step to improve the `parse_config` function further.
At the moment, weâ€™re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we donâ€™t have
the right abstraction yet.
-->
<p>Nous pouvons appliquer une nouvelle petite Ã©tape pour amÃ©liorer la fonction
<code>interpreter_config</code>. Pour le moment, nous retournons un tuple, mais ensuite
nous divisons immÃ©diatement ce tuple Ã  nouveau en plusieurs Ã©lÃ©ments. C'est un
signe que nous n'avons peut-Ãªtre la bonne approche.</p>
<!--
Another indicator that shows thereâ€™s room for improvement is the `config` part
of `parse_config`, which implies that the two values we return are related and
are both part of one configuration value. Weâ€™re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.
-->
<p>Un autre signe qui indique qu'il y a encore de la place pour de l'amÃ©lioration
est que la partie <code>config</code> de <code>interpreter_config</code>, ce qui sous-entend que les
deux valeurs que nous retournons sont liÃ©es et font partie d'une mÃªme valeur de
configuration. Actuellement, nous ne donnons pas de signification Ã  cela dans la
structure des donnÃ©es autrement qu'en regroupant les deux valeurs dans un
tupleÂ ; nous pourrions mettre les deux valeurs dans une seule structure et
donner un nom significatif Ã  chacun des champs de la structure. Faire ainsi
permet de faciliter la comprÃ©hension du code par les futurs dÃ©veloppeurs de ce
code pour comprendre le lien entre les deux et quels sont leurs rÃ´les.</p>
<!--
> Note: Using primitive values when a complex type would be more appropriate is
> an anti-pattern known as *primitive obsession*.
-->
<blockquote>
<p>RemarqueÂ : l'utilisation de valeurs primitives Ã  la place d'un type
sophistiquÃ© lorsque c'est nÃ©cessaire est un anti-patron connu sous le nom
<em>d'obsession primitive</em>.</p>
</blockquote>
<!--
Listing 12-6 shows the improvements to the `parse_config` function.
-->
<p>L'encart 12-6 montre les amÃ©liorations apportÃ©es Ã  la fonction
<code>interpreter_config</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
# 
#     println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = interpreter_config(&amp;args);

    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);

    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

struct Config {
    recherche: String,
    nom_fichier: String,
}

fn interpreter_config(args: &amp;[String]) -&gt; Config {
    let recherche = args[1].clone();
    let nom_fichier = args[2].clone();

    Config { recherche, nom_fichier }
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-6: Refactoring `parse_config` to return an
instance of a `Config` struct</span>
-->
<p><span class="caption">Encart 12-6Â : Remaniement de <code>interpreter_config</code> pour
retourner une instance de la structure <code>Config</code></span></p>
<!--
Weâ€™ve added a struct named `Config` defined to have fields named `query` and
`filename`. The signature of `parse_config` now indicates that it returns a
`Config` value. In the body of `parse_config`, where we used to return string
slices that reference `String` values in `args`, we now define `Config` to
contain owned `String` values. The `args` variable in `main` is the owner of
the argument values and is only letting the `parse_config` function borrow
them, which means weâ€™d violate Rustâ€™s borrowing rules if `Config` tried to take
ownership of the values in `args`.
-->
<p>Nous avons ajoutÃ© une structure <code>Config</code> qui a deux champs <code>recherche</code> et
<code>nom_fichier</code>. La signature de <code>interpreter_config</code> indique maintenant qu'elle
retourne une valeur <code>Config</code>. Dans le corps de <code>interpreter_config</code>, oÃ¹ nous
retournions une slice de chaÃ®nes de caractÃ¨res qui pointaient sur des valeurs
<code>String</code> prÃ©sentes dans <code>args</code>, nous dÃ©finissons maintenant la structure
<code>Config</code> pour contenir des valeurs <code>String</code> qu'elle possÃ¨de. La variable <code>args</code>
du <code>main</code> est la propriÃ©taire des valeurs des arguments et permet uniquement Ã 
la fonction <code>interpreter_config</code> de les emprunter, ce qui signifie que nous
violons les rÃ¨gles d'emprunt de Rust si <code>Config</code> essaye de prendre possession
des valeurs provenant de <code>args</code>.</p>
<!--
We could manage the `String` data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the `clone` method on
the values. This will make a full copy of the data for the `Config` instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we donâ€™t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.
-->
<p>Nous pourrions gÃ©rer les donnÃ©es <code>String</code> de plusieurs maniÃ¨res, mais la faÃ§on
la plus facile, bien que non optimisÃ©e, est d'appeler la mÃ©thode <code>clone</code> sur
les valeurs. Cela va produire une copie complÃ¨te des donnÃ©es pour que
l'instance de <code>Config</code> puisse se les approprier, ce qui va prendre plus de
temps et de mÃ©moire que de stocker une rÃ©fÃ©rence vers les donnÃ©es de la chaÃ®ne
de caractÃ¨res. Cependant le clonage des donnÃ©es rend votre code trÃ¨s simple
car nous n'avons pas Ã  gÃ©rer les durÃ©es de vie des rÃ©fÃ©rencesÂ ; dans ces
circonstances, sacrifier un peu de performances pour gagner en simplicitÃ© est
un compromis qui en vaut la peine.</p>
<!--
> ### The Trade-Offs of Using `clone`
>
> Thereâ€™s a tendency among many Rustaceans to avoid using `clone` to fix
> ownership problems because of its runtime cost. In
> [Chapter 13][ch13]<!-- ignore -- >, youâ€™ll learn how to use more efficient
> methods in this type of situation. But for now, itâ€™s okay to copy a few
> strings to continue making progress because youâ€™ll make these copies only
> once and your filename and query string are very small. Itâ€™s better to have
> a working program thatâ€™s a bit inefficient than to try to hyperoptimize code
> on your first pass. As you become more experienced with Rust, itâ€™ll be
> easier to start with the most efficient solution, but for now, itâ€™s
> perfectly acceptable to call `clone`.
-->
<blockquote>
<h3><a class="header" href="#les-contre-parties-de-lutilisation-de-clone" id="les-contre-parties-de-lutilisation-de-clone">Les contre-parties de l'utilisation de <code>clone</code></a></h3>
<p>Il y a une tendance chez les RustacÃ©s de s'interdire l'utilisation de <code>clone</code>
pour rÃ©gler les problÃ¨mes d'appartenance Ã  cause du coÃ»t Ã  l'exÃ©cution. Dans
le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->, vous allez apprendre Ã  utiliser des
mÃ©thodes plus efficaces dans ce genre de situation. Mais pour le moment, ce
n'est pas un problÃ¨me de copier quelques chaÃ®nes de caractÃ¨res pour continuer
Ã  progresser car vous allez le faire une seule fois et votre <code>nom_fichier</code> et
<code>recherche</code> sont trÃ¨s courts. Il est plus important d'avoir un programme
fonctionnel qui est n'est trÃ¨s optimisÃ© plutÃ´t que d'essayer d'optimiser Ã 
outrance le code dÃ¨s sa premiÃ¨re Ã©criture. Plus vous deviendrez expÃ©rimentÃ©
en Rust, plus il sera facile de commencer par la solution la plus
performante, mais pour le moment, il est parfaitement acceptable de faire
appel Ã  <code>clone</code>.</p>
</blockquote>
<!--
Weâ€™ve updated `main` so it places the instance of `Config` returned by
`parse_config` into a variable named `config`, and we updated the code that
previously used the separate `query` and `filename` variables so it now uses
the fields on the `Config` struct instead.
-->
<p>Nous avons actualisÃ© <code>main</code> pour qu'il utilise l'instance de <code>Config</code> retournÃ©e
par <code>interpreter_config</code> dans une variable <code>config</code>, et nous avons rafraÃ®chi le
code qui utilisait les variables sÃ©parÃ©es <code>recherche</code> et <code>nom_fichier</code> pour
qu'il utilise maintenant les champs de la structure <code>Config</code> Ã  la place.</p>
<!--
Now our code more clearly conveys that `query` and `filename` are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the `config` instance in the fields
named for their purpose.
-->
<p>Maintenant, notre code indique clairement que <code>recherche</code> et <code>nom_fichier</code> sont
reliÃ©s et que leur but est de configurer le fonctionnement du programme.
N'importe quel code qui utilise ces valeurs sait comment les retrouver dans les
champs de l'instance <code>config</code> grÃ¢ce Ã  leurs noms donnÃ©s Ã  cet effet.</p>
<!--
#### Creating a Constructor for `Config`
-->
<h4><a class="header" href="#crÃ©er-un-constructeur-pour-config" id="crÃ©er-un-constructeur-pour-config">CrÃ©er un constructeur pour <code>Config</code></a></h4>
<!--
So far, weâ€™ve extracted the logic responsible for parsing the command line
arguments from `main` and placed it in the `parse_config` function. Doing so
helped us to see that the `query` and `filename` values were related and that
relationship should be conveyed in our code. We then added a `Config` struct to
name the related purpose of `query` and `filename` and to be able to return the
valuesâ€™ names as struct field names from the `parse_config` function.
-->
<p>Pour l'instant, nous avons extrait la logique en charge d'interprÃ©ter les
arguments de la ligne de commande Ã  partir du <code>main</code> et nous l'avons placÃ© dans
la fonction <code>interpreter_config</code>. Cela nous a aidÃ© Ã  dÃ©couvrir que les valeurs
<code>recherche</code> et <code>nom_fichier</code> Ã©taient liÃ©es et que ce lien devait Ãªtre
retranscrit dans notre code. Nous avons ensuite crÃ©Ã© une structure <code>Config</code>
afin de donner un nom au rÃ´le apparentÃ© Ã  <code>recherche</code> et Ã  <code>nom_fichier</code>, et
pour pouvoir retourner les noms des valeurs sous la forme de noms de champs Ã 
partir de la fonction <code>interpreter_config</code>.</p>
<!--
So now that the purpose of the `parse_config` function is to create a `Config`
instance, we can change `parse_config` from a plain function to a function
named `new` that is associated with the `Config` struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as `String`, by calling `String::new`. Similarly, by
changing `parse_config` into a `new` function associated with `Config`, weâ€™ll
be able to create instances of `Config` by calling `Config::new`. Listing 12-7
shows the changes we need to make.
-->
<p>Maintenant que le but de la fonction <code>interpreter_config</code> est de crÃ©er une
instance de <code>Config</code>, nous pouvons transformer <code>interpreter_config</code> d'une
simple fonction Ã  une fonction <code>new</code> qui est associÃ©e Ã  la structure <code>Config</code>.
Ce changement rendra le code plus familier. Habituellement, nous crÃ©ons des
instances de types de la bibliothÃ¨que standard, comme <code>String</code>, en appelant
<code>String::new</code>. Si on change le <code>interpreter_config</code> en une fonction <code>new</code>
associÃ©e Ã  <code>Config</code>, nous pourrons crÃ©er de la mÃªme faÃ§on des instances de
<code>Config</code> en appelant <code>Config::new</code>. L'encart 12-7 nous montre les changements
que nous devons faire pour cela.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,should_panic
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);

    // --snip--
}

// --snip--

# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>
    // -- partie masquÃ©e ici --
}

// -- partie masquÃ©e ici --

<span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Config { recherche, nom_fichier }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-7: Changing `parse_config` into
`Config::new`</span>
-->
<p><span class="caption">Encart 12-7Â : Transformer <code>interpreter_config</code> en
<code>Config::new</code></span></p>
<!--
Weâ€™ve updated `main` where we were calling `parse_config` to instead call
`Config::new`. Weâ€™ve changed the name of `parse_config` to `new` and moved it
within an `impl` block, which associates the `new` function with `Config`. Try
compiling this code again to make sure it works.
-->
<p>Nous avons actualisÃ© le <code>main</code> oÃ¹ nous appelions <code>interpreter_config</code> pour
appeler Ã  la place le <code>Config::new</code>. Nous avons changÃ© le nom de
<code>interpreter_config</code> par <code>new</code> et nous l'avons dÃ©placÃ© dans un bloc <code>impl</code>,
ce qui relie la fonction <code>new</code> Ã  <code>Config</code>. Essayez Ã  nouveau de compiler ce
code pour vous assurer qu'il fonctionne.</p>
<!--
### Fixing the Error Handling
-->
<h3><a class="header" href="#corriger-la-gestion-des-erreurs" id="corriger-la-gestion-des-erreurs">Corriger la gestion des erreurs</a></h3>
<!--
Now weâ€™ll work on fixing our error handling. Recall that attempting to access
the values in the `args` vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:
-->
<p>Maintenant, nous allons nous pencher sur la correction de la gestion des
erreurs. Rappellez-vous que la tentative d'accÃ©der aux valeurs dans le vecteur
<code>args</code> aux indices 1 ou 2 va faire paniquer le programme si le vecteur contient
moins de trois Ã©lÃ©ments. Essayez de lancer le programme sans aucun argumentÂ ;
cela donnera quelque chose comme ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
The line `index out of bounds: the len is 1 but the index is 1` is an error
message intended for programmers. It wonâ€™t help our end users understand what
happened and what they should do instead. Letâ€™s fix that now.
-->
<p>La ligne <code>index out of bounds: the len is 1 but the index is 1</code> est un
message d'erreur destinÃ© aux dÃ©veloppeurs. Il n'aidera pas nos utilisateurs
finaux Ã  comprendre ce qu'il s'est passÃ© et ce qu'ils devraient faire Ã  la
place. Corrigeons cela dÃ¨s maintenant.</p>
<!--
#### Improving the Error Message
-->
<h4><a class="header" href="#amÃ©liorer-le-message-derreur" id="amÃ©liorer-le-message-derreur">AmÃ©liorer le message d'erreur</a></h4>
<!--
In Listing 12-8, we add a check in the `new` function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isnâ€™t long
enough, the program panics and displays a better error message than the `index
out of bounds` message.
-->
<p>Dans l'encart 12-8, nous ajoutons une vÃ©rification dans la fonction <code>new</code>, qui
va vÃ©rifier que le slice est suffisamment grand avant d'accÃ©der aux indices 1
et 2. Si le slice n'est pas suffisamment grand, le programme va paniquer et
afficher un meilleur message d'erreur que le message <code>index out of bounds</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
    // --snip--
    fn new(args: &[String]) -> Config {
        if args.len() < 3 {
            panic!("not enough arguments");
        }
        // --snip--
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Config { query, filename }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // -- partie masquÃ©e ici --
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;il n'y a pas assez d'arguments&quot;);
        }
        // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { recherche, nom_fichier }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-rust ignore">// -- partie masquÃ©e ici --
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;il n'y a pas assez d'arguments&quot;);
    }
    // -- partie masquÃ©e ici --
</code></pre>
<!--
<span class="caption">Listing 12-8: Adding a check for the number of
arguments</span>
-->
<p><span class="caption">Encart 12-8Â : Ajout d'une vÃ©rification du nombre
d'arguments</span></p>
<!--
This code is similar to [the `Guess::new` function we wrote in Listing
9-10][ch9-custom-types]<!-- ignore -- >, where we called `panic!` when the
`value` argument was out of the range of valid values. Instead of checking for
a range of values here, weâ€™re checking that the length of `args` is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If `args` has fewer than three items, this condition
will be true, and we call the `panic!` macro to end the program immediately.
-->
<p>Ce code est similaire Ã  <a href="ch09-03-to-panic-or-not-to-panic.html">la fonction Supposition::new que nous avons Ã©crit
dans l'encart 9-10</a><!-- ignore -->, dans lequel nous
appelions <code>panic!</code> lorsque l'argument <code>valeur</code> Ã©tait hors de l'intervalle des
valeurs valides. PlutÃ´t que de vÃ©rifier un intervalle de valeurs dans le cas
prÃ©sent, nous vÃ©rifions que la taille de <code>args</code> est au moins de 3 et que le
reste de la fonction puisse fonctionner en s'appuyant sur l'affirmation que
cette condition a bien Ã©tÃ© remplie. Si <code>args</code> avait moins de trois Ã©lÃ©ments,
cette fonction serait vraie, et nous appellerions alors la macro <code>panic!</code>
pour mettre fin au programme immÃ©diatement.</p>
<!--
With these extra few lines of code in `new`, letâ€™s run the program without any
arguments again to see what the error looks like now:
-->
<p>Avec ces quelques lignes de code en plus dans <code>new</code>, lanÃ§ons le programme sans
aucun argument Ã  nouveau pour voir Ã  quoi ressemble dÃ©sormais l'erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'il n'y a pas assez d'arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
This output is better: we now have a reasonable error message. However, we also
have extraneous information we donâ€™t want to give to our users. Perhaps using
the technique we used in Listing 9-10 isnâ€™t the best to use here: a call to
`panic!` is more appropriate for a programming problem than a usage problem,
[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -- >. Instead, we
can use the other technique you learned about in Chapter 9â€”[returning a
`Result`][ch9-result]<!-- ignore -- > that indicates either success or an error.
-->
<p>Cette sortie est meilleureÂ : nous avons maintenant un message d'erreur
comprÃ©hensible. Cependant, nous avons aussi des informations superflues que
nous ne souhaitons pas afficher Ã  nos utilisateurs. Peut-Ãªtre que la technique
que nous avons utilisÃ© dans l'encart 9-10 n'est pas la plus appropriÃ©e dans ce
casÂ : un appel Ã  <code>panic!</code> est plus appropriÃ© pour un problÃ¨me de dÃ©veloppement
qu'un problÃ¨me d'utilisation, <a href="ch09-03-to-panic-or-not-to-panic.html">comme nous l'avons appris au chapitre
9</a><!-- ignore -->. A la place, nous pourrions utiliser
une autre technique que vous avez appris au chapitre 9 â€” <a href="ch09-02-recoverable-errors-with-result.html">retourner un
<code>Result</code></a><!-- ignore --> qui indique si c'est un succÃ¨s ou une
erreur.</p>
<!--
#### Returning a `Result` from `new` Instead of Calling `panic!`
-->
<h4><a class="header" href="#retourner-un-result-Ã -partir-de-new-plutÃ´t-que-dappeler-panic" id="retourner-un-result-Ã -partir-de-new-plutÃ´t-que-dappeler-panic">Retourner un <code>Result</code> Ã  partir de <code>new</code> plutÃ´t que d'appeler <code>panic!</code></a></h4>
<!--
We can instead return a `Result` value that will contain a `Config` instance in
the successful case and will describe the problem in the error case. When
`Config::new` is communicating to `main`, we can use the `Result` type to
signal there was a problem. Then we can change `main` to convert an `Err`
variant into a more practical error for our users without the surrounding text
about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.
-->
<p>Nous pouvons Ã  la place retourner une valeur <code>Result</code> qui contiendra une
instance de <code>Config</code> dans le cas d'un succÃ¨s et va dÃ©crire le problÃ¨me dans le
cas d'une erreur. Lorsque <code>Config::new</code> communiquera avec le <code>main</code>, nous
pourrons utiliser le type de <code>Result</code> pour signaler oÃ¹ il y a un problÃ¨me.
Ensuite, nous pourrons changer le <code>main</code> pour convertir une variante de <code>Err</code>
dans une erreur plus pratique pour nos utilisateurs sans avoir le texte Ã 
propos de <code>thread 'main'</code> et de <code>RUST_BACKTRACE</code> qui sont provoquÃ©s par l'appel
Ã  <code>panic!</code>.</p>
<!--
Listing 12-9 shows the changes we need to make to the return value of
`Config::new` and the body of the function needed to return a `Result`. Note
that this wonâ€™t compile until we update `main` as well, which weâ€™ll do in the
next listing.
-->
<p>L'encart 12-9 nous montre les changements que nous devons faire pour Ã  la
valeur de retour de <code>Config::new</code> et le corps de la fonction qui doit retourner
un <code>Result</code>. Notez que cela ne va pas se compiler tant que nous ne corrigeons
pas aussi le <code>main</code>, ce que nous allons faire dans le prochain encart.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Ok(Config { recherche, nom_fichier })
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-9: Returning a `Result` from
`Config::new`</span>
-->
<p><span class="caption">Encart 12-9Â : Retourner un <code>Result</code> Ã  partir de
<code>Config::new</code></span></p>
<!--
Our `new` function now returns a `Result` with a `Config` instance in the
success case and a `&'static str` in the error case. Recall from [â€œThe Static
Lifetimeâ€][the-static-lifetime]<!-- ignore -- > section in Chapter 10 that
`&'static str` is the type of string literals, which is our error message type
for now.
-->
<p>Notre fonction <code>new</code> retourne dÃ©sormais un <code>Result</code> contenant une instance de
<code>Config</code> dans le cas d'un succÃ¨s et une <code>&amp;'static str</code> dans le cas d'une
erreur. Pour rappel, nous avons vu dans une section du
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> que <code>&amp;'static str</code> est le
type des chaÃ®nes de caractÃ¨res littÃ©rales, ce qui est dÃ©sormais le type de
notre message d'erreur.</p>
<!--
Weâ€™ve made two changes in the body of the `new` function: instead of calling
`panic!` when the user doesnâ€™t pass enough arguments, we now return an `Err`
value, and weâ€™ve wrapped the `Config` return value in an `Ok`. These changes
make the function conform to its new type signature.
-->
<p>Nous avons fait deux changements dans le corps de notre fonction <code>new</code>Â :
plutÃ´t que d'avoir Ã  appeler <code>panic!</code> lorsque l'utilisateur n'envoie pas assez
d'arguments, nous retournons maintenant une valeur <code>Err</code>, et nous avons intÃ©grÃ©
la valeur de retour <code>Config</code> dans un <code>Ok</code>. Ces modifications font en sorte que
la fonction soit dÃ©sormais conformes Ã  son nouveau type de signature.</p>
<!--
Returning an `Err` value from `Config::new` allows the `main` function to
handle the `Result` value returned from the `new` function and exit the process
more cleanly in the error case.
-->
<p>Retourner une valeur <code>Err</code> Ã  partir de <code>Config::new</code> permet Ã  la fonction
<code>main</code> de gÃ©rer la valeur <code>Result</code> retournÃ©e par la fonction <code>new</code> et de
terminer plus proprement le processus dans cas d'une erreur.</p>
<!--
#### Calling `Config::new` and Handling Errors
-->
<h4><a class="header" href="#appeler-confignew-et-gÃ©rer-les-erreurs" id="appeler-confignew-et-gÃ©rer-les-erreurs">Appeler <code>Config::new</code> et gÃ©rer les erreurs</a></h4>
<!--
To handle the error case and print a user-friendly message, we need to update
`main` to handle the `Result` being returned by `Config::new`, as shown in
Listing 12-10. Weâ€™ll also take the responsibility of exiting the command line
tool with a nonzero error code from `panic!` and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.
-->
<p>Pour gÃ©rer les cas d'erreurs et afficher un message correct pour
l'utilisateur, nous devons mettre Ã  jour <code>main</code> pour gÃ©rer le <code>Result</code>
retournÃ© par <code>Config::new</code>, comme dans l'encart 12-10. Nous allons aussi
prendre la dÃ©cision de quitter l'outil en ligne de commande avec un code
d'erreur diffÃ©rent de zÃ©ro avec <code>panic!</code> et nous allons l'implÃ©menter
manuellement. Un statut de sortie diffÃ©rent de zÃ©ro est une convention pour
signaler au processus qui a appelÃ© notre programme que le programme s'est
terminÃ© dans un Ã©tat d'erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-10: Exiting with an error code if creating a
new `Config` fails</span>
-->
<p><span class="caption">Encart 12-10Â : Quitter avec un code d'erreur si la
crÃ©ation d'une nouvelle <code>Config</code> Ã©choue.
</span></p>
<!--
In this listing, weâ€™ve used a method we havenâ€™t covered before:
`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.
Using `unwrap_or_else` allows us to define some custom, non-`panic!` error
handling. If the `Result` is an `Ok` value, this methodâ€™s behavior is similar
to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value
is an `Err` value, this method calls the code in the *closure*, which is an
anonymous function we define and pass as an argument to `unwrap_or_else`. Weâ€™ll
cover closures in more detail in [Chapter 13][ch13]<!-- ignore -- >. For now,
you just need to know that `unwrap_or_else` will pass the inner value of the
`Err`, which in this case is the static string `not enough arguments` that we
added in Listing 12-9, to our closure in the argument `err` that appears
between the vertical pipes. The code in the closure can then use the `err`
value when it runs.
-->
<p>Dans cet encart, nous avons utilisÃ© une mÃ©thode que nous n'avons pas encore
abordÃ©Â : <code>unwrap_or_else</code>, qui est dÃ©fini sur <code>Result&lt;T, E&gt;</code> par la bibliothÃ¨que
standard. L'utilisation de <code>unwrap_or_else</code> nous permet de dÃ©finir une gestion
des erreurs personnalisÃ©e, exempt de <code>panic!</code>. Si le <code>Result</code> est une valeur
<code>Ok</code>, le comportement de cette mÃ©thode est similaire Ã  <code>unwrap</code>Â : elle retourne
la valeur Ã  l'intÃ©rieur du <code>Ok</code>. Cependant, si la valeur est une valeur <code>Err</code>,
cette mÃ©thode appelle le code dans la <em>fermeture</em>, qui est une fonction anonyme
que nous dÃ©finissons et passons en argument de <code>unwrap_or_else</code>. Nous verrons
les fermetures plus en dÃ©tail dans le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->. Pour
l'instant, vous avez juste Ã  savoir que le <code>unwrap_or_else</code> va passer la valeur
interne du <code>Err</code> (qui dans ce cas est la chaÃ®ne de caractÃ¨res statique
<code>pas assez d'arguments</code> que nous avons ajoutÃ© dans l'encart 12-9) Ã  notre
fermeture dans l'argument <code>err</code> qui est prÃ©sent entre deux barres verticales. Le
code dans la fermeture peut ensuite utiliser la valeur <code>err</code> lorsqu'il est
exÃ©cutÃ©.</p>
<!--
Weâ€™ve added a new `use` line to bring `process` from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the `err` value and then call `process::exit`. The
`process::exit` function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
`panic!`-based handling we used in Listing 12-8, but we no longer get all the
extra output. Letâ€™s try it:
-->
<p>Nous avons ajoutÃ© une nouvelle ligne <code>use</code> pour importer <code>portÃ©</code> dans la portÃ©e
Ã  partir de la bibliothÃ¨que standard. Le code dans la fermeture qui sera exÃ©cutÃ©
dans le cas d'une erreur fait uniquement deux lignesÂ : nous affichons la valeur
de <code>err</code> et nous appelons ensuite <code>process::exit</code>. La fonction <code>process::exit</code>
va stopper le programme immÃ©diatement et retourner le nombre qui lui a Ã©tÃ© donnÃ©
en paramÃ¨tre comme code de statut de sortie. C'est semblable Ã  la gestion basÃ©e
sur <code>panic!</code> que nous avons utilisÃ© Ã  l'encart 12-8, mais nous n'avons plus tout
le texte en plus. Essayons celaÂ :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : il n'y a pas assez d'arguments
</code></pre>
<!--
Great! This output is much friendlier for our users.
-->
<p>TrÃ¨s bien ! Cette sortie est bien plus comprÃ©hensible pour nos utilisateurs.</p>
<!--
### Extracting Logic from `main`
-->
<h3><a class="header" href="#extraction-de-la-logique-du-main" id="extraction-de-la-logique-du-main">Extraction de la logique du <code>main</code></a></h3>
<!--
Now that weâ€™ve finished refactoring the configuration parsing, letâ€™s turn to
the programâ€™s logic. As we stated in [â€œSeparation of Concerns for Binary
Projectsâ€](#separation-of-concerns-for-binary-projects)<!-- ignore -- >, weâ€™ll
extract a function named `run` that will hold all the logic currently in the
`main` function that isnâ€™t involved with setting up configuration or handling
errors. When weâ€™re done, `main` will be concise and easy to verify by
inspection, and weâ€™ll be able to write tests for all the other logic.
-->
<p>Maintenant que nous avons fini le remaniement de l'interprÃ©tation de la
configuration, occupons-nous de logique du programme. Comme nous l'avons dit
dans <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">â€œSÃ©paration des tÃ¢ches des projets de
binairesâ€</a><!-- ignore -->, nous
allons extraire une fonction <code>run</code> qui va contenir toute la logique qui est
actuellement dans la fonction <code>main</code> qui n'est pas liÃ©e au rÃ©glage de la
configuration ou la gestion des erreurs. Lorsque nous aurons terminÃ©, <code>main</code>
sera plus concise et facile Ã  vÃ©rifier en l'inspectant, et nous pourrons Ã©crire
des tests pour toutes les autres logiques.</p>
<!--
Listing 12-11 shows the extracted `run` function. For now, weâ€™re just making
the small, incremental improvement of extracting the function. Weâ€™re still
defining the function in *src/main.rs*.
-->
<p>L'encart 12-11 montre la fonction <code>run</code> extraite. Pour le moment, nous faisons
des petites amÃ©liorations progressives pour extraire les fonctions. Nous
continuons Ã  dÃ©finir la fonction dans <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masquÃ©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);

    run(config);
}

fn run(config: Config) {
    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal passÃ© lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte :\n{}&quot;, contenu);
}

// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-11: Extracting a `run` function containing the
rest of the program logic</span>
-->
<p><span class="caption">Encart 12-11Â : Extraction d'une fonction <code>run</code> qui
contient le reste de la logique du programme</span></p>
<!--
The `run` function now contains all the remaining logic from `main`, starting
from reading the file. The `run` function takes the `Config` instance as an
argument.
-->
<p>La fonction <code>run</code> contient maintenant toute la logique qui restait dans le
<code>main</code>, en commenÃ§ant par la lecture du fichier. La fonction <code>run</code> prend
l'instance de <code>Config</code> en argument.</p>
<!--
#### Returning Errors from the `run` Function
-->
<h4><a class="header" href="#retourner-des-erreurs-avec-la-fonction-run" id="retourner-des-erreurs-avec-la-fonction-run">Retourner des erreurs avec la fonction <code>run</code></a></h4>
<!--
With the remaining program logic separated into the `run` function, we can
improve the error handling, as we did with `Config::new` in Listing 12-9.
Instead of allowing the program to panic by calling `expect`, the `run`
function will return a `Result<T, E>` when something goes wrong. This will let
us further consolidate into `main` the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of `run`.
-->
<p>Avec le restant de la logique du programme maintenant sÃ©parÃ©e dans la fonction
<code>run</code>, nous pouvons amÃ©liorer la gestion des erreurs, comme nous l'avons fait
avec <code>Config::new</code> dans l'encart 12-9. PlutÃ´t que de permettre au programme Ã 
paniquer en appelant <code>expect</code>, la fonction <code>run</code> va retourner un <code>Result&lt;T, E&gt;</code>
lorsque quelque chose se passe mal. Cela va nous permettre de consolider
davantage la logique de gestion des erreurs dans le <code>main</code> pour qu'elle soit
plus conviviale pour l'utilisateur. L'encart 12-12 montre les changements que
nous devons appliquer Ã  la signature et au corps du <code>run</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
use std::error::Error;

// --snip--

# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     run(config);
# }
# 
fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// -- partie masquÃ©e ici --

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    println!(&quot;Dans le texte :\n{}&quot;, contenu);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-12: Changing the `run` function to return
`Result`</span>
-->
<p><span class="caption">Encart 12-12Â : Changer la fonction <code>run</code> pour retourner
un <code>Result</code></span></p>
<!--
Weâ€™ve made three significant changes here. First, we changed the return type of
the `run` function to `Result<(), Box<dyn Error>>`. This function previously
returned the unit type, `()`, and we keep that as the value returned in the
`Ok` case.
-->
<p>Nous avons fait trois changements significatifs ici. PremiÃ¨rement, nous avons
changÃ© le type de retour de la fonction <code>run</code> en <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>.
Cette fonction renvoyait prÃ©cÃ©demment le type unitÃ©, <code>()</code>, que nous gardons
comme valeur de retour dans le cas de <code>Ok</code>.</p>
<!--
For the error type, we used the *trait object* `Box<dyn Error>` (and weâ€™ve
brought `std::error::Error` into scope with a `use` statement at the top).
Weâ€™ll cover trait objects in [Chapter 17][ch17]<!-- ignore -- >. For now, just
know that `Box<dyn Error>` means the function will return a type that
implements the `Error` trait, but we donâ€™t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The `dyn` keyword is short
for â€œdynamic.â€
-->
<p>En ce qui concerne le type d'erreur, nous avons utilisÃ© <em>l'objet trait</em>
<code>Box&lt;dyn Error&gt;</code> (et nous avons importÃ© <code>std::error::Error</code> dans la portÃ©e avec
une instruction <code>use</code> en haut). Nous allons voir les objets trait dans le
<a href="ch17-00-oop.html">chapitre 17</a><!-- ignore -->. Pour l'instant, retenez juste que
<code>Box&lt;dyn Error&gt;</code> signifie que la fonction va retourner un type qui implÃ©mente
le trait <code>Error</code>, mais que nous n'avons pas Ã  prÃ©ciser quel sera prÃ©cisÃ©ment le
type de la valeur de retour. Cela nous donne de la flexibilitÃ© sur les valeurs
d'erreurs de retour qui peuvent Ãªtre diffÃ©rentes dans diffÃ©rents cas d'erreurs.
Le mot-clÃ© <code>dyn</code> est un raccourci pour â€œdynamiqueâ€.</p>
<!--
Second, weâ€™ve removed the call to `expect` in favor of the `?` operator, as we
talked about in [Chapter 9][ch9-question-mark]<!-- ignore -- >. Rather than
`panic!` on an error, `?` will return the error value from the current function
for the caller to handle.
-->
<p>DeuxiÃ¨mement, nous avons enlevÃ© l'appel Ã  <code>expect</code> pour privilÃ©gier l'opÃ©rateur
<code>?</code>, que nous avons vu dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore -->.
Au lieu de faire un <code>panic!</code> sur une erreur, <code>?</code> va retourner la valeur d'erreur
de la fonction courante vers le code qui l'a appelÃ© pour qu'il la gÃ¨re.</p>
<!--
Third, the `run` function now returns an `Ok` value in the success case. Weâ€™ve
declared the `run` functionâ€™s success type as `()` in the signature, which
means we need to wrap the unit type value in the `Ok` value. This `Ok(())`
syntax might look a bit strange at first, but using `()` like this is the
idiomatic way to indicate that weâ€™re calling `run` for its side effects only;
it doesnâ€™t return a value we need.
-->
<p>TroisiÃ¨mement, la fonction <code>run</code> retourne maintenant une valeur <code>Ok</code> dans les
cas de succÃ¨s. Nous avons dÃ©clarÃ© dans la signature que le type de succÃ¨s de la
fonction <code>run</code> Ã©tait <code>()</code>, ce qui signifie que nous avons envelopper la valeur
de type unitÃ© dans la valeur <code>Ok</code>. Cette syntaxe <code>Ok(())</code> peut sembler un peu
Ã©trange au dÃ©part, mais utiliser <code>()</code> de cette maniÃ¨re est la faÃ§on idÃ©ale
d'indiquer que nous appelons <code>run</code> uniquement pour ses effets secondairesÂ ; elle
ne retourne pas de valeur que nous pourrions avoir besoin.</p>
<!--
When you run this code, it will compile but will display a warning:
-->
<p>Lorsque vous exÃ©cutez ce code, il va se compiler mais il va afficher un
avertissementÂ :</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `std::result::Result` that must be used
  -- > src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
On rechercheÂ : the
Dans le fichierÂ : poem.txt
Dans le texte :
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us - donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Rust tells us that our code ignored the `Result` value and the `Result` value
might indicate that an error occurred. But weâ€™re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Letâ€™s rectify that problem now.
-->
<p>Rust nous informe que notre code ignore la valeur <code>Result</code> et que cette valeur
<code>Result</code> pourrait indiquer qu'une erreur s'est passÃ©e. Mais nous ne vÃ©rifions
pas pour savoir si oui ou non il y a eu une erreur, et le compilateur nous
rappelle que nous devrions avoir du code de gestion des erreurs ici !
Corrigeons dÃ¨s Ã  prÃ©sent ce problÃ¨me.</p>
<!--
#### Handling Errors Returned from `run` in `main`
-->
<h4><a class="header" href="#gÃ©rer-les-erreurs-retournÃ©es-par-run-dans-main" id="gÃ©rer-les-erreurs-retournÃ©es-par-run-dans-main">GÃ©rer les erreurs retournÃ©es par <code>run</code> dans <code>main</code></a></h4>
<!--
Weâ€™ll check for errors and handle them using a technique similar to one we used
with `Config::new` in Listing 12-10, but with a slight difference:
-->
<p>Nous allons vÃ©rifier les erreurs et les gÃ©rer en utilisant une technique
similaire Ã  celle que nous avons utilisÃ© avec <code>Config::new</code> dans l'encart
12-10, mais avec une lÃ©gÃ¨re diffÃ©renceÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}
# 
# fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masquÃ©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);

    if let Err(e) = run(config) {
        println!(&quot;Erreur applicativeÂ : {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We use `if let` rather than `unwrap_or_else` to check whether `run` returns an
`Err` value and call `process::exit(1)` if it does. The `run` function doesnâ€™t
return a value that we want to `unwrap` in the same way that `Config::new`
returns the `Config` instance. Because `run` returns `()` in the success case,
we only care about detecting an error, so we donâ€™t need `unwrap_or_else` to
return the unwrapped value because it would only be `()`.
-->
<p>Nous utilisons <code>if let</code> plutÃ´t que <code>unwrap_or_else</code> pour vÃ©rifier si <code>run</code>
retourne un valeure <code>Err</code> et appeler <code>process::exit(1)</code> le cas Ã©chÃ©ant. La
fonction <code>run</code> ne retourne pas de valeur que nous avons besoin de <code>unwrap</code>
comme nous l'avions fait avec le <code>Config::new</code> qui retournait une instance de
<code>Config</code>. Comme <code>run</code> retourne <code>()</code> dans le cas d'un succÃ¨s, nous nous
prÃ©occupons uniquement de dÃ©tecter les erreurs, donc n'avons pas besoin de
<code>unwrap_or_else</code> pour retourner la valeur extraite car elle sera toujours
<code>()</code>.</p>
<!--
The bodies of the `if let` and the `unwrap_or_else` functions are the same in
both cases: we print the error and exit.
-->
<p>Les corps du <code>if let</code> et de la fonction <code>unwrap_or_else</code> sont identiques dans
les deux casÂ : nous affichons l'erreur et nous quittons.</p>
<!--
### Splitting Code into a Library Crate
-->
<h3><a class="header" href="#dÃ©placer-le-code-dans-une-crate-de-bibliothÃ¨que" id="dÃ©placer-le-code-dans-une-crate-de-bibliothÃ¨que">DÃ©placer le code dans une crate de bibliothÃ¨que</a></h3>
<!--
Our `minigrep` project is looking good so far! Now weâ€™ll split the
*src/main.rs* file and put some code into the *src/lib.rs* file so we can test
it and have a *src/main.rs* file with fewer responsibilities.
-->
<p>Notre projet <code>minigrep</code> se prÃ©sente plutÃ´t bien pour le momentÂ ! Maintenant,
nous allons diviser notre fichier <em>src/main.rs</em> et dÃ©placer du code dans le
fichier <em>src/lib.rs</em> pour que nous puissions le tester et avoir fichier
<em>src/main.rs</em> qui hÃ©berge moins de fonctionnalitÃ©s.</p>
<!--
Letâ€™s move all the code that isnâ€™t the `main` function from *src/main.rs* to
*src/lib.rs*:
-->
<p>DÃ©plaÃ§ons tout le code qui ne fait pas partie de la fonction <code>main</code> dans le
<em>src/main.rs</em> vers le <em>src/lib.rs</em>Â :</p>
<!--
* The `run` function definition
* The relevant `use` statements
* The definition of `Config`
* The `Config::new` function definition
-->
<ul>
<li>La dÃ©finition de la fonction <code>run</code></li>
<li>Les instructions <code>use</code> correspondantes</li>
<li>La dÃ©finition de <code>Config</code></li>
<li>La dÃ©finition de la fonction <code>Config::new</code></li>
</ul>
<!--
The contents of *src/lib.rs* should have the signatures shown in Listing 12-13
(weâ€™ve omitted the bodies of the functions for brevity). Note that this wonâ€™t
compile until we modify *src/main.rs* in Listing 12-14.
-->
<p>Le contenu du <em>src/lib.rs</em> devrait contenir les signatures de l'encart 12-13
(nous avons enlevÃ© les corps des fonctions pour des raisons de briÃ¨vetÃ©). Notez
que cela ne va pas se compiler jusqu'Ã  ce que nous modifions le <em>src/main.rs</em>
dans l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        // --snip--
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // -- partie masquÃ©e ici --
<span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 12-13: Moving `Config` and `run` into
*src/lib.rs*</span>
-->
<p><span class="caption">Encart 12-13Â : DÃ©placement de <code>Config</code> et de <code>run</code> dans
<em>src/lib.rs</em></span></p>
<!--
Weâ€™ve made liberal use of the `pub` keyword: on `Config`, on its fields and its
`new` method, and on the `run` function. We now have a library crate that has a
public API that we can test!
-->
<p>Nous avons fait un usage gÃ©nÃ©reux du mot-clÃ© <code>pub</code>Â : sur <code>Config</code>, sur ses
champs et sur la mÃ©thode <code>new</code>, et sur la fonction <code>run</code>. Nous avons maintenant
une crate de bibliothÃ¨que qui a une API publique que nous pouvons testerÂ !</p>
<!--
Now we need to bring the code we moved to *src/lib.rs* into the scope of the
binary crate in *src/main.rs*, as shown in Listing 12-14.
-->
<p>Maintenant nous devons importer le code que nous avons dÃ©placÃ© dans
<em>src/lib.rs</em> dans la portÃ©e de la crate binaire dans <em>src/main.rs</em>, comme dans
l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
    if let Err(e) = minigrep::run(config) {
        // --snip--
#         println!("Application error: {}", e);
# 
#         process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // -- partie masquÃ©e ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On rechercheÂ : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichierÂ : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // -- partie masquÃ©e ici --
<span class="boring">        println!(&quot;Erreur applicativeÂ : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 12-14: Using the `minigrep` library crate in
*src/main.rs*</span>
-->
<p><span class="caption">Encart 12-14Â : Utilisation de la crate de bibliothÃ¨que
<code>minigrep</code> dans <em>src/main.rs</em></span></p>
<!--
We add a `use minigrep::Config` line to bring the `Config` type from the
library crate into the binary crateâ€™s scope, and we prefix the `run` function
with our crate name. Now all the functionality should be connected and should
work. Run the program with `cargo run` and make sure everything works
correctly.
-->
<p>Nous avons ajoutÃ© une ligne <code>use minigrep::Config</code> pour importer le type
<code>Config</code> de la crate de bibliothÃ¨que dans la portÃ©e de la crate binaire, et
nous avons avons prÃ©fixÃ© la fonction <code>run</code> avec le nom de notre crate.
Maintenant, toutes les fonctionnalitÃ©s devraient Ãªtre connectÃ©es et devraient
fonctionner. Lancez le programme avec <code>cargo run</code> pour vous assurer que tout
fonctionne correctement.</p>
<!--
Whew! That was a lot of work, but weâ€™ve set ourselves up for success in the
future. Now itâ€™s much easier to handle errors, and weâ€™ve made the code more
modular. Almost all of our work will be done in *src/lib.rs* from here on out.
-->
<p>OuahÂ ! C'Ã©tait pas mal de travail, mais nous sommes organisÃ©s pour nous assurer
le succÃ¨s Ã  venir. Maintenant il est bien plus facile de gÃ©rer les erreurs, et
nous avons rendu le code plus modulaire. A partir de maintenant, l'essentiel de
notre travail sera effectuÃ© dans <em>src/lib.rs</em>.</p>
<!--
Letâ€™s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: weâ€™ll
write some tests!
-->
<p>Profitons de cette nouvelle modularitÃ© en accomplissant quelque chose qui
aurait Ã©tÃ© difficile Ã  faire avec l'ancien code, mais qui est facile avec ce
nouveau codeÂ : nous allons Ã©crire des testsÂ !</p>
<!--
[the-static-lifetime]: ch10-03-lifetime-syntax.html#the-static-lifetime
[ch13]: ch13-00-functional-features.html
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[ch9-result]: ch09-02-recoverable-errors-with-result.html
[ch17]: ch17-00-oop.html
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--16" id="-attention-peinture-fraÃ®che--16">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/139">Pull Request</a>.</p>
</blockquote>
<!--
## Developing the Libraryâ€™s Functionality with Test-Driven Development
-->
<h2><a class="header" href="#dÃ©velopper-les-fonctionnalitÃ©s-de-la-bibliothÃ¨que-avec-le-tdd" id="dÃ©velopper-les-fonctionnalitÃ©s-de-la-bibliothÃ¨que-avec-le-tdd">DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></h2>
<!--
Now that weâ€™ve extracted the logic into *src/lib.rs* and left the argument
collecting and error handling in *src/main.rs*, itâ€™s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the `Config::new` and `run` functions on your own.
-->
<p>Maintenant que nous avons extrait la logique dans <em>src/lib.rs</em> et que nous
avons laissÃ© la rÃ©cupÃ©ration des arguments et la gestion des erreurs dans
<em>src/main.rs</em>, il est bien plus facile d'Ã©crire les tests pour les
fonctionnalitÃ©s de base de notre code. Nous pouvons appeler les fonctions
directement avec diffÃ©rents arguments et vÃ©rifier les valeurs de retour sans
avoir Ã  appeler notre binaire dans la ligne de commande. N'hÃ©sitez pas Ã  Ã©crire
quelques tests par vous-mÃªme pour les fonctions <code>Config::new</code> et <code>run</code>.</p>
<!--
In this section, weâ€™ll add the searching logic to the `minigrep` program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:
-->
<p>Dans cette section, nous allons ajouter la logique de recherche au programme
<code>minigrep</code> en utilisant le processus de dÃ©veloppement orientÃ© par les tests
(c'est le TDDÂ : <em>Test-Driven Development</em>). Cette technique de dÃ©veloppement
de logiciels suit ces trois Ã©tapesÂ :</p>
<!--
1. Write a test that fails and run it to make sure it fails for the reason you
   expect.
2. Write or modify just enough code to make the new test pass.
3. Refactor the code you just added or changed and make sure the tests
   continue to pass.
4. Repeat from step 1!
-->
<ol>
<li>Ecrire un test qui Ã©choue et lancez-le pour vous assurer qu'il va Ã©chouer
pour la raison que vous attendiez.</li>
<li>Ecrire ou modifier juste assez de code pour faire rÃ©ussir ce nouveau test.</li>
<li>Remanier le code que vous venez d'ajouter ou de changer pour vous assurer
que les tests continuent Ã  rÃ©ussir.</li>
<li>Recommencer Ã  l'Ã©tape 1Â !</li>
</ol>
<!--
This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.
-->
<p>Ce processus n'est qu'une des diffÃ©rentes maniÃ¨res d'Ã©crire des programmes,
mais le TDD peut aussi aider Ã  piloter sa conception. Ecrire les tests avant
d'Ã©crire le code qui fait rÃ©ussir les tests aide Ã  maintenir une haute
couverture de tests tout le long du processus.</p>
<!--
Weâ€™ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. Weâ€™ll add this functionality in a function called
`search`.
-->
<p>Nous allons expÃ©rimenter cela avec l'implÃ©mentation de la fonctionnalitÃ© qui va
rechercher la chaÃ®ne de caractÃ¨res demandÃ©e dans le contenu du fichier et
gÃ©nÃ©rer une liste de lignes qui correspond Ã  cette recherche. Nous ajouterons
cette fonctionnalitÃ© dans une fonction <code>rechercher</code>.</p>
<!--
### Writing a Failing Test
-->
<h3><a class="header" href="#ecrire-un-test-qui-Ã©choue" id="ecrire-un-test-qui-Ã©choue">Ecrire un test qui Ã©choue</a></h3>
<!--
Because we donâ€™t need them anymore, letâ€™s remove the `println!` statements from
*src/lib.rs* and *src/main.rs* that we used to check the programâ€™s behavior.
Then, in *src/lib.rs*, weâ€™ll add a `tests` module with a test function, as we
did in [Chapter 11][ch11-anatomy]<!-- ignore -- >. The test function specifies
the behavior we want the `search` function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which wonâ€™t compile
yet.
-->
<p>Comme nous n'en avons plus besoin, enlevons les instructions <code>println!</code> de
<em>src/lib.rs</em> et <em>src/main.rs</em> que nous avions utilisÃ© pour vÃ©rifier le bon
comportement du programme. Ensuite, dans <em>src/lib.rs</em>, nous allons ajouter un
module <code>tests</code> avec une fonction de test, comme nous l'avions fait dans le
<a href="ch11-01-writing-tests.html">chapitre 11</a><!-- ignore -->. La fonction de test dÃ©finit le
comportement que nous voulons qu'ait la fonction <code>rechercher</code>Â : elle va prendre
en arguments une recherche et le texte dans lequel rechercher, et elle va
retourner seulement les lignes du texte qui correspondent Ã  la recherche.
L'encart 12-15 montre ce test, qui ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_resultat() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
Obtenez les trois en mÃªme temps.&quot;;

        assert_eq!(
            vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;],
            rechercher(recherche, contenu)
        );
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 12-15: Creating a failing test for the `search`
function we wish we had</span>
-->
<p><span class="caption">Encart 12-15Â : CrÃ©ation d'un test qui Ã©choue pour la
fonction <code>rechercher</code> que nous souhaitons concevoir</span></p>
<!--
This test searches for the string `"duct"`. The text weâ€™re searching is three
lines, only one of which contains `"duct"`. We assert that the value returned
from the `search` function contains only the line we expect.
-->
<p>Ce test recherche la chaÃ®ne de caractÃ¨res <code>&quot;duct&quot;</code>. Le texte dans lequel nous
recherchons fait trois lignes, et seulement une d'entre elles contient <code>&quot;duct&quot;</code>.
Nous vÃ©rifions que la valeur retournÃ©e par la fonction <code>rechercher</code> contient
seulement la ligne que nous avions prÃ©vu.</p>
<!--
We arenâ€™t able to run this test and watch it fail because the test doesnâ€™t even
compile: the `search` function doesnâ€™t exist yet! So now weâ€™ll add just enough
code to get the test to compile and run by adding a definition of the `search`
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesnâ€™t match a vector
containing the line `"safe, fast, productive."`
-->
<p>Nous ne pouvons pas encore exÃ©cuter ce test et vÃ©rifier s'il Ã©choue car mÃªme le
test ne peut pas se compilerÂ : la fonction <code>rechercher</code> n'existe pas encoreÂ !
Donc pour le moment nous allons ajouter juste assez de code pour quel le test
puisse compiler et s'exÃ©cuter en ajoutant une dÃ©finition de la fonction
<code>rechercher</code> qui retourne un vecteur vide, comme dans l'encart 12-16. Ensuite
le test va compiler et Ã©chouer car un vecteur vide ne correspond pas au vecteur
qui contient la ligne <code>&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;</code></p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-16: Defining just enough of the `search`
function so our test will compile</span>
-->
<p><span class="caption">Encart 12-16Â : DÃ©finition du strict minimum de la fonction
<code>rechercher</code> pour que notre test puisse compiler</span></p>
<!--
Notice that we need an explicit lifetime `'a` defined in the signature of
`search` and used with the `contents` argument and the return value. Recall in
[Chapter 10][ch10-lifetimes]<!-- ignore -- > that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument `contents` (rather than the
argument `query`).
-->
<p>Remarquez que nous avons besoin de prÃ©ciser explicitement une durÃ©e de vie <code>'a</code>
dÃ©finie dans la signature de <code>rechercher</code> et l'utiliser sur l'argument <code>contenu</code>
et la valeur de retour. Rappelez-vous que dans le
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> nous avions vu que les paramÃ¨tres
de durÃ©e de vie renseignent Ã  quelle durÃ©e de vie des arguments sont connectÃ©es
les durÃ©es de vie des valeurs de retour. Dans notre cas, nous indiquons que le
vecteur retournÃ© devrait contenir des slices de chaÃ®nes de caractÃ¨res qui sont
des slices de l'argument <code>contenu</code> (et non pas de l'argument <code>recherche</code>).</p>
<!--
In other words, we tell Rust that the data returned by the `search` function
will live as long as the data passed into the `search` function in the
`contents` argument. This is important! The data referenced *by* a slice needs
to be valid for the reference to be valid; if the compiler assumes weâ€™re making
string slices of `query` rather than `contents`, it will do its safety checking
incorrectly.
-->
<p>Autrement dit, nous disons Ã  Rust que les donnÃ©es retournÃ©es par la fonction
<code>rechercher</code> vont vivre aussi longtemps que la donnÃ©e dans l'argument <code>contenu</code>
de la fonction <code>rechercher</code>. C'est trÃ¨s importantÂ ! Les donnÃ©es sur lesquelles
pointent les slices doivent Ãªtre en vigueur pour que la rÃ©fÃ©rence reste valideÂ ;
si le compilateur croit que nous crÃ©ons des slices de <code>recherche</code> plutÃ´t que de
<code>contenu</code>, ses vÃ©rifications de sÃ©curitÃ© seront incorrectes.</p>
<!--
If we forget the lifetime annotations and try to compile this function, weâ€™ll
get this error:
-->
<p>Si nous oublions les annotations de durÃ©e de vie et que nous essayons de
compiler cette fonction, nous allons obtenir cette erreurÂ :</p>
<!--
```console
$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  -- > src/lib.rs:28:51
   |
28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
   |                                                   ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn rechercher(recherche: &amp;str, contenu: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                                                          ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `recherche` or `contenu`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rust canâ€™t possibly know which of the two arguments we need, so we need to tell
it. Because `contents` is the argument that contains all of our text and we
want to return the parts of that text that match, we know `contents` is the
argument that should be connected to the return value using the lifetime syntax.
-->
<p>Rust ne peut pas deviner lequel des deux arguments nous allons utiliser, donc
nous devons lui dire. Comme <code>contenu</code> est l'argument qui contient tout notre
texte et que nous voulons retourner des extraits de ce texte qui correspondent Ã 
la recherche, nous savons que <code>contenu</code> est l'argument qui doit Ãªtre connectÃ© Ã 
la valeur de retour, en utilisant la syntaxe de durÃ©e de vie.</p>
<!--
Other programming languages donâ€™t require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the [â€œValidating
References with Lifetimesâ€][validating-references-with-lifetimes]<!-- ignore
-- > section in Chapter 10.
-->
<p>Les autres langages de programmation n'ont pas besoin que vous connectiez les
arguments aux valeurs de retour dans la signature. Bien que cela puisse paraÃ®tre
Ã©trange, cela devient plus facile au fil du temps. Vous devriez peut-Ãªtre
comparer cet exemple Ã  la
<a href="ch10-03-lifetime-syntax.html">section 3 du chapitre 10</a><!-- ignore -->.</p>
<!--
Now letâ€™s run the test:
-->
<p>Maintenant, exÃ©cutons le testÂ :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::un_resultat ... FAILED

failures:

---- tests::un_resultat stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::un_resultat

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Great, the test fails, exactly as we expected. Letâ€™s get the test to pass!
-->
<p>TrÃ¨s bien, le test a Ã©chouÃ©, comme nous nous y attendions. Faisons maintenant en
sorte qu'il rÃ©ussisseÂ !</p>
<!--
### Writing Code to Pass the Test
-->
<h3><a class="header" href="#ecrire-du-code-pour-rÃ©ussir-au-test" id="ecrire-du-code-pour-rÃ©ussir-au-test">Ecrire du code pour rÃ©ussir au test</a></h3>
<!--
Currently, our test is failing because we always return an empty vector. To fix
that and implement `search`, our program needs to follow these steps:
-->
<p>Pour le moment, notre test Ã©choue car nous retournons toujours un vecteur vide.
Pour corriger cela et implÃ©menter <code>rechercher</code>, notre programme doit suivre les
Ã©tapes suivantesÂ :</p>
<!--
* Iterate through each line of the contents.
* Check whether the line contains our query string.
* If it does, add it to the list of values weâ€™re returning.
* If it doesnâ€™t, do nothing.
* Return the list of results that match.
-->
<ul>
<li>ItÃ©rer sur chacune des lignes de <code>contenu</code>.</li>
<li>VÃ©rifier si la ligne contient la chaÃ®ne de caractÃ¨res recherchÃ©e.</li>
<li>Si c'est le cas, l'ajouter Ã  la liste des valeurs que nous retournerons.</li>
<li>Si ce n'est pas le cas, ne rien faire.</li>
<li>Retourner la liste des rÃ©sultats qui ont Ã©tÃ© trouvÃ©s.</li>
</ul>
<!--
Letâ€™s work through each step, starting with iterating through lines.
-->
<p>Travaillons sur chacune de ces Ã©tapes, en commenÃ§ant par l'itÃ©ration sur les
lignes.</p>
<!--
#### Iterating Through Lines with the `lines` Method
-->
<h4><a class="header" href="#itÃ©rer-sur-chacune-des-lignes-avec-la-mÃ©thode-lines" id="itÃ©rer-sur-chacune-des-lignes-avec-la-mÃ©thode-lines">ItÃ©rer sur chacune des lignes avec la mÃ©thode <code>lines</code></a></h4>
<!--
Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named `lines`, that works as shown in Listing 12-17. Note this
wonâ€™t compile yet.
-->
<p>Rust a une mÃ©thode trÃ¨s pratique pour gÃ©rer l'itÃ©ration ligne-par-ligne des
chaÃ®nes de caractÃ¨res, judicieusement appelÃ©e <code>lines</code>, qui fonctionne comme dans
l'encart 12-17. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        // faire quelquechose avec ligne ici
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-17: Iterating through each line in `contents`
</span>
-->
<p><span class="caption">Encart 12-17Â : ItÃ©ration sur chacune des lignes de
<code>contenu</code> </span></p>
<!-- markdownlint-disable -->
<!--
The `lines` method returns an iterator. Weâ€™ll talk about iterators in depth in
[Chapter 13][ch13-iterators]<!-- ignore -- >, but recall that you saw this way of using an
iterator in [Listing 3-5][ch3-iter]<!-- ignore -- >, where we used a `for` loop
with an iterator to run some code on each item in a collection.
-->
<!-- markdownlint-restore -->
<p>La mÃ©thode <code>lines</code> retourne un itÃ©rateur. Nous verrons plus tard les itÃ©rateurs
dans le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, mais souvenez-vous que
vous avez vu cette faÃ§on d'utiliser un itÃ©rateur dans
<a href="ch03-05-control-flow.html">l'encart 3-5</a><!-- ignore -->, dans lequel nous avions utilisÃ© une
boucle <code>for</code> sur un itÃ©rateur pour exÃ©cuter du code sur chaque Ã©lÃ©ment d'une
collection.</p>
<!--
#### Searching Each Line for the Query
-->
<h4><a class="header" href="#trouver-chaque-ligne-correspondante-Ã -la-recherche" id="trouver-chaque-ligne-correspondante-Ã -la-recherche">Trouver chaque ligne correspondante Ã  la recherche</a></h4>
<!--
Next, weâ€™ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note this still wonâ€™t compile yet.
-->
<p>Ensuite, nous allons vÃ©rifier que la ligne courante contient la chaÃ®ne de
caractÃ¨res que nous recherchons. Heureusement, les chaÃ®nes de caractÃ¨res ont une
mÃ©thode <code>contains</code> assez pratique qui fait cela pour nousÂ ! Ajoutez l'appel Ã 
la mÃ©thode <code>contains</code> dans la fonction <code>rechercher</code>, comme dans l'encart 12-18.
Notez qu'ici non plus nous ne pouvons pas encore compiler.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            // faire quelquechose avec la ligne ici
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in `query`</span>
-->
<p><span class="caption">Encart 12-18Â : Ajout d'une fonctionnalitÃ© pour trouver
quelle ligne contient la chaÃ®ne de caractÃ¨res <code>recherche</code></span></p>
<!--
#### Storing Matching Lines
-->
<h4><a class="header" href="#stocker-les-lignes-trouvÃ©es" id="stocker-les-lignes-trouvÃ©es">Stocker les lignes trouvÃ©es</a></h4>
<!--
We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the `for` loop and call the `push` method
to store a `line` in the vector. After the `for` loop, we return the vector, as
shown in Listing 12-19.
-->
<p>Nous avons aussi besoin d'un moyen de stocker les lignes qui contienent la
chaÃ®ne de caractÃ¨res que nous recherchons. Pour cela, nous pouvons crÃ©er un
vecteur mutable avant la boucle <code>for</code> et appeler la mÃ©thode <code>push</code> pour
enregistrer la <code>ligne</code> dans le vecteur. AprÃ¨s la boucle <code>for</code>, nous retournons
le vecteur, comme dans l'encart 12-19Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-rust ignore">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
</code></pre>
<!--
<span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span>
-->
<p><span class="caption">Encart 12-19Â : Enregistrement des lignes qui sont
trouvÃ©es afin que nous puissions les retourner</span></p>
<!--
Now the `search` function should return only the lines that contain `query`,
and our test should pass. Letâ€™s run the test:
-->
<p>Maintenant, notre fonction <code>rechercher</code> retourne uniquement les lignes qui
contiennent <code>recherche</code>, et notre test devrait rÃ©ussir. ExÃ©cutons le testÂ :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::un_resultat ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Our test passed, so we know it works!
-->
<p>Notre test a rÃ©ussi, donc nous savons que cela fonctionneÂ !</p>
<!--
At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isnâ€™t too bad,
but it doesnâ€™t take advantage of some useful features of iterators. Weâ€™ll
return to this example in [Chapter 13][ch13-iterators]<!-- ignore -- >, where weâ€™ll
explore iterators in detail, and look at how to improve it.
-->
<p>ArrivÃ© Ã  ce stade, nous pourrions envisager des pistes de remaniement pour
l'implÃ©mentation de la fonction de recherche tout en faisant en sorte que les
tests rÃ©ussissent toujours afin de conserver les mÃªmes fonctionnalitÃ©s. Le code
de la fonction de recherche n'est pas mauvais, mais il ne profite pas de
quelques fonctionnalitÃ©s utiles des itÃ©rateurs. Nous retrouverons cet exemple dans
le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, dans lequel nous explorerons
les itÃ©rateurs en dÃ©tail, et ainsi dÃ©couvrir comment nous pourrions l'amÃ©liorer.</p>
<!--
#### Using the `search` Function in the `run` Function
-->
<h4><a class="header" href="#utiliser-la-fonction-rechercher-dans-la-fonction-run" id="utiliser-la-fonction-rechercher-dans-la-fonction-run">Utiliser la fonction <code>rechercher</code> dans la fonction <code>run</code></a></h4>
<!--
Now that the `search` function is working and tested, we need to call `search`
from our `run` function. We need to pass the `config.query` value and the
`contents` that `run` reads from the file to the `search` function. Then `run`
will print each line returned from `search`:
-->
<p>Maintenant que la fonction <code>rechercher</code> fonctionne et est testÃ©, nous devons
appeler <code>rechercher</code> dans notre fonction <code>run</code>. Nous devons passer Ã 
<code>rechercher</code> la valeur de <code>config.recherche</code>  et le <code>contenu</code> que <code>run</code> obtient
en lisant le fichier. Ensuite, <code>run</code> devra afficher chaque ligne retournÃ©e par
<code>rechercher</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}
# 
# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
#     let mut results = Vec::new();
# 
#     for line in contents.lines() {
#         if line.contains(query) {
#             results.push(line);
#         }
#     }
# 
#     results
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Weâ€™re still using a `for` loop to return each line from `search` and print it.
-->
<p>Nous utilisons ici aussi une boucle <code>for</code> pour rÃ©cupÃ©rer chaque ligne provenant
de <code>rechercher</code> et l'afficher.</p>
<!--
Now the entire program should work! Letâ€™s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, â€œfrogâ€:
-->
<p>Maintenant, l'intÃ©gralitÃ© du programme devrait fonctionnerÂ ! Essayons-le, pour
commencer avec un mot qui devrait retourner exactement une seule ligne du poÃ¨me
d'Emily Dickinson, â€œfrogâ€Â :</p>
<!--
```console
$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```
-->
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!--
Cool! Now letâ€™s try a word that will match multiple lines, like â€œbodyâ€:
-->
<p>SuperÂ ! Maintenant, essayons un mot qui devrait retourner plusieurs lignes,
comme â€œbodyâ€Â :</p>
<!--
```console
$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
Iâ€™m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
Iâ€™m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
And finally, letâ€™s make sure that we donâ€™t get any lines when we search for a
word that isnâ€™t anywhere in the poem, such as â€œmonomorphizationâ€:
-->
<p>Et enfin, assurons-nous que nous n'obtenons aucune ligne lorsque nous cherchons
un mot qui n'est nulle part dans le poÃ¨me, comme â€œmonomorphizationâ€Â :</p>
<!--
```console
$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```
-->
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!--
Excellent! Weâ€™ve built our own mini version of a classic tool and learned a lot
about how to structure applications. Weâ€™ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.
-->
<p>TrÃ¨s bienÂ ! Nous avons construit notre propre mini-version d'un outil classique
et nous avons beaucoup appris Ã  structurer nos applications. Nous avons aussi
appris un peu sur les entrÃ©es et sorties des fichiers, les durÃ©es de vie, les
tests, et l'interprÃ©tation de la ligne de commande.</p>
<!--
To round out this project, weâ€™ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when youâ€™re writing command line programs.
-->
<p>Pour clÃ´turer ce projet, nous allons briÃ¨vement voir comment travailler avec les
variables d'environnement et comment Ã©crire sur la sortie standard des erreurs,
qui sont tous les deux utiles lorsque nous Ã©crivez des programmes en ligne de
commande.</p>
<!--
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--17" id="-attention-peinture-fraÃ®che--17">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/141">Pull Request</a>.</p>
</blockquote>
<!--
## Working with Environment Variables
-->
<h2><a class="header" href="#travailler-avec-des-variables-denvironnement" id="travailler-avec-des-variables-denvironnement">Travailler avec des variables d'environnement</a></h2>
<!--
Weâ€™ll improve `minigrep` by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead weâ€™ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.
-->
<p>Nous allons amÃ©liorer <code>minigrep</code> en lui ajoutant une fonctionnalitÃ©
supplÃ©mentaire : une option pour rechercher sans Ãªtre sensible Ã  la casse que
l'utilisateur pourra activer via une variable d'environnement. Nous pourrions
appliquer cette fonctionnalitÃ© avec une option en ligne de commande et demander
Ã  l'utilisateur de la renseigner Ã  chaque fois qu'il veut l'activer, mais Ã  la
place nous allons utiliser une variable d'environnement. Ceci permet Ã  nos
utilisateurs de rÃ©gler la variable d'environnement une seule fois et d'avoir
leurs recherches insensibles Ã  la casse dans cette session du terminal.</p>
<!--
### Writing a Failing Test for the Case-Insensitive `search` Function
-->
<h3><a class="header" href="#ecrire-un-test-qui-Ã©choue-pour-la-fonction-rechercher-insensible-Ã -la-casse" id="ecrire-un-test-qui-Ã©choue-pour-la-fonction-rechercher-insensible-Ã -la-casse">Ecrire un test qui Ã©choue pour la fonction <code>rechercher</code> insensible Ã  la casse</a></h3>
<!--
We want to add a new `search_case_insensitive` function that weâ€™ll call when
the environment variable is on. Weâ€™ll continue to follow the TDD process, so
the first step is again to write a failing test. Weâ€™ll add a new test for the
new `search_case_insensitive` function and rename our old test from
`one_result` to `case_sensitive` to clarify the differences between the two
tests, as shown in Listing 12-20.
-->
<p>Nous souhaitons ajouter une nouvelle fonction <code>rechercher_insensible_casse</code> que
nous allons appeler lorsque la variable d'environnement est active. Nous allons
continuer Ã  suivre le processus de TDD, donc la premiÃ¨re Ã©tape et d'Ã©crire Ã 
nouveau un test qui Ã©choue. Nous allons ajouter un nouveau test pour la nouvelle
fonction <code>rechercher_insensible_casse</code> et renommer notre ancien test
<code>one_result</code> en <code>sensible_casse</code> pour clarifier les diffÃ©rences entre les deux
tests, comme dans l'encart 12-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     for ligne in rechercher(&config.recherche, &contenu) {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sensible_casse() {
        let recherche = "duct";
        let contenu = "\
Rust:
sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
Obtenez les trois en mÃªme temps.
Duck tape.";

        assert_eq!(vec!["sÃ©curitÃ©, rapiditÃ©, productivitÃ©."], rechercher(recherche, contenu));
    }

    #[test]
    fn insensible_casse() {
        let recherche = "rUsT";
        let contenu = "\
Rust:
sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
Obtenez les trois en mÃªme temps.
C'est pas rustique.";

        assert_eq!(
            vec!["Rust:", "C'est pas rustique."],
            rechercher_insensible_casse(recherche, contenu)
        );
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sensible_casse() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
Obtenez les trois en mÃªme temps.
Duck tape.&quot;;

        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
    }

    #[test]
    fn insensible_casse() {
        let recherche = &quot;rUsT&quot;;
        let contenu = &quot;\
Rust:
sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
Obtenez les trois en mÃªme temps.
C'est pas rustique.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;C'est pas rustique.&quot;],
            rechercher_insensible_casse(recherche, contenu)
        );
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function weâ€™re about to add</span>
-->
<p><span class="caption">Encart 12-20 : Ajout d'un nouveau test qui Ã©choue pour la
fonction insensible Ã  la casse que nous sommes en train d'ajouter</span></p>
<!--
Note that weâ€™ve edited the old testâ€™s `contents` too. Weâ€™ve added a new line
with the text `"Duct tape."` using a capital D that shouldnâ€™t match the query
`"duct"` when weâ€™re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we donâ€™t accidentally break the case-sensitive
search functionality that weâ€™ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.
-->
<p>Remarquez aussi que nous avons aussi modifiÃ© le <code>contenu</code> des anciens tests.
Nous avons ajoutÃ© une nouvelle ligne avec le texte <code>&quot;Duct tape.&quot;</code> en utilisant
un D majuscule qui ne devrait pas correspondre Ã  la recherche <code>&quot;duct&quot;</code> lorsque
nous recherchons de maniÃ¨re Ã  Ãªtre sensible Ã  la casse. Ce changement de
l'ancien test permet de nous assurer que nous ne casserons pas accidentellement
la fonction de recherche sensible Ã  la casse que nous avons dÃ©jÃ  implÃ©mentÃ©. Ce
test devrait toujours continuer Ã  rÃ©ussir au fur et Ã  mesure que nous progressons
sur la recherche insensible Ã  la casse.</p>
<!--
The new test for the case-*insensitive* search uses `"rUsT"` as its query. In
the `search_case_insensitive` function weâ€™re about to add, the query `"rUsT"`
should match the line containing `"Rust:"` with a capital R and match the line
`"Trust me."` even though both have different casing from the query. This is
our failing test, and it will fail to compile because we havenâ€™t yet defined
the `search_case_insensitive` function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the `search` function in Listing 12-16 to see the test compile and fail.
-->
<p>Le nouveau test pour la recherche insensible Ã  la casse utilise <code>&quot;rUsT&quot;</code> comme
recherche. Dans la fonction <code>rechercher_insensible_casse</code> que nous sommes en
train d'ajouter, la recherche <code>&quot;rUsT&quot;</code> devrait correspondre Ã  la ligne qui
contient <code>&quot;Rust:&quot;</code> avec un R majuscule ainsi que la ligne <code>C'est pas rustique.</code>
mÃªme si ces deux cas ont des casses diffÃ©rentes de la recherche. C'est notre
test qui doit Ã©chouer, et il ne devrait pas se compiler car nous n'avons pas
encore dÃ©fini la fonction <code>rechercher_insensible_casse</code>. Ajoutez son
implÃ©mentation qui retourne toujours un vecteur vide, de la mÃªme maniÃ¨re que
nous l'avions fait pour la fonction <code>rechercher</code> dans l'encart 12-16 pour voir
si les tests se compilent et Ã©chouent.</p>
<!--
### Implementing the `search_case_insensitive` Function
-->
<h3><a class="header" href="#implÃ©menter-la-fonction-rechercher_insensible_casse" id="implÃ©menter-la-fonction-rechercher_insensible_casse">ImplÃ©menter la fonction <code>rechercher_insensible_casse</code></a></h3>
<!--
The `search_case_insensitive` function, shown in Listing 12-21, will be almost
the same as the `search` function. The only difference is that weâ€™ll lowercase
the `query` and each `line` so whatever the case of the input arguments,
theyâ€™ll be the same case when we check whether the line contains the query.
-->
<p>La fonction <code>rechercher_insensible_casse</code>, prÃ©sente dans l'encart 12-21, sera
presque la mÃªme que la fonction <code>rechercher</code>. La seule diffÃ©rence est que nous
allons transformer en minuscule le contenu de <code>recherche</code> et de chaque <code>ligne</code>
pour que quel que soit la casse des arguments d'entrÃ©e, nous aurons toujours la
mÃªme casse lorsque nous vÃ©rifierons si la ligne contient la recherche.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     for ligne in rechercher(&config.recherche, &contenu) {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
pub fn rechercher_insensible_casse<'a>(
    recherche: &str,
    contenu: &'a str
) -> Vec<&'a str> {
    let recherche = recherche.to_lowercase();
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.to_lowercase().contains(&recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
# Obtenez les trois en mÃªme temps.
# Duck tape.";
# 
#         assert_eq!(vec!["sÃ©curitÃ©, rapiditÃ©, productivitÃ©."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn insensible_casse() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
# Obtenez les trois en mÃªme temps.
# C'est pas rustique.";
# 
#         assert_eq!(
#             vec!["Rust:", "C'est pas rustique."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher_insensible_casse&lt;'a&gt;(
    recherche: &amp;str,
    contenu: &amp;'a str
) -&gt; Vec&lt;&amp;'a str&gt; {
    let recherche = recherche.to_lowercase();
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.to_lowercase().contains(&amp;recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.
</span><span class="boring">Duck tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn insensible_casse() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.
</span><span class="boring">C'est pas rustique.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;C'est pas rustique.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-21: Defining the `search_case_insensitive`
function to lowercase the query and the line before comparing them</span>
-->
<p><span class="caption">Encart 12-21 : DÃ©finition de la fonction
<code>rechercher_insensible_casse</code> pour obtenir en minuscule la recherche et la
ligne avant de les comparer</span></p>
<!--
First, we lowercase the `query` string and store it in a shadowed variable with
the same name. Calling `to_lowercase` on the query is necessary so no matter
whether the userâ€™s query is `"rust"`, `"RUST"`, `"Rust"`, or `"rUsT"`, weâ€™ll
treat the query as if it were `"rust"` and be insensitive to the case. While
`to_lowercase` will handle basic Unicode, it won't be 100% accurate. If we were
writing a real application, we'd want to do a bit more work here, but this section
is about environment variables, not Unicode, so we'll leave it at that here.
-->
<p>D'abord, nous obtenons la chaÃ®ne de caractÃ¨res <code>recherche</code> en minuscule et nous
l'enregistrons dans une variable masquÃ©e avec le mÃªme nom. L'appel Ã 
<code>to_lowercase</code> sur la recherche est nÃ©cessaire afin que quel que soit la
recherche de l'utilisateur, comme <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, ou <code>&quot;rUsT&quot;</code>,
nous traitons la recherche comme si elle Ã©tait <code>&quot;rust&quot;</code> et par consÃ©quent elle
est insensible Ã  la casse. La mÃ©thode <code>to_lowercase</code> devrait gÃ©rer de l'Unicode
de base, mais ne sera pas fiable Ã  100%. Si nous avions Ã©cris une application
sÃ©rieuse, nous aurions dÃ» faire plus de choses Ã  ce propos, toutefois la section
actuelle traite des variables d'environnement et non pas de la gestion de
l'Unicode, donc nous allons conserver ce code simplifiÃ©.</p>
<!--
Note that `query` is now a `String` rather than a string slice, because calling
`to_lowercase` creates new data rather than referencing existing data. Say the
query is `"rUsT"`, as an example: that string slice doesnâ€™t contain a lowercase
`u` or `t` for us to use, so we have to allocate a new `String` containing
`"rust"`. When we pass `query` as an argument to the `contains` method now, we
need to add an ampersand because the signature of `contains` is defined to take
a string slice.
-->
<p>Notez que <code>recherche</code> est dÃ©sormais une <code>String</code> et non plus une slice de chaÃ®ne
de caractÃ¨res, car l'appel Ã  <code>to_lowercase</code> crÃ©e des nouvelles donnÃ©es au lieu
de modifier les donnÃ©es dÃ©jÃ  existantes. Par exemple, disons que la recherche
est <code>&quot;rUsT&quot;</code> : cette slice de chaÃ®ne de caractÃ¨res ne contient pas de <code>u</code> ou de
<code>t</code> minuscule que nous pourrions utiliser, donc nous devons allouer une nouvelle
<code>String</code> qui contient <code>&quot;rust&quot;</code>. Maintenant, lorsque nous passons <code>recherche</code> en
argument de la mÃ©thode <code>contains</code>, nous devons rajouter une esperluette car la
signature de <code>contains</code> est dÃ©finie pour prendre une slice de chaÃ®ne de
caractÃ¨res.</p>
<!--
Next, we add a call to `to_lowercase` on each `line` before we check whether it
contains `query` to lowercase all characters. Now that weâ€™ve converted `line`
and `query` to lowercase, weâ€™ll find matches no matter what the case of the
query is.
-->
<p>Ensuite, nous ajoutons un appel Ã  <code>to_lowercase</code> sur chaque <code>ligne</code> avant de
vÃ©rifier si elle contient <code>recherche</code> afin d'obtenir tous ses caractÃ¨res en
minuscule. Maintenant que nous avons <code>ligne</code> et <code>recherche</code> en minuscule, nous
allons rechercher les correspondances peu importe la casse de la recherche.</p>
<!--
Letâ€™s see if this implementation passes the tests:
-->
<p>Voyons si cette implÃ©mentation passe les tests :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running target/debug/deps/minigrep-4672b652f7794785

running 2 tests
test tests::sensible_casse ... ok
test tests::insensible_casse ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running target/debug/deps/minigrep-4672b652f7794785

running 2 tests
test tests::sensible_casse ... ok
test tests::insensible_casse ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Great! They passed. Now, letâ€™s call the new `search_case_insensitive` function
from the `run` function. First, weâ€™ll add a configuration option to the
`Config` struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we arenâ€™t initializing
this field anywhere yet:
-->
<p>TrÃ¨s bien ! Elles ont rÃ©ussi. Maintenant, utilisons la nouvelle fonction
<code>rechercher_insensible_casse</code> dans la fonction <code>run</code>. Pour commencer, nous
allons ajouter une option de configuration Ã  la structure <code>Config</code> pour changer
entre la recherche sensible et non-sensible Ã  la casse. L'ajout de ce champ va
causer des erreurs de compilation car nous n'avons jamais initialisÃ© ce champ
pour le moment :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
    pub sensible_casse: bool,
}
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
    pub sensible_casse: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Note that we added the `case_sensitive` field that holds a Boolean. Next, we
need the `run` function to check the `case_sensitive` fieldâ€™s value and use
that to decide whether to call the `search` function or the
`search_case_insensitive` function, as shown in Listing 12-22. Note this still
wonâ€™t compile yet.
-->
<p>Remarquez que le champ <code>sensible_casse</code> que nous avons ajoutÃ© est un BoolÃ©en.
Ensuite, nous devons faire en sorte que la fonction <code>run</code> vÃ©rifie la valeur du
champ <code>sensible_casse</code> et l'utilise pour dÃ©cider si elle doit appeler la
fonction <code>rechercher</code> ou la fonction <code>rechercher_insensible_casse</code>, comme dans
l'encart 12-22. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    let resultats = if config.sensible_casse {
        rechercher(&config.recherche, &contenu)
    } else {
        rechercher_insensible_casse(&config.recherche, &contenu)
    };

    for ligne in resultats {
        println!("{}", ligne);
    }

    Ok(())
}
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    let resultats = if config.sensible_casse {
        rechercher(&amp;config.recherche, &amp;contenu)
    } else {
        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
    };

    for ligne in resultats {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 12-22: Calling either `search` or
`search_case_insensitive` based on the value in `config.case_sensitive`</span>
-->
<p><span class="caption">Encart 12-22 : Appeler <code>rechercher</code> ou
<code>rechercher_insensible_casse</code> en fonction de la valeur dans <code>config.sensible_casse</code>
</span></p>
<!--
Finally, we need to check for the environment variable. The functions for
working with environment variables are in the `env` module in the standard
library, so we want to bring that module into scope with a `use std::env;` line
at the top of *src/lib.rs*. Then weâ€™ll use the `var` function from the `env`
module to check for an environment variable named `CASE_INSENSITIVE`, as shown
in Listing 12-23.
-->
<p>Enfin, nous devons vÃ©rifier la variable d'environnement. Les fonctions pour
travailler avec les variables d'environnement sont dans le module <code>env</code> de la
bibliothÃ¨que standard, donc nous allons importer ce module dans la portÃ©e avec
une ligne <code>use std::env;</code> en haut de <em>src/lib.rs</em>. Ensuite, nous allons utiliser
la fonction <code>var</code> du module <code>env</code> pour vÃ©rifier la prÃ©sence d'une variable
d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code>, comme dans l'encart 12-23.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
use std::env;
// -- partie masquÃ©e ici --

# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::env;
// -- partie masquÃ©e ici --

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-23: Checking for an environment variable named
`CASE_INSENSITIVE`</span>
-->
<p><span class="caption">Encart 12-23 : VÃ©rification de la prÃ©sence de la variable
d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code></span></p>
<!--
Here, we create a new variable `case_sensitive`. To set its value, we call the
`env::var` function and pass it the name of the `CASE_INSENSITIVE` environment
variable. The `env::var` function returns a `Result` that will be the successful
`Ok` variant that contains the value of the environment variable if the
environment variable is set. It will return the `Err` variant if the
environment variable is not set.
-->
<p>Ici, nous crÃ©ons une nouvelle variable <code>sensible_casse</code>. Pour lui donner une
valeur, nous appelons la fonction <code>env::var</code> et nous lui passons le nom de la
variable d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code>. La fonction <code>env::var</code>
retourne un <code>Result</code> qui sera en cas de succÃ¨s la variante <code>Ok</code> qui contiendra
la valeur de la variable d'environnement si cette variable d'environnement est
dÃ©finie. Elle retournera la variante <code>Err</code> si cette variable d'environnement
n'est pas dÃ©finie.</p>
<!--
Weâ€™re using the `is_err` method on the `Result` to check whether itâ€™s an error
and therefore unset, which means it *should* do a case-sensitive search. If the
`CASE_INSENSITIVE` environment variable is set to anything, `is_err` will
return false and the program will perform a case-insensitive search. We donâ€™t
care about the *value* of the environment variable, just whether itâ€™s set or
unset, so weâ€™re checking `is_err` rather than using `unwrap`, `expect`, or any
of the other methods weâ€™ve seen on `Result`.
-->
<p>Nous utilisons la mÃ©thode <code>is_err</code> sur le <code>Result</code> pour vÃ©rifier si c'est une
erreur et donc par consÃ©quent non dÃ©finie, ce qui veut dire que nous <em>devons</em>
effectuer une recherche sensible Ã  la casse. Si la variable d'environnement
<code>MINIGREP_INSENSIBLE_CASSE</code> a une valeur qui lui a Ã©tÃ© assignÃ©e, <code>is_err</code> va
retourner <code>false</code> et le programme va procÃ©der Ã  une recherche non sensible Ã 
la casse. Nous ne prÃ©occupons pas de la <em>valeur</em> de la variable d'environnement,
mais uniquement de savoir si elle est dÃ©finie ou non, donc nous utilisons
<code>is_err</code> plutÃ´t que <code>unwrap</code>, <code>expect</code>, ou toute autre mÃ©thode que nous avons
vu pour <code>Result</code>.</p>
<!--
We pass the value in the `case_sensitive` variable to the `Config` instance so
the `run` function can read that value and decide whether to call `search` or
`search_case_insensitive`, as we implemented in Listing 12-22.
-->
<p>Nous passons la valeur de la variable <code>sensible_casse</code> Ã  l'instance de <code>Config</code>
afin que la fonction <code>run</code> puisse lire cette valeur et dÃ©cider d'appeler
<code>rechercher</code> ou <code>rechercher_insensible_casse</code>, comme nous l'avons implÃ©mentÃ©
dans l'encart 12-22.</p>
<!--
Letâ€™s give it a try! First, weâ€™ll run our program without the environment
variable set and with the query `to`, which should match any line that contains
the word â€œtoâ€ in all lowercase:
-->
<p>Faisons un essai ! D'abord, nous allons lancer notre programme avec la variable
d'environnement non dÃ©finie et avec la recherche <code>to</code>, qui devrait trouver
toutes les lignes qui contiennent le mot â€œtoâ€ en minuscule :</p>
<!--
```console
$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
Looks like that still works! Now, letâ€™s run the program with `CASE_INSENSITIVE`
set to `1` but with the same query `to`.
-->
<p>On dirait que cela fonctionne ! Maintenant, lanÃ§ons le programme avec
<code>MINIGREP_INSENSIBLE_CASSE</code> dÃ©finie Ã  <code>1</code> mais avec la mÃªme recherche <code>to</code>.</p>
<!--
If you're using PowerShell, you will need to set the environment
variable and run the program as separate commands:
-->
<p>Si vous utilisez PowerShell, vous allez avoir besoin d'affecter la variable
d'environnement puis exÃ©cuter le programme avec deux commande sÃ©parÃ©es :</p>
<!--
```console
PS> $Env:CASE_INSENSITIVE=1; cargo run to poem.txt
```
-->
<pre><code class="language-console">PS&gt; $Env:MINIGREP_INSENSIBLE_CASSE=1; cargo run to poem.txt
</code></pre>
<!--
This will make `CASE_INSENSITIVE` persist for the remainder of your shell
session. It can be unset with the `Remove-Item` cmdlet:
-->
<p>Cela va faire persister la variable <code>MINIGREP_INSENSIBLE_CASSE</code> pour la durÃ©e de
votre session de terminal. Elle peut Ãªtre dÃ©saffectÃ©e avec la cmdlet
<code>Remove-Item</code>Â :</p>
<!--
```console
PS> Remove-Item Env:CASE_INSENSITIVE
```
-->
<pre><code class="language-console">PS&gt; Remove-Item Env:MINIGREP_INSENSIBLE_CASSE
</code></pre>
<!--
We should get lines that contain â€œtoâ€ that might have uppercase letters:
-->
<p>Nous devrions trouver les lignes qui contiennent â€œtoâ€ qui ont des lettres
majuscules :</p>
<!--
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
CASE_INSENSITIVE=1 cargo run to poem.txt
can't extract because of the environment variable
-- >
-->
<!--
```console
$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```
-->
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
Excellent, we also got lines containing â€œToâ€! Our `minigrep` program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.
-->
<p>TrÃ¨s bien, nous avons aussi obtenu les lignes qui contiennent â€œToâ€ ! Notre
programme <code>minigrep</code> peut maintenant faire des recherches insensibles Ã  la
casse, pilotÃ©es par une variable d'environnement. Vous savez maintenant comment
gÃ©rer des options dÃ©finies soit par des arguments en ligne de commande, soit
par des variables d'environnement.</p>
<!--
Some programs allow arguments *and* environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.
-->
<p>Certains programmes permettent d'utiliser les arguments <em>et</em> les variables
d'environnement pour un mÃªme rÃ©glage. Dans ce cas, le programme dÃ©cide si l'un
ou l'autre a la prioritÃ©. Pour vous exercer Ã  nouveau, essayez de piloter la
sensibilitÃ© Ã  la casse via un argument de ligne de commande ou une variable
d'environnement. Vous devrez choisir si l'argument de la ligne de commande ou
la variable d'environnement devrait Ãªtre prioritaire si le programme est exÃ©cutÃ©
avec l'option rÃ©glÃ©e dans un cas pour Ãªtre sensible Ã  la casse et Ãªtre
insensible Ã  la casse dans l'autre cas simultanÃ©ment.</p>
<!--
The `std::env` module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.
-->
<p>Le module <code>std::env</code> contient plein d'autres fonctionnalitÃ©es utiles pour
utiliser les variables d'environnement : regardez sa documentation pour voir ce
qu'il est possible de faire.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--18" id="-attention-peinture-fraÃ®che--18">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/143">Pull Request</a>.</p>
</blockquote>
<!--
## Writing Error Messages to Standard Error Instead of Standard Output
-->
<h2><a class="header" href="#ecrire-les-messages-derreur-sur-la-sortie-derreurs-standard-au-lieu-de-la-sortie-normale" id="ecrire-les-messages-derreur-sur-la-sortie-derreurs-standard-au-lieu-de-la-sortie-normale">Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></h2>
<!--
At the moment, weâ€™re writing all of our output to the terminal using the
`println!` macro. Most terminals provide two kinds of output: *standard
output* (`stdout`) for general information and *standard error* (`stderr`)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.
-->
<p>Pour l'instant, nous avons Ã©crit toutes nos sorties du terminal en utilisant
la macro <code>println!</code>. La plupart des terminaux fournissent deux genres de
sortiesÂ : la <em>sortie standard</em> (<code>stdout</code>) pour les informations gÃ©nÃ©rales
et <em>la sortie d'erreur standard</em> (<code>stderr</code>) pour les messages d'erreur. Cette
distinction permet Ã  l'utilisateur de choisir de rediriger la sortie des
rÃ©ussites d'un programme vers un fichier mais continuer Ã  afficher les messages
d'erreur Ã  l'Ã©cran.</p>
<!--
The `println!` macro is only capable of printing to standard output, so we
have to use something else to print to standard error.
-->
<p>La macro <code>println!</code> ne peut Ã©crire que sur la sortie standard, donc nous
devons utiliser autre chose pour Ã©crire sur la sortie d'erreur standard.</p>
<!--
### Checking Where Errors Are Written
-->
<h3><a class="header" href="#vÃ©rifier-oÃ¹-sont-Ã©cris-les-erreurs" id="vÃ©rifier-oÃ¹-sont-Ã©cris-les-erreurs">VÃ©rifier oÃ¹ sont Ã©cris les erreurs</a></h3>
<!--
First, letâ€™s observe how the content printed by `minigrep` is currently being
written to standard output, including any error messages we want to write to
standard error instead. Weâ€™ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We wonâ€™t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.
-->
<p>CommenÃ§ons par observer comment le contenu Ã©cris par <code>minigrep</code> est actuellement
Ã©cris sur la sortie standard, y compris les messages d'erreur que nous
souhaitons plutÃ´t Ã©crire sur la sortie d'erreur standard. Nous allons faire cela
en redirigeant le flux de sortie standard vers un fichier pendant que nous
dÃ©clencherons intentionnellement une erreur. Nous ne redirigerons pas le flux
de sortie d'erreur standard, donc n'importe quel contenu envoyÃ© Ã  la sortie
d'erreur standard va continuer Ã  s'afficher Ã  l'Ã©cran.</p>
<!--
Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
weâ€™re about to see that it saves the error message output to a file instead!
-->
<p>Les programmes en ligne de commande sont censÃ©s envoyer leurs messages d'erreur
dans le flux d'erreurs standard afin que nous puissions continuer Ã  voir les
messages d'erreurs Ã  l'Ã©cran mÃªme si nous redirigeons le flux de la sortie
standard dans un fichier. Notre programme ne se comporte pas comme il le
devraitÂ : nous allons voir qu'Ã  la place, il envoie les messages d'erreur
dans le fichierÂ !</p>
<!--
The way to demonstrate this behavior is by running the program with `>` and the
filename, *output.txt*, that we want to redirect the standard output stream to.
We wonâ€™t pass any arguments, which should cause an error:
-->
<p>Pour dÃ©montrer ce comportement, il faut exÃ©cuter le programme avec <code>&gt;</code> suivi du
nom du fichier, <em>sortie.txt</em>, dans lequel nous souhaitons rediriger le flux de
sortie standard. Nous ne fournissons aucun argument, ce qui va causer une
erreurÂ :</p>
<!--
```console
$ cargo run > output.txt
```
-->
<pre><code class="language-console">$ cargo run &gt; sortie.txt
</code></pre>
<!--
The `>` syntax tells the shell to write the contents of standard output to
*output.txt* instead of the screen. We didnâ€™t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what *output.txt* contains:
-->
<p>La syntaxe indique Ã  l'invite de commande d'Ã©crire le contenu de la sortie
standard dans <em>sortie.txt</em> plutÃ´t qu'Ã  l'Ã©cran. Nous n'avons pas vu le
message d'erreur que nous nous attendions de voir Ã  l'Ã©cran, ce qui veut
dire qu'il a dÃ» finir dans le fichier. Voici ce que <em>sortie.txt</em> contientÂ :</p>
<!--
```text
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-text">ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : il n'y a pas assez d'arguments
</code></pre>
<!--
Yup, our error message is being printed to standard output. Itâ€™s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. Weâ€™ll change that.
-->
<p>Effectivement, notre message d'erreur est Ã©cris sur la sortie standard. Il
est bien plus utile que les messages d'erreur comme celui-ci soient Ã©cris
dans la sortie d'erreur standard afin qu'uniquement les donnÃ©es d'une
exÃ©cution fructueuse finissent dans le fichier. Nous allons corriger cela.</p>
<!--
### Printing Errors to Standard Error
-->
<h3><a class="header" href="#ecrire-les-erreurs-sur-la-sortie-derreur-standard" id="ecrire-les-erreurs-sur-la-sortie-derreur-standard">Ecrire les erreurs sur la sortie d'erreur standard</a></h3>
<!--
Weâ€™ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, `main`. The standard library provides
the `eprintln!` macro that prints to the standard error stream, so letâ€™s change
the two places we were calling `println!` to print errors to use `eprintln!`
instead.
-->
<p>Nous allons utiliser le code de l'encart 12-24 pour changer la maniÃ¨re dont les
messages d'erreur sont Ã©cris. GrÃ¢ce au remaniement que nous avons fait plus tÃ´t
dans ce chapitre, tout le code qui Ã©cris les messages d'erreurs se trouve dans
une seule fonction, <code>main</code>. La bibliothÃ¨que standard fournit la macro
<code>eprintln!</code> qui Ã©cris dans le flux d'erreur standard, donc changeons les deux
endroits oÃ¹ nous appelons <code>println!</code> afin d'utiliser <code>eprintln!</code> Ã  la place.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}", err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Erreur applicativeÂ : {}", e);

        process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Erreur applicativeÂ : {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using `eprintln!`</span>
-->
<p><span class="caption">Encart 12-24Â : Ecrire les messages d'erreur sur la sortie
d'erreur standard au lieu de la sortie standard en utilisant <code>eprintln!</code></span></p>
<!--
After changing `println!` to `eprintln!`, letâ€™s run the program again in the
same way, without any arguments and redirecting standard output with `>`:
-->
<p>AprÃ¨s avoir changÃ© <code>println!</code> en <code>eprintln!</code>, exÃ©cutons le programme Ã  nouveau
de la mÃªme maniÃ¨re, sans aucun argument et en redirigeant la sortie standard
avec <code>&gt;</code>Â :</p>
<!--
```text
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-text">$ cargo run &gt; sortie.txt
ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des argumentsÂ : il n'y a pas assez d'arguments
</code></pre>
<!--
Now we see the error onscreen and *output.txt* contains nothing, which is the
behavior we expect of command line programs.
-->
<p>DÃ©sormais nous pouvons voir l'erreur Ã  l'Ã©cran et <em>sortie.txt</em> ne contient rien,
ce qui est le comportement de que nous attendons d'un programme en ligne de
commande.</p>
<!--
Letâ€™s run the program again with arguments that donâ€™t cause an error but still
redirect standard output to a file, like so:
-->
<p>ExÃ©cutons le programme Ã  nouveau avec des arguments qui ne causent pas d'erreurs
mais nous continuons Ã  rediriger la sortie standard, comme ceciÂ :</p>
<!--
```console
$ cargo run to poem.txt > output.txt
```
-->
<pre><code class="language-console">$ cargo run to poem.txt &gt; sortie.txt
</code></pre>
<!--
We wonâ€™t see any output to the terminal, and *output.txt* will contain our
results:
-->
<p>Nous ne voyons rien sur la sortie du terminal, et <em>sortie.txt</em> devrait contenir
notre rÃ©sultatÂ :</p>
<!--
<span class="filename">Filename: output.txt</span>
-->
<p><span class="filename">FichierÂ : sortie.txt</span></p>
<!--
```text
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
This demonstrates that weâ€™re now using standard output for successful output
and standard error for error output as appropriate.
-->
<p>Ceci prouve que nous utilisons maintenant la sortie standard pour la sortie
rÃ©ussie et l'erreur standard pour la sortie d'erreur, en fonction des
circonstances.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-11" id="rÃ©sumÃ©-11">RÃ©sumÃ©</a></h2>
<!--
This chapter recapped some of the major concepts youâ€™ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the `eprintln!` macro for printing
errors, youâ€™re now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.
-->
<p>Ce chapitre a rÃ©sumÃ© certains des concepts majeurs que vous avez appris
prÃ©cÃ©demment et expliquÃ© comment procÃ©der Ã  des opÃ©rations courantes sur les
entrÃ©es/sorties en Rust. En utilisant les arguments en ligne de commande, les
fichiers, les variables d'environnement, et la macro <code>eprintln!</code> pour Ã©crire les
erreurs, vous pouvez dÃ©sormais Ã©crire des applications en ligne de commande. En
suivant les concepts vus dans les chapitres prÃ©cÃ©dents, votre code restera bien
organisÃ©, stockera les donnÃ©es dans les bonnes structures de donnÃ©es, gÃ©rera
correctement les erreurs, et sera correctement testÃ©.</p>
<!--
Next, weâ€™ll explore some Rust features that were influenced by functional
languages: closures and iterators.
-->
<p>Maintenant, nous allons dÃ©couvrir quelques fonctionnalitÃ©s de Rust qui ont Ã©tÃ©
influencÃ©es par les langages fonctionnelsÂ : les closures et les itÃ©rateurs.</p>
<!--
# Functional Language Features: Iterators and Closures
-->
<h1><a class="header" href="#les-fonctionnalitÃ©s-des-langages-fonctionnels--les-itÃ©rateurs-et-les-fermetures" id="les-fonctionnalitÃ©s-des-langages-fonctionnels--les-itÃ©rateurs-et-les-fermetures">Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></h1>
<!--
Rustâ€™s design has taken inspiration from many existing languages and
techniques, and one significant influence is *functional programming*.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.
-->
<p>La conception de Rust s'est inspirÃ©e de nombreux langages et technologies
existantes, et une de ses influences la plus marquante est la <em>programmation
fonctionnelle</em>. La programmation fonctionnelle consiste souvent Ã  utiliser une
fonction comme une valeur en la passant en argument d'une autre fonction, la
retourner en rÃ©sultat d'une autre fonction, l'assigner Ã  une variable pour
l'exÃ©cuter plus tard, par exemple.</p>
<!--
In this chapter, we wonâ€™t debate the issue of what functional programming is or
isnâ€™t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.
-->
<p>Dans ce chapitre, nous n'allons pas dÃ©battre sur ce qu'est ou non la
programmation fonctionnelle, mais nous allons plutÃ´t voir quelques
fonctionnalitÃ©s de Rust qui sont similaires Ã  celles des autres langages souvent
considÃ©rÃ©s comme fonctionnels.</p>
<!--
More specifically, weâ€™ll cover:
-->
<p>Plus prÃ©cisÃ©ment, nous allons voirÂ :</p>
<!--
* *Closures*, a function-like construct you can store in a variable
* *Iterators*, a way of processing a series of elements
* How to use these two features to improve the I/O project in Chapter 12
* The performance of these two features (Spoiler alert: theyâ€™re faster than you
  might think!)
-->
<ul>
<li><em>les fermetures</em>, une construction qui ressemble Ã  une fonction que vous
pouvez stocker dans une variable</li>
<li><em>les itÃ©rateurs</em>, une faÃ§on de travailler sur une sÃ©rie d'Ã©lÃ©ments</li>
<li>Comment utiliser ces deux fonctionnalitÃ©s pour amÃ©liorer le projet
d'entrÃ©e/sortie du chapitre 12</li>
<li>Etudier la performance de ces deux fonctionnalitÃ©s (divulgÃ¢chageÂ : elles sont
probablement plus rapides que ce que vous pensezÂ !)</li>
</ul>
<!--
Other Rust features, such as pattern matching and enums, which weâ€™ve covered in
other chapters, are influenced by the functional style as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so weâ€™ll devote this entire chapter to them.
-->
<p>Les autres fonctionnalitÃ©s de Rust, comme le filtrage par motif et les
Ã©numÃ©rations que nous avons vu dans les chapitres prÃ©cÃ©dents, sont influencÃ©s
par la programmation fonctionnelle. La maÃ®trise des fermetures et des itÃ©rateurs
est une Ã©tape importante pour Ã©crire du code Rust performant, c'est pourquoi
nous allons leur dÃ©dier ce chapitre entier.</p>
<!--
## Closures: Anonymous Functions that Can Capture Their Environment
-->
<h2><a class="header" href="#les-fermetures--fonctions-anonymes-qui-peuvent-utiliser-leur-environnement" id="les-fermetures--fonctions-anonymes-qui-peuvent-utiliser-leur-environnement">Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></h2>
<!--
Rustâ€™s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which theyâ€™re defined. Weâ€™ll
demonstrate how these closure features allow for code reuse and behavior
customization.
-->
<p>Les fermetures en Rust sont des fonctions anonymes qui peuvent Ãªtre sauvegardÃ©s
dans une variable ou qui peuvent Ãªtre passÃ©es en argument Ã  d'autres fonctions.
Il est possible de crÃ©er une fermeture Ã  un endroit du code et ensuite de
l'appeler dans un contexte diffÃ©rent pour l'exÃ©cuter. Contrairement aux
fonctions, les fermetures ont la possibilitÃ© de capturer les valeurs prÃ©sentes
dans le contexte oÃ¹ elles sont appelÃ©es. Nous allons montrer comment les
fonctionnalitÃ©s des fermetures permettent de rÃ©utiliser du code et suivre des
comportements personnalisÃ©s.</p>
<!--
### Creating an Abstraction of Behavior with Closures
-->
<h3><a class="header" href="#crÃ©er-une-abstraction-de-comportement-avec-une-fermeture" id="crÃ©er-une-abstraction-de-comportement-avec-une-fermeture">CrÃ©er une abstraction de comportement avec une fermeture</a></h3>
<!--
Letâ€™s work on an example of a situation in which itâ€™s useful to store a closure
to be executed later. Along the way, weâ€™ll talk about the syntax of closures,
type inference, and traits.
-->
<p>Travaillons sur un exemple d'une situation oÃ¹ il est utile de stocker une
fermeture qui s'exÃ©cutera ultÃ©rieurement. Nous allons parler de la syntaxe des
fermetures, de l'infÃ©rence de type, et des traits au cours de ce chapitre.</p>
<!--
Consider this hypothetical situation: we work at a startup thatâ€™s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app userâ€™s age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isnâ€™t
important in this example; whatâ€™s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we donâ€™t make the user wait more than necessary.
-->
<p>Imaginons la situation suivanteÂ : nous travaillons dans une <em>startup</em> qui crÃ©Ã©
une application pour gÃ©nÃ©rer des plans d'entraÃ®nements physiques personnalisÃ©s.
L'application dorsale est Ã©crite en Rust et l'algorithme qui gÃ©nÃ¨re les
exercices en fonction de beaucoup de facteurs comme l'Ã¢ge de l'utilisateur, son
indice de masse corporelle, ses prÃ©fÃ©rences et une intensitÃ© paramÃ©trÃ©e par
l'utilisateur. L'algorithme rÃ©ellement utilisÃ© n'est pas important pour cet
exempleÂ : ce qui est important c'est que le calcul prenne plusieurs secondes.
Nous voulons appeler l'algorithme uniquement lorsque nous avons besoin, et
seulement une fois, afin que l'utilisateur n'ai pas Ã  attendre plus longtemps
que nÃ©cessaire.</p>
<!--
Weâ€™ll simulate calling this hypothetical algorithm with the function
`simulated_expensive_calculation` shown in Listing 13-1, which will print
`calculating slowly...`, wait for two seconds, and then return whatever number
we passed in.
-->
<p>Pour simuler l'appel Ã  cet algorithme hypothÃ©tique, nous allons utiliser la
fonction <code>simuler_gros_calcul</code> prÃ©sent dans l'encart 13-1, qui affichera
<code>calcul trÃ¨s lent ...</code>, attendra deux secondes, et ensuite retournera le nombre
qui lui a Ã©tÃ© donnÃ©Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
    println!(&quot;calcul trÃ¨s lent ...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensite
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span>
-->
<p><span class="caption">Encart 13-1Â : une fonction pour remplacer un calcul
hypothÃ©tique qui prend environ deux secondes Ã  exÃ©cuter</span></p>
<!--
Next is the `main` function, which contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
appâ€™s frontend isnâ€™t relevant to the use of closures, weâ€™ll hardcode values
representing inputs to our program and print the outputs.
-->
<p>Ensuite, nous avons la fonction <code>main</code> qui contient les parties importantes de
cet exemple d'application d'entraÃ®nement. Cette fonction reprÃ©sente le code que
l'application appellera lorsqu'un utilisateur demande un plan d'entraÃ®nement.
Comme l'interaction avec l'application dorsale n'est pas adaptÃ© Ã  l'utilisation
des fermetures, nous allons coder en dur les valeurs reprÃ©sentant les entrÃ©es de
notre programme, puis afficher les rÃ©sultats.</p>
<!--
The required inputs are these:
-->
<p>Les paramÃ¨tres d'entrÃ©es nÃ©cessaires sontÂ :</p>
<!--
* An intensity number from the user, which is specified when they request
  a workout to indicate whether they want a low-intensity workout or a
  high-intensity workout
* A random number that will generate some variety in the workout plans
-->
<ul>
<li><code>intensite</code> qui est un nombre saisi par utilisateur lorsqu'il demande un
entraÃ®nement, afin qu'ils puissent indiquer s'ils veulent un entraÃ®nement de
faible ou de haute intensitÃ©.</li>
<li>Un nombre alÃ©atoire qui variera les plans d'entraÃ®nement</li>
</ul>
<!--
The output will be the recommended workout plan. Listing 13-2 shows the `main`
function weâ€™ll use.
-->
<p>Le rÃ©sultat sera le plan d'entraÃ®nement recommandÃ©. L'encart 13-2 montre la
fonction <code>main</code> que nous allons utiliser.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
# fn generate_workout(intensity: u32, random_number: u32) {}
# 
fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul trÃ¨s lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {}
</span><span class="boring">
</span>fn main() {
    let valeur_utilisateur_simule = 10;
    let nombre_aleatoire_simule = 7;

    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-2: A `main` function with hardcoded values to
simulate user input and random number generation</span>
-->
<p><span class="caption">Encart 13-2Â : une fonction <code>main</code> avec des valeurs codÃ©es
en dur pour simuler l'entrÃ©e d'un utilisateur et la gÃ©nÃ©ration de nombres
alÃ©atoires</span></p>
<!--
Weâ€™ve hardcoded the variable `simulated_user_specified_value` as 10 and the
variable `simulated_random_number` as 7 for simplicityâ€™s sake; in an actual
program, weâ€™d get the intensity number from the app frontend, and weâ€™d use the
`rand` crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The `main` function calls a `generate_workout` function
with the simulated input values.
-->
<p>Nous avons codÃ© en dur la variable <code>valeur_utilisateur_simule</code> Ã  10 et la
variable <code>nombre_aleatoire_simule</code> Ã  7 pour des raisons de simplicitÃ©Â ; dans un
vrai programme nous obtiendrions le nombre d'intensitÃ© Ã  partir de l'application
frontale et nous utiliserions la crate <code>rand</code> pour gÃ©nÃ©rer un nombre alÃ©atoire,
comme nous l'avons fait dans l'exemple du jeu du plus ou du moins dans le
chapitre 2. La fonction <code>main</code> appelle une fonction <code>generer_exercices</code> avec les
valeurs d'entrÃ©e simulÃ©es.</p>
<!--
Now that we have the context, letâ€™s get to the algorithm. The function
`generate_workout` in Listing 13-3 contains the business logic of the
app that weâ€™re most concerned with in this example. The rest of the code
changes in this example will be made to this function.
-->
<p>Maintenant que nous avons le contexte, passons Ã  l'algorithme. La fonction
<code>generer_exercices</code> dans l'encart 13-3 contient la logique mÃ©tier de
l'application qui nous prÃ©occupe le plus dans cet exemple. Le reste des
changements de code dans cet exemple sera appliquÃ© Ã  cette fonctionÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            simulated_expensive_calculation(intensity)
        );
        println!(
            "Next, do {} situps!",
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul trÃ¨s lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    if intensite &lt; 25 {
        println!(
            &quot;Aujourd'hui, faire {} pompesÂ !&quot;,
            simuler_gros_calcul(intensite)
        );
        println!(
            &quot;Ensuite, faire {} abdominauxÂ !&quot;,
            simuler_gros_calcul(intensite)
        );
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'huiÂ ! Rappelez-vous de bien vous hydraterÂ !&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutesÂ !&quot;,
                simuler_gros_calcul(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the `simulated_expensive_calculation`
function</span>
-->
<p><span class="caption">Encart 13-3Â : la logique mÃ©tier qui affiche les plans
d'entraÃ®nement en fonction des entrÃ©es et des appels Ã  la fonction
<code>simuler_gros_calcul</code>.</span></p>
<!--
The code in Listing 13-3 has multiple calls to the slow calculation function.
The first `if` block calls `simulated_expensive_calculation` twice, the `if`
inside the outer `else` doesnâ€™t call it at all, and the code inside the
second `else` case calls it once.
-->
<p>Le code de l'encart 13-3 a plusieurs appels Ã  la fonction de calcul lentÂ : le
premier bloc <code>if</code> appelle <code>simuler_gros_calcul</code> deux fois, le <code>if</code> Ã  l'intÃ©rieur
du <code>else</code> ne l'appelle pas du tout, et le code Ã  l'intÃ©rieur du second <code>else</code>
l'appelle une seule fois.</p>
<!--
The desired behavior of the `generate_workout` function is to first check
whether the user wants a low-intensity workout (indicated by a number less than
25) or a high-intensity workout (a number of 25 or greater).
-->
<p>Le comportement souhaitÃ© de la fonction <code>generer_exercices</code> est de vÃ©rifier
d'abord si l'utilisateur veut un entraÃ®nement de faible intensitÃ© (indiquÃ© par
un nombre infÃ©rieur Ã  25) ou un entraÃ®nement de haute intensitÃ© (un nombre de 25
ou plus).</p>
<!--
Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm weâ€™re simulating.
-->
<p>Les plans d'entraÃ®nement Ã  faible intensitÃ© recommanderont un certain nombre de
pompes et d'abdominaux basÃ©s sur l'algorithme complexe que nous simulons.</p>
<!--
If the user wants a high-intensity workout, thereâ€™s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.
-->
<p>Si l'utilisateur souhaite un entraÃ®nement de haute intensitÃ©, il y a une logique
en plusÂ : si la valeur du nombre alÃ©atoire gÃ©nÃ©rÃ© par l'application est 3,
l'application recommandera une pause et une hydratation Ã  la place. Sinon,
l'utilisateur recevra un nombre de minutes de course qui provient de
l'algorithme complexe.</p>
<!--
This code works the way the business wants it to now, but letâ€™s say the data
science team decides that we need to make some changes to the way we call the
`simulated_expensive_calculation` function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
`simulated_expensive_calculation` function only once. We also want to cut the
place where weâ€™re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we donâ€™t want
to call it if the result isnâ€™t needed, and we still want to call it only once.
-->
<p>Ce code fonctionne comme la logique mÃ©tier le souhaite, mais imaginons que
l'Ã©quipe de science des donnÃ©es nous informe qu'il va y avoir des changements
dans la faÃ§on dont nous devrons appeler l'algorithme Ã  l'avenir. Pour simplifier
la mise Ã  jour lorsque ces changements se produisent, nous voulons remanier ce
code pour qu'il n'appelle la fonction <code>simuler_gros_calcul</code> qu'une seule fois.
Nous voulons Ã©galement nous dÃ©barrasser de l'endroit oÃ¹ nous appelons la
fonction deux fois inutilement, sans ajouter d'autres appels Ã  cette fonction au
cours de ce processus. Autrement dit, nous ne voulons pas l'appeler si le
rÃ©sultat n'en a pas besoin, et nous voulons faire l'appeler qu'une seule fois au
maximum.</p>
<!--
#### Refactoring Using Functions
-->
<h4><a class="header" href="#remaniement-en-utilisant-des-fonctions" id="remaniement-en-utilisant-des-fonctions">Remaniement en utilisant des fonctions</a></h4>
<!--
We could restructure the workout program in many ways. First, weâ€™ll try
extracting the duplicated call to the `simulated_expensive_calculation`
function into a variable, as shown in Listing 13-4.
-->
<p>Nous pourrions restructurer le programme d'entraÃ®nement de plusieurs maniÃ¨res.
Tout d'abord, nous allons essayer d'extraire l'appel en double Ã  la fonction
<code>simuler_gros_calcul</code> dans une variable, comme dans l'encart 13-4Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_result);
        println!("Next, do {} situps!", expensive_result);
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!("Today, run for {} minutes!", expensive_result);
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul trÃ¨s lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let resultat_lent = simuler_gros_calcul(intensite);

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompesÂ !&quot;, resultat_lent);
        println!(&quot;Ensuite, faire {} abdominauxÂ !&quot;, resultat_lent);
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'huiÂ ! Rappelez-vous de bien vous hydraterÂ !&quot;);
        } else {
            println!(&quot;Aujourd'hui, courrez pendant {} minutesÂ !&quot;, resultat_lent);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-4: Extracting the calls to
`simulated_expensive_calculation` to one place and storing the result in the
`expensive_result` variable</span>
-->
<p><span class="caption">Encart 13-4Â : extraction des appels Ã 
<code>simuler_gros_calcul</code> dans un seul endroit et stockage du rÃ©sultat dans la
variable <code>resultat_lent</code>.</span></p>
<!--
This change unifies all the calls to `simulated_expensive_calculation` and
solves the problem of the first `if` block unnecessarily calling the function
twice. Unfortunately, weâ€™re now calling this function and waiting for the
result in all cases, which includes the inner `if` block that doesnâ€™t use the
result value at all.
-->
<p>Ce changement unifie tous les appels Ã  <code>simuler_gros_calcul</code> et rÃ©sout le
problÃ¨me du premier bloc <code>if</code> qui appelle inutilement la fonction Ã  deux
reprises. Malheureusement, nous appelons maintenant cette fonction et attendons
le rÃ©sultat dans tous les cas, ce qui inclut le bloc <code>if</code> interne qui n'utilise
pas du tout la valeur du rÃ©sultat.</p>
<!--
We want to define code in one place in our program, but only *execute* that
code where we actually need the result. This is a use case for closures!
-->
<p>Nous voulons dÃ©finir ce code Ã  un seul endroit dans notre programme, mais
<em>exÃ©cuter</em> ce code uniquement oÃ¹ nous avons rÃ©ellement besoin du rÃ©sultat.
C'est un cas d'utilisation des fermeturesÂ !</p>
<!--
#### Refactoring with Closures to Store Code
-->
<h4><a class="header" href="#remanier-le-code-avec-des-fermetures-pour-stocker-du-code" id="remanier-le-code-avec-des-fermetures-pour-stocker-du-code">Remanier le code avec des fermetures pour stocker du code</a></h4>
<!--
Instead of always calling the `simulated_expensive_calculation` function before
the `if` blocks, we can define a closure and store the *closure* in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of `simulated_expensive_calculation` within
the closure weâ€™re introducing here.
-->
<p>Au lieu d'appeler systÃ©matiquement la fonction <code>simuler_gros_calcul</code> avant
les blocs <code>if</code>, nous pouvons dÃ©finir une fermeture et la stocker dans une
variable au lieu de le faire pour le rÃ©sultat, comme le montre l'encart 13-5.
Nous pouvons en fait dÃ©placer l'ensemble du corps de <code>simuler_gros_calcul</code> dans
la fermeture que nous introduisons ici.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
# 
#     if intensity < 25 {
#         println!("Today, do {} pushups!", expensive_closure(intensity));
#         println!("Next, do {} situps!", expensive_closure(intensity));
#     } else {
#         if random_number == 3 {
#             println!("Take a break today! Remember to stay hydrated!");
#         } else {
#             println!(
#                 "Today, run for {} minutes!",
#                 expensive_closure(intensity)
#             );
#         }
#     }
# }
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
</span>    let fermeture_lente = |nombre| {
        println!(&quot;calcul trÃ¨s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };
<span class="boring">
</span><span class="boring">    if intensite &lt; 25 {
</span><span class="boring">        println!(&quot;Aujourd'hui, faire {} pompesÂ !&quot;, fermeture_lente(intensite));
</span><span class="boring">        println!(&quot;Ensuite, faire {} abdominauxÂ !&quot;, fermeture_lente(intensite));
</span><span class="boring">    } else {
</span><span class="boring">        if nombre_aleatoire == 3 {
</span><span class="boring">            println!(&quot;Faites une pause aujourd'huiÂ ! Rappelez-vous de bien vous hydraterÂ !&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Aujourd'hui, courrez pendant {} minutesÂ !&quot;,
</span><span class="boring">                fermeture_lente(intensite)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-5: Defining a closure and storing it in the
`expensive_closure` variable</span>
-->
<p><span class="caption">Encart 13-5Â : dÃ©finition d'une fermeture et son
enregistrement dans la variable <code>fermeture_lente</code>.</span></p>
<!--
The closure definition comes after the `=` to assign it to the variable
`expensive_closure`. To define a closure, we start with a pair of vertical
pipes (`|`), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named `num`: if we had more than one
parameter, we would separate them with commas, like `|param1, param2|`.
-->
<p>La dÃ©finition de la fermeture vient aprÃ¨s le <code>=</code> pour l'assigner Ã  la variable
<code>fermeture_lente</code>. Pour dÃ©finir une fermeture, on commence par une paire de
barres verticales (<code>|</code>), Ã  l'intÃ©rieur desquelles on renseigne les paramÃ¨tres de
la fermetureÂ ; cette syntaxe a Ã©tÃ© choisie en raison de sa similitude avec les
dÃ©finitions des fermetures en Smalltalk et en Ruby. Cette fermeture a un
paramÃ¨tre <code>nombre</code>Â : si nous avions plus d'un paramÃ¨tre, nous les sÃ©parerions
par des virgules, comme <code>|param1, param2|</code>.</p>
<!--
After the parameters, we place curly brackets that hold the body of the
closureâ€”these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
`let` statement. The value returned from the last line in the closure body
(`num`) will be the value returned from the closure when itâ€™s called, because
that line doesnâ€™t end in a semicolon; just as in function bodies.
-->
<p>AprÃ¨s les paramÃ¨tres, on ajoute des accolades qui contiennent le corps de la
fermeture, celles-ci sont facultatives si le corps de la fermeture est une seule
expression. AprÃ¨s les accolades, nous avons besoin d'un point-virgule
pour terminer l'instruction <code>let</code>. La valeur Ã  la derniÃ¨re ligne dans le corps
de la fermeture (<code>nombre</code>) sera la valeur retournÃ©e par la fermeture lorsqu'elle
sera exÃ©cutÃ©e, et cette ligne ne se termine pas par un point-virgule, exactement
comme dans le corps des fonctions.</p>
<!--
Note that this `let` statement means `expensive_closure` contains the
*definition* of an anonymous function, not the *resulting value* of calling the
anonymous function. Recall that weâ€™re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in `expensive_closure`.
-->
<p>Notez que cette instruction <code>let</code> signifie que la variable <code>fermeture_lente</code>
contient la <em>dÃ©finition</em> d'une fonction anonyme, pas la <em>valeur rÃ©sultante</em> Ã 
l'appel de cette fonction anonyme. Rappelons que nous utilisons une fermeture
pour dÃ©finir le code Ã  appeler dans un seul endroit, stocker ce code, et
l'appeler plus tardÂ ; le code que nous voulons appeler est maintenant stockÃ©
dans <code>fermeture_lente</code>.</p>
<!--
With the closure defined, we can change the code in the `if` blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6.
-->
<p>Maintenant que nous avons dÃ©fini la fermeture, nous pouvons changer le code dans
les blocs <code>if</code> pour appeler la fermeture afin d'exÃ©cuter le code et obtenir la
valeur rÃ©sultante. L'appel d'une fermeture fonctionne comme pour l'appel d'une
fonctionÂ : nous renseignons le nom de la variable qui stocke la dÃ©finition de la
fermeture et la complÃ©tons avec des parenthÃ¨ses contenant les valeurs du ou des
arguments que nous voulons utiliser pour cet appel, comme dans l'encart 13-6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let fermeture_lente = |nombre| {
        println!(&quot;calcul trÃ¨s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompesÂ !&quot;, fermeture_lente(intensite));
        println!(&quot;Ensuite, faire {} abdominauxÂ !&quot;, fermeture_lente(intensite));
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'huiÂ ! Rappelez-vous de bien vous hydraterÂ !&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutesÂ !&quot;,
                fermeture_lente(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-6: Calling the `expensive_closure` weâ€™ve
defined</span>
-->
<p><span class="caption">Encart 13-6Â : appel de la fermeture <code>fermeture_lente</code>
que nous avons dÃ©fini</span></p>
<!--
Now the expensive calculation is called in only one place, and weâ€™re only
executing that code where we need the results.
-->
<p>Maintenant, le calcul lent n'est appelÃ© qu'Ã  un seul endroit, et nous
n'exÃ©cutons ce code uniquement oÃ¹ nous avons besoin des rÃ©sultats.</p>
<!--
However, weâ€™ve reintroduced one of the problems from Listing 13-3: weâ€™re still
calling the closure twice in the first `if` block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that `if` block to hold
the result of calling the closure, but closures provide us with another
solution. Weâ€™ll talk about that solution in a bit. But first letâ€™s talk about
why there arenâ€™t type annotations in the closure definition and the traits
involved with closures.
-->
<p>Cependant, nous avons rÃ©introduit l'un des problÃ¨mes de l'encart 13-3Â : nous
continuons d'appeler la fermeture deux fois dans le premier bloc <code>if</code>, qui
appellera le code lent Ã  deux reprises et fera attendre l'utilisateur deux fois
plus longtemps que nÃ©cessaire. Nous pourrions rÃ©soudre ce problÃ¨me en crÃ©ant une
variable locale Ã  ce bloc <code>if</code> pour conserver le rÃ©sultat de l'appel Ã  la
fermeture, mais les fermetures nous ouvrent d'autres solutions. CommenÃ§ons
d'abord par expliquer pourquoi il n'y a pas d'annotation de type dans la
dÃ©finition des fermetures et les traits liÃ©s aux fermetures.</p>
<!--
### Closure Type Inference and Annotation
-->
<h3><a class="header" href="#linfÃ©rence-de-type-et-lannotation-des-fermetures" id="linfÃ©rence-de-type-et-lannotation-des-fermetures">L'infÃ©rence de type et l'annotation des fermetures</a></h3>
<!--
Closures donâ€™t require you to annotate the types of the parameters or the
return value like `fn` functions do. Type annotations are required on functions
because theyâ€™re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures arenâ€™t used in an
exposed interface like this: theyâ€™re stored in variables and used without
naming them and exposing them to users of our library.
-->
<p>Les fermetures ne nÃ©cessitent pas d'annoter le type des paramÃ¨tres ou de la
valeur de retour comme le font les fonctions <code>fn</code>. Les annotations de type sont
nÃ©cessaires pour les fonctions, car elles font partie d'une interface explicite
exposÃ©e Ã  leurs utilisateurs. DÃ©finir cette interface de maniÃ¨re rigide est
nÃ©cessaire pour s'assurer que tout le monde s'accorde sur les types de valeurs
qu'une fonction utilise et retourne. Mais les fermetures ne sont pas utilisÃ©es
dans une interface exposÃ©e ainsiÂ : elles sont stockÃ©es dans des variables et
utilisÃ©es sans les nommer ni les exposer aux utilisateurs de notre bibliothÃ¨que.</p>
<!--
Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how itâ€™s able to infer the types of most variables.
-->
<p>En outre, les fermetures sont gÃ©nÃ©ralement brÃ¨ves et ne sont pertinentes que
dans un contexte prÃ©cis plutÃ´t que pour des cas gÃ©nÃ©riques. Dans ce contexte
prÃ©cis, le compilateur est capable de dÃ©duire le type des paramÃ¨tres et le type
de retour, comme il est capable d'infÃ©rer le type de la plupart des variables.</p>
<!--
Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.
-->
<p>Demander aux dÃ©veloppeurs d'annoter le type dans ces petites fonctions anonymes
serait ennuyant et largement redondant avec l'information dont dispose dÃ©jÃ  le
compilateur.</p>
<!--
As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7.
-->
<p>Comme pour les variables, nous pouvons ajouter des annotations de type si nous
voulons rendre explicite et clarifier le code au risque d'Ãªtre plus verbeux que
ce qui est strictement nÃ©cessaire. Annoter les types de la fermeture que nous
avons dÃ©fini dans l'encart 13-5 ressemblerait Ã  l'encart 13-7.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
# 
#     if intensity < 25 {
#         println!("Today, do {} pushups!", expensive_closure(intensity));
#         println!("Next, do {} situps!", expensive_closure(intensity));
#     } else {
#         if random_number == 3 {
#             println!("Take a break today! Remember to stay hydrated!");
#         } else {
#             println!(
#                 "Today, run for {} minutes!",
#                 expensive_closure(intensity)
#             );
#         }
#     }
# }
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
</span>    let fermeture_lente = |nombre: u32| -&gt; u32 {
        println!(&quot;calcul trÃ¨s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };
<span class="boring">
</span><span class="boring">    if intensite &lt; 25 {
</span><span class="boring">        println!(&quot;Aujourd'hui, faire {} pompesÂ !&quot;, fermeture_lente(intensite));
</span><span class="boring">        println!(&quot;Ensuite, faire {} abdominauxÂ !&quot;, fermeture_lente(intensite));
</span><span class="boring">    } else {
</span><span class="boring">        if nombre_aleatoire == 3 {
</span><span class="boring">            println!(&quot;Faites une pause aujourd'huiÂ ! Rappelez-vous de bien vous hydraterÂ !&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Aujourd'hui, courrez pendant {} minutesÂ !&quot;,
</span><span class="boring">                fermeture_lente(intensite)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span>
-->
<p><span class="caption">Encart 13-7Â : ajout d'annotations de type optionnelles sur
les paramÃ¨tres et les valeurs de retour de la fermeture</span></p>
<!--
With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. Weâ€™ve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:
-->
<p>La syntaxe des fermetures et des fonctions semble plus similaire avec les
annotations de type. Ce qui suit est une comparaison verticale entre la syntaxe
d'une dÃ©finition d'une fonction qui ajoute 1 Ã  son paramÃ¨tre, et d'une fermeture
qui a le mÃªme comportement. Nous avons ajoutÃ© des espaces pour aligner les
parties pertinentes. Ceci met en Ã©vidence la similaritÃ© entre la syntaxe des
fermetures et celle des fonctions, hormis l'utilisation des barres verticales
et certaines syntaxes facultativesÂ :</p>
<!--
```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```
-->
<pre><code class="language-rust ignore">fn  ajouter_un_v1   (x: u32) -&gt; u32 { x + 1 }
let ajouter_un_v2 = |x: u32| -&gt; u32 { x + 1 };
let ajouter_un_v3 = |x|             { x + 1 };
let ajouter_un_v4 = |x|               x + 1  ;
</code></pre>
<!--
The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when theyâ€™re called. Calling
the closures is required for `add_one_v3` and `add_one_v4` to be able to
compile because the types will be inferred from their usage.
-->
<p>La premiÃ¨re ligne affiche la dÃ©finition d'une fonction et la deuxiÃ¨me ligne une
dÃ©finition d'une fermeture entiÃ¨rement annotÃ©e. La troisiÃ¨me ligne supprime les
annotations de type de la dÃ©finition de la fermeture, et la quatriÃ¨me ligne
supprime les accolades qui sont facultatives, parce que le corps d'une fermeture
n'a qu'une seule expression. Ce sont toutes des dÃ©finitions valides qui
suivront le mÃªme comportement lorsqu'on les appellera. L'appel aux fermetures
est nÃ©cessaire pour que <code>ajouter_un_v3</code> et <code>ajouter_un_v4</code> puisse Ãªtre compilÃ©s
car les types seront dÃ©duits en fonction de leur utilisation.</p>
<!--
Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isnâ€™t very useful except for the purposes of this
example. Note that we havenâ€™t added any type annotations to the definition: if
we then try to call the closure twice, using a `String` as an argument the
first time and a `u32` the second time, weâ€™ll get an error.
-->
<p>Les dÃ©finitions des fermetures auront un type concret dÃ©duit pour chacun de
leurs paramÃ¨tres et pour leur valeur de retour. Par exemple, l'encart 13-8
montre la dÃ©finition d'une petite fermeture qui renvoie simplement la valeur
qu'elle reÃ§oit comme paramÃ¨tre. Cette fermeture n'est pas trÃ¨s utile sauf pour
les besoins de cet exemple. Notez que nous n'avons pas ajoutÃ© d'annotations de
type Ã  la dÃ©finitionÂ : si nous essayons alors d'appeler la fermeture deux fois,
en utilisant une <code>String</code> comme argument la premiÃ¨re fois et un <code>u32</code> la
deuxiÃ¨me fois, nous obtiendrons une erreurÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let fermeture_exemple = |x| x;

    let s = fermeture_exemple(String::from(&quot;hello&quot;));
    let n = fermeture_exemple(5);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span>
-->
<p><span class="caption">Encart 13-8Â : tentative d'appeler une fermeture dont les
types sont dÃ©duits avec deux types diffÃ©rents</span></p>
<!--
The compiler gives us this error:
-->
<p>Le compilateur nous renvoie l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 -- > src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `std::string::String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = fermeture_exemple(5);
  |                               ^
  |                               |
  |                               expected struct `std::string::String`, found integer
  |                               help: try using a conversion method: `5.to_string()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The first time we call `example_closure` with the `String` value, the compiler
infers the type of `x` and the return type of the closure to be `String`. Those
types are then locked in to the closure in `example_closure`, and we get a type
error if we try to use a different type with the same closure.
-->
<p>La premiÃ¨re fois que nous appelons <code>fermeture_exemple</code> avec une <code>String</code>, le
compilateur dÃ©duit que le type de <code>x</code> et le type de retour de la fermeture sont
de type <code>String</code>. Ces types sont ensuite verrouillÃ©s dans <code>fermeture_exemple</code>,
et nous obtenons une erreur de type si nous essayons d'utiliser un type
diffÃ©rent avec la mÃªme fermeture.</p>
<!--
### Storing Closures Using Generic Parameters and the `Fn` Traits
-->
<h3><a class="header" href="#stockage-des-fermetures-avec-des-paramÃ¨tres-gÃ©nÃ©riques-et-le-trait-fn" id="stockage-des-fermetures-avec-des-paramÃ¨tres-gÃ©nÃ©riques-et-le-trait-fn">Stockage des fermetures avec des paramÃ¨tres gÃ©nÃ©riques et le trait <code>Fn</code></a></h3>
<!--
Letâ€™s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.
-->
<p>Revenons Ã  notre application de gÃ©nÃ©ration d'entraÃ®nements. Dans l'encart 13-6,
notre code appelait toujours la fermeture lente plus de fois que nÃ©cessaire. Une
option pour rÃ©soudre ce problÃ¨me est de sauvegarder le rÃ©sultat de la fermeture
lente dans une variable pour une future utilisation et d'utiliser la variable Ã 
chaque endroit oÃ¹ nous en avons besoin au lieu de rappeler la fermeture Ã 
nouveau. Cependant, cette mÃ©thode pourrait donner lieu Ã  du code trÃ¨s rÃ©pÃ©tÃ©.</p>
<!--
Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesnâ€™t have to be
responsible for saving and reusing the result. You may know this pattern as
*memoization* or *lazy evaluation*.
-->
<p>Heureusement, une autre solution s'offre Ã  nous. Nous pouvons crÃ©er une
structure qui stockera la fermeture et la valeur qui en rÃ©sulte. La structure
n'exÃ©cutera la fermeture uniquement si nous avons besoin de la valeur
rÃ©sultante, et elle mettra en cache la valeur rÃ©sultante pour que le reste de
notre code ne soit pas en charge de sauvegarder et de la rÃ©utiliser le rÃ©sultat.
Vous connaissez peut-Ãªtre cette technique sous le nom de <em>mÃ©moÃ¯sation</em> ou
<em>d'Ã©valuation paresseuse</em>.</p>
<!--
To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.
-->
<p>Pour faire en sorte qu'une structure dÃ©tienne une fermeture, il faut prÃ©ciser
le type de fermeture, car une dÃ©finition de structure a besoin de connaÃ®tre les
types de chacun de ses champs. Chaque instance de fermeture a son propre type
anonyme uniqueÂ : cela signifie que mÃªme si deux fermetures ont la mÃªme
signature, leurs types sont toujours considÃ©rÃ©s comme diffÃ©rents. Pour dÃ©finir
des structures, des enumÃ©rations ou des paramÃ¨tres de fonction qui utilisent des
fermetures, nous utilisons des gÃ©nÃ©riques et des traits liÃ©s, comme nous
l'avons vu au chapitre 10.</p>
<!--
The `Fn` traits are provided by the standard library. All closures implement at
least one of the traits: `Fn`, `FnMut`, or `FnOnce`. Weâ€™ll discuss the
difference between these traits in the [â€œCapturing the Environment with
Closuresâ€](#capturing-the-environment-with-closures)<!-- ignore -- > section; in
this example, we can use the `Fn` trait.
-->
<p>Les traits <code>Fn</code> sont fournis par la bibliothÃ¨que standard. Toutes les fermetures
implÃ©mentent au moins un des traits suivantsÂ : <code>Fn</code>, <code>FnMut</code>, ou <code>FnOnce</code>. Nous
verrons la diffÃ©rence entre ces traits dans la section
<a href="ch13-01-closures.html#capturer-lenvironnement-avec-les-fermetures">â€œCapturer l'environnement avec les
fermeturesâ€</a><!-- ignore -->Â ; dans
cet exemple, nous pouvons utiliser le trait <code>Fn</code>.</p>
<!--
We add types to the `Fn` trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type `u32` and returns a `u32`, so the
trait bound we specify is `Fn(u32) -> u32`.
-->
<p>Nous ajoutons des types au trait liÃ© <code>Fn</code> pour reprÃ©senter les types de
paramÃ¨tres et les valeurs de retour que les fermetures doivent avoir pour
correspondre Ã  ce trait liÃ©. Dans ce cas, notre fermeture a un paramÃ¨tre de type
<code>u32</code> et renvoie un <code>u32</code>, le trait liÃ© que nous prÃ©cisons est donc
<code>Fn (u32) -&gt; u32</code>.</p>
<!--
Listing 13-9 shows the definition of the `Cacher` struct that holds a closure
and an optional result value.
-->
<p>L'encart 13-9 montre la dÃ©finition de la structure <code>Cache</code> qui possÃ¨de une
fermeture et une valeur de rÃ©sultat optionnelleÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    value: Option<u32>,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Cache&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calcul: T,
    valeur: Option&lt;u32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-9: Defining a `Cacher` struct that holds a
closure in `calculation` and an optional result in `value`</span>
-->
<p><span class="caption">Encart 13-9Â : dÃ©finition d'une structure <code>Cache</code> qui
possÃ¨de une fermeture dans <code>calcul</code> et un rÃ©sultat facultatif dans <code>valeur</code>.
</span></p>
<!--
The `Cacher` struct has a `calculation` field of the generic type `T`. The
trait bounds on `T` specify that itâ€™s a closure by using the `Fn` trait. Any
closure we want to store in the `calculation` field must have one `u32`
parameter (specified within the parentheses after `Fn`) and must return a
`u32` (specified after the `->`).
-->
<p>La structure <code>Cache</code> a un champ <code>calcul</code> du type gÃ©nÃ©rique <code>T</code>. Le trait liÃ© <code>T</code>
prÃ©cise que c'est une fermeture en utilisant le trait <code>Fn</code>. Toute fermeture que
l'on veut stocker dans le champ <code>calcul</code> doit avoir un paramÃ¨tre <code>u32</code> (ce qui
est prÃ©cisÃ© entre parenthÃ¨se aprÃ¨s le <code>Fn</code>) et doit retourner un <code>u32</code> (ce qui
est prÃ©cisÃ© aprÃ¨s le <code>-&gt;</code>).</p>
<!--
> Note: Functions can implement all three of the `Fn` traits too. If what we
> want to do doesnâ€™t require capturing a value from the environment, we can use
> a function rather than a closure where we need something that implements an
> `Fn` trait.
-->
<blockquote>
<p>RemarqueÂ : les fonctions implÃ©mentent aussi tous les trois traits <code>Fn</code>. Si ce
que nous voulons faire n'a pas besoin de capturer une valeur de
l'environnement, nous pouvons utiliser une fonction plutÃ´t qu'une fermeture oÃ¹
nous avons besoin de quelque chose qui implÃ©mente un trait <code>Fn</code>.</p>
</blockquote>
<!--
The `value` field is of type `Option<u32>`. Before we execute the closure,
`value` will be `None`. When code using a `Cacher` asks for the *result* of the
closure, the `Cacher` will execute the closure at that time and store the
result within a `Some` variant in the `value` field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
`Cacher` will return the result held in the `Some` variant.
-->
<p>Le champ <code>valeur</code> est de type <code>Option&lt;u32&gt;</code>. Avant d'exÃ©cuter la fermeture,
<code>valeur</code> sera initialisÃ©e Ã  <code>None</code>. Lorsque du code utilisant un <code>Cache</code> demande
le <em>rÃ©sultat</em> de la fermeture, le <code>Cache</code> exÃ©cutera la fermeture Ã  ce moment-lÃ 
et stockera le rÃ©sultat dans une variante <code>Some</code> dans le champ <code>valeur</code>.
Ensuite, si le code demande Ã  nouveau le rÃ©sultat de la fermeture, le <code>Cache</code>
renverra le rÃ©sultat contenu dans la variante <code>Some</code> au lieu d'exÃ©cuter Ã 
nouveau la fermeture.</p>
<!--
The logic around the `value` field weâ€™ve just described is defined in Listing
13-10.
-->
<p>La logique autour du champ <code>valeur</code> que nous venons de dÃ©crire est dÃ©finie dans
l'encart 13-10Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cache&lt;T&gt;
where
    T: Fn(u32) -&gt; u32
{
    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
        Cache {
            calcul,
            valeur: None,
        }
    }

    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
        match self.valeur {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calcul)(arg);
                self.valeur = Some(v);
                v
            },
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-10: The caching logic of `Cacher`</span>
-->
<p><span class="caption">Encart 13-10Â : la logique de <code>Cache</code></span></p>
<!--
We want `Cacher` to manage the struct fieldsâ€™ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.
-->
<p>Nous voulons que <code>Cache</code> gÃ¨re les valeurs des champs de structure plutÃ´t que de
laisser la possibilitÃ© au code appelant la possibilitÃ© de modifier directement
les valeurs dans ces champs, donc nous faisons en sorte que ces champs soient
privÃ©s.</p>
<!--
The `Cacher::new` function takes a generic parameter `T`, which weâ€™ve defined
as having the same trait bound as the `Cacher` struct. Then `Cacher::new`
returns a `Cacher` instance that holds the closure specified in the
`calculation` field and a `None` value in the `value` field, because we havenâ€™t
executed the closure yet.
-->
<p>La fonction <code>Cache::new</code> prend un paramÃ¨tre gÃ©nÃ©rique <code>T</code>, que nous avons
dÃ©fini comme ayant le mÃªme trait liÃ© que la structure <code>Cache</code>. Puis <code>Cache::new</code>
renvoie une instance <code>Cache</code> qui contient la fermeture prÃ©sente dans le champ
<code>calcul</code> et une valeur <code>None</code> dans le champ <code>valeur</code>, car nous n'avons pas
encore exÃ©cutÃ© la fermeture.</p>
<!--
When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the `value` method. This method
checks whether we already have a resulting value in `self.value` in a `Some`;
if we do, it returns the value within the `Some` without executing the closure
again.
-->
<p>Lorsque le code appelant veut le rÃ©sultat de l'exÃ©cution de la fermeture, au
lieu d'appeler directement la fermeture, il appellera la mÃ©thode <code>valeur</code>. Cette
mÃ©thode vÃ©rifie si nous avons dÃ©jÃ  une valeur dans un <code>Some</code> dans
<code>self.valeur</code>Â ; et si c'est le cas, elle renvoie la valeur contenue dans le
<code>Some</code> sans exÃ©cuter de nouveau la fermeture.</p>
<!--
If `self.value` is `None`, the code calls the closure stored in
`self.calculation`, saves the result in `self.value` for future use, and
returns the value as well.
-->
<p>Si <code>self.valeur</code> est <code>None</code>, nous appelons la fermeture stockÃ©e dans
<code>self.calcul</code>, et nous sauvegardons le rÃ©sultat dans <code>self.valeur</code> pour une
utilisation future, puis nous retournons la valeur.</p>
<!--
Listing 13-11 shows how we can use this `Cacher` struct in the function
`generate_workout` from Listing 13-6.
-->
<p>L'encart 13-11 montre comment utiliser cette structure <code>Cache</code> dans la fonction
<code>generer_exercices</code> de l'encart 13-6Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
# impl<T> Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     fn new(calculation: T) -> Cacher<T> {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
# 
#     fn value(&mut self, arg: u32) -> u32 {
#         match self.value {
#             Some(v) => v,
#             None => {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             }
#         }
#     }
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_result.value(intensity));
        println!("Next, do {} situps!", expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result.value(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
</span><span class="boring">        Cache {
</span><span class="boring">            calcul,
</span><span class="boring">            valeur: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.valeur {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calcul)(arg);
</span><span class="boring">                self.valeur = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let mut resultat_lent = Cache::new(|nombre| {
        println!(&quot;calcul trÃ¨s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    });

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompesÂ !&quot;, resultat_lent.valeur(intensite));
        println!(&quot;Ensuite, faire {} abdominauxÂ !&quot;, resultat_lent.valeur(intensite));
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'huiÂ ! Rappelez-vous de bien vous hydraterÂ !&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutesÂ !&quot;,
                resultat_lent.valeur(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-11: Using `Cacher` in the `generate_workout`
function to abstract away the caching logic</span>
-->
<p><span class="caption">Encart 13-11Â : utilisation de <code>Cache</code> dans la fonction
<code>generer_exercices</code> pour masquer la logique du cache.</span></p>
<!--
Instead of saving the closure in a variable directly, we save a new instance of
`Cacher` that holds the closure. Then, in each place we want the result, we
call the `value` method on the `Cacher` instance. We can call the `value`
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.
-->
<p>Au lieu de sauvegarder la fermeture dans une variable directement, nous
sauvegardons une nouvelle instance de <code>Cache</code> qui contient la fermeture.
Ensuite, Ã  chaque fois que nous voulons le rÃ©sultat, nous appelons la mÃ©thode
<code>valeur</code> sur cette instance de <code>Cache</code>. Nous pouvons appeler la mÃ©thode <code>valeur</code>
autant de fois que nous souhaitons, ou ne pas l'appeler du tout, et le calcul
lent sera exÃ©cutÃ© une fois au maximum.</p>
<!--
Try running this program with the `main` function from Listing 13-2. Change the
values in the `simulated_user_specified_value` and `simulated_random_number`
variables to verify that in all the cases in the various `if` and `else`
blocks, `calculating slowly...` appears only once and only when needed. The
`Cacher` takes care of the logic necessary to ensure we arenâ€™t calling the
expensive calculation more than we need to so `generate_workout` can focus on
the business logic.
-->
<p>Essayez d'exÃ©cuter ce programme avec la fonction <code>main</code> de l'encart 13-2.
Modifiez les valeurs des variables <code>valeur_utilisateur_simule</code> et
<code>nombre_aleatoire_simule</code> pour vÃ©rifier que dans tous les cas des diffÃ©rents
blocs <code>if</code> et <code>else</code>, <code>calcul trÃ¨s lent ...</code> n'apparaÃ®t qu'une seule fois et
seulement si nÃ©cessaire. Le <code>Cache</code> se charge de la logique nÃ©cessaire pour
s'assurer que nous n'appelons pas le calcul lent plus que nous n'en avons
besoin afin que <code>generer_exercices</code> puisse se concentrer sur la logique mÃ©tier.</p>
<!--
### Limitations of the `Cacher` Implementation
-->
<h3><a class="header" href="#limitations-de-limplÃ©mentation-de-cache" id="limitations-de-limplÃ©mentation-de-cache">Limitations de l'implÃ©mentation de <code>Cache</code></a></h3>
<!--
Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of `Cacher` that would make reusing it
in different contexts difficult.
-->
<p>La mise en cache des valeurs est un comportement gÃ©nÃ©ralement utile que nous
pourrions vouloir utiliser dans d'autres parties de notre code avec diffÃ©rentes
fermetures. Cependant, il y a deux problÃ¨mes avec l'implÃ©mentation actuelle de
<code>Cache</code> qui rendraient difficile sa rÃ©utilisation dans des contextes diffÃ©rents.</p>
<!--
The first problem is that a `Cacher` instance assumes it will always get the
same value for the parameter `arg` to the `value` method. That is, this test of
`Cacher` will fail:
-->
<p>Le premier problÃ¨me est qu'une instance de <code>Cache</code> suppose qu'elle obtienne
toujours la mÃªme valeur, indÃ©pendamment du paramÃ¨tre <code>arg</code> de la mÃ©thode
<code>valeur</code>. Autrement dit, ce test sur <code>Cache</code> Ã©choueraÂ :</p>
<!--
```rust,ignore,panics
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
# impl<T> Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     fn new(calculation: T) -> Cacher<T> {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
# 
#     fn value(&mut self, arg: u32) -> u32 {
#         match self.value {
#             Some(v) => v,
#             None => {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             }
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
</span><span class="boring">        Cache {
</span><span class="boring">            calcul,
</span><span class="boring">            valeur: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.valeur {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calcul)(arg);
</span><span class="boring">                self.valeur = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_avec_differentes_valeurs() {
        let mut c = Cache::new(|a| a);

        let v1 = c.valeur(1);
        let v2 = c.valeur(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}
</span></code></pre>
<!--
This test creates a new `Cacher` instance with a closure that returns the value
passed into it. We call the `value` method on this `Cacher` instance with an
`arg` value of 1 and then an `arg` value of 2, and we expect the call to
`value` with the `arg` value of 2 to return 2.
-->
<p>Ce test crÃ©Ã© une nouvelle instance de <code>Cache</code> avec une fermeture qui retourne
la valeur qui lui est passÃ©e. Nous appelons la mÃ©thode <code>valeur</code> sur cette
instance de <code>Cache</code> avec une valeur <code>arg</code> de 1 et ensuite une valeur <code>arg</code>
de 2, et nous nous attendons Ã  ce que l'appel Ã  <code>valeur</code> avec la valeur <code>arg</code>
de 2 devrait retourner 2.</p>
<!--
Run this test with the `Cacher` implementation in Listing 13-9 and Listing
13-10, and the test will fail on the `assert_eq!` with this message:
-->
<p>ExÃ©cutez ce test avec l'implÃ©mentation de <code>Cache</code> de l'encart 13-9 et de
l'encart 13-10, et le test Ã©chouera sur le <code>assert_eq!</code> avec ce messageÂ :</p>
<!--
```console
$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/cacher-4116485fb32b3fff

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/cacher-4116485fb32b3fff

running 1 test
test tests::appel_avec_differentes_valeurs ... FAILED

failures:

---- tests::appel_avec_differentes_valeurs stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::appel_avec_differentes_valeurs

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The problem is that the first time we called `c.value` with 1, the `Cacher`
instance saved `Some(1)` in `self.value`. Thereafter, no matter what we pass in
to the `value` method, it will always return 1.
-->
<p>Le problÃ¨me est que la premiÃ¨re fois que nous avons appelÃ© <code>c.valeur</code> avec 1,
l'instance <code>Cache</code> a sauvegardÃ© <code>Some(1)</code> dans <code>self.valeur</code>. Par la suite, peu
importe ce que nous passons Ã  la mÃ©thode <code>valeur</code>, elle retournera toujours 1.</p>
<!--
Try modifying `Cacher` to hold a hash map rather than a single value. The keys
of the hash map will be the `arg` values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether `self.value` directly has a `Some` or a `None` value, the
`value` function will look up the `arg` in the hash map and return the value if
itâ€™s present. If itâ€™s not present, the `Cacher` will call the closure and save
the resulting value in the hash map associated with its `arg` value.
-->
<p>Essayez de modifier <code>Cache</code> pour tenir une table de hachage plutÃ´t qu'une seule
valeur. Les clÃ©s de la table de hachage seront les valeurs <code>arg</code> qui lui sont
passÃ©es, et les valeurs de la table de hachage seront le rÃ©sultat de l'appel Ã 
la fermeture avec cette clÃ©. PlutÃ´t que de regarder directement si <code>self.valeur</code>
a une valeur <code>Some</code> ou une valeur <code>None</code>, la fonction <code>valeur</code> recherchera <code>arg</code>
dans la table de hachage et retournera la valeur si elle est prÃ©sente. S'il
n'est pas prÃ©sent, le <code>Cache</code> appellera la fermeture et sauvegardera la valeur
rÃ©sultante dans la table de hachage associÃ©e Ã  sa clÃ©e <code>arg</code>.</p>
<!--
The second problem with the current `Cacher` implementation is that it only
accepts closures that take one parameter of type `u32` and return a `u32`. We
might want to cache the results of closures that take a string slice and return
`usize` values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the `Cacher` functionality.
-->
<p>Le second problÃ¨me avec l'implÃ©mentation actuelle de <code>Cache</code> est qu'il n'accepte
que les fermetures qui prennent un paramÃ¨tre de type <code>u32</code> et renvoient un
<code>u32</code>. Nous pourrions vouloir mettre en cache les rÃ©sultats des fermetures qui
prennent une slice d'une chaÃ®ne de caractÃ¨res et renvoient des valeurs <code>usize</code>,
par exemple. Pour corriger ce problÃ¨me, essayez d'introduire des paramÃ¨tres plus
gÃ©nÃ©riques pour augmenter la flexibilitÃ© de la fonctionnalitÃ© offerte par
<code>Cache</code>.</p>
<!--
### Capturing the Environment with Closures
-->
<h3><a class="header" href="#capturer-lenvironnement-avec-les-fermetures" id="capturer-lenvironnement-avec-les-fermetures">Capturer l'environnement avec les fermetures</a></h3>
<!--
In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions donâ€™t
have: they can capture their environment and access variables from the scope in
which theyâ€™re defined.
-->
<p>Dans l'exemple du gÃ©nÃ©rateur d'entraÃ®nement, nous n'avons utilisÃ© les fermetures
uniquement comme des fonctions anonymes internes. Cependant, les fermetures ont
une capacitÃ© supplÃ©mentaire que les fonctions n'ont pasÂ : elles peuvent capturer
leur environnement et accÃ©der aux variables de la portÃ©e dans laquelle elles
sont dÃ©finies.</p>
<!--
Listing 13-12 has an example of a closure stored in the `equal_to_x` variable
that uses the `x` variable from the closureâ€™s surrounding environment.
-->
<p>L'encart 13-12 montre un exemple de fermeture stockÃ©e dans la variable
<code>egal_a_x</code> qui utilise la variable <code>x</code> de l'environnement environnant de la
fermetureÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let egal_a_x = |z| z == x;

    let y = 4;

    assert!(egal_a_x(y));
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span>
-->
<p><span class="caption">Encart 13-12Â : exemple d'une fermeture qui rÃ©fÃ¨re Ã  une
variable prÃ©sente dans la portÃ©e qui la contient.</span></p>
<!--
Here, even though `x` is not one of the parameters of `equal_to_x`, the
`equal_to_x` closure is allowed to use the `x` variable thatâ€™s defined in the
same scope that `equal_to_x` is defined in.
-->
<p>Ici, mÃªme si <code>x</code> n'est pas un des paramÃ¨tres de <code>egal_a_x</code>, la fermeture
<code>egal_a_x</code> est autorisÃ©e Ã  utiliser la variable <code>x</code> dÃ©finie dans la mÃªme
portÃ©e oÃ¹ est dÃ©finie <code>egal_a_x</code>.</p>
<!--
We canâ€™t do the same with functions; if we try with the following example, our
code wonâ€™t compile:
-->
<p>Nous ne pouvons pas faire la mÃªme chose avec les fonctionsÂ ; si nous essayons
avec l'exemple suivant, notre code ne se compilera pasÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -> bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 4;

    fn egal_a_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(egal_a_x(y));
}
</code></pre>
<!--
We get an error:
-->
<p>Nous obtenons l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 -- > src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The compiler even reminds us that this only works with closures!
-->
<p>Le compilateur nous rappelle mÃªme que cela ne fonctionne qu'avec les
fermeturesÂ !</p>
<!--
When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
donâ€™t want to pay in more common cases where we want to execute code that
doesnâ€™t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.
-->
<p>Lorsqu'une fermeture capture une valeur de son environnement, elle utilise la
mÃ©moire pour stocker les valeurs Ã  utiliser dans son corps. Cette utilisation de
la mÃ©moire a un coÃ»t supplÃ©mentaire que nous ne voulons pas payer dans les cas
les plus courants oÃ¹ nous voulons exÃ©cuter du code qui ne capture pas leur
environnement. Comme les fonctions ne sont jamais autorisÃ©es Ã  capturer leur
environnement, la dÃ©finition et l'utilisation des fonctions n'occasionneront
jamais cette surcharge.</p>
<!--
Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three `Fn` traits as follows:
-->
<p>Les fermetures peuvent capturer les valeurs de leur environnement de trois
faÃ§ons diffÃ©rentes, qui correspondent directement aux trois faÃ§ons dont une
fonction peut prendre un paramÃ¨treÂ : prendre possession, emprunter de maniÃ¨re
immuable et emprunter de maniÃ¨re mutable. Ces moyens sont codÃ©s dans les trois
traits <code>Fn</code> comme ceciÂ :</p>
<!--
* `FnOnce` consumes the variables it captures from its enclosing scope, known
  as the closureâ€™s *environment*. To consume the captured variables, the
  closure must take ownership of these variables and move them into the closure
  when it is defined. The `Once` part of the name represents the fact that the
  closure canâ€™t take ownership of the same variables more than once, so it can
  be called only once.
* `FnMut` can change the environment because it mutably borrows values.
* `Fn` borrows values from the environment immutably.
-->
<ul>
<li><code>FnOnce</code> consomme les variables qu'il capture Ã  partir de sa portÃ©e, connu
sous le nom de <em>l'environnement</em> de la fermeture. Pour consommer les variables
capturÃ©es, la fermeture doit prendre possession de ces variables et les
dÃ©placer dans la fermeture lorsqu'elle est dÃ©finie. La partie <code>Once</code> du nom
reprÃ©sente le fait que la fermeture ne puisse pas prendre prendre possession
des mÃªmes variables plus d'une fois, donc elle ne peut Ãªtre appelÃ©e qu'une
seule fois.</li>
<li><code>FnMut</code> peut changer l'environnement car elle emprunte des valeurs de maniÃ¨re
mutable.</li>
<li><code>Fn</code> emprunte des valeurs de l'environnement de maniÃ¨re immuable.</li>
</ul>
<!--
When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement `FnOnce`
because they can all be called at least once. Closures that donâ€™t move the
captured variables also implement `FnMut`, and closures that donâ€™t need mutable
access to the captured variables also implement `Fn`. In Listing 13-12, the
`equal_to_x` closure borrows `x` immutably (so `equal_to_x` has the `Fn` trait)
because the body of the closure only needs to read the value in `x`.
-->
<p>Lorsque nous crÃ©ons une fermeture, Rust dÃ©duit quel trait utiliser en se basant
sur la faÃ§on dont la fermeture utilise les valeurs de l'environnement. Toutes
les fermetures implÃ©mentent <code>FnOne</code> car elles peuvent toute Ãªtre appelÃ©es au
moins une fois. Les fermetures qui ne dÃ©placent pas les variables capturÃ©es
implÃ©mentent Ã©galement <code>FnMut</code>, et les fermetures qui n'ont pas besoin d'accÃ¨s
mutable aux variables capturÃ©es implÃ©mentent aussi <code>Fn</code>. Dans l'encart 13-12, la
fermeture <code>egal_a_x</code> emprunte <code>x</code> immuablement (donc <code>egal_a_x</code> a le trait <code>Fn</code>)
parce que le corps de la fermeture ne fait que lire la valeur de <code>x</code>.</p>
<!--
If you want to force the closure to take ownership of the values it uses in the
environment, you can use the `move` keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so itâ€™s owned by the new thread.
-->
<p>Si nous voulons forcer la fermeture Ã  prendre possession des valeurs qu'elle
utilise dans l'environnement, nous pouvons utiliser le mot-clÃ© <code>move</code> avant la
liste des paramÃ¨tres. Cette technique est trÃ¨s utile lorsque vous passez une
fermeture Ã  une nouvelle tÃ¢che pour dÃ©placer les donnÃ©es afin qu'elles
appartiennent Ã  la nouvelle tÃ¢che.</p>
<!--
Weâ€™ll have more examples of `move` closures in Chapter 16 when we talk about
concurrency. For now, hereâ€™s the code from Listing 13-12 with the `move`
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.
-->
<p>Nous aurons d'autres exemples de fermetures utilisant <code>move</code> au chapitre 16
lorsque nous parlerons de la concurrence. Pour l'instant, voici le code de
l'encart 13-12 avec le mot-clÃ© <code>move</code> ajoutÃ© Ã  la dÃ©finition de la fermeture et
utilisant des vecteurs au lieu d'entiers, car les entiers peuvent Ãªtre copiÃ©s
plutÃ´t que dÃ©placÃ©sÂ ; notez aussi que ce code ne compile pas encore.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let egal_a_x = move |z| z == x;

    println!(&quot;On ne peut pas utiliser x iciÂ : {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(egal_a_x(y));
}
</code></pre>
<!--
We receive the following error:
-->
<p>Nous obtenons l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 -- > src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!("can't use x here: {:?}", x);
  |                                        ^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let egal_a_x = move |z| z == x;
  |                    --------      - variable moved due to use in closure
  |                    |
  |                    value moved into closure here
5 | 
6 |     println!(&quot;On ne peut pas utiliser x iciÂ : {:?}&quot;, x);
  |                                                      ^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The `x` value is moved into the closure when the closure is defined, because we
added the `move` keyword. The closure then has ownership of `x`, and `main`
isnâ€™t allowed to use `x` anymore in the `println!` statement. Removing
`println!` will fix this example.
-->
<p>La valeur <code>x</code> est dÃ©placÃ©e dans la fermeture lorsque la fermeture est dÃ©finie,
parce que nous avons ajoutÃ© le mot-clÃ© <code>move</code>. La fermeture a alors la propriÃ©tÃ©
de <code>x</code>, et <code>main</code> n'est plus autorisÃ© Ã  utiliser <code>x</code> dans l'instruction
<code>println!</code>. Supprimer <code>println!</code> corrigera cet exemple.</p>
<!--
Most of the time when specifying one of the `Fn` trait bounds, you can start
with `Fn` and the compiler will tell you if you need `FnMut` or `FnOnce` based
on what happens in the closure body.
-->
<p>La plupart du temps, lorsque vous renseignez l'un des traits liÃ©s <code>Fn</code>, vous
pouvez commencer par <code>Fn</code> et le compilateur vous dira si vous avez besoin de
<code>FnMut</code> ou <code>FnOnce</code> en fonction de ce qui se passe dans le corps de la
fermeture.</p>
<!--
To illustrate situations where closures that can capture their environment are
useful as function parameters, letâ€™s move on to our next topic: iterators.
-->
<p>Pour illustrer les situations oÃ¹ des fermetures qui capturent leur
environnement sont utiles comme paramÃ¨tres de fonction, passons Ã  notre
sujet suivantÂ : les itÃ©rateurs.</p>
<!--
## Processing a Series of Items with Iterators
-->
<h2><a class="header" href="#traiter-une-sÃ©rie-dÃ©lÃ©ments-avec-un-itÃ©rateur" id="traiter-une-sÃ©rie-dÃ©lÃ©ments-avec-un-itÃ©rateur">Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></h2>
<!--
The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you donâ€™t
have to reimplement that logic yourself.
-->
<p>Les itÃ©rateurs vous permettent d'effectuer une tÃ¢che sur une sÃ©quence d'Ã©lÃ©ments
Ã  tour de rÃ´le. Un <em>itÃ©rateur</em> est responsable de la logique d'itÃ©ration sur
chaque Ã©lÃ©ment et de dÃ©terminer lorsque la sÃ©quence est terminÃ©e. Lorsque nous
utilisons des itÃ©rateurs, nous n'avons pas besoin de rÃ©-implÃ©menter cette
logique nous-mÃªmes.</p>
<!--
In Rust, iterators are *lazy*, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector `v1` by calling
the `iter` method defined on `Vec<T>`. This code by itself doesnâ€™t do anything
useful.
-->
<p>En Rust, un itÃ©rateur est <em>une Ã©valuation paresseuse</em>, ce qui signifie qu'il n'a
aucun effet jusqu'Ã  ce que nous appelions des mÃ©thodes qui consomment
l'itÃ©rateur pour l'utiliser. Par exemple, le code dans l'encart 13-13 crÃ©e un
itÃ©rateur sur les Ã©lÃ©ments du vecteur <code>v1</code> en appelant la mÃ©thode <code>iter</code> dÃ©finie
sur <code>Vec&lt;T&gt;</code>. Ce code en lui-mÃªme ne fait rien d'utile.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-13: Creating an iterator</span>
-->
<p><span class="caption">Encart 13-13Â : crÃ©ation d'un itÃ©rateur</span></p>
<!--
Once weâ€™ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with `for` loops to execute some code on
each item, although we glossed over what the call to `iter` did until now.
-->
<p>Une fois que nous avons crÃ©Ã© un itÃ©rateur, nous pouvons l'utiliser de diverses
maniÃ¨res. Dans l'encart 3-4 du chapitre 3, nous avions utilisÃ© des itÃ©rateurs
avec des boucles <code>for</code> pour exÃ©cuter du code sur chaque Ã©lÃ©ment, bien que nous
ayons laissÃ© de cÃ´tÃ© ce que l'appel Ã  <code>iter</code> faisait jusqu'Ã  prÃ©sent.</p>
<!--
The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the `for` loop. The iterator is stored in the `v1_iter`
variable, and no iteration takes place at that time. When the `for` loop is
called using the iterator in `v1_iter`, each element in the iterator is used in
one iteration of the loop, which prints out each value.
-->
<p>L'exemple dans l'encart 13-14 sÃ©pare la crÃ©ation de l'itÃ©rateur de son
utilisation dans la boucle <code>for</code>. L'itÃ©rateur est stockÃ© dans la variable
<code>v1_iter</code>, et aucune itÃ©ration n'a lieu Ã  ce moment-lÃ . Lorsque la boucle <code>for</code>
est appelÃ©e en utilisant l'itÃ©rateur <code>v1_iter</code>, chaque Ã©lÃ©ment de l'itÃ©rateur
est utilisÃ© Ã  chaque itÃ©ration de la boucle, qui affiche chaque valeur.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;On aÂ : {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-14: Using an iterator in a `for` loop</span>
-->
<p><span class="caption">Encart 13-14Â : utilisation d'un itÃ©rateur dans une boucle
<code>for</code></span></p>
<!--
In languages that donâ€™t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.
-->
<p>Dans les langages qui n'ont pas d'itÃ©rateurs fournis par leur bibliothÃ¨que
standard, nous Ã©cririons probablement cette mÃªme fonctionnalitÃ© en dÃ©marrant une
variable Ã  l'indice 0, utiliser cette variable comme indice sur le vecteur afin
d'obtenir une valeur, et incrÃ©menter la valeur de cette variable dans une boucle
jusqu'Ã  ce qu'elle atteigne le nombre total d'Ã©lÃ©ments dans le vecteur.</p>
<!--
Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Letâ€™s examine how iterators do that.
-->
<p>Les itÃ©rateurs s'occupent de toute cette logique pour nous, rÃ©duisant le code
redondant dans lequel nous pourrions potentiellement faire des erreurs. Les
itÃ©rateurs nous donnent plus de flexibilitÃ© pour utiliser la mÃªme logique avec
de nombreux types de sÃ©quences diffÃ©rentes, et non pas uniquement avec des
structures de donnÃ©es avec lesquelles nous pouvons utiliser des indices, comme
les vecteurs. Voyons comment les itÃ©rateurs font cela.</p>
<!--
### The `Iterator` Trait and the `next` Method
-->
<h3><a class="header" href="#le-trait-iterator-et-la-mÃ©thode-next" id="le-trait-iterator-et-la-mÃ©thode-next">Le trait <code>Iterator</code> et la mÃ©thode <code>next</code></a></h3>
<!--
All iterators implement a trait named `Iterator` that is defined in the
standard library. The definition of the trait looks like this:
-->
<p>Tous les itÃ©rateurs implÃ©mentent un trait appelÃ© <code>Iterator</code> qui est dÃ©fini dans
la bibliothÃ¨que standard. La dÃ©finition du trait ressemble Ã  ceciÂ :</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // les mÃ©thodes avec des implÃ©mentations par dÃ©faut ont Ã©tÃ© exclues
}
<span class="boring">}
</span></code></pre></pre>
<!--
Notice this definition uses some new syntax: `type Item` and `Self::Item`,
which are defining an *associated type* with this trait. Weâ€™ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the `Iterator` trait requires that you also define
an `Item` type, and this `Item` type is used in the return type of the `next`
method. In other words, the `Item` type will be the type returned from the
iterator.
-->
<p>Remarquez que cette dÃ©finition utilise une nouvelle syntaxeÂ : <code>type Item</code> et
<code>Self::Item</code>, qui dÃ©finissent un <em>type associÃ©</em> Ã  ce trait. Nous verrons ce que
sont les types associÃ©s au chapitre 19. Pour l'instant, tout ce que vous devez
savoir est que ce code dit que l'implÃ©mentation du trait <code>Iterator</code> nÃ©cessite
que vous dÃ©finissiez aussi un type <code>Item</code>, et ce type <code>Item</code> est utilisÃ© dans le
type de retour de la mÃ©thode <code>next</code>. En d'autres termes, le type <code>Item</code> sera le
type retournÃ© par l'itÃ©rateur.</p>
<!--
The `Iterator` trait only requires implementors to define one method: the
`next` method, which returns one item of the iterator at a time wrapped in
`Some` and, when iteration is over, returns `None`.
-->
<p>Le trait <code>Iterator</code> exige la dÃ©finition d'une seule mÃ©thode par les
dÃ©veloppeursÂ : la mÃ©thode <code>next</code>, qui retourne un Ã©lÃ©ment de l'itÃ©rateur Ã  la
fois intÃ©grÃ© dans un <code>Some</code>, et lorsque l'itÃ©ration est terminÃ©e, il retourne
<code>None</code>.</p>
<!--
We can call the `next` method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to `next` on the iterator created
from the vector.
-->
<p>On peut appeler la mÃ©thode <code>next</code> directement sur les itÃ©rateursÂ ; l'encart
13-15 montre quelles valeurs sont retournÃ©es par des appels rÃ©pÃ©tÃ©s Ã  <code>next</code> sur
l'itÃ©rateur crÃ©Ã© Ã  partir du vecteur.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn demo_iterateur() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-15: Calling the `next` method on an
iterator</span>
-->
<p><span class="caption">Encart 13-15Â : appel de la mÃ©thode <code>next</code> sur un itÃ©rateur
</span></p>
<!--
Note that we needed to make `v1_iter` mutable: calling the `next` method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code *consumes*, or uses up, the
iterator. Each call to `next` eats up an item from the iterator. We didnâ€™t need
to make `v1_iter` mutable when we used a `for` loop because the loop took
ownership of `v1_iter` and made it mutable behind the scenes.
-->
<p>Remarquez que nous avons eu besoin de rendre mutable <code>v1_iter</code>Â : appeler la
mÃ©thode <code>next</code> sur un iterator change son Ã©tat interne qui garde en mÃ©moire oÃ¹
il est dans la sÃ©quence. En d'autres termes, ce code <em>consomme</em>, ou utilise,
l'itÃ©rateur. Chaque appel Ã  <code>next</code> consomme un Ã©lÃ©ment de l'itÃ©rateur. Nous
n'avions pas eu besoin de rendre mutable <code>v1_iter</code> lorsque nous avions utilisÃ©
une boucle <code>for</code> parce que la boucle avait pris possession de <code>v1_iter</code> et l'a
rendu mutable en coulisses.</p>
<!--
Also note that the values we get from the calls to `next` are immutable
references to the values in the vector. The `iter` method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of `v1` and returns owned values, we can call `into_iter` instead of
`iter`. Similarly, if we want to iterate over mutable references, we can call
`iter_mut` instead of `iter`.
-->
<p>Notez Ã©galement que les valeurs que nous obtenons des appels Ã  <code>next</code> sont des
rÃ©fÃ©rences immuables aux valeurs dans le vecteur. La mÃ©thode <code>iter</code> produit un
itÃ©rateur pour des rÃ©fÃ©rences immuables. Si nous voulons crÃ©er un itÃ©rateur qui
prend possession de <code>v1</code> et retourne les valeurs possÃ©dÃ©es, nous pouvons appeler
<code>into_iter</code> au lieu de <code>iter</code>. De mÃªme, si nous voulons itÃ©rer sur des
rÃ©fÃ©rences mutables, nous pouvons appeler <code>iter_mut</code> au lieu de <code>iter</code>.</p>
<!--
### Methods that Consume the Iterator
-->
<h3><a class="header" href="#les-mÃ©thodes-qui-consomment-un-itÃ©rateur" id="les-mÃ©thodes-qui-consomment-un-itÃ©rateur">Les mÃ©thodes qui consomment un itÃ©rateur</a></h3>
<!--
The `Iterator` trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the `Iterator`
trait. Some of these methods call the `next` method in their definition, which
is why youâ€™re required to implement the `next` method when implementing the
`Iterator` trait.
-->
<p>Le trait <code>Iterator</code> a un certain nombre de mÃ©thodes diffÃ©rentes avec des
implÃ©mentations par dÃ©faut que nous fournit la bibliothÃ¨que standardÂ ; vous
pouvez dÃ©couvrir ces mÃ©thodes en regardant dans la documentation de l'API de la
bibliothÃ¨que standard pour le trait <code>Iterator</code>. Certaines de ces mÃ©thodes
appellent la mÃ©thode <code>next</code> dans leur dÃ©finition, c'est pourquoi nous devons
toujours implÃ©menter la mÃ©thode <code>next</code> lors de l'implÃ©mentation du trait
<code>Iterator</code>.</p>
<!--
Methods that call `next` are called *consuming adaptors*, because calling them
uses up the iterator. One example is the `sum` method, which takes ownership of
the iterator and iterates through the items by repeatedly calling `next`, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the `sum` method:
-->
<p>Les mÃ©thodes qui appellent <code>next</code> sont appelÃ©es des
<em>adaptateurs de consommation</em>, parce que les appeler consomme l'itÃ©rateur. Un
exemple est la mÃ©thode <code>sum</code>, qui prend possession de l'itÃ©rateur et itÃ©re sur
ses Ã©lÃ©ments en appelant plusieurs fois <code>next</code>, consommant ainsi l'itÃ©rateur. A
chaque Ã©tape de l'itÃ©ration, il ajoute chaque Ã©lÃ©ment Ã  un total en cours et
retourne le total une fois l'itÃ©ration terminÃ©e. L'encart 13-16 a un test
illustrant une utilisation de la mÃ©thode <code>sum</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-16: Calling the `sum` method to get the total
of all items in the iterator</span>
-->
<p><span class="caption">Encart 13-16Â : appel de la mÃ©thode <code>sum</code> pour obtenir la
somme de tous les Ã©lÃ©ments prÃ©sents dans l'itÃ©rateur</span></p>
<!--
We arenâ€™t allowed to use `v1_iter` after the call to `sum` because `sum` takes
ownership of the iterator we call it on.
-->
<p>Nous ne sommes pas autorisÃ©s Ã  utiliser <code>v1_iter</code> aprÃ¨s l'appel Ã  <code>sum</code> car
<code>sum</code> a pris possession de l'itÃ©rateur sur lequel nous l'appelons.</p>
<!--
### Methods that Produce Other Iterators
-->
<h3><a class="header" href="#mÃ©thodes-qui-produisent-dautres-itÃ©rateurs" id="mÃ©thodes-qui-produisent-dautres-itÃ©rateurs">MÃ©thodes qui produisent d'autres itÃ©rateurs</a></h3>
<!--
Other methods defined on the `Iterator` trait, known as *iterator adaptors*,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.
-->
<p>D'autres mÃ©thodes dÃ©finies sur le trait <code>Iterator</code>, connues sous le nom
<em>d'adaptateurs d'itÃ©ration</em>, nous permettent de transformer un itÃ©rateur en un
type d'itÃ©rateur diffÃ©rent. Nous pouvons enchaÃ®ner plusieurs appels Ã  des
adaptateurs d'itÃ©ration pour effectuer des actions complexes de maniÃ¨re
comprÃ©hensible. Mais comme les itÃ©rateurs sont <em>des Ã©valuations paresseuses</em>,
nous devons faire appel Ã  l'une des mÃ©thodes d'adaptation de consommation pour
obtenir les rÃ©sultats des appels aux adaptateurs d'itÃ©ration.</p>
<!--
Listing 13-17 shows an example of calling the iterator adaptor method `map`,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:
-->
<p>L'encart 13-17 montre un exemple d'appel Ã  la mÃ©thode d'adaptation d'itÃ©ration
<code>map</code>, qui prend en paramÃ¨tre une fermeture qui va s'exÃ©cuter sur chaque Ã©lÃ©ment
pour produire un nouvel itÃ©rateur. La fermeture crÃ©e ici un nouvel itÃ©rateur
dans lequel chaque Ã©lÃ©ment du vecteur a Ã©tÃ© incrÃ©mentÃ© de 1. Cependant, ce code
dÃ©clenche un avertissementÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,not_desired_behavior
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
# }
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-17: Calling the iterator adaptor `map` to
create a new iterator</span>
-->
<p><span class="caption">Encart 13-17Â : appel de l'adaptateur d'itÃ©ration <code>map</code>
pour crÃ©er un nouvel itÃ©rateur</span></p>
<!--
The warning we get is this:
-->
<p>Voici l'avertissement que nous obtenonsÂ :</p>
<!--
```console
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 -- > src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```
-->
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<!--
The code in Listing 13-17 doesnâ€™t do anything; the closure weâ€™ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.
-->
<p>Le code dans l'encart 13-17 ne fait rienÂ ; la fermeture que nous avons renseignÃ©
n'est jamais exÃ©cutÃ©. L'avertissement nous rappelle pourquoiÂ : les adaptateurs
d'itÃ©ration sont des <em>Ã©valuations paresseuses</em>, c'est pourquoi nous devons
consommer l'itÃ©rateur ici.</p>
<!--
To fix this and consume the iterator, weâ€™ll use the `collect` method, which we
used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.
-->
<p>Pour corriger ceci et consommer l'itÃ©rateur, nous utiliserons la mÃ©thode
<code>collect</code>, que vous avez utilisÃ© avec <code>env::args</code> dans l'encart 12-1 du
chapitre 12. Cette mÃ©thode consomme l'itÃ©rateur et collecte les valeurs
rÃ©sultantes dans un type de collection de donnÃ©es.</p>
<!--
In Listing 13-18, we collect the results of iterating over the iterator thatâ€™s
returned from the call to `map` into a vector. This vector will end up
containing each item from the original vector incremented by 1.
-->
<p>Dans l'encart 13-18, nous recueillons les rÃ©sultats de l'itÃ©ration sur
l'itÃ©rateur qui sont retournÃ©s par l'appel Ã  <code>map</code> sur un vecteur. Ce vecteur
finira par contenir chaque Ã©lÃ©ment du vecteur original incrÃ©mentÃ© de 1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-18: Calling the `map` method to create a new
iterator and then calling the `collect` method to consume the new iterator and
create a vector</span>
-->
<p><span class="caption">Encart 13-18Â : appel de la mÃ©thode <code>map</code> pour crÃ©er un
nouvel itÃ©rateur, puis appel de la mÃ©thode <code>collect</code> pour consommer le nouvel
itÃ©rateur afin de crÃ©er un vecteur</span></p>
<!--
Because `map` takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the `Iterator` trait
provides.
-->
<p>Comme <code>map</code> prend en paramÃ¨tre une fermeture, nous pouvons renseigner n'importe
quelle opÃ©ration que nous souhaitons exÃ©cuter sur chaque Ã©lÃ©ment. C'est un bon
exemple de la faÃ§on dont les fermetures nous permettent de personnaliser
certains comportements tout en rÃ©utilisant le comportement d'itÃ©ration fourni
par le trait <code>Iterator</code>.</p>
<!--
### Using Closures that Capture Their Environment
-->
<h3><a class="header" href="#utilisation-de-fermetures-capturant-leur-environnement" id="utilisation-de-fermetures-capturant-leur-environnement">Utilisation de fermetures capturant leur environnement</a></h3>
<!--
Now that weâ€™ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the `filter` iterator adaptor.
The `filter` method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns `true`, the value
will be included in the iterator produced by `filter`. If the closure returns
`false`, the value wonâ€™t be included in the resulting iterator.
-->
<p>Maintenant que nous avons prÃ©sentÃ© les itÃ©rateurs, nous pouvons illustrer une
utilisation commune des fermetures qui capturent leur environnement en utilisant
l'adaptateur d'itÃ©ration <code>filter</code>. La mÃ©thode <code>filter</code> appelÃ©e sur un itÃ©rateur
prend en paramÃ¨tre une fermeture qui s'exÃ©cute sur chaque Ã©lÃ©ment de l'itÃ©rateur
et retourne un boolÃ©en pour chacun. Si la fermeture retourne <code>true</code>, la valeur
sera incluse dans l'itÃ©rateur produit par <code>filter</code>. Si la fermeture retourne
<code>false</code>, la valeur ne sera pas incluse dans l'itÃ©rateur rÃ©sultant.</p>
<!--
In Listing 13-19, we use `filter` with a closure that captures the `shoe_size`
variable from its environment to iterate over a collection of `Shoe` struct
instances. It will return only shoes that are the specified size.
-->
<p>Dans l'encart 13-19, nous utilisons <code>filter</code> avec une fermeture qui capture la
variable <code>pointure_chaussure</code> de son environnement pour itÃ©rer sur une
collection d'instances de la structure <code>Chaussure</code>. Il ne retournera que les
chaussures avec la pointure demandÃ©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Debug)]
struct Chaussure {
    pointure: u32,
    style: String,
}

fn chaussures_a_la_pointure(chaussures: Vec&lt;Chaussure&gt;, pointure_chaussure: u32) -&gt; Vec&lt;Chaussure&gt; {
    chaussures.into_iter()
              .filter(|s| s.pointure == pointure_chaussure)
              .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filtres_par_pointure() {
        let chaussures = vec![
            Chaussure {
                pointure: 10,
                style: String::from(&quot;baskets&quot;),
            },
            Chaussure {
                pointure: 13,
                style: String::from(&quot;sandale&quot;),
            },
            Chaussure {
                pointure: 10,
                style: String::from(&quot;bottes&quot;),
            },
        ];

        let a_ma_pointure = chaussures_a_la_pointure(chaussures, 10);

        assert_eq!(
            a_ma_pointure,
            vec![
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;baskets&quot;)
                },
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;bottes&quot;)
                },
            ]
        );
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 13-19: Using the `filter` method with a closure
that captures `shoe_size`</span>
-->
<p><span class="caption">Encart 13-19Â : utilisation de la mÃ©thode <code>filter</code> avec une
fermeture capturant <code>pointure_chaussure</code></span></p>
<!--
The `shoes_in_my_size` function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.
-->
<p>La fonction <code>chaussures_a_la_pointure</code> prend possession d'un vecteur de
chaussures et d'une pointure comme paramÃ¨tres. Il retourne un vecteur contenant
uniquement des chaussures de la pointure demandÃ©e.</p>
<!--
In the body of `shoes_in_my_size`, we call `into_iter` to create an iterator
that takes ownership of the vector. Then we call `filter` to adapt that
iterator into a new iterator that only contains elements for which the closure
returns `true`.
-->
<p>Dans le corps de <code>chaussures_a_la_pointure</code>, nous appelons <code>into_iter</code> pour
crÃ©er un itÃ©rateur qui prend possession du vecteur. Ensuite, nous appelons
<code>filter</code> pour adapter cet itÃ©rateur dans un nouvel itÃ©rateur qui ne contient que
les Ã©lÃ©ments pour lesquels la fermeture retourne <code>true</code>.</p>
<!--
The closure captures the `shoe_size` parameter from the environment and
compares the value with each shoeâ€™s size, keeping only shoes of the size
specified. Finally, calling `collect` gathers the values returned by the
adapted iterator into a vector thatâ€™s returned by the function.
-->
<p>La fermeture capture le paramÃ¨tre <code>pointure_chaussure</code> de l'environnement et
compare la valeur avec la pointure de chaque chaussure, en ne gardant que les
chaussures de la pointure spÃ©cifiÃ©e. Enfin, l'appel Ã  <code>collect</code> retourne un
vecteur qui regroupe les valeurs renvoyÃ©es par l'itÃ©rateur.</p>
<!--
The test shows that when we call `shoes_in_my_size`, we get back only shoes
that have the same size as the value we specified.
-->
<p>Le test confirme que lorsque nous appelons <code>chaussures_a_la_pointure</code>, nous
n'obtenons que des chaussures qui ont la mÃªme pointure que la valeur que nous
avons demandÃ©.</p>
<!--
### Creating Our Own Iterators with the `Iterator` Trait
-->
<h3><a class="header" href="#crÃ©er-nos-propres-itÃ©rateurs-avec-le-trait-iterator" id="crÃ©er-nos-propres-itÃ©rateurs-avec-le-trait-iterator">CrÃ©er nos propres itÃ©rateurs avec le trait <code>Iterator</code></a></h3>
<!--
Weâ€™ve shown that you can create an iterator by calling `iter`, `into_iter`, or
`iter_mut` on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the `Iterator` trait on your own
types. As previously mentioned, the only method youâ€™re required to provide a
definition for is the `next` method. Once youâ€™ve done that, you can use all
other methods that have default implementations provided by the `Iterator`
trait!
-->
<p>Nous avons vu que nous pouvons crÃ©er un itÃ©rateur en appelant <code>iter</code>,
<code>into_iter</code>, ou <code>iter_mut</code> sur un vecteur. Nous pouvons crÃ©er des itÃ©rateurs Ã 
partir d'autres types de collections de la bibliothÃ¨que standard, comme les
tables de hachage. Nous pouvons aussi crÃ©er des itÃ©rateurs qui font tout ce que
nous voulons en implÃ©mentant le trait <code>Iterator</code> sur nos propres types. Comme
nous l'avons mentionnÃ© prÃ©cÃ©demment, la seule mÃ©thode pour laquelle nous devons
fournir une dÃ©finition est la mÃ©thode <code>next</code>. Une fois que nous avons fait cela,
nous pouvons utiliser toutes les autres mÃ©thodes qui ont des implÃ©mentations par
dÃ©faut fournies par le trait <code>Iterator</code>Â !</p>
<!--
To demonstrate, letâ€™s create an iterator that will only ever count from 1 to 5.
First, weâ€™ll create a struct to hold some values. Then weâ€™ll make this struct
into an iterator by implementing the `Iterator` trait and using the values in
that implementation.
-->
<p>Pour preuve, crÃ©ons un itÃ©rateur qui ne comptera que de 1 Ã  5. D'abord, nous
allons crÃ©er une structure contenant quelques valeurs. Ensuite nous
transformerons cette structure en itÃ©rateur en implÃ©mentant le trait <code>Iterator</code>
et nous utiliserons les valeurs de cette implÃ©mentation.</p>
<!--
Listing 13-20 has the definition of the `Counter` struct and an associated
`new` function to create instances of `Counter`:
-->
<p>L'encart 13-20 montre la dÃ©finition de la structure <code>Compteur</code> et une fonction
associÃ©e <code>new</code> pour crÃ©er des instances de <code>Compteur</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Compteur {
    compteur: u32,
}

impl Compteur {
    fn new() -&gt; Compteur {
        Compteur { compteur: 0 }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 13-20: Defining the `Counter` struct and a `new`
function that creates instances of `Counter` with an initial value of 0 for
`count`</span>
-->
<p><span class="caption">Encart 13-20Â : dÃ©finition de la structure <code>Compteur</code> et
d'une fonction <code>new</code> qui crÃ©e des instances de <code>Compteur</code> avec une valeur
initiale de 0 pour le champ <code>compteur</code>.</span></p>
<!--
The `Counter` struct has one field named `count`. This field holds a `u32`
value that will keep track of where we are in the process of iterating from 1
to 5. The `count` field is private because we want the implementation of
`Counter` to manage its value. The `new` function enforces the behavior of
always starting new instances with a value of 0 in the `count` field.
-->
<p>La structure <code>Compteur</code> a un champ <code>compteur</code>. Ce champ contient une valeur
<code>u32</code> qui gardera la trace de l'endroit oÃ¹ nous sommes dans le processus
d'itÃ©ration de 1 Ã  5. Le champ <code>compteur</code> est privÃ© car nous voulons que ce soit
l'implÃ©mentation de <code>Compteur</code> qui gÃ¨re sa valeur. La fonction <code>new</code> impose le
de toujours dÃ©marrer de nouvelles instances avec une valeur de 0 pour le champ
<code>compteur</code>.</p>
<!--
Next, weâ€™ll implement the `Iterator` trait for our `Counter` type by defining
the body of the `next` method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:
-->
<p>Ensuite, nous allons implÃ©menter le trait <code>Iterator</code> sur notre type <code>Compteur</code>
en dÃ©finissant le corps de la mÃ©thode <code>next</code> pour prÃ©ciser ce que nous voulons
qu'il se passe quand cet itÃ©rateur est utilisÃ©, comme dans l'encart 13-21Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.compteur &lt; 5 {
            self.compteur += 1;
            Some(self.compteur)
        } else {
            None
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-21: Implementing the `Iterator` trait on our
`Counter` struct</span>
-->
<p><span class="caption">Encart 13-21Â : implÃ©mentation du trait <code>Iterator</code> sur
notre structure <code>Compteur</code></span></p>
<!--
We set the associated `Item` type for our iterator to `u32`, meaning the
iterator will return `u32` values. Again, donâ€™t worry about associated types
yet, weâ€™ll cover them in Chapter 19.
-->
<p>Nous avons dÃ©fini le type associÃ© <code>Item</code> pour notre itÃ©rateur Ã  <code>u32</code>, ce qui
signifie que l'itÃ©rateur renverra des valeurs <code>u32</code>. Encore une fois, ne vous
prÃ©occupez pas des types associÃ©s, nous les aborderons au chapitre 19.</p>
<!--
We want our iterator to add 1 to the current state, so we initialized `count`
to 0 so it would return 1 first. If the value of `count` is less than 5, `next`
will increment `count` and return the current value wrapped in `Some`. Once
`count` is 5, our iterator will stop incrementing `count` and always return
`None`.
-->
<p>Nous voulons que notre itÃ©rateur ajoute 1 Ã  l'Ã©tat courant, donc nous avons
initialisÃ© <code>compteur</code> Ã  0 pour qu'il retourne 1 lors du premier appel Ã  <code>next</code>.
Si la valeur de <code>compteur</code> est strictement infÃ©rieure Ã  5, <code>next</code> va incrÃ©menter
<code>compteur</code> puis va retourner valeur courante intÃ©grÃ©e dans un <code>Some</code>. Une fois
que <code>compteur</code> vaudra 5, notre itÃ©rateur va arrÃªter d'incrÃ©menter <code>compteur</code> et
retournera toujours <code>None</code>.</p>
<!--
#### Using Our `Counter` Iteratorâ€™s `next` Method
-->
<h3><a class="header" href="#utiliser-la-mÃ©thode-next-de-notre-itÃ©rateur-compteur" id="utiliser-la-mÃ©thode-next-de-notre-itÃ©rateur-compteur">Utiliser la mÃ©thode <code>next</code> de notre ItÃ©rateur <code>Compteur</code></a></h3>
<!--
Once weâ€™ve implemented the `Iterator` trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
`Counter` struct by calling the `next` method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.
-->
<p>Une fois que nous avons implÃ©mentÃ© le trait <code>Iterator</code>, nous avons un
itÃ©rateurÂ ! L'encart 13-22 montre un test dÃ©montrant que nous pouvons utiliser
la fonctionnalitÃ© d'itÃ©ration de notre structure <code>Compteur</code> en appelant
directement la mÃ©thode <code>next</code>, comme nous l'avons fait avec l'itÃ©rateur crÃ©Ã© Ã 
partir d'un vecteur dans l'encart 13-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_direct_a_next() {
        let mut compteur = Compteur::new();

        assert_eq!(compteur.next(), Some(1));
        assert_eq!(compteur.next(), Some(2));
        assert_eq!(compteur.next(), Some(3));
        assert_eq!(compteur.next(), Some(4));
        assert_eq!(compteur.next(), Some(5));
        assert_eq!(compteur.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-22: Testing the functionality of the `next`
method implementation</span>
-->
<p><span class="caption">Encart 13-22Â : test de l'implÃ©mentation de la mÃ©thode
<code>next</code></span></p>
<!--
This test creates a new `Counter` instance in the `counter` variable and then
calls `next` repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.
-->
<p>Ce test crÃ©Ã© une nouvelle instance de <code>Compteur</code> dans la variable <code>compteur</code> et
appelle ensuite <code>next</code> Ã  plusieurs reprises, en vÃ©rifiant que nous avons
implÃ©mentÃ© le comportement que nous voulions que cet itÃ©rateur suiveÂ : renvoyer
les valeurs de 1 Ã  5.</p>
<!--
#### Using Other `Iterator` Trait Methods
-->
<h4><a class="header" href="#utiliser-dautres-mÃ©thodes-du-trait-iterator" id="utiliser-dautres-mÃ©thodes-du-trait-iterator">Utiliser d'autres mÃ©thodes du trait <code>Iterator</code></a></h4>
<!--
We implemented the `Iterator` trait by defining the `next` method, so we
can now use any `Iterator` trait methodâ€™s default implementations as defined in
the standard library, because they all use the `next` methodâ€™s functionality.
-->
<p>Maintenant que nous avons implÃ©mentÃ© le trait <code>Iterator</code> en dÃ©finissant la
mÃ©thode <code>next</code>, nous pouvons maintenant utiliser les implÃ©mentations par dÃ©faut
de n'importe quelle mÃ©thode du trait <code>Iterator</code> telles que dÃ©finies dans la
bibliothÃ¨que standard, car elles utilisent toutes la mÃ©thode <code>next</code>.</p>
<!--
For example, if for some reason we wanted to take the values produced by an
instance of `Counter`, pair them with values produced by another `Counter`
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:
-->
<p>Par exemple, si pour une raison quelconque nous voulions prendre les valeurs
produites par une instance de <code>Compteur</code>, les coupler avec des valeurs produites
par une autre instance de <code>Compteur</code> aprÃ¨s avoir sautÃ© la premiÃ¨re valeur,
multiplier chaque paire ensemble, ne garder que les rÃ©sultats qui sont
divisibles par 3 et additionner toutes les valeurs rÃ©sultantes ensemble, nous
pourrions le faire, comme le montre le test dans l'encart 13-23Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn calling_next_directly() {
#         let mut counter = Counter::new();
# 
#         assert_eq!(counter.next(), Some(1));
#         assert_eq!(counter.next(), Some(2));
#         assert_eq!(counter.next(), Some(3));
#         assert_eq!(counter.next(), Some(4));
#         assert_eq!(counter.next(), Some(5));
#         assert_eq!(counter.next(), None);
#     }
# 
    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn appel_direct_a_next() {
</span><span class="boring">        let mut compteur = Compteur::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(compteur.next(), Some(1));
</span><span class="boring">        assert_eq!(compteur.next(), Some(2));
</span><span class="boring">        assert_eq!(compteur.next(), Some(3));
</span><span class="boring">        assert_eq!(compteur.next(), Some(4));
</span><span class="boring">        assert_eq!(compteur.next(), Some(5));
</span><span class="boring">        assert_eq!(compteur.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn utilisation_des_autres_methodes_du_trait_iterator() {
        let somme: u32 = Compteur::new()
            .zip(Compteur::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, somme);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-23: Using a variety of `Iterator` trait
methods on our `Counter` iterator</span>
-->
<p><span class="caption">Encart 13-23Â : utilisation d'une gamme de mÃ©thodes de
traits <code>Iterator</code> sur notre itÃ©rateur <code>Counter</code> </span></p>
<!--
Note that `zip` produces only four pairs; the theoretical fifth pair `(5,
None)` is never produced because `zip` returns `None` when either of its input
iterators return `None`.
-->
<p>Notez que <code>zip</code> ne produit que quatre pairesÂ ; la cinquiÃ¨me paire thÃ©orique
<code>(5, None)</code> n'est jamais produite car <code>zip</code> retourne <code>None</code> lorsque l'un de
ses itÃ©rateurs d'entrÃ©e retourne <code>None</code>.</p>
<!--
All of these method calls are possible because we specified how the `next`
method works, and the standard library provides default implementations for
other methods that call `next`.
-->
<p>Tous ces appels de mÃ©thode sont possibles car nous avons renseignÃ© comment
la mÃ©thode <code>next</code> fonctionne et la bibliothÃ¨que standard fournit des
implÃ©mentations par dÃ©faut pour les autres mÃ©thodes qui appellent <code>next</code>.</p>
<!--
## Improving Our I/O Project
-->
<h2><a class="header" href="#amÃ©lioration-de-notre-projet-dentrÃ©esortie" id="amÃ©lioration-de-notre-projet-dentrÃ©esortie">AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></h2>
<!--
With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Letâ€™s look at how iterators can improve our implementation of the
`Config::new` function and the `search` function.
-->
<p>GrÃ¢ce Ã  ces nouvelles connaissances sur les itÃ©rateurs, nous pouvons amÃ©liorer
le projet d'entrÃ©e/sortie du chapitre 12 en utilisant des itÃ©rateurs pour
rendre certains endroits du code plus clairs et plus concis. Voyons comment les
itÃ©rateurs peuvent amÃ©liorer notre implÃ©mentation de la fonction <code>Config::new</code>
et de la fonction <code>rechercher</code>.</p>
<!--
### Removing a `clone` Using an Iterator
-->
<h3><a class="header" href="#supprimer-lappel-Ã -clone-Ã -laide-dun-itÃ©rateur" id="supprimer-lappel-Ã -clone-Ã -laide-dun-itÃ©rateur">Supprimer l'appel Ã  <code>clone</code> Ã  l'aide d'un itÃ©rateur</a></h3>
<!--
In Listing 12-6, we added code that took a slice of `String` values and created
an instance of the `Config` struct by indexing into the slice and cloning the
values, allowing the `Config` struct to own those values. In Listing 13-24,
weâ€™ve reproduced the implementation of the `Config::new` function as it was in
Listing 12-23:
-->
<p>Dans l'encart 12-6, nous avions ajoutÃ© du code qui prenait une <em>slice</em> de
<code>String</code> et qui crÃ©ait une instance de la structure <code>Config</code> en utilisant les
indices de la <em>slice</em> et en clonant les valeurs, permettant ainsi Ã  la
structure <code>Config</code> de possÃ©der ces valeurs. Dans l'encart 13-24, nous avions
reproduit l'implÃ©mentation de la fonction <code>Config::new</code> comme Ã©tait dans
l'encart 12-23 Ã  la fin du chapitre 12Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 13-24: Reproduction of the `Config::new` function
from Listing 12-23</span>
-->
<p><span class="caption">Encart 13-24Â : reproduction de la fonction <code>Config::new</code>
de la fin du chapitre 12</span></p>
<!--
At the time, we said not to worry about the inefficient `clone` calls because
we would remove them in the future. Well, that time is now!
-->
<p>Ã€ ce moment-lÃ , nous avions dit de ne pas s'inquiÃ©ter des appels inefficaces Ã 
<code>clone</code> parce que nous les supprimerions Ã  l'avenir. Et bien, ce moment est
venuÂ !</p>
<!--
We needed `clone` here because we have a slice with `String` elements in the
parameter `args`, but the `new` function doesnâ€™t own `args`. To return
ownership of a `Config` instance, we had to clone the values from the `query`
and `filename` fields of `Config` so the `Config` instance can own its values.
-->
<p>Nous avions besoin de <code>clone</code> ici parce que nous avons une slice d'Ã©lÃ©ments
<code>String</code> dans le paramÃ¨tre <code>args</code>, mais la fonction <code>new</code> ne possÃ¨de pas <code>args</code>.
Pour rendre la propriÃ©tÃ© d'une instance de <code>Config</code>, nous avons dÃ» cloner les
valeurs des champs <code>recherche</code> et <code>nom_fichier</code> de <code>Config</code> pour qu'elle puisse
prendre possession de ses valeurs.</p>
<!--
With our new knowledge about iterators, we can change the `new` function to
take ownership of an iterator as its argument instead of borrowing a slice.
Weâ€™ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
`Config::new` function is doing because the iterator will access the values.
-->
<p>Avec nos nouvelles connaissances sur les itÃ©rateurs, nous pouvons changer la
fonction <code>new</code> pour prendre possession d'un itÃ©rateur passÃ© en argument au lieu
d'emprunter une <em>slice</em>. Nous utiliserons les fonctionnalitÃ©s des itÃ©rateurs Ã 
la place du code qui vÃ©rifie la taille de la slice et qui utilise les indices
des Ã©lÃ©ments prÃ©cis. Cela clarifiera ce que la fonction <code>Config::new</code> fait car
l'itÃ©rateur accÃ©dera aux valeurs.</p>
<!--
Once `Config::new` takes ownership of the iterator and stops using indexing
operations that borrow, we can move the `String` values from the iterator into
`Config` rather than calling `clone` and making a new allocation.
-->
<p>Une fois que <code>Config::new</code> prend possession de l'itÃ©rateur et cesse d'utiliser
les opÃ©rations avec les indices et d'emprunter les donnÃ©es, nous pouvons
dÃ©placer les valeurs <code>String</code> de l'iterator dans <code>Config</code> plutÃ´t que de faire
appel Ã  <code>clone</code> et de crÃ©er par consÃ©quent de nouvelles allocations.</p>
<!--
#### Using the Returned Iterator Directly
-->
<h4><a class="header" href="#utiliser-directement-litÃ©rateur-retournÃ©" id="utiliser-directement-litÃ©rateur-retournÃ©">Utiliser directement l'itÃ©rateur retournÃ©</a></h4>
<!--
Open your I/O projectâ€™s *src/main.rs* file, which should look like this:
-->
<p>Ouvrez le fichier <em>src/main.rs</em> de votre projet d'entrÃ©e/sortie, qui devrait
ressembler Ã  ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
Weâ€™ll change the start of the `main` function that we had in Listing 12-24 to
the code in Listing 13-25. This wonâ€™t compile until we update `Config::new` as
well.
-->
<p>Nous allons changer le dÃ©but de la fonction <code>main</code> que nous avions dans l'encart
12-24 pour le code dans l'encart 13-25. Ceci ne compilera pas encore jusqu'Ã  ce
que nous mettions Ã©galement Ã  jour <code>Config::new</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;ProblÃ¨me rencontrÃ© lors de l'interprÃ©tation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 13-25: Passing the return value of `env::args` to
`Config::new`</span>
-->
<p><span class="caption">Encart 13-25Â : on passe directement la valeur de retour de
<code>env::args</code> Ã  <code>Config::new</code>.</span></p>
<!--
The `env::args` function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to `Config::new`, now
weâ€™re passing ownership of the iterator returned from `env::args` to
`Config::new` directly.
-->
<p>La fonction <code>env::args</code> retourne un itÃ©rateurÂ ! PlutÃ´t que de collecter les
valeurs de l'itÃ©rateur dans un vecteur et de passer ensuite une <em>slice</em> Ã 
<code>Config::new</code>, nous passons maintenant la possession de l'itÃ©rateur de
<code>env::args</code> directement Ã  <code>Config::new</code>.</p>
<!--
Next, we need to update the definition of `Config::new`. In your I/O projectâ€™s
*src/lib.rs* file, letâ€™s change the signature of `Config::new` to look like
Listing 13-26. This still wonâ€™t compile because we need to update the function
body.
-->
<p>Ensuite, nous devons mettre Ã  jour la dÃ©finition de <code>Config::new</code>. Dans le
fichier <em>src/lib.rs</em> de votre projet d'entrÃ©e/sortie, modifions la signature de
<code>Config::new</code> pour qu'elle ressemble Ã  l'encart 13-26. Ceci ne compilera pas
encore car nous devons mettre Ã  jour le corps de la fonction.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        // -- partie masquÃ©e ici --
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-26: Updating the signature of `Config::new` to
expect an iterator</span>
-->
<p><span class="caption">Encart 13-26Â : mise Ã  jour de la signature de
<code>Config::new</code> pour recevoir un itÃ©rateur</span></p>
<!--
The standard library documentation for the `env::args` function shows that the
type of the iterator it returns is `std::env::Args`. Weâ€™ve updated the
signature of the `Config::new` function so the parameter `args` has the type
`std::env::Args` instead of `&[String]`. Because weâ€™re taking ownership of
`args` and weâ€™ll be mutating `args` by iterating over it, we can add the `mut`
keyword into the specification of the `args` parameter to make it mutable.
-->
<p>La documentation de la bibliothÃ¨que standard de la fonction <code>env::args</code>
indique que le type de l'itÃ©rateur qu'elle renvoie est <code>std::env::Args</code>. Nous
avons mis Ã  jour la signature de la fonction <code>Config::new</code> pour que le
paramÃ¨tre <code>args</code> ait le type <code>std::env::Args</code> au lieu de <code>&amp;[String]</code>. Etant
donnÃ© que nous prenons possession de <code>args</code> et que nous allons muter <code>args</code>
en itÃ©rant dessus, nous pouvons ajouter le mot-clÃ© <code>mut</code> dans la spÃ©cification
du paramÃ¨tre <code>args</code> pour le rendre mutable.</p>
<!--
#### Using `Iterator` Trait Methods Instead of Indexing
-->
<h4><a class="header" href="#utilisation-des-mÃ©thodes-du-trait-iterator-au-lieu-des-indices" id="utilisation-des-mÃ©thodes-du-trait-iterator-au-lieu-des-indices">Utilisation des mÃ©thodes du trait <code>Iterator</code> au lieu des indices</a></h4>
<!--
Next, weâ€™ll fix the body of `Config::new`. The standard library documentation
also mentions that `std::env::Args` implements the `Iterator` trait, so we know
we can call the `next` method on it! Listing 13-27 updates the code from
Listing 12-23 to use the `next` method:
-->
<p>Ensuite corrigeons le corps de <code>Config::new</code>. La documentation de la bibliothÃ¨que
standard explique aussi que <code>std::env::Args</code> implÃ©mente le trait <code>Iterator</code>, donc
nous savons que nous pouvons appeler la mÃ©thode <code>next</code> dessusÂ ! L'encart 13-27
met Ã  jour le code de l'encart 12-23 afin d'utiliser la mÃ©thode <code>next</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        args.next();

        let recherche = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de chaÃ®ne de caractÃ¨res"),
        };

        let nom_fichier = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de nom de fichier"),
        };

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let recherche = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de chaÃ®ne de caractÃ¨res&quot;),
        };

        let nom_fichier = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
        };

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-27: Changing the body of `Config::new` to use
iterator methods</span>
-->
<p><span class="caption">Encart 13-27Â : changement du corps de <code>Config::new</code> afin
d'utiliser les mÃ©thodes d'itÃ©ration</span></p>
<!--
Remember that the first value in the return value of `env::args` is the name of
the program. We want to ignore that and get to the next value, so first we call
`next` and do nothing with the return value. Second, we call `next` to get the
value we want to put in the `query` field of `Config`. If `next` returns a
`Some`, we use a `match` to extract the value. If it returns `None`, it means
not enough arguments were given and we return early with an `Err` value. We do
the same thing for the `filename` value.
-->
<p>Rappelez-vous que la premiÃ¨re valeur de ce qui est retournÃ© par <code>env::args</code> est
le nom du programme. Nous voulons ignorer cette valeur et passer Ã  la suivante,
donc d'abord nous appelons une fois <code>next</code> et nous ne faisons rien avec sa
valeur de retour. Ensuite, nous appelons <code>next</code> pour obtenir la valeur que nous
voulons mettre dans le champ <code>recherche</code> de <code>Config</code>. Si <code>next</code> renvoie un
<code>Some</code>, nous utilisons un <code>match</code> pour extraire sa valeur. S'il retourne <code>None</code>,
cela signifie qu'il n'y a pas assez d'arguments donnÃ©s et nous revenons plus tÃ´t
avec une valeur <code>Err</code>. De mÃªme pour la valeur <code>nom_fichier</code>.</p>
<!--
### Making Code Clearer with Iterator Adaptors
-->
<h3><a class="header" href="#rendre-le-code-plus-clair-avec-des-adaptateurs-ditÃ©ration" id="rendre-le-code-plus-clair-avec-des-adaptateurs-ditÃ©ration">Rendre le code plus clair avec des adaptateurs d'itÃ©ration</a></h3>
<!--
We can also take advantage of iterators in the `search` function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:
-->
<p>Nous pouvons Ã©galement tirer parti des itÃ©rateurs dans la fonction
<code>rechercher</code> de notre projet d'entrÃ©e/sortie, qui est reproduite ici dans
l'encart 13-28, comme elle l'Ã©tait dans l'encart 12-19 Ã  la fin du chapitre 12Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_resultat() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
# Obtenez les trois en mÃªme temps.";
# 
#         assert_eq!(vec!["sÃ©curitÃ©, rapiditÃ©, productivitÃ©."], rechercher(recherche, contenu));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sÃ©curitÃ©, rapiditÃ©, productivitÃ©.
</span><span class="boring">Obtenez les trois en mÃªme temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sÃ©curitÃ©, rapiditÃ©, productivitÃ©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-28: The implementation of the `search`
function from Listing 12-19</span>
-->
<p><span class="caption">Encart 13-28Â : La mise en oeuvre de la fonction
<code>rechercher</code> de l'encart 12-19</span></p>
<!--
We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate `results` vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldnâ€™t have to manage
concurrent access to the `results` vector. Listing 13-29 shows this change:
-->
<p>Nous pouvons Ã©crire ce code de faÃ§on plus concise en utilisant des mÃ©thodes
des adaptateurs d'itÃ©ration. Ce faisant, nous Ã©vitons ainsi d'avoir le vecteur
mutableÂ <code>resultats</code>. Le style de programmation fonctionnelle prÃ©fÃ¨re minimiser
la quantitÃ© d'Ã©tats modifiables pour rendre le code plus clair. Supprimer l'Ã©tat
mutable pourrait nous aider Ã  faire une amÃ©lioration future afin que la recherche
se fasse en parallÃ¨le, car nous n'aurions pas Ã  gÃ©rer l'accÃ¨s concurrent au
vecteur <code>resultats</code>. L'encart 13-29 montre ce changementÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
#         args.next();
# 
#         let recherche = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de chaÃ®ne de caractÃ¨res"),
#         };
# 
#         let nom_fichier = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de nom de fichier"),
#         };
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let recherche = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de chaÃ®ne de caractÃ¨res&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let nom_fichier = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the `search` function</span>
-->
<p><span class="caption">Encart 13-29Â : utilisation des mÃ©thodes des adaptateurs
d'itÃ©ration dans l'implÃ©mentation de la fonction <code>rechercher</code></span></p>
<!--
Recall that the purpose of the `search` function is to return all lines in
`contents` that contain the `query`. Similar to the `filter` example in Listing
13-19, this code uses the `filter` adaptor to keep only the lines that
`line.contains(query)` returns `true` for. We then collect the matching lines
into another vector with `collect`. Much simpler! Feel free to make the same
change to use iterator methods in the `search_case_insensitive` function as
well.
-->
<p>Souvenez-vous que le but de la fonction <code>rechercher</code> est de renvoyer toutes
les lignes dans <code>contenu</code> qui contiennent <code>recherche</code>. Comme dans l'exemple de
<code>filter</code> dans l'encart 13-19, nous pouvons utiliser l'adaptateur <code>filter</code>
pour garder uniquement les lignes pour lesquelles <code>ligne.contains(recherche)</code>
renvoie <code>true</code>. Nous collectons ensuite les lignes correspondantes dans un
autre vecteur avec <code>collect</code>. C'est bien plus simpleÂ ! N'hÃ©sitez pas Ã  faire
le mÃªme changement pour utiliser les mÃ©thodes d'itÃ©ration dans la fonction
<code>rechercher_insensible_casse</code>.</p>
<!--
The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. Itâ€™s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so itâ€™s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.
-->
<p>Logiquement la question suivante est de savoir quel style utiliser dans votre
propre code et pourquoiÂ : l'implÃ©mentation originale de l'encart 13-28 ou la
version utilisant l'itÃ©rateur dans l'encart 13-29. La plupart des dÃ©veloppeurs
Rust prÃ©fÃ¨rent utiliser le style avec l'itÃ©rateur. C'est un peu plus difficile
Ã  comprendre au dÃ©but, mais une fois que vous avez compris les diffÃ©rents
adaptateurs d'itÃ©ration et de ce qu'ils font, les itÃ©rateurs peuvent devenir
plus faciles Ã  comprendre. Au lieu de jongler avec diffÃ©rentes boucles et de
construire de nouveaux vecteurs, ce code se concentre sur l'objectif de haut
niveau de la boucle. Cette abstraction permet d'Ã©liminer une partie du code
trivial, de sorte qu'il soit plus facile de dÃ©gager les concepts propres Ã  ce
code, comme le filtrage de chaque Ã©lÃ©ment de l'itÃ©rateur qui est appliquÃ©.</p>
<!--
But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Letâ€™s talk about
performance.
-->
<p>Mais ces deux implÃ©mentations sont-elles rÃ©ellement Ã©quivalentesÂ ? L'hypothÃ¨se
intuitive pourrait Ãªtre que la boucle de plus bas niveau sera plus rapide.
IntÃ©ressons nous maintenant Ã  leurs performances.</p>
<!--
## Comparing Performance: Loops vs. Iterators
-->
<h2><a class="header" href="#comparaison-des-performances--les-boucles-et-les-itÃ©rateurs" id="comparaison-des-performances--les-boucles-et-les-itÃ©rateurs">Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></h2>
<!--
To determine whether to use loops or iterators, you need to know which version
of our `search` functions is faster: the version with an explicit `for` loop or
the version with iterators.
-->
<p>Pour dÃ©terminer s'il faut utiliser des boucles ou des itÃ©rateurs, nous devons
savoir quelle version de notre fonction <code>rechercher</code> est la plus rapideÂ : la
version avec une boucle <code>for</code> explicite ou la version avec des itÃ©rateursÂ ?</p>
<!--
We ran a benchmark by loading the entire contents of *The Adventures of
Sherlock Holmes* by Sir Arthur Conan Doyle into a `String` and looking for the
word *the* in the contents. Here are the results of the benchmark on the
version of `search` using the `for` loop and the version using iterators:
-->
<p>Nous avons lancÃ© un benchmark en chargeant tout le contenu de <em>The Adventures
of Sherlock Holmes</em> de Sir Arthur Conan Doyle dans une <code>String</code> et en cherchant
le mot &quot;the&quot; dans le contenu. Voici les rÃ©sultats du benchmark sur la version
de <code>rechercher</code> avec une boucle <code>for</code> et avec un itÃ©rateurÂ :</p>
<!--
```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```
-->
<pre><code class="language-text">test benchmark_rechercher_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test benchmark_rechercher_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<!--
The iterator version was slightly faster! We wonâ€™t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.
-->
<p>La version avec l'itÃ©rateur Ã©tait un peu plus rapideÂ ! Nous n'expliquerons pas
le code du benchmark ici, car il ne s'agit pas de prouver que les deux versions
sont Ã©quivalentes, mais d'avoir une idÃ©e gÃ©nÃ©rale de la diffÃ©rence de
performances entre les deux.</p>
<!--
For a more comprehensive benchmark, you should check using various texts of
various sizes as the `contents`, different words and words of different lengths
as the `query`, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if youâ€™d written the lower-level code yourself. Iterators are one
of Rustâ€™s *zero-cost abstractions*, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
*zero-overhead* in â€œFoundations of C++â€ (2012):
-->
<p>Pour un benchmark plus complet, nous vous conseillons d'utiliser des textes de
diffÃ©rentes tailles pour <code>contenu</code>, des mots diffÃ©rents et de diffÃ©rentes
longueurs pour <code>recherche</code>, ainsi que tout autre type de variation que vous
pourriez trouver. Le point important est le suivantÂ : les itÃ©rateurs, bien qu'il
s'agisse d'une abstraction de haut niveau, sont compilÃ©s Ã  peu prÃ¨s comme si
vous aviez Ã©crit vous-mÃªme le code un niveau plus bas. Les itÃ©rateurs sont l'une
des abstractions Ã  <em>coÃ»t zÃ©ro</em> de Rust, c'est-Ã -dire que l'utilisation de
l'abstraction n'impose aucun surcoÃ»t lors de l'exÃ©cution. C'est la mÃªme notion
que Bjarne Stroustrup, le concepteur et dÃ©veloppeur original de C++, dÃ©finit le
<em>coÃ»t zÃ©ro</em> dans â€œFoundations of C++â€ (2012)Â :</p>
<!--
> In general, C++ implementations obey the zero-overhead principle: What you
> donâ€™t use, you donâ€™t pay for. And further: What you do use, you couldnâ€™t hand
> code any better.
-->
<blockquote>
<p>En gÃ©nÃ©ral, les implÃ©mentations de C++ obÃ©issent au principe du coÃ»t zÃ©roÂ :
ce que vous n'utilisez pas, vous ne payez pas. Et encore plus loinÂ : ce que
vous utilisez, vous ne pouvez pas mieux le coder.</p>
</blockquote>
<!--
As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
`buffer` slice of data, an array of 12 `coefficients`, and an amount by which
to shift data in `qlp_shift`. Weâ€™ve declared the variables within this example
but not given them any values; although this code doesnâ€™t have much meaning
outside of its context, itâ€™s still a concise, real-world example of how Rust
translates high-level ideas to low-level code.
-->
<p>Comme autre exemple, le code suivant est tirÃ© d'un dÃ©codeur audio. L'algorithme
de dÃ©codage utilise l'opÃ©ration mathÃ©matique de prÃ©diction linÃ©aire pour
estimer les valeurs futures Ã  partir d'une fonction linÃ©aire des Ã©chantillons
prÃ©cÃ©dents. Ce code utilise une chaÃ®ne d'itÃ©rateurs pour faire quelques calculs
sur trois variables dans la portÃ©eÂ : une slice de donnÃ©es <code>tampon</code>, un tableau
de 12 <code>coefficients</code>, et une quantitÃ© de dÃ©calage des donnÃ©es dans <code>decalage</code>.
Nous avons dÃ©clarÃ© les variables dans cet exemple, mais nous ne leur avons pas
donnÃ© de valeursÂ ; bien que ce code n'ait pas beaucoup de signification en
dehors de son contexte, c'est toutefois un exemple concis et concret de la faÃ§on
dont Rust traduit des idÃ©es de haut niveau en code de plus bas niveau.</p>
<!--
```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```
-->
<pre><code class="language-rust ignore">let tampon: &amp;mut [i32];
let coefficients: [i64; 12];
let decalage: i16;

for i in 12..tampon.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;tampon[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; decalage;
    let delta = tampon[i];
    tampon[i] = prediction as i32 + delta;
}
</code></pre>
<!--
To calculate the value of `prediction`, this code iterates through each of the
12 values in `coefficients` and uses the `zip` method to pair the coefficient
values with the previous 12 values in `buffer`. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum `qlp_shift` bits to the right.
-->
<p>Pour calculer la valeur de <code>prediction</code>, ce code itÃ¨re sur chacune des 12
valeurs dans <code>coefficients</code> et utilise la mÃ©thode <code>zip</code> pour appairer la
valeur de coefficient avec les 12 valeurs prÃ©cÃ©dentes, prÃ©sentes dans <code>tampon</code>.
Ensuite, pour chaque paire, nous multiplions les valeurs ensemble, nous
additionnons tous les rÃ©sultats et nous dÃ©calons les bits de l'addition de la
valeur de <code>decalage</code> vers la droite.</p>
<!--
Calculations in applications like audio decoders often prioritize performance
most highly. Here, weâ€™re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly youâ€™d write by hand.
Thereâ€™s no loop at all corresponding to the iteration over the values in
`coefficients`: Rust knows that there are 12 iterations, so it â€œunrollsâ€ the
loop. *Unrolling* is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.
-->
<p>Les calculs dans des applications comme les dÃ©codeurs audio donnent souvent la
prioritÃ© aux performances. Ici, nous crÃ©ons un itÃ©rateur Ã  l'aide de deux
adaptateurs, puis nous en consommons la valeur. A quel code d'assemblage
ressemblera ce code Rust ressemblera-t-il une fois compilÃ©Â ? Et bien, Ã  l'heure
oÃ¹ nous Ã©crivons ces lignes, il est Ã©quivalent mÃªme code assembleur que vous
Ã©cririez Ã  la main. Il n'y a pas du tout de boucle correspondant Ã  l'itÃ©ration
sur les valeurs dans <code>coefficients</code>Â : Rust sait qu'il y a 12 itÃ©rations, donc il
â€œdÃ©rouleâ€ la boucle. Le <em>dÃ©roulage</em> est une optimisation qui supprime la
surcharge du code de contrÃ´le de boucle et gÃ©nÃ¨re Ã  la place du code rÃ©pÃ©tÃ© pour
chaque itÃ©ration de la boucle.</p>
<!--
All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like itâ€™s higher level but donâ€™t impose a
runtime performance penalty for doing so.
-->
<p>Tous les coefficients sont stockÃ©s dans des registres, ce qui signifie qu'il
est trÃ¨s rapide d'accÃ©der Ã  ces valeurs. Il n'y a pas de vÃ©rification des bornes
sur les accÃ¨s au tableau Ã  l'exÃ©cution. Toutes ces optimisations que Rust est
capable d'appliquer rendent le code produit extrÃªmement efficace. Maintenant
que vous savez cela, vous pouvez utiliser des itÃ©rateurs et des closures
sans crainteÂ ! Ils font en sorte que le code est de haut niveau, mais ils n'ont
pas de pÃ©nalitÃ© de performance Ã  l'exÃ©cution.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-12" id="rÃ©sumÃ©-12">RÃ©sumÃ©</a></h2>
<!--
Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rustâ€™s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rustâ€™s goal to strive to provide zero-cost abstractions.
-->
<p>Les closures et les itÃ©rateurs sont des fonctionnalitÃ©s de Rust inspirÃ©es par
des idÃ©es des langages de programmation fonctionnels. Ils contribuent Ã  la
capacitÃ© de Rust d'exprimer clairement des idÃ©es de haut niveau avec des
performances dignes d'un langage de bas niveau. Les implÃ©mentations des
closures et des itÃ©rateurs sont telles que les performances Ã  l'exÃ©cution ne
sont pas affectÃ©es. Cela fait partie de l'objectif de Rust de s'efforcer Ã 
fournir des abstractions Ã  coÃ»t zÃ©ro.</p>
<!--
Now that weâ€™ve improved the expressiveness of our I/O project, letâ€™s look at
some more features of `cargo` that will help us share the project with the
world.
-->
<p>Maintenant que nous avons amÃ©liorÃ© l'expressivitÃ© de notre projet
d'entrÃ©e/sortie, regardons d'autres fonctionnalitÃ©s fournies par <code>cargo</code> qui
nous aideront Ã  partager notre projet avec le monde entier.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--19" id="-attention-peinture-fraÃ®che--19">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/179">Pull Request</a>.</p>
</blockquote>
<!--
# More About Cargo and Crates.io
-->
<h1><a class="header" href="#en-savoir-plus-sur-cargo-et-cratesio" id="en-savoir-plus-sur-cargo-et-cratesio">En savoir plus sur cargo et crates.io</a></h1>
<!--
So far weâ€™ve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. In this chapter, weâ€™ll discuss some of its
other, more advanced features to show you how to do the following:
-->
<p>PrÃ©cÃ©demment, nous avons utilisÃ© les fonctionnalitÃ©s les plus basiques de cargo
pour compiler, exÃ©cuter, et tester notre code, mais il peut faire bien plus.
Dans ce chapitre, nous allons voir d'autres fonctionnalitÃ©s avancÃ©es pour vous
apprendre Ã  faire ceciÂ :</p>
<!--
* Customize your build through release profiles
* Publish libraries on [crates.io](https://crates.io/)<!-- ignore -- >
* Organize large projects with workspaces
* Install binaries from [crates.io](https://crates.io/)<!-- ignore -- >
* Extend Cargo using custom commands
-->
<ul>
<li>Personnaliser votre compilation grÃ¢ce aux profils de publication</li>
<li>Publier des bibliothÃ¨ques sur <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organiser des gros projets avec les espaces de travail</li>
<li>Installer des binaires Ã  partir de
<a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>AmÃ©liorer cargo en utilisant des commandes personnalisÃ©es</li>
</ul>
<!--
Cargo can do even more than what we cover in this chapter, so for a full
explanation of all its features, see [its
documentation](https://doc.rust-lang.org/cargo/).
-->
<p>Cargo peut faire encore plus de choses que ce que nous allons voir dans ce
chapitre, donc pour une explication plus complÃ¨te vous avez Ã  votre disposition
<a href="https://doc.rust-lang.org/cargo/">sa documentation</a>.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--20" id="-attention-peinture-fraÃ®che--20">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/180">Pull Request</a>.</p>
</blockquote>
<!--
## Customizing Builds with Release Profiles
-->
<h2><a class="header" href="#personnaliser-les-compilations-avec-les-profils-de-publication" id="personnaliser-les-compilations-avec-les-profils-de-publication">Personnaliser les compilations avec les profils de publication</a></h2>
<!--
In Rust, *release profiles* are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.
-->
<p>Dans Rust, les <em>profils de publication</em> sont profils prÃ©dÃ©finis et
personnalisables avec diffÃ©rentes configurations qui permettent au dÃ©veloppeur
d'avoir plus de contrÃ´le sur diffÃ©rentes options de compilation du code. Chaque
profil est configurÃ© indÃ©pendamment des autres.</p>
<!--
Cargo has two main profiles: the `dev` profile Cargo uses when you run `cargo
build` and the `release` profile Cargo uses when you run `cargo build
--release`. The `dev` profile is defined with good defaults for development,
and the `release` profile has good defaults for release builds.
-->
<p>Cargo a deux profils principauxÂ : le profil <code>dev</code> que cargo utilise lorsque vous
lancez <code>cargo build</code> et le profil <code>release</code> (NdTÂ : publication) que cargo
utilise lorsque vous lancez <code>cargo build --release</code>. Le profil <code>dev</code> est dÃ©fini
avec de bons rÃ©glages par dÃ©faut pour le dÃ©veloppement, et le profil <code>release</code> a
de bons rÃ©glages par dÃ©faut de compilations pour publication.</p>
<!--
These profile names might be familiar from the output of your builds:
-->
<p>Ces noms de profils vous rappellent peut-Ãªtre quelque chose sur la sortie
standard de vos compilationsÂ :</p>
<!--
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-- >
-->
<!--
```console
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
```
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<!--
The `dev` and `release` shown in this build output indicate that the compiler
is using different profiles.
-->
<p>Les profils <code>dev</code> et <code>release</code> sont mentionnÃ©s dans cette sortie de compilation,
pour indiquer les diffÃ©rents profils qu'utilise le compilateur.</p>
<!--
Cargo has default settings for each of the profiles that apply when there
arenâ€™t any `[profile.*]` sections in the projectâ€™s *Cargo.toml* file. By adding
`[profile.*]` sections for any profile you want to customize, you can override
any subset of the default settings. For example, here are the default values
for the `opt-level` setting for the `dev` and `release` profiles:
-->
<p>Cargo a des rÃ©glages par dÃ©faut pour chacun des profils qui s'appliquent
lorsqu'il n'y a pas de section <code>[profile.*]</code> dans le fichier <em>Cargo.toml</em> du
projet. En ajoutant les sections <code>[profile.*]</code> pour chaque profil que vous
souhaitez personnaliser, vous pouvez remplacer n'importe quel paramÃ¨tre par
dÃ©faut. Par exemple, voici les valeurs par dÃ©faut pour le paramÃ¨tre <code>opt-level</code>
des profils <code>dev</code> et <code>release</code>Â :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```
-->
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<!--
The `opt-level` setting controls the number of optimizations Rust will apply to
your code, with a range of 0 to 3. Applying more optimizations extends
compiling time, so if youâ€™re in development and compiling your code often,
youâ€™ll want faster compiling even if the resulting code runs slower. That is
the reason the default `opt-level` for `dev` is `0`. When youâ€™re ready to
release your code, itâ€™s best to spend more time compiling. Youâ€™ll only compile
in release mode once, but youâ€™ll run the compiled program many times, so
release mode trades longer compile time for code that runs faster. That is why
the default `opt-level` for the `release` profile is `3`.
-->
<p>Le paramÃ¨tre <code>opt-level</code> contrÃ´le le nombre d'optimisations que Rust va
appliquer Ã  votre code, sur une Ã©chelle allant de 0 Ã  3. L'application d'un
niveau plus haut d'optimisation signifie un allongement de la durÃ©e de
compilation, donc si vous Ãªtes en train de dÃ©velopper et que vous compilez
souvent votre code, vous prÃ©fÃ©rerez certainement avoir une compilation rapide
mÃªme si le code qui en rÃ©sulte s'exÃ©cute plus lentement. C'est la raison pour
laquelle la valeur par dÃ©faut de <code>opt-level</code> pour <code>dev</code> est Ã  <code>0</code>. Lorsque vous
serez prÃªt Ã  publier votre code, il sera prÃ©fÃ©rable de passer un peu plus de
temps Ã  le compiler. Vous ne compilerez en mode publication (NdTÂ : release)
qu'une seule fois, mais vous exÃ©cuterez le programme compilÃ© plusieurs fois,
donc le mode publication opte pour un temps de compilation plus long afin que le
code s'exÃ©cute plus rapidement. C'est pourquoi le paramÃ¨tre <code>opt-level</code> par
dÃ©faut pour le profil <code>release</code> est Ã  <code>3</code>.</p>
<!--
You can override any default setting by adding a different value for it in
*Cargo.toml*. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our projectâ€™s *Cargo.toml*
file:
-->
<p>Vous pouvez remplacer n'importe quel paramÃ¨tre par dÃ©faut en ajoutant une valeur
diffÃ©rente dans <em>Cargo.toml</em>. Par exemple, si nous voulons utiliser le niveau 1
d'optimisation dans le profil de dÃ©veloppement, nous pouvons ajouter ces deux
lignes Ã  notre fichier <em>Cargo.toml</em>Â :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[profile.dev]
opt-level = 1
```
-->
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<!--
This code overrides the default setting of `0`. Now when we run `cargo build`,
Cargo will use the defaults for the `dev` profile plus our customization to
`opt-level`. Because we set `opt-level` to `1`, Cargo will apply more
optimizations than the default, but not as many as in a release build.
-->
<p>Ce code remplace le paramÃ¨tre par dÃ©faut Ã  <code>0</code>. Maintenant, lorsque nous lanÃ§ons
<code>cargo build</code>, cargo va utiliser les rÃ©glages par dÃ©faut du profil <code>dev</code> ainsi
que notre valeur personnalisÃ©e de <code>opt-level</code>. Comme nous avons rÃ©glÃ©
<code>opt-level</code> Ã  <code>1</code>, Cargo va appliquer plus d'optimisation que par dÃ©faut, mais
pas autant que dans une compilation de publication.</p>
<!--
For the full list of configuration options and defaults for each profile, see
[Cargoâ€™s documentation](https://doc.rust-lang.org/cargo/reference/profiles.html).
-->
<p>Pour la liste complÃ¨te des options de configuration et leurs valeurs par dÃ©faut
pour chaque profil, rendez-vous Ã  la
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">documentation de cargo</a>.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--21" id="-attention-peinture-fraÃ®che--21">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/181">Pull Request</a>.</p>
</blockquote>
<!--
## Publishing a Crate to Crates.io
-->
<h2><a class="header" href="#publier-une-crate-sur-cratesio" id="publier-une-crate-sur-cratesio">Publier une crate sur crates.io</a></h2>
<!--
Weâ€™ve used packages from [crates.io](https://crates.io/)<!-- ignore -- > as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
[crates.io](https://crates.io/)<!-- ignore -- > distributes the source code of
your packages, so it primarily hosts code that is open source.
-->
<p>Nous avons dÃ©jÃ  utilisÃ© des paquets provenant de
<a href="https://crates.io/">crates.io</a><!-- ignore --> comme dÃ©pendance de notre projet,
mais vous pouvez aussi partager votre code avec d'autres personnes en publiant
vos propres paquets. Le registre des crates disponible sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> distribue le code source de vos
paquets, donc il hÃ©berge principalement du code qui est open source.</p>
<!--
Rust and Cargo have features that help make your published package easier for
people to use and to find in the first place. Weâ€™ll talk about some of these
features next and then explain how to publish a package.
-->
<p>Rust et cargo ont des fonctionnalitÃ©s qui aident les dÃ©veloppeurs Ã  trouver et
utiliser les paquets que vous publiez. Nous allons voir certaines de ces
fonctionnalitÃ©s puis nous allons expliquer comment publier un paquet.</p>
<!--
### Making Useful Documentation Comments
-->
<h3><a class="header" href="#crÃ©er-des-commentaires-de-documentation-utiles" id="crÃ©er-des-commentaires-de-documentation-utiles">CrÃ©er des commentaires de documentation utiles</a></h3>
<!--
Accurately documenting your packages will help other users know how and when to
use them, so itâ€™s worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, `//`. Rust also has
a particular kind of comment for documentation, known conveniently as a
*documentation comment*, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to *use* your crate as opposed to how
your crate is *implemented*.
-->
<p>Documenter correctement vos paquets aidera les autres utilisateurs Ã  savoir
comment et quand les utiliser, donc Ã§a vaut la peine de consacrer du temps Ã  la
rÃ©daction de la documentation. Dans le chapitre 3, nous avons vu comment
commenter du code Rust en utilisant deux barres obliques <code>//</code>. Rust a aussi un
type particulier de commentaire pour la documentation, aussi connu sous le nom
de <em>commentaire de documentation</em>, qui va gÃ©nÃ©rer de la documentation en HTML.
Le HTML affiche le contenu des commentaires de documentation pour les Ã©lÃ©ments
public de votre API Ã  destination des dÃ©veloppeurs qui s'intÃ©ressent Ã  la
maniÃ¨re <em>d'utiliser</em> votre crate et non pas Ã  la maniÃ¨re dont elle est
<em>implÃ©mentÃ©e</em>.</p>
<!--
Documentation comments use three slashes, `///`, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item theyâ€™re documenting. Listing 14-1 shows documentation comments
for an `add_one` function in a crate named `my_crate`:
-->
<p>Les commentaires de documentation utilisent trois barres obliques <code>///</code> au lieu
de deux et prend en charge la notation Markdown pour mettre en forme le texte.
Placez les commentaires de documentation juste avant l'Ã©lÃ©ment qu'ils
documentent. L'encart 14-1 montre des commentaires de documentation pour une
fonction <code>ajouter_un</code> dans une crate nommÃ©e <code>ma_crate</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><code class="language-rust ignore">/// Ajoute 1 au nombre donnÃ©.
///
/// # Exemples
///
/// ```
/// let argument = 5;
/// let reponse = ma_crate::ajouter_un(argument);
///
/// assert_eq!(6, reponse);
/// ```
pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<!--
<span class="caption">Listing 14-1: A documentation comment for a
function</span>
-->
<p><span class="caption">Encart 14-1Â : un commentaire de documentation pour une
fonction</span></p>
<!--
Here, we give a description of what the `add_one` function does, start a
section with the heading `Examples`, and then provide code that demonstrates
how to use the `add_one` function. We can generate the HTML documentation from
this documentation comment by running `cargo doc`. This command runs the
`rustdoc` tool distributed with Rust and puts the generated HTML documentation
in the *target/doc* directory.
-->
<p>Ici nous avons Ã©crit une description de ce que fait la fonction <code>ajouter_un</code>,
dÃ©butÃ© une section avec le titre <code>Exemples</code>, et ensuite on a fourni du code qui
montre comment utiliser la fonction <code>ajouter_un</code>. Nous pouvons gÃ©nÃ©rer la
documentation HTML de ces commentaires de documentation en lanÃ§ant <code>cargo doc</code>.
Cette commande lance l'outil <code>rustdoc</code> qui est distribuÃ© avec Rust et place la
documentation HTML gÃ©nÃ©rÃ©e dans le dossier <em>target/doc</em>.</p>
<!--
For convenience, running `cargo doc --open` will build the HTML for your
current crateâ€™s documentation (as well as the documentation for all of your
crateâ€™s dependencies) and open the result in a web browser. Navigate to the
`add_one` function and youâ€™ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1:
-->
<p>Pour plus de facilitÃ©, lancer <code>cargo doc --open</code> va gÃ©nÃ©rer le HTML pour la
documentation de votre crate courante (ainsi que la documentation pour toutes
les dÃ©pendances de la crate) et ouvrir le rÃ©sultat dans un navigateur web.
Rendez-vous Ã  la fonction <code>ajouter_one</code> et vous dÃ©couvrirez comment le texte
dans les commentaires de la documentation a Ã©tÃ© interprÃ©tÃ©, qui devrait
ressembler Ã  l'illustration 14-1Â :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Documentation HTML gÃ©nÃ©rÃ©e pour la fonction `ajouter_un` de `ma_crate`"
    src="img/trpl14-01.png"
    class="center" /></p>
<!--
<span class="caption">Figure 14-1: HTML documentation for the `add_one`
function</span>
-->
<p><span class="caption">Illustration 14-1Â : documentation HTML pour la fonction
<code>ajouter_un</code></span></p>
<!--
#### Commonly Used Sections
-->
<h4><a class="header" href="#les-sections-utilisÃ©es-frÃ©quemment" id="les-sections-utilisÃ©es-frÃ©quemment">Les sections utilisÃ©es frÃ©quemment</a></h4>
<!--
We used the `# Examples` Markdown heading in Listing 14-1 to create a section
in the HTML with the title â€œExamples.â€ Here are some other sections that crate
authors commonly use in their documentation:
-->
<p>Nous avons utilisÃ© le titre en Markdown <code># Exemples</code> dans l'encart 14-1 afin de
crÃ©er une section dans le HTML avec le titre â€œExemplesâ€. Voici d'autres sections
que les auteurs de crate utilisent frÃ©quemment dans leur documentationÂ :</p>
<!--
* **Panics**: The scenarios in which the function being documented could
  panic. Callers of the function who donâ€™t want their programs to panic should
  make sure they donâ€™t call the function in these situations.
* **Errors**: If the function returns a `Result`, describing the kinds of
  errors that might occur and what conditions might cause those errors to be
  returned can be helpful to callers so they can write code to handle the
  different kinds of errors in different ways.
* **Safety**: If the function is `unsafe` to call (we discuss unsafety in
  Chapter 19), there should be a section explaining why the function is unsafe
  and covering the invariants that the function expects callers to uphold.
-->
<ul>
<li><strong>Panics</strong>Â : le scÃ©nario dans lequel la fonction est documentÃ©e peut paniquer.
Ceux qui utilisent la fonction et qui ne veulent pas que leur programme
panique doivent s'assurer qu'ils n'appellent pas la fonction dans ce genre de
situation.</li>
<li><strong>Errors</strong>Â : si la fonction retourne un <code>Result</code>, documenter les types
d'erreurs qui peuvent survenir ainsi que les conditions qui mÃ¨nent Ã  ces
erreurs sera trÃ¨s bÃ©nÃ©fique pour ceux qui utilisent votre API afin qu'ils
puissent Ã©crire du code pour gÃ©rer ces diffÃ©rents types d'erreurs de maniÃ¨re Ã 
ce que cela leur convienne.</li>
<li><strong>Safety</strong>Â : si la fonction fait un appel Ã  <code>unsafe</code> (que nous verrons au
chapitre 19), il devrait exister une section qui explique pourquoi la fonction
fait appel Ã  <em>unsafe</em> et quels sont les paramÃ¨tres que la fonction s'attend Ã 
recevoir des utilisateurs de l'API.</li>
</ul>
<!--
Most documentation comments donâ€™t need all of these sections, but this is a
good checklist to remind you of the aspects of your code that people calling
your code will be interested in knowing about.
-->
<p>La plupart des commentaires sur la documentation n'ont pas besoin de ces
sections, mais c'est une bonne liste de vÃ©rifications Ã  avoir pour vous rappeler
les Ã©lÃ©ments importants Ã  signaler aux utilisateurs.</p>
<!--
#### Documentation Comments as Tests
-->
<h4><a class="header" href="#les-commentaires-de-documentation-pour-faire-des-tests" id="les-commentaires-de-documentation-pour-faire-des-tests">Les commentaires de documentation pour faire des tests</a></h4>
<!--
Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running `cargo
test` will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that donâ€™t work because the code has changed since the documentation was
written. If we run `cargo test` with the documentation for the `add_one`
function from Listing 14-1, we will see a section in the test results like this:
-->
<p>L'ajout des blocs de code d'exemple dans vos commentaires de documentation
peuvent vous aider Ã  montrer comment utiliser votre bibliothÃ¨que, et faire ceci
apporte un bonus supplÃ©mentaireÂ : l'exÃ©cution de <code>cargo test</code> va lancer les
codes d'exemples prÃ©sents dans votre documentation comme Ã©tant des testsÂ ! Il
n'y a rien de mieux que de la documentation avec des exemples. Mais il n'y a
rien de pire que des exemples qui ne fonctionnent plus car le code a changÃ©
depuis que la documentation a Ã©tÃ© Ã©crite. Si nous lanÃ§ons <code>cargo test</code> avec la
documentation de la fonction <code>ajouter_un</code> de l'encart 14-1, nous verrons une
section dans les rÃ©sultats de tests comme celle-ciÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-- >
-->
<!--
```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```
-->
<pre><code class="language-text">   Doc-tests ma_crate

running 1 test
test src/lib.rs - ajouter_un (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Now if we change either the function or the example so the `assert_eq!` in the
example panics and run `cargo test` again, weâ€™ll see that the doc tests catch
that the example and the code are out of sync with each other!
-->
<p>Maintenant, si nous changeons la fonction ou l'exemple de sorte que le
<code>assert_eq!</code> fasse paniquer l'exemple et que nous lanÃ§ons <code>cargo test</code> Ã 
nouveau, nous verrons que les tests de documentation vont dÃ©couvrir que
l'exemple et le code sont dÃ©synchronisÃ©s l'un de l'autreÂ !</p>
<!--
#### Commenting Contained Items
-->
<h4><a class="header" href="#commenter-lÃ©lÃ©ment-qui-contient-lÃ©lÃ©ment-courant" id="commenter-lÃ©lÃ©ment-qui-contient-lÃ©lÃ©ment-courant">Commenter l'Ã©lÃ©ment qui contient l'Ã©lÃ©ment courant</a></h4>
<!--
Another style of doc comment, `//!`, adds documentation to the item that
contains the comments rather than adding documentation to the items following
the comments. We typically use these doc comments inside the crate root file
(*src/lib.rs* by convention) or inside a module to document the crate or the
module as a whole.
-->
<p>Un autre style de commentaire de documentation, <code>//!</code>, ajoute de la
documentation Ã  l'Ã©lÃ©ment qui contient ce commentaire plutÃ´t que d'ajouter la
documentation Ã  l'Ã©lÃ©ment qui suit ce commentaire. Nous utilisons
habituellement ces commentaires de documentation dans le fichier de la crate
racine (qui est <em>src/lib.rs</em> par convention) ou Ã  l'intÃ©rieur d'un module afin
de documenter la crate ou le module dans son ensemble.</p>
<!--
For example, if we want to add documentation that describes the purpose of the
`my_crate` crate that contains the `add_one` function, we can add documentation
comments that start with `//!` to the beginning of the *src/lib.rs* file, as
shown in Listing 14-2:
-->
<p>Par exemple, si nous souhaitons ajouter de la documentation qui dÃ©crit le rÃ´le
de la crate <code>ma_crate</code> qui contient la fonction <code>ajouter_un</code>, nous pouvons
ajouter des commentaires de documentation qui commencent par <code>//!</code> au dÃ©but du
fichier <em>src/lib.rs</em>, comme dans l'encart 14-2Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
# ///
# /// # Examples
# ///
# /// ```
# /// let arg = 5;
# /// let answer = my_crate::add_one(arg);
# ///
# /// assert_eq!(6, answer);
# /// ```
# pub fn add_one(x: i32) -> i32 {
#     x + 1
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">//! # Ma crate
</span><span class="boring">//!
</span><span class="boring">//! `ma_crate` est un regroupement d'utilitaires pour rendre plus pratique
</span><span class="boring">//! certains calculs.
</span><span class="boring">
</span><span class="boring">/// Ajoute 1 au nombre donnÃ©.
</span><span class="boring">// -- partie masquÃ©e ici --
</span><span class="boring">///
</span><span class="boring">/// # Exemples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let argument = 5;
</span><span class="boring">/// let reponse = ma_crate::ajouter_un(argument);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, reponse);
</span><span class="boring">/// ```
</span><span class="boring">pub fn ajouter_un(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 14-2: Documentation for the `my_crate` crate as a
whole</span>
-->
<p><span class="caption">Encart 14-2Â : documentation portant sur la crate
<code>ma_crate</code></span></p>
<!--
Notice there isnâ€™t any code after the last line that begins with `//!`. Because
we started the comments with `//!` instead of `///`, weâ€™re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the *src/lib.rs* file, which
is the crate root. These comments describe the entire crate.
-->
<p>Remarquez qu'il n'y a pas de code aprÃ¨s la derniÃ¨re ligne qui commence par
<code>//!</code>. Comme nous commenÃ§ons les commentaires par <code>//!</code> au lieu de <code>///</code>, nous
documentons l'Ã©lÃ©ment qui contient ce commentaire plutÃ´t que l'Ã©lÃ©ment qui suit
ce commentaire. Dans notre cas, l'Ã©lÃ©ment qui contient ce commentaire est le
fichier <em>src/lib.rs</em>, qui est la racine de la crate. Ces commentaires vont
dÃ©crire l'intÃ©gralitÃ© de la crate.</p>
<!--
When we run `cargo doc --open`, these comments will display on the front
page of the documentation for `my_crate` above the list of public items in the
crate, as shown in Figure 14-2:
-->
<p>Lorsque nous lanÃ§ons <code>cargo doc --open</code>, ces commentaires vont s'afficher sur la
page d'accueil de la documentation de <code>ma_crate</code>, au-dessus de la liste des
Ã©lÃ©ments publics de la crate, comme montrÃ© dans l'illustration 14-2Â :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Documentation HTML gÃ©nÃ©rÃ©e avec un commentaire pour toute la crate"
    src="img/trpl14-02.png"
    class="center" /></p>
<!--
<span class="caption">Figure 14-2: Rendered documentation for `my_crate`,
including the comment describing the crate as a whole</span>
-->
<p><span class="caption">Illustration 14-2Â : Documentation gÃ©nÃ©rÃ©e pour <code>ma_crate</code>,
qui contient le commentaire qui dÃ©crit l'intÃ©gralitÃ© de la crate</span></p>
<!--
Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your users understand the crateâ€™s organization.
-->
<p>Les commentaires de la documentation placÃ©s Ã  l'intÃ©rieur des Ã©lÃ©ments sont
particuliÃ¨rement utiles pour dÃ©crire les crates et les modules. Utilisez-les
pour expliquer globalement le rÃ´le du conteneur pour aider vos utilisateurs Ã 
comprendre l'organisation de votre crate.</p>
<!--
### Exporting a Convenient Public API with `pub use`
-->
<h3><a class="header" href="#exporter-une-api-publique-conviviale-avec-pub-use" id="exporter-une-api-publique-conviviale-avec-pub-use">Exporter une API publique conviviale avec <code>pub use</code></a></h3>
<!--
In Chapter 7, we covered how to organize our code into modules using the `mod`
keyword, how to make items public using the `pub` keyword, and how to bring
items into a scope with the `use` keyword. However, the structure that makes
sense to you while youâ€™re developing a crate might not be very convenient for
your users. You might want to organize your structs in a hierarchy containing
multiple levels, but then people who want to use a type youâ€™ve defined deep in
the hierarchy might have trouble finding out that type exists. They might also
be annoyed at having to enter `use`
`my_crate::some_module::another_module::UsefulType;` rather than `use`
`my_crate::UsefulType;`.
-->
<p>Dans le chapitre 7, nous avons vu comment organiser notre code en modules en
utilisant le mot-clÃ© <code>mod</code>, comment faire pour rendre des Ã©lÃ©ments publics en
utilisant le mot-clÃ© <code>pub</code>, et comment importer des Ã©lÃ©ments dans la portÃ©e en
utilisant le mot-clÃ© <code>use</code>. Cependant, la structure qui a un sens pour vous
pendant que vous dÃ©veloppez une crate peut ne pas Ãªtre pratique pour vos
utilisateurs. Vous pourriez vouloir organiser vos structures dans une hiÃ©rarchie
qui a plusieurs niveaux, mais les personnes qui veulent utiliser un type que
vous avez dÃ©fini dans un niveau profond de la hiÃ©rarchie pourraient rencontrer
des difficultÃ©s pour savoir que ce type existe. Ils peuvent aussi Ãªtre agacÃ©s
d'avoir Ã  Ã©crire <code>use ma_crate::un_module::un_autre_module::TypeUtile;</code> plutÃ´t
que <code>use ma_crate::TypeUtile;</code>.</p>
<!--
The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.
-->
<p>La structure de votre API publique est une question importante lorsque vous
publiez une crate. Les personnes qui utilisent votre crate sont moins familiers
avec la structure que vous l'Ãªtes et pourraient avoir des difficultÃ©s Ã  trouver
les Ã©lÃ©ments qu'ils souhaitent utiliser si votre crate a une hiÃ©rarchie de
module imposante.</p>
<!--
The good news is that if the structure *isnâ€™t* convenient for others to use
from another library, you donâ€™t have to rearrange your internal organization:
instead, you can re-export items to make a public structure thatâ€™s different
from your private structure by using `pub use`. Re-exporting takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.
-->
<p>La bonne nouvelle est que si la structure <em>n'est pas</em> pratique pour ceux qui
l'utilisent dans une autre bibliothÃ¨que, vous n'avez pas Ã  rÃ©organiser votre
organisation interneÂ : Ã  la place, vous pouvez rÃ©-exporter les Ã©lÃ©ments pour
crÃ©er une structure publique qui est diffÃ©rente de votre structure privÃ©e en
utilisant <code>pub use</code>. RÃ©-exporter prend un Ã©lÃ©ment public d'un endroit et le
rend public dans un autre endroit, comme s'il Ã©tait dÃ©fini dans l'autre endroit.</p>
<!--
For example, say we made a library named `art` for modeling artistic concepts.
Within this library are two modules: a `kinds` module containing two enums
named `PrimaryColor` and `SecondaryColor` and a `utils` module containing a
function named `mix`, as shown in Listing 14-3:
-->
<p>Par exemple, disons que nous avons crÃ©Ã© une bibliothÃ¨que <code>art</code> pour modÃ©liser
des concepts artistiques. A l'intÃ©rieur de cette bibliothÃ¨que nous avons deux
modulesÂ : un module <code>types</code> qui contient deux Ã©numÃ©rations <code>CouleurPrimaire</code> et
<code>CouleurSecondaire</code>, et un module <code>utilitaires</code> qui contient une fonction
<code>mixer</code>, comme dans l'encart 14-3Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
#         SecondaryColor::Orange
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">//! # Art
//!
//! Une bibliothÃ¨que pour modÃ©liser des concepts artistiques.

pub mod types {
    /// Les couleurs primaires du modÃ¨le RJB.
    pub enum CouleurPrimaire {
        Rouge,
        Jaune,
        Bleu,
    }

    /// Les couleurs secondaires du modÃ¨le RJB.
    pub enum CouleurSecondaire {
        Orange,
        Vert,
        Violet,
    }
}

pub mod utilitaires {
    use crate::types::*;

    /// Combine deux couleurs primaires dans les mÃªmes quantitÃ©s pour
    /// crÃ©er une couleur secondaire.
    pub fn mixer(c1: CouleurPrimaire, c2: CouleurPrimaire) -&gt; CouleurSecondaire {
        // -- partie masquÃ©e ici --
<span class="boring">        CouleurSecondaire::Orange
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 14-3: An `art` library with items organized into
`kinds` and `utils` modules</span>
-->
<p><span class="caption">Encart 14-3Â : une bibliothÃ¨que <code>art</code> avec des Ã©lÃ©ments
organisÃ©s selon les modules <code>types</code> and <code>utilitaires</code></span></p>
<!--
Figure 14-3 shows what the front page of the documentation for this crate
generated by `cargo doc` would look like:
-->
<p>L'illustration 14-3 montre la page d'accueil de la documentation de cette crate
gÃ©nÃ©rÃ©e par <code>cargo doc</code> qui devrait ressembler Ã  celaÂ :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
-->
<p><img
    alt="Documentation gÃ©nÃ©rÃ©e pour la crate `art` qui liste les modules `types` et `utilitaires`"
    src="img/trpl14-03.png"
    class="center" /></p>
<!-- markdownlint-restore -->
<!--
<span class="caption">Figure 14-3: Front page of the documentation for `art`
that lists the `kinds` and `utils` modules</span>
-->
<p><span class="caption">Illustration 14-3Â : Page d'accueil de la documentation de
<code>art</code> qui liste les modules <code>types</code> et <code>utilitaires</code></span></p>
<!--
Note that the `PrimaryColor` and `SecondaryColor` types arenâ€™t listed on the
front page, nor is the `mix` function. We have to click `kinds` and `utils` to
see them.
-->
<p>Notez que les types <code>CouleurPrimaire</code> et <code>CouleurSecondaire</code> ne sont pas listÃ©s
sur la page d'accueil, ni la fonction <code>mixer</code>. Nous devons cliquer sur <code>types</code>
et <code>utilitaires</code> pour les voir.</p>
<!--
Another crate that depends on this library would need `use` statements that
bring the items from `art` into scope, specifying the module structure thatâ€™s
currently defined. Listing 14-4 shows an example of a crate that uses the
`PrimaryColor` and `mix` items from the `art` crate:
-->
<p>Une autre crate qui dÃ©pend de cette bibliothÃ¨que va avoir besoin d'utiliser
l'instruction <code>use</code> pour importer les Ã©lÃ©ments de <code>art</code> dans sa portÃ©e, en
suivant la structure du module qui est actuellement dÃ©finie. L'encart 14-4
montre un exemple d'une crate qui utilise les Ã©lÃ©ments <code>CouleurPrimaire</code> et
<code>mixer</code> de la crate <code>art</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```
-->
<pre><code class="language-rust ignore">use art::types::CouleurPrimaire;
use art::utilitaires::mixer;

fn main() {
    let rouge = CouleurPrimaire::Rouge;
    let jaune = CouleurPrimaire::Jaune;
    mixer(rouge, jaune);
}
</code></pre>
<!--
<span class="caption">Listing 14-4: A crate using the `art` crateâ€™s items with
its internal structure exported</span>
-->
<p><span class="caption">Encart 14-4Â : une crate qui utilise les Ã©lÃ©ments de la
crate <code>art</code> avec sa structure interne exportÃ©e</span></p>
<!--
The author of the code in Listing 14-4, which uses the `art` crate, had to
figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the
`utils` module. The module structure of the `art` crate is more relevant to
developers working on the `art` crate than to developers using the `art` crate.
The internal structure that organizes parts of the crate into the `kinds`
module and the `utils` module doesnâ€™t contain any useful information for
someone trying to understand how to use the `art` crate. Instead, the `art`
crateâ€™s module structure causes confusion because developers have to figure out
where to look, and the structure is inconvenient because developers must
specify the module names in the `use` statements.
-->
<p>L'auteur du code de l'encart 14-4, qui utilise la crate <code>art</code>, doit comprendre
que <code>CouleurPrimaire</code> est dans le module <code>types</code> et que <code>mixer</code> est dans le
module <code>utilitaires</code>. La structure du module de la crate <code>art</code> est bien plus
pratique pour les dÃ©veloppeurs qui travaillent sur la crate <code>art</code> que pour les
dÃ©veloppeurs qui utilisent la crate <code>art</code>. La structure interne qui divise les
Ã©lÃ©ments de la crate dans le module <code>types</code> et le module <code>utilitaires</code> ne
contient aucune information utile Ã  quelqu'un qui essaye de comprendre comment
utiliser la crate <code>art</code>. Au lieu de cela, la structure du module de la crate
<code>art</code> gÃ©nÃ¨re de la confusion car les dÃ©veloppeurs doivent dÃ©couvrir oÃ¹ trouver
les Ã©lÃ©ments, et la structure n'est pas pratique car les dÃ©veloppeurs doivent
renseigner les noms des modules dans les instructions <code>use</code>.</p>
<!--
To remove the internal organization from the public API, we can modify the
`art` crate code in Listing 14-3 to add `pub use` statements to re-export the
items at the top level, as shown in Listing 14-5:
-->
<p>Pour masquer l'organisation interne de l'API publique, nous pouvons modifier le
code de la crate <code>art</code> de l'encart 14-3 pour ajouter l'instruction <code>pub use</code>
pour rÃ©-exporter les Ã©lÃ©ments au niveau supÃ©rieur, comme montrÃ© dans l'encart
14-5Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
#     /// The primary colors according to the RYB color model.
#     pub enum PrimaryColor {
#         Red,
#         Yellow,
#         Blue,
#     }
# 
#     /// The secondary colors according to the RYB color model.
#     pub enum SecondaryColor {
#         Orange,
#         Green,
#         Purple,
#     }
}

pub mod utils {
    // --snip--
#     use crate::kinds::*;
# 
#     /// Combines two primary colors in equal amounts to create
#     /// a secondary color.
#     pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
#         SecondaryColor::Orange
#     }
}
```
-->
<pre><code class="language-rust ignore">//! # Art
//!
//! Une bibliothÃ¨que pour modÃ©liser des concepts artistiques.

pub use self::types::CouleurPrimaire;
pub use self::types::CouleurSecondaire;
pub use self::utilitaires::mixer;

pub mod types {
    // -- partie masquÃ©e ici --
<span class="boring">    /// Les couleurs primaires du modÃ¨le RJB.
</span><span class="boring">    pub enum CouleurPrimaire {
</span><span class="boring">        Rouge,
</span><span class="boring">        Jaune,
</span><span class="boring">        Bleu,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Les couleurs secondaires du modÃ¨le RJB.
</span><span class="boring">    pub enum CouleurSecondaire {
</span><span class="boring">        Orange,
</span><span class="boring">        Vert,
</span><span class="boring">        Violet,
</span><span class="boring">    }
</span>}

pub mod utilitaires {
    // -- partie masquÃ©e ici --
<span class="boring">    use crate::types::*;
</span><span class="boring">
</span><span class="boring">    /// Combine deux couleurs primaires dans les mÃªmes quantitÃ©s pour
</span><span class="boring">    /// crÃ©er une couleur secondaire.
</span><span class="boring">    pub fn mixer(c1: CouleurPrimaire, c2: CouleurPrimaire) -&gt; CouleurSecondaire {
</span><span class="boring">        CouleurSecondaire::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 14-5: Adding `pub use` statements to re-export
items</span>
-->
<p><span class="caption">Encart 14-5Â : ajout de l'instruction <code>pub use</code> pour
rÃ©-exporter les Ã©lÃ©ments</span></p>
<!--
The API documentation that `cargo doc` generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
`PrimaryColor` and `SecondaryColor` types and the `mix` function easier to find.
-->
<p>La documentation de l'API qui <code>cargo doc</code> a gÃ©nÃ©rÃ© pour cette crate va
maintenant lister et lier les rÃ©-exportations sur la page d'accueil, comme dans
l'illustration 14-4, ce qui rend les types <code>CouleurPrimaire</code> et
<code>CouleurSecondaire</code> plus faciles Ã  trouver.</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
-->
<p><img
    alt="Documentation gÃ©nÃ©rÃ©e pour la crate `art` avec les rÃ©-exports sur la page d'accueil"
    src="img/trpl14-04.png"
    class="center" /></p>
<!-- markdownlint-restore -->
<!--
<span class="caption">Figure 14-4: The front page of the documentation for `art`
that lists the re-exports</span>
-->
<p><span class="caption">Illustration 14-4Â : la page d'accueil de la documentation
pour <code>art</code> qui liste les rÃ©-exports</span></p>
<!--
The `art` crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6:
-->
<p>Les utilisateurs de la crate <code>art</code> peuvent toujours voir et utiliser la
structure interne de l'encart 14-3 comme ils l'utilisaient dans l'encart 14-4,
mais ils peuvent maintenant utiliser la structure plus pratique de l'encart
14-5, comme montrÃ© dans l'encart 14-6Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
#     let red = PrimaryColor::Red;
#     let yellow = PrimaryColor::Yellow;
#     mix(red, yellow);
}
```
-->
<pre><code class="language-rust ignore">use art::mixer;
use art::CouleurPrimaire;

fn main() {
    // -- partie masquÃ©e ici --
<span class="boring">    let rouge = CouleurPrimaire::Rouge;
</span><span class="boring">    let jaune = CouleurPrimaire::Jaune;
</span><span class="boring">    mixer(rouge, jaune);
</span>}
</code></pre>
<!--
<span class="caption">Listing 14-6: A program using the re-exported items from
the `art` crate</span>
-->
<p><span class="caption">Encart 14-6Â : un programme qui utilise les Ã©lÃ©ments
rÃ©-exportÃ©s de la crate <code>art</code></span></p>
<!--
In cases where there are many nested modules, re-exporting the types at the top
level with `pub use` can make a significant difference in the experience of
people who use the crate.
-->
<p>Dans les cas oÃ¹ il y a de nombreux modules imbriquÃ©s, rÃ©-exporter les types au
niveau le plus haut avec <code>pub use</code> peut faire une diffÃ©rence significative dans
l'expÃ©rience utilisateur de ceux qui utilisent cette crate.</p>
<!--
Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing `pub
use` gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates youâ€™ve installed to see if their internal structure
differs from their public API.
-->
<p>CrÃ©er une structure d'API publique utile est plus un art qu'une science, et vous
pouvez itÃ©rer plusieurs fois pour trouver une API qui fonctionne mieux pour vos
utilisateurs. Choisir <code>pub use</code> vous donne de la flexibilitÃ© pour l'organisation
interne de votre crate et dÃ©couple la structure interne de ce que vous prÃ©sentez
aux utilisateurs. N'hÃ©sitez pas Ã  regarder le code source des crates que vous
avez installÃ© pour voir si leur structure interne est diffÃ©rente de leur API
publique.</p>
<!--
### Setting Up a Crates.io Account
-->
<h3><a class="header" href="#mise-en-place-dun-compte-cratesio" id="mise-en-place-dun-compte-cratesio">Mise en place d'un compte crates.io</a></h3>
<!--
Before you can publish any crates, you need to create an account on
[crates.io](https://crates.io/)<!-- ignore -- > and get an API token. To do so,
visit the home page at [crates.io](https://crates.io/)<!-- ignore -- > and log in
via a GitHub account. (The GitHub account is currently a requirement, but the
site might support other ways of creating an account in the future.) Once
youâ€™re logged in, visit your account settings at
[https://crates.io/me/](https://crates.io/me/)<!-- ignore -- > and retrieve your
API key. Then run the `cargo login` command with your API key, like this:
-->
<p>Avant de pouvoir publier une crate, vous devez crÃ©er un compte sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> et obtenir un jeton d'API. Pour
pouvoir faire cela, visitez la page d'accueil de
<a href="https://crates.io/">crates.io</a><!-- ignore --> et connectez-vous avec votre
compte GitHub (le compte GitHub est actuellement une obligation, mais crates.io
pourra permettre de crÃ©er un compte d'une autre maniÃ¨re un jour). Une fois
identifiÃ©, visitez les rÃ©glages de votre compte Ã  l'adresse
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> et rÃ©cupÃ©rez votre
jeton d'API (NdTÂ : <em>API key</em>). Ensuite, lancez la commande <code>cargo login</code> avec
votre clÃ© d'API, comme ceciÂ :</p>
<!--
```console
$ cargo login abcdefghijklmnopqrstuvwxyz012345
```
-->
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<!--
This command will inform Cargo of your API token and store it locally in
*~/.cargo/credentials*. Note that this token is a *secret*: do not share it
with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on [crates.io](https://crates.io/)<!-- ignore
-- >.
-->
<p>Cette commande informera cargo de votre jeton d'API et l'enregistrera localement
dans <em>~/.cargo/credentials</em>. Notez que ce jeton est un <em>secret</em>Â : ne le partagez
avec personne d'autre. Si vous le donnez Ã  quelqu'un pour une quelconque raison,
vous devriez la rÃ©voquer et gÃ©nÃ©rer un nouveau jeton sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->.</p>
<!--
### Adding Metadata to a New Crate
-->
<h3><a class="header" href="#ajouter-des-mÃ©tadonnÃ©es-Ã -une-nouvelle-crate" id="ajouter-des-mÃ©tadonnÃ©es-Ã -une-nouvelle-crate">Ajouter des mÃ©tadonnÃ©es Ã  une nouvelle crate</a></h3>
<!--
Now that you have an account, letâ€™s say you have a crate you want to publish.
Before publishing, youâ€™ll need to add some metadata to your crate by adding it
to the `[package]` section of the crateâ€™s *Cargo.toml* file.
-->
<p>Maintenant que vous avez un compte, imaginons que vous avez une crate que vous
souhaitez publier. Avant de la publier, vous aurez besoin d'ajouter quelques
mÃ©tadonnÃ©es Ã  votre crate en les ajoutant Ã  la section <code>[package]</code> de votre
fichier <em>Cargo.toml</em> de la crate.</p>
<!--
Your crate will need a unique name. While youâ€™re working on a crate locally,
you can name a crate whatever youâ€™d like. However, crate names on
[crates.io](https://crates.io/)<!-- ignore -- > are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Before attempting to publish a crate, search for the name you
want to use on the site. If the name has been used by another crate, you will
need to find another name and edit the `name` field in the *Cargo.toml* file
under the `[package]` section to use the new name for publishing, like so:
-->
<p>Votre crate va avoir besoin d'un nom unique. Tant que vous travaillez en local,
vous pouvez nommer un crate comme vous le souhaitez. Cependant, les noms des
crates sur <a href="https://crates.io/">crates.io</a><!-- ignore --> sont accordÃ©s selon le
principe du <em>premier arrivÃ©, premier servi</em>. Une fois qu'un nom de crate est
accordÃ©, personne d'autre ne peut publier une crate avec ce nom. Avant d'essayer
de publier une crate, recherchez sur le site le nom que vous souhaitez utiliser.
Si le nom a Ã©tÃ© utilisÃ© par une autre crate, vous allez devoir trouver un autre
nom et modifier le champ <code>name</code> dans le fichier <em>Cargo.toml</em> sous la section
<code>[package]</code> pour utiliser le nouveau nom pour la publication, comme ceciÂ :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
</code></pre>
<!--
Even if youâ€™ve chosen a unique name, when you run `cargo publish` to publish
the crate at this point, youâ€™ll get a warning and then an error:
-->
<p>MÃªme si vous avez choisi un nom unique, lorsque vous lancez <code>cargo publish</code> pour
publier la crate Ã  ce stade, vous allez avoir un avertissement suivi par une
erreurÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-- >
-->
<!--
```console
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
```
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
-- partie masquÃ©e ici --
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<!--
The reason is that youâ€™re missing some crucial information: a description and
license are required so people will know what your crate does and under what
terms they can use it. To rectify this error, you need to include this
information in the *Cargo.toml* file.
-->
<p>La raison est qu'il manque quelques informations essentiellesÂ : une description
et une licence sont nÃ©cessaires pour que les gens puissent savoir ce que fait
votre crate et sous quelles conditions ils peuvent l'utiliser. Pour corriger
cette erreur, vous devez rajouter ces informations dans le fichier <em>Cargo.toml</em>.</p>
<!--
Add a description that is just a sentence or two, because it will appear with
your crate in search results. For the `license` field, you need to give a
*license identifier value*. The [Linux Foundationâ€™s Software Package Data
Exchange (SPDX)][spdx] lists the identifiers you can use for this value. For
example, to specify that youâ€™ve licensed your crate using the MIT License, add
the `MIT` identifier:
-->
<p>Ajoutez une description qui ne fait qu'une phrase ou deux, car elle va
s'afficher Ã  proximitÃ© de votre crate dans les rÃ©sultats de recherche. Pour le
champ <code>license</code>, vous devez donner une <em>valeur d'identification de la licence</em>.
La <a href="http://spdx.org/licenses/">Linux Foundationâ€™s Software Package Data Exchange (SPDX)</a> liste les
identifications que vous pouvez utiliser pour cette valeur. Par exemple, pour
renseigner que votre crate est sous la licence MIT, ajoutez l'identifiant
<code>MIT</code>Â :</p>
<!--
[spdx]: http://spdx.org/licenses/
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
license = "MIT"
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
license = &quot;MIT&quot;
</code></pre>
<!--
If you want to use a license that doesnâ€™t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use `license-file` to specify the name of that file instead of using the
`license` key.
-->
<p>Si vous voulez utiliser une licence qui n'apparaÃ®t pas dans le SPDX, vous devez
placer le texte de cette licence dans un fichier, inclure ce fichier dans votre
projet, et ensuite utiliser <code>licence-file</code> pour renseigner le nom de ce fichier
plutÃ´t que d'utiliser la clÃ© <code>licence</code>.</p>
<!--
Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of `MIT OR Apache-2.0`. This practice
demonstrates that you can also specify multiple license identifiers separated
by `OR` to have multiple licenses for your project.
-->
<p>Les conseils sur le choix de la licence appropriÃ©e pour votre projet sortent du
cadre de ce livre. De nombreuses personnes dans la communautÃ© Rust appliquent Ã 
leurs projets la mÃªme licence que Rust qui utilise la licence double
<code>MIT OR Apache-2.0</code>. Cette pratique montre que vous pouvez Ã©galement indiquer
plusieurs identificateurs de licence sÃ©parÃ©s par <code>OR</code> pour avoir plusieurs
licences pour votre projet.</p>
<!--
With a unique name, the version, the author details that `cargo new` added
when you created the crate, your description, and a license added, the
*Cargo.toml* file for a project that is ready to publish might look like this:
-->
<p>Avec le nom unique, la version, les informations du dÃ©veloppeur que <code>cargo new</code>
a ajoutÃ© lorsque vous avez crÃ©Ã© la crate, ainsi que la description et la licence
que vous avez ajoutÃ©, le fichier <em>Cargo.toml</em> de ce projet qui est prÃªt Ã  Ãªtre
publiÃ© devrait ressembler Ã  ceci :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Votre nom &lt;adresse@exemple.com&gt;&quot;]
edition = &quot;2018&quot;
description = &quot;Un jeu oÃ¹ vous devez deviner quel nombre l'ordinateur a choisi.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<!--
[Cargoâ€™s documentation](https://doc.rust-lang.org/cargo/) describes other
metadata you can specify to ensure others can discover and use your crate more
easily.
-->
<p>La <a href="https://doc.rust-lang.org/cargo/">documentation de cargo</a> dÃ©cris d'autres
mÃ©tadonnÃ©es que vous pouvez renseigner pour vous assurer que les autres
dÃ©veloppeurs puissent dÃ©couvrir encore plus facilement votre crate.</p>
<!--
### Publishing to Crates.io
-->
<h3><a class="header" href="#publier-sur-cratesio" id="publier-sur-cratesio">Publier sur crates.io</a></h3>
<!--
Now that youâ€™ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, youâ€™re ready to publish!
Publishing a crate uploads a specific version to
[crates.io](https://crates.io/)<!-- ignore -- > for others to use.
-->
<p>Maintenant que vous avez crÃ©Ã© un compte, sauvegardÃ© votre jeton de clÃ©, choisi
un nom pour votre crate, et prÃ©cisÃ© les mÃ©tadonnÃ©es requises, vous Ãªtes prÃªt Ã 
publier ! Publier une crate tÃ©lÃ©verse une version prÃ©cise sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> pour que les autres puissent
l'utiliser.</p>
<!--
Be careful when publishing a crate because a publish is *permanent*. The
version can never be overwritten, and the code cannot be deleted. One major
goal of [crates.io](https://crates.io/)<!-- ignore -- > is to act as a permanent
archive of code so that builds of all projects that depend on crates from
[crates.io](https://crates.io/)<!-- ignore -- > will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.
-->
<p>Faites attention lorsque vous publiez une crate car une publication est
<em>permanente</em>. La version ne pourra jamais Ãªtre remplacÃ©e, et le code ne pourra
jamais Ãªtre effacÃ©. Le but majeur de
<a href="https://crates.io/">crates.io</a><!-- ignore --> est de fournir une archive
durable de code afin que les compilations de tous les projets qui dÃ©pendent des
crates de <a href="https://crates.io/">crates.io</a><!-- ignore --> puissent toujours
continuer Ã  fonctionner. Si la suppression de version Ã©tait autorisÃ©e, cela
rendrait ce but impossible. Cependant, il n'y a pas de limites au nombre de
versions de votre crate que vous pouvez publier.</p>
<!--
Run the `cargo publish` command again. It should succeed now:
-->
<p>Lancez la commande <code>cargo publish</code> Ã  nouveau. Elle devrait fonctionner Ã 
prÃ©sent :</p>
<!--
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-- >
-->
<!--
```console
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
   Verifying jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
   Compiling jeu_du_plus_ou_du_moins v0.1.0
(file:///projects/jeu_du_plus_ou_du_moins/target/package/jeu_du_plus_ou_du_moins-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
</code></pre>
<!--
Congratulations! Youâ€™ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.
-->
<p>FÃ©licitations ! Vous venez de partager votre code avec la communautÃ© Rust, et
dÃ©sormais tout le monde peut facilement ajouter votre crate comme une dÃ©pendance
de leur projet.</p>
<!--
### Publishing a New Version of an Existing Crate
-->
<h3><a class="header" href="#publier-une-nouvelle-version-dune-crate-existante" id="publier-une-nouvelle-version-dune-crate-existante">Publier une nouvelle version d'une crate existante</a></h3>
<!--
When youâ€™ve made changes to your crate and are ready to release a new version,
you change the `version` value specified in your *Cargo.toml* file and
republish. Use the [Semantic Versioning rules][semver] to decide what an
appropriate next version number is based on the kinds of changes youâ€™ve made.
Then run `cargo publish` to upload the new version.
-->
<p>Lorsque vous avez fait des changements sur votre crate et que vous Ãªtes prÃªt Ã 
publier une nouvelle version, vous devez changer la valeur de <code>version</code>
renseignÃ©e dans votre fichier <em>Cargo.toml</em> et le publier Ã  nouveau. Utilisez les
<a href="https://semver.org/lang/fr/">rÃ¨gles versionnage sÃ©mantique</a> pour choisir quelle sera la prochaine
version la plus appropriÃ©e en fonction des changements que vous avez fait.
Lancez ensuite <code>cargo publish</code> pour tÃ©lÃ©verser la nouvelle version.</p>
<!--
[semver]: http://semver.org/
-->
<!--
### Removing Versions from Crates.io with `cargo yank`
-->
<h3><a class="header" href="#retirer-des-versions-de-cratesio-avec-cargo-yank" id="retirer-des-versions-de-cratesio-avec-cargo-yank">Retirer des versions de crates.io avec <code>cargo yank</code></a></h3>
<!--
Although you canâ€™t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports *yanking* a crate version.
-->
<p>Bien que vous ne puissiez pas enlever des versions prÃ©cÃ©dentes d'une crate, vous
pouvez prÃ©venir les futurs projets de ne pas l'ajouter comme une nouvelle
dÃ©pendance. Cela s'avÃ¨re pratique lorsqu'une version de crate est dÃ©fectueuse
pour une raison ou une autre. Dans de telles circonstances, cargo permet de
<em>dÃ©prÃ©cier</em> une version de crate.</p>
<!--
Yanking a version prevents new projects from starting to depend on that version
while allowing all existing projects that depend on it to continue to download
and depend on that version. Essentially, a yank means that all projects with a
*Cargo.lock* will not break, and any future *Cargo.lock* files generated will
not use the yanked version.
-->
<p>DÃ©prÃ©cier une version Ã©vite que les nouveaux projets ajoutent une dÃ©pendance Ã 
cette version tout en permettant Ã  tous les projets existants de continuer Ã  en
dÃ©pendre en leur permettant toujours de tÃ©lÃ©charger et dÃ©pendre de cette
version. En gros, une version dÃ©prÃ©ciÃ©e permet Ã  tous les projets avec un
<em>Cargo.lock</em> de ne pas Ã©chouer, mais tous les futurs fichiers <em>Cargo.lock</em>
gÃ©nÃ©rÃ©s n'utiliseront pas la version dÃ©prÃ©ciÃ©e.</p>
<!--
To yank a version of a crate, run `cargo yank` and specify which version you
want to yank:
-->
<p>Pour dÃ©prÃ©cier une version d'une crate, lancez <code>cargo yank</code> et renseignez quelle
version vous voulez dÃ©prÃ©cier :</p>
<!--
```console
$ cargo yank --vers 1.0.1
```
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
</code></pre>
<!--
By adding `--undo` to the command, you can also undo a yank and allow projects
to start depending on a version again:
-->
<p>Si vous ajoutez <code>--undo</code> Ã  la commande, vous pouvez aussi annuler une
dÃ©prÃ©ciation et permettre Ã  nouveaux aux projets de dÃ©pendre de cette version :</p>
<!--
```console
$ cargo yank --vers 1.0.1 --undo
```
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<!--
A yank *does not* delete any code. For example, the yank feature is not
intended for deleting accidentally uploaded secrets. If that happens, you must
reset those secrets immediately.
-->
<p>Une dÃ©prÃ©ciation <em>ne supprime pas</em> du code. Par exemple, la fonctionnalitÃ© de
dÃ©prÃ©ciation n'est pas conÃ§ue pour supprimer des <em>secrets</em> tÃ©lÃ©versÃ©s par
mÃ©garde. Si cela arrive, vous devriez rÃ©gÃ©nÃ©rer immÃ©diatement ces secrets.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--22" id="-attention-peinture-fraÃ®che--22">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/182">Pull Request</a>.</p>
</blockquote>
<!--
## Cargo Workspaces
-->
<h2><a class="header" href="#les-espaces-de-travail-de-cargo" id="les-espaces-de-travail-de-cargo">Les espaces de travail de cargo</a></h2>
<!--
In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split up your package further into
multiple library crates. In this situation, Cargo offers a feature called
*workspaces* that can help manage multiple related packages that are developed
in tandem.
-->
<p>Dans le chapitre 12, nous avons construit un paquet qui comprenait une crate
binaire et une crate de bibliothÃ¨que. Au fur et Ã  mesure que votre projet se
dÃ©veloppe, vous pourrez constater que la crate de bibliothÃ¨que continue de
s'agrandir et vous voudriez alors peut-Ãªtre diviser votre paquet en plusieurs
crates de bibliothÃ¨que. Pour cette situation, cargo a une fonctionnalitÃ© qui
s'appelle <em>les espaces de travail</em> qui peuvent aider Ã  gÃ©rer plusieurs paquets
liÃ©s qui sont dÃ©veloppÃ©s en tandem.</p>
<!--
### Creating a Workspace
-->
<h3><a class="header" href="#crÃ©er-un-espace-de-travail" id="crÃ©er-un-espace-de-travail">CrÃ©er un espace de travail</a></h3>
<!--
A *workspace* is a set of packages that share the same *Cargo.lock* and output
directory. Letâ€™s make a project using a workspaceâ€”weâ€™ll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace; weâ€™re going to show one common way. Weâ€™ll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an `add_one` function, and a second library an `add_two` function.
These three crates will be part of the same workspace. Weâ€™ll start by creating
a new directory for the workspace:
-->
<p>Un <em>espace de travail</em> est un jeu de paquets qui partagent tous le mÃªme
<em>Cargo.lock</em> et le mÃªme dossier de sortie. CrÃ©ons donc un projet en utilisant un
espace de travail â€” nous allons utiliser du code trivial afin de nous concentrer
sur la structure de l'espace de travail. Il existe plusieurs faÃ§ons de
structurer un espace de travailÂ ; nous allons vous montrer une maniÃ¨re commune
d'organisation. Nous allons avoir un espace de travail contenant un binaire et
deux bibliothÃ¨ques. Le binaire, qui devrait fournir les fonctionnalitÃ©s
principales, va dÃ©pendre des deux bibliothÃ¨ques. Une bibliothÃ¨que va fournir une
fonction <code>ajouter_un</code>, et la seconde bibliothÃ¨que, une fonction <code>ajouter_deux</code>.
Ces trois crates feront partie du mÃªme espace de travail. Nous allons commencer
par crÃ©er un nouveau dossier pour cet espace de travailÂ :</p>
<!--
```console
$ mkdir add
$ cd add
```
-->
<pre><code class="language-console">$ mkdir ajout
$ cd ajout
</code></pre>
<!--
Next, in the *add* directory, we create the *Cargo.toml* file that will
configure the entire workspace. This file wonâ€™t have a `[package]` section or
the metadata weâ€™ve seen in other *Cargo.toml* files. Instead, it will start
with a `[workspace]` section that will allow us to add members to the workspace
by specifying the path to the package with our binary crate; in this case,
that path is *adder*:
-->
<p>Ensuite, dans le dossier <em>ajout</em>, nous crÃ©ons le fichier <em>Cargo.toml</em> qui va
configurer l'intÃ©gralitÃ© de l'espace de travail. Ce fichier n'aura pas de
section <code>[package]</code> ou les mÃ©tadonnÃ©es que nous avons vues dans les autres
fichiers <em>Cargo.toml</em>. A la place, il commencera par une section <code>[workspace]</code>
qui va nous permettre d'ajouter des membres Ã  l'espace de travail en
renseignant le chemin vers le paquet qui contient notre crate binaireÂ ; dans ce
cas, ce chemin est <em>additioneur</em>Â :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[workspace]

members = [
    "adder",
]
```
-->
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
]
</code></pre>
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
]
</code></pre>
<!--
Next, weâ€™ll create the `adder` binary crate by running `cargo new` within the
*add* directory:
-->
<p>Ensuite, nous allons crÃ©er la crate binaire <code>additioneur</code> en lanÃ§ant <code>cargo new</code>
dans le dossier <em>ajout</em>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-- >
-->
<!--
```console
$ cargo new adder
     Created binary (application) `adder` package
```
-->
<pre><code class="language-console">$ cargo new additioneur
     Created binary (application) `additioneur` package
</code></pre>
<!--
At this point, we can build the workspace by running `cargo build`. The files
in your *add* directory should look like this:
-->
<p>A partir de ce moment, nous pouvons compiler l'espace de travail en lanÃ§ant
<code>cargo build</code>. Les fichiers dans votre dossier <em>ajout</em> devraient ressembler Ã 
ceciÂ :</p>
<!--
```text
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ adder
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
```
-->
<pre><code class="language-text">â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ additioneur
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
</code></pre>
<!--
The workspace has one *target* directory at the top level for the compiled
artifacts to be placed into; the `adder` package doesnâ€™t have its own *target*
directory. Even if we were to run `cargo build` from inside the *adder*
directory, the compiled artifacts would still end up in *add/target* rather
than *add/adder/target*. Cargo structures the *target* directory in a workspace
like this because the crates in a workspace are meant to depend on each other.
If each crate had its own *target* directory, each crate would have to
recompile each of the other crates in the workspace to have the artifacts in
its own *target* directory. By sharing one *target* directory, the crates can
avoid unnecessary rebuilding.
-->
<p>L'espace de travail a un dossier <em>target</em> au niveau le plus haut pour y placer
les artefacts compilÃ©sÂ ; le paquet <code>additioneur</code> n'a pas son propre dossier
<em>target</em>. MÃªme si nous lancions <code>cargo build</code> Ã  l'intÃ©rieur du dossier
<em>additioneur</em>, les artefacts compilÃ©s finirons toujours dans <em>ajout/target</em>
plutÃ´t que dans <em>ajout/additioneur/target</em>. Cargo organise ainsi le dossier
<em>target</em> car les crates d'un espace de travail sont censÃ©s dÃ©pendre l'une de
l'autre. Si chaque crate avait son propre dossier <em>target</em>, chaque crate
devrait recompiler chacune des autres crates prÃ©sentes dans l'espace de
travail pour avoir les artefacts dans son propre dossier <em>target</em>. En
partageant un seul dossier <em>target</em>, les crates peuvent Ã©viter des
re-compilations inutiles.</p>
<!--
### Creating the Second Package in the Workspace
-->
<h3><a class="header" href="#crÃ©er-le-second-paquet-dans-lespace-de-travail" id="crÃ©er-le-second-paquet-dans-lespace-de-travail">CrÃ©er le second paquet dans l'espace de travail</a></h3>
<!--
Next, letâ€™s create another member package in the workspace and call it `add-one`.
Change the top-level *Cargo.toml* to specify the *add-one* path in the
`members` list:
-->
<p>Ensuite, crÃ©ons un autre paquet, membre de l'espace de travail et appelons-la
<code>ajouter-un</code>. Changeons le <em>Cargo.toml</em> du niveau le plus haut pour renseigner
le chemin vers <em>ajouter-un</em> dans la liste <code>members</code>Â :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[workspace]

members = [
    "adder",
    "add-one",
]
```
-->
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
    &quot;ajouter-un&quot;,
]
</code></pre>
<!--
Then generate a new library crate named `add-one`:
-->
<p>Ensuite, gÃ©nÃ©rons une nouvelle crate de bibliothÃ¨que <code>ajouter-un</code>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add-one
cargo new add-one --lib
copy output below
-- >
-->
<!--
```console
$ cargo new add-one --lib
     Created library `add-one` package
```
-->
<pre><code class="language-console">$ cargo new ajouter-un --lib
     Created library `ajouter-un` package
</code></pre>
<!--
Your *add* directory should now have these directories and files:
-->
<p>Votre dossier <em>ajout</em> devrait maintenant avoir ces dossiers et fichiersÂ :</p>
<!--
```text
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ add-one
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ adder
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
```
-->
<pre><code class="language-text">â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ ajouter-un
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ additioneur
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
</code></pre>
<!--
In the *add-one/src/lib.rs* file, letâ€™s add an `add_one` function:
-->
<p>Dans le fichier <em>ajouter-un/src/lib.rs</em>, ajoutons une fonction <code>ajouter_un</code>Â :</p>
<!--
<span class="filename">Filename: add-one/src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : ajouter-un/src/lib.rs</span></p>
<!--
```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now that we have another package in the workspace, we can have the `adder`
package with our binary depend on the `add-one` package, that has our
library. First, weâ€™ll need to add a path dependency on `add-one` to
*adder/Cargo.toml*.
-->
<p>Maintenant que nous avons un autre paquet dans l'espace de travail, nous pouvons
faire en sorte que le paquet <code>additioneur</code> qui contient notre binaire dÃ©pende du
paquet <code>ajouter-un</code>, qui contient notre bibliothÃ¨que. D'abord, nous devons
ajouter un chemin de dÃ©pendance Ã  <code>ajouter-un</code> dans <em>additioneur/Cargo.toml</em>.</p>
<!--
<span class="filename">Filename: adder/Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : additioneur/Cargo.toml</span></p>
<!--
```toml
[dependencies]

add-one = { path = "../add-one" }
```
-->
<pre><code class="language-toml">[dependencies]

ajouter-un = { path = &quot;../ajouter-un&quot; }
</code></pre>
<!--
Cargo doesnâ€™t assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships between the crates.
-->
<p>Cargo ne fait pas la supposition que les crates d'un espace de travail
dÃ©pendent l'une de l'autre, donc vous devez Ãªtre explicites sur les relations
de dÃ©pendance entre les crates.</p>
<!--
Next, letâ€™s use the `add_one` function from the `add-one` crate in the `adder`
crate. Open the *adder/src/main.rs* file and add a `use` line at the top to
bring the new `add-one` library crate into scope. Then change the `main`
function to call the `add_one` function, as in Listing 14-7.
-->
<p>Ensuite, utilisons la fonction <code>ajouter_un</code> de la crate <code>ajouter-un</code> dans la
crate <code>additioneur</code>. Ouvrez le fichier <em>additioneur/src/main.rs</em> et ajoutez une
ligne <code>use</code> tout en haut pour importer la bibliothÃ¨que <code>ajouter-un</code> dans la
portÃ©e. Changez ensuite la fonction <code>main</code> pour appeler la fonction
<code>ajouter_un</code>, comme dans l'encart 14-7.</p>
<!--
<span class="filename">Filename: adder/src/main.rs</span>
-->
<p><span class="filename">FichierÂ : additioneur/src/main.rs</span></p>
<!--
```rust,ignore
use add_one;

fn main() {
    let num = 10;
    println!(
        "Hello, world! {} plus one is {}!",
        num,
        add_one::add_one(num)
    );
}
```
-->
<pre><code class="language-rust ignore">use ajouter_un;

fn main() {
    let nombre = 10;
    println!(
        &quot;Hello, worldÂ ! {} plus un vaut {}Â !&quot;,
        nombre,
        ajouter_un::ajouter_un(nombre)
    );
}
</code></pre>
<!--
<span class="caption">Listing 14-7: Using the `add-one` library crate from the 
 `adder` crate</span>
-->
<p><span class="caption">Encart 14-7Â : utilisation de la bibliothÃ¨que <code>ajouter-un</code>
dans la crate <code>additioneur</code></span></p>
<!--
Letâ€™s build the workspace by running `cargo build` in the top-level *add*
directory!
-->
<p>Compilons l'espace de travail en lanÃ§ant <code>cargo build</code> dans le niveau le plus
haut du dossier <em>ajout</em>Â !</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling ajouter-un v0.1.0 (file:///projects/ajout/ajouter-un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<!--
To run the binary crate from the *add* directory, we can specify which
package in the workspace we want to run by using the `-p` argument and the
package name with `cargo run`:
-->
<p>Pour lancer la crate binaire Ã  partir du dossier <em>ajout</em>, nous pouvons
prÃ©ciser quel paquet nous souhaitons exÃ©cuter dans l'espace de travail en
utilisant l'argument <code>-p</code> suivi du nom du paquet avec <code>cargo run</code>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```
-->
<pre><code class="language-console">$ cargo run -p additioneur
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/additioneur`
Hello, worldÂ ! 10 plus un vaut 11Â !
</code></pre>
<!--
This runs the code in *adder/src/main.rs*, which depends on the `add-one` crate.
-->
<p>Cela exÃ©cute le code de <em>additioneur/src/main.rs</em>, qui dÃ©pend de la crate
<code>ajouter-un</code>.</p>
<!--
#### Depending on an External Package in a Workspace
-->
<h4><a class="header" href="#dÃ©pendre-dun-paquet-externe-dans-un-espace-de-travail" id="dÃ©pendre-dun-paquet-externe-dans-un-espace-de-travail">DÃ©pendre d'un paquet externe dans un espace de travail</a></h4>
<!--
Notice that the workspace has only one *Cargo.lock* file at the top level of
the workspace rather than having a *Cargo.lock* in each crateâ€™s directory. This
ensures that all crates are using the same version of all dependencies. If we
add the `rand` package to the *adder/Cargo.toml* and *add-one/Cargo.toml*
files, Cargo will resolve both of those to one version of `rand` and record
that in the one *Cargo.lock*. Making all crates in the workspace use the same
dependencies means the crates in the workspace will always be compatible with
each other. Letâ€™s add the `rand` crate to the `[dependencies]` section in the
*add-one/Cargo.toml* file to be able to use the `rand` crate in the `add-one`
crate:
-->
<p>Notez que l'espace de travail a un seul fichier <em>Cargo.lock</em> dans le niveau le
plus haut de l'espace de travail plutÃ´t que d'avoir un <em>Cargo.lock</em> dans chaque
dossier de chaque crate. Cela garantit que toutes les crates utilisent la mÃªme
version de toutes les dÃ©pendances. Si nous ajoutons le paquet <code>rand</code> aux
fichiers <em>additioneur/Cargo.toml</em> et <em>ajouter-un/Cargo.toml</em>, cargo va rÃ©unir
ces deux en une seule version de <code>rand</code> et enregistrer cela dans un seul
<em>Cargo.lock</em>. Faire en sorte que toutes les crates de l'espace de travail
utilisent la mÃªme dÃ©pendance signifie que les crates dans l'espace de travail
seront toujours compatibles l'une avec l'autre. Ajoutons la crate <code>rand</code> Ã  la
section <code>[dependencies]</code> du fichier <em>ajouter-un/Cargo.toml</em> pour pouvoir
utiliser la crate <code>rand</code> dans la crate <code>ajouter-un</code>Â :</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-- >
-->
<!--
<span class="filename">Filename: add-one/Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : ajouter-un/Cargo.toml</span></p>
<!--
```toml
[dependencies]
rand = "0.5.5"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<!--
We can now add `use rand;` to the *add-one/src/lib.rs* file, and building the
whole workspace by running `cargo build` in the *add* directory will bring in
and compile the `rand` crate:
-->
<p>Nous pouvons maintenant ajouter <code>use rand;</code> au fichier <em>ajouter-un/src/lib.rs</em>,
et compiler l'ensemble de l'espace de travail en lanÃ§ant <code>cargo build</code> dans le
dossier <em>ajout</em>, ce qui va importer et compiler la crate <code>rand</code>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   --snip--
   Compiling rand v0.5.6
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
```
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   -- partie masquÃ©e ici --
   Compiling rand v0.5.6
   Compiling ajouter-un v0.1.0 (file:///projects/ajout/ajouter-un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<!--
The top-level *Cargo.lock* now contains information about the dependency of
`add-one` on `rand`. However, even though `rand` is used somewhere in the
workspace, we canâ€™t use it in other crates in the workspace unless we add
`rand` to their *Cargo.toml* files as well. For example, if we add `use rand;`
to the *adder/src/main.rs* file for the `adder` package, weâ€™ll get an error:
-->
<p>Le <em>Cargo.lock</em> du niveau le plus haut contient maintenant les informations
de dÃ©pendance Ã  <code>rand</code> pour <code>ajouter-un</code>. Cependant, mÃªme si <code>rand</code> est
utilisÃ© quelque part dans l'espace de travail, nous ne pouvons pas l'utiliser
dans d'autres crates de l'espace de travail tant que nous n'ajoutons pas
<code>rand</code> dans leurs fichiers <em>Cargo.toml</em>. Par exemple, si nous ajoutons
<code>use rand;</code> dans le fichier <em>additioneur/src/main.rs</em> pour le paquet
<code>additioneur</code>, nous allons avoir une erreurÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 -- > adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no `rand` external crate
```
-->
<pre><code class="language-console">$ cargo build
  -- partie masquÃ©e ici --
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
error[E0432]: unresolved import `rand`
 -- &gt; additioneur/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no `rand` external crate
</code></pre>
<!--
To fix this, edit the *Cargo.toml* file for the `adder` package and indicate
that `rand` is a dependency for it as well. Building the `adder` package will
add `rand` to the list of dependencies for `adder` in *Cargo.lock*, but no
additional copies of `rand` will be downloaded. Cargo has ensured that every
crate in every package in the workspace using the `rand` package will be
using the same version. Using the same version of `rand` across the workspace
saves space because we wonâ€™t have multiple copies and ensures that the crates
in the workspace will be compatible with each other.
-->
<p>Pour corriger cela, modifiez le fichier <em>Cargo.toml</em> pour le paquet
<code>additioneur</code> et rajouter-lui aussi un dÃ©pendance Ã  <code>rand</code>. La compilation du
paquet <code>additioneur</code> va rajouter <code>rand</code> Ã  la liste des dÃ©pendances pour
<code>additioneur</code> dans <em>Cargo.lock</em>, mais aucune copie supplÃ©mentaire de <code>rand</code> sera
tÃ©lÃ©chargÃ©. Cargo s'est assurÃ© que toutes les crates de chaque paquet de
l'espace de travail qui utilise le paquet <code>rand</code> serait de la mÃªme version.
Utiliser la mÃªme version de <code>rand</code> dans les espaces de travail Ã©conomise de
l'espace car nous n'avons pas Ã  multiplier les copies, ni s'assurer que les
crates dans l'espace de travail seraient compatibles l'une envers l'autre.</p>
<!--
#### Adding a Test to a Workspace
-->
<h4><a class="header" href="#ajouter-un-test-Ã -lespace-de-travail" id="ajouter-un-test-Ã -lespace-de-travail">Ajouter un test Ã  l'espace de travail</a></h4>
<!--
For another enhancement, letâ€™s add a test of the `add_one::add_one` function
within the `add_one` crate:
-->
<p>Afin de procÃ©der Ã  une autre amÃ©lioration, ajoutons un test de la fonction
<code>ajouter_un::ajouter_un</code> dans la crate <code>ajouter_un</code>Â :</p>
<!--
<span class="filename">Filename: add-one/src/lib.rs</span>
-->
<p><span class="filename">FihcierÂ : add-one/src/lib.rs</span></p>
<!--
```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_fonctionne() {
        assert_eq!(3, ajouter_un(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now run `cargo test` in the top-level *add* directory:
-->
<p>Lancez maintenant <code>cargo test</code> dans le niveau le plus haut du
dossier <em>ajout</em>Â :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```
-->
<pre><code class="language-console">$ cargo test
   Compiling ajouter-un v0.1.0 (file:///projects/ajout/ajouter-un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/ajouter_un-f0253159197f7841

running 1 test
test tests::cela_fonctionne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/additioneur-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests ajouter-un

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
The first section of the output shows that the `it_works` test in the `add-one`
crate passed. The next section shows that zero tests were found in the `adder`
crate, and then the last section shows zero documentation tests were found in
the `add-one` crate. Running `cargo test` in a workspace structured like this
one will run the tests for all the crates in the workspace.
-->
<p>La premiÃ¨re section de la sortie indique que le test <code>cela_fonctionne</code> de la
crate <code>ajouter-un</code> a rÃ©ussi. La section suivante indique qu'aucun test n'a Ã©tÃ©
trouvÃ© dans la crate <code>additioneur</code>, et ensuite la derniÃ¨re section indique elle
aussi qu'aucun test de documentation a Ã©tÃ© trouvÃ© dans la crate <code>ajouter-un</code>.
Lancer <code>cargo test</code> dans un espace de travail structurÃ© comme celui-ci va
exÃ©cuter les tests pour toutes les crates de cet espace de travail.</p>
<!--
We can also run tests for one particular crate in a workspace from the
top-level directory by using the `-p` flag and specifying the name of the crate
we want to test:
-->
<p>Nous pouvons aussi lancer des tests pour une crate en particulier dans un
espace de travail Ã  partir du dossier du plus haut niveau en utilisant le
drapeau <code>-p</code> et en renseignant le nom de la crate que nous voulons testerÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add-one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo test -p add-one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```
-->
<pre><code class="language-console">$ cargo test -p ajouter-un
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/ajouter_un-b3235fea9a156f74

running 1 test
test tests::cela_fonctionne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests ajouter-un

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
This output shows `cargo test` only ran the tests for the `add-one` crate and
didnâ€™t run the `adder` crate tests.
-->
<p>Cette sortie montre que <code>cargo test</code> a lancÃ© les tests uniquement pour la
crate <code>ajouter-un</code> et n'a pas lancÃ© les tests de la crate <code>additioneur</code>.</p>
<!--
If you publish the crates in the workspace to [crates.io](https://crates.io/),
each crate in the workspace will need to be published separately. The `cargo
publish` command does not have an `--all` flag or a `-p` flag, so you must
change to each crateâ€™s directory and run `cargo publish` on each crate in the
workspace to publish the crates.
-->
<p>Si vous publiez les crates prÃ©sentes dans l'espace de travail sur
<a href="https://crates.io/">crates.io</a>, chaque crate de l'espace de travail va avoir
besoin d'Ãªtre publiÃ©e de maniÃ¨re sÃ©parÃ©e. La commande <code>cargo publish</code> n'a pas
de drapeau <code>--all</code> ou <code>-p</code>, donc vous devrez vous rendre dans chaque dossier de
chaque crate et lancer <code>cargo publish</code> sur chaque crate prÃ©sente dans l'espace
de travail pour publier les crates.</p>
<!--
For additional practice, add an `add-two` crate to this workspace in a similar
way as the `add-one` crate!
-->
<p>En guise d'entrainement supplÃ©mentaire, ajoutez une crate <code>ajouter-deux</code> dans
cet espace de travail de la mÃªme maniÃ¨re que nous l'avons fait pour la crate
<code>ajouter-un</code>Â !</p>
<!--
As your project grows, consider using a workspace: itâ€™s easier to understand
smaller, individual components than one big blob of code. Furthermore, keeping
the crates in a workspace can make coordination between them easier if they are
often changed at the same time.
-->
<p>Au fur et Ã  mesure que votre projet se dÃ©veloppe, pensez Ã  utiliser un espace
de travailÂ : il est plus facile de comprendre des composants individuels, plus
petits, plutÃ´t qu'un gros tas de code. De plus, garder les crates dans un
espace de travail peut amÃ©liorer la collation entre elles si elles sont souvent
modifiÃ©es ensemble.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--23" id="-attention-peinture-fraÃ®che--23">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/183">Pull Request</a>.</p>
</blockquote>
<!--
## Installing Binaries from Crates.io with `cargo install`
-->
<h2><a class="header" href="#installer-des-binaires-Ã -partir-de-cratesio-avec-cargo-install" id="installer-des-binaires-Ã -partir-de-cratesio-avec-cargo-install">Installer des binaires Ã  partir de crates.io avec <code>cargo install</code></a></h2>
<!--
The `cargo install` command allows you to install and use binary crates
locally. This isnâ€™t intended to replace system packages; itâ€™s meant to be a
convenient way for Rust developers to install tools that others have shared on
[crates.io](https://crates.io/)<!-- ignore -- >. Note that you can only install
packages that have binary targets. A *binary target* is the runnable program
that is created if the crate has a *src/main.rs* file or another file specified
as a binary, as opposed to a library target that isnâ€™t runnable on its own but
is suitable for including within other programs. Usually, crates have
information in the *README* file about whether a crate is a library, has a
binary target, or both.
-->
<p>La commande <code>cargo install</code> vous permet d'installer et utiliser des crates de
binaires localement. Cela n'est pas conÃ§u pour remplacer les systÃ¨mes de
paquetsÂ ; c'est plutÃ´t un moyen pratique pour les dÃ©veloppeurs Rust d'installer
des outils que les autres ont partagÃ© sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->. Notez que vous ne pouvez
installer que des paquets qui ont des destinations binaires. Une <em>destination
binaire</em> est le programme exÃ©cutable qui est crÃ©Ã© si la crate a un fichier
<em>src/main.rs</em> ou un autre fichier renseignÃ© comme un binaire, contrairement
Ã  une destination de bibliothÃ¨que qui n'est pas exÃ©cutable en tant que tel mais
qu'il est possible d'intÃ©grer Ã  un autre programme. Habituellement, les crates
ont l'information dans le fichier <em>README</em> pour savoir si elle est une
bibliothÃ¨que, a une destination binaire, ou les deux.</p>
<!--
All binaries installed with `cargo install` are stored in the installation
rootâ€™s *bin* folder. If you installed Rust using *rustup.rs* and donâ€™t have any
custom configurations, this directory will be *$HOME/.cargo/bin*. Ensure that
directory is in your `$PATH` to be able to run programs youâ€™ve installed with
`cargo install`.
-->
<p>Tous les binaires installÃ©s avec <code>cargo install</code> sont stockÃ©s dans le dossier
<em>bin</em> de la racine. Si vous installez Rust avec <em>rustup.rs</em> et que vous n'avez
pas personnalisÃ© la configuration, ce dossier sera <em>$HOME/.cargo/bin</em>.
Assurez-vous que ce dossier est dans votre <code>$PATH</code> pour pouvoir exÃ©cuter des
programmes que vous avez installÃ© avec <code>cargo install</code>.</p>
<!--
For example, in Chapter 12 we mentioned that thereâ€™s a Rust implementation of
the `grep` tool called `ripgrep` for searching files. If we want to install
`ripgrep`, we can run the following:
-->
<p>Par exemple, dans le chapitre 12 nous avions mentionnÃ© le fait qu'il existait
une implÃ©mentation de l'outil <code>grep</code> en Rust qui s'appelait <code>ripgrep</code> et qui
permettait de rechercher dans des fichiers. Si nous voulons installer
<code>ripgrep</code>, nous pouvons faire comme ceciÂ :</p>
<!--
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-- >
-->
<!--
```console
$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
```
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
-- partie masquÃ©e ici --
   Compiling ripgrep v11.0.2
    Finished release [optimized] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre>
<!--
The second-to-last line of the output shows the location and the name of the
installed binary, which in the case of `ripgrep` is `rg`. As long as the
installation directory is in your `$PATH`, as mentioned previously, you can
then run `rg --help` and start using a faster, rustier tool for searching files!
-->
<p>L'avant-derniÃ¨re ligne de la sortie nous montre l'emplacement et le nom du
binaire installÃ©, qui est <code>rg</code> dans le cas de <code>ripgrep</code>. Tel que mentionnÃ©
prÃ©cÃ©demment, du moment que le dossier d'installation est dans votre <code>$PATH</code>,
vous pouvez ensuite lancer <code>rg --help</code> et commencer Ã  utiliser un outil en Rust
qui est rapide pour rechercher dans les fichiersÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--24" id="-attention-peinture-fraÃ®che--24">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/184">Pull Request</a>.</p>
</blockquote>
<!--
## Extending Cargo with Custom Commands
-->
<h2><a class="header" href="#etendre-les-fonctionnalitÃ©s-de-cargo-avec-des-commandes-personnalisÃ©es" id="etendre-les-fonctionnalitÃ©s-de-cargo-avec-des-commandes-personnalisÃ©es">Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></h2>
<!--
Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you can
run it as if it was a Cargo subcommand by running `cargo something`. Custom
commands like this are also listed when you run `cargo --list`. Being able to
use `cargo install` to install extensions and then run them just like the
built-in Cargo tools is a super convenient benefit of Cargoâ€™s design!
-->
<p>Cargo est conÃ§u pour que vous puissiez Ã©tendre ses fonctionnalitÃ©s avec des
nouvelles sous-commandes sans avoir Ã  modifier cargo. Si un binaire dans votre
<code>$PATH</code> est nommÃ© selon <code>cargo-quelquechose</code>, vous pouvez le lancer comme s'il
Ã©tait une sous-commande de cargo en lanÃ§ant <code>cargo quelquechose</code>. Les commandes
personnalisÃ©es comme celle-ci  sont aussi listÃ©es lorsque vous lancez
<code>cargo --list</code>. Pouvoir utiliser <code>cargo install</code> pour installer des extensions
et ensuite les lancer comme Ã©tant un outil intÃ©grÃ© Ã  cargo est un avantage
super pratique de la conception de cargoÂ !</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-13" id="rÃ©sumÃ©-13">RÃ©sumÃ©</a></h2>
<!--
Sharing code with Cargo and [crates.io](https://crates.io/)<!-- ignore -- > is
part of what makes the Rust ecosystem useful for many different tasks. Rustâ€™s
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from that of the language. Donâ€™t be shy about
sharing code thatâ€™s useful to you on [crates.io](https://crates.io/)<!-- ignore
-- >; itâ€™s likely that it will be useful to someone else as well!
-->
<p>Le partage de code avec cargo et <a href="https://crates.io/">crates.io</a><!-- ignore -->
est la partie qui rend l'Ã©cosystÃ¨me de Rust trÃ¨s utile pour de nombreuses
tÃ¢ches. La bibliothÃ¨que standard de Rust est compacte et stable, et les crates
sont faciles Ã  partager, utiliser, et Ã  amÃ©liorer dans un cycle de vie diffÃ©rent
du langage. N'hÃ©sitez pas Ã  partager du code qui vous est utile sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->Â ; il est fort probable qu'il
sera aussi utile Ã  quelqu'un d'autreÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--25" id="-attention-peinture-fraÃ®che--25">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/185">Pull Request</a>.</p>
</blockquote>
<!--
# Smart Pointers
-->
<h1><a class="header" href="#les-pointeurs-intelligents" id="les-pointeurs-intelligents">Les pointeurs intelligents</a></h1>
<!--
A *pointer* is a general concept for a variable that contains an address in
memory. This address refers to, or â€œpoints at,â€ some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the `&` symbol and borrow the value they
point to. They donâ€™t have any special capabilities other than referring to
data. Also, they donâ€™t have any overhead and are the kind of pointer we use
most often.
-->
<p>Un <em>pointeur</em> est concept gÃ©nÃ©ral pour une variable qui contient une adresse
vers la mÃ©moire. Cette adresse pointe vers d'autres donnÃ©es. Le type de pointeur
le plus courant en Rust est la rÃ©fÃ©rence, que vous avez appris au chapitre 4.
Les rÃ©fÃ©rences sont marquÃ©es par le symbole <code>&amp;</code> et empruntent la valeur sur
laquelle ils pointent. Elles n'ont pas d'autres fonctionnalitÃ©s que celle de
pointer sur une donnÃ©e. De plus, elles n'ont pas coÃ»t sur les performances et
c'est le type de pointeur que nous utilisons le plus souvent.</p>
<!--
*Smart pointers*, on the other hand, are data structures that not only act like
a pointer but also have additional metadata and capabilities. The concept of
smart pointers isnâ€™t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide functionality beyond that provided by references.
One example that weâ€™ll explore in this chapter is the *reference counting*
smart pointer type. This pointer enables you to have multiple owners of data by
keeping track of the number of owners and, when no owners remain, cleaning up
the data.
-->
<p>Les <em>pointeurs intelligents</em>, d'une autre cÃ´tÃ©, sont des structures de donnÃ©es
qui, non seulement se comportent comme un pointeur, mais ont aussi des
fonctionnalitÃ©s et mÃ©tadonnÃ©es supplÃ©mentaires. Le concept de pointeur
intelligent n'est pas propre Ã  RustÂ : les pointeurs intelligents sont
originaires du C++ et existent aussi dans d'autres langages. En Rust, les
diffÃ©rents pointeurs intelligents dÃ©finis dans bibliothÃ¨que standard
fournissent des fonctionnalitÃ©s supplÃ©mentaires Ã  celles des rÃ©fÃ©rences.
Un exemple que nous allons explorer dans ce chapitre est le type de pointeur
intelligent <em>compteur de rÃ©fÃ©rences</em>. Ce pointeur vous permet d'avoir
plusieurs propriÃ©taires d'une donnÃ©e tout en gardant une trace leur nombre et,
lorsqu'il n'y en a plus, nettoyer cette donnÃ©e.</p>
<!--
In Rust, which uses the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
*own* the data they point to.
-->
<p>En Rust, qui utilise le concept de propriÃ©taire et d'emprunt, une diffÃ©rence
supplÃ©mentaire entre les rÃ©fÃ©rences et les pointeurs intelligents est que les
rÃ©fÃ©rences sont des pointeurs qui empruntent seulement la donnÃ©eÂ ; alors qu'au
contraire, dans de nombreux cas, les pointeurs intelligents sont
<em>propriÃ©taires</em> des donnÃ©es sur lesquels ils pointent.</p>
<!--
Weâ€™ve already encountered a few smart pointers in this book, such as `String`
and `Vec<T>` in Chapter 8, although we didnâ€™t call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with `String` ensuring its data
will always be valid UTF-8).
-->
<p>Nous avons dÃ©jÃ  rencontrÃ© quelques pointeurs intelligents au cours de ce
livre, comme <code>String</code> et <code>Vec&lt;T&gt;</code> au chapitre 8, mÃªme si nous ne les avons pas
dÃ©signÃ©s comme Ã©tant des pointeurs intelligents Ã  ce moment-lÃ . Ces deux types
sont considÃ©rÃ©s comme des pointeurs intelligents car ils sont propriÃ©taires de
ces donnÃ©es et vous permettent de les manipuler. Ils ont aussi des mÃ©tadonnÃ©es
(comme leur capacitÃ©) et certaines fonctionnalitÃ©s ou garanties (comme <code>String</code>
qui s'assure que ses donnÃ©es soient toujours en UTF-8).</p>
<!--
Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the `Deref` and `Drop` traits. The `Deref` trait allows an instance
of the smart pointer struct to behave like a reference so you can write code
that works with either references or smart pointers. The `Drop` trait allows
you to customize the code that is run when an instance of the smart pointer
goes out of scope. In this chapter, weâ€™ll discuss both traits and demonstrate
why theyâ€™re important to smart pointers.
-->
<p>Les pointeurs intelligents sont souvent implÃ©mentÃ©s en utilisant des
structures. Les caractÃ©ristiques qui distinguent un pointeur intelligent d'une
structure classique est que les pointeurs intelligents implÃ©mentent les traits
<code>Deref</code> et <code>Drop</code>. Le trait <code>Deref</code> permet Ã  une instance d'un pointeur
intelligent de se comporter comme une rÃ©fÃ©rence afin que vous puissiez Ã©crire
du code qui fonctionne aussi bien avec des rÃ©fÃ©rences qu'avec des pointeurs
intelligents. Le trait <code>Drop</code> vous permet de personnaliser le code qui est
exÃ©cutÃ© lorsqu'une instance d'un pointeur intelligent sort de la portÃ©e. Dans
ce chapitre, nous verrons ces deux traits et expliquer pourquoi ils sont
importants pour les pointeurs intelligents.</p>
<!--
Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter wonâ€™t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. Weâ€™ll
cover the most common smart pointers in the standard library:
-->
<p>Vu que le motif des pointeurs intelligents est un motif de conception gÃ©nÃ©ral
frÃ©quemment utilisÃ© en Rust, ce chapitre ne couvrira pas tous les pointeurs
intelligents existants. De nombreuses bibliothÃ¨ques ont leurs propres pointeurs
intelligents, et vous pouvez mÃªme Ã©crire le vÃ´tre. Nous allons voir les
pointeurs intelligents les plus courants de la bibliothÃ¨que standardÂ :</p>
<!--
* `Box<T>` for allocating values on the heap
* `Rc<T>`, a reference counting type that enables multiple ownership
* `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces
  the borrowing rules at runtime instead of compile time
-->
<ul>
<li><code>Box&lt;T&gt;</code> pour l'allocation de valeurs sur le tas</li>
<li><code>Rc&lt;T&gt;</code>, un type comptant les rÃ©fÃ©rences, qui permet d'avoir plusieurs
propriÃ©taires</li>
<li><code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>, par lesquels on y accÃ¨de via <code>RefCell&lt;T&gt;</code>, un type
qui permet d'appliquer les rÃ¨gles d'emprunt au moment de l'exÃ©cution au lieu
du moment de la compilation</li>
</ul>
<!--
In addition, weâ€™ll cover the *interior mutability* pattern where an immutable
type exposes an API for mutating an interior value. Weâ€™ll also discuss
*reference cycles*: how they can leak memory and how to prevent them.
-->
<p>En outre, nous allons voir le motif de <em>mutabilitÃ© interne</em> dans lequel un
type immuable propose une API pour muter une valeur interne. Nous allons aussi
parler des <em>boucles de rÃ©fÃ©rences</em>Â : comment elles peuvent provoquer des fuites
de mÃ©moire et comment les Ã©viter.</p>
<!--
Letâ€™s dive in!
-->
<p>Allons-yÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--26" id="-attention-peinture-fraÃ®che--26">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/188">Pull Request</a>.</p>
</blockquote>
<!--
## Using `Box<T>` to Point to Data on the Heap
-->
<h2><a class="header" href="#utiliser-boxt-pour-pointer-sur-des-donnÃ©es-prÃ©sentes-sur-le-tas" id="utiliser-boxt-pour-pointer-sur-des-donnÃ©es-prÃ©sentes-sur-le-tas">Utiliser <code>Box&lt;T&gt;</code> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></h2>
<!--
The most straightforward smart pointer is a *box*, whose type is written
`Box<T>`. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.
-->
<p>Le pointeur intelligent le plus simple est la <em>boite</em>, dont le type s'Ã©crit
<code>Box&lt;T&gt;</code>. Les boites vous permettent de stocker des donnÃ©es sur le tas plutÃ´t
que sur la pile. La seule chose qui reste sur la pile est le pointeur vers les
donnÃ©es sur le tas. Revenez au chapitre 4 pour vous rappeler la diffÃ©rence entre
la pile et le tas.</p>
<!--
Boxes donâ€™t have performance overhead, other than storing their data on the
heap instead of on the stack. But they donâ€™t have many extra capabilities
either. Youâ€™ll use them most often in these situations:
-->
<p>Les boites ne provoquent pas de surcharge au niveau des performances, si ce
n'est le stockage de leurs donnÃ©es sur le tas plutÃ´t que sur la pile. Mais elles
n'ont pas non plus beaucoup plus de fonctionnalitÃ©s. Vous allez les utiliser
principalement dans les situations suivantesÂ :</p>
<!--
* When you have a type whose size canâ€™t be known at compile time and you want
  to use a value of that type in a context that requires an exact size
* When you have a large amount of data and you want to transfer ownership but
  ensure the data wonâ€™t be copied when you do so
* When you want to own a value and you care only that itâ€™s a type that
  implements a particular trait rather than being of a specific type
-->
<ul>
<li>Lorsque vous avez un type dont la taille ne peut pas Ãªtre connu au moment de
la compilation et que vous souhaitez une valeur d'un certain type dans un
contexte qui nÃ©cessite de savoir exactement sa taille</li>
<li>Lorsque vous avez une grosse quantitÃ© de donnÃ©es et que vous souhaitez
transfÃ©rer la possession mais vous assurer que les donnÃ©es ne seront pas
copiÃ©es lorsque vous le ferez</li>
<li>Lorsque vous voulez prendre possession d'une valeur et que vous souhaitez
seulement qu'elle soit d'un type qui implÃ©mente un trait particulier plutÃ´t
que d'attendre qu'elle soit d'un type prÃ©cis</li>
</ul>
<!--
Weâ€™ll demonstrate the first situation in the [â€œEnabling Recursive Types with
Boxesâ€](#enabling-recursive-types-with-boxes)<!-- ignore -- > section. In the
second case, transferring ownership of a large amount of data can take a long
time because the data is copied around on the stack. To improve performance in
this situation, we can store the large amount of data on the heap in a box.
Then, only the small amount of pointer data is copied around on the stack,
while the data it references stays in one place on the heap. The third case is
known as a *trait object*, and Chapter 17 devotes an entire section, [â€œUsing
Trait Objects That Allow for Values of Different Types,â€][trait-objects]<!--
ignore -- > just to that topic. So what you learn here youâ€™ll apply again in
Chapter 17!
-->
<p>Nous allons expÃ©rimenter la premiÃ¨re situation dans la section <a href="ch15-01-box.html#pouvoir-utiliser-des-types-r%C3%A9cursifs-gr%C3%A2ce-aux-boites">â€œPouvoir
utiliser des types rÃ©cursifs grÃ¢ce aux
boitesâ€</a><!-- ignore -->.
Pour la seconde situation, le transfert de possession d'une grosse quantitÃ© de
donnÃ©es peut prendre beaucoup de temps car les donnÃ©es sont recopiÃ©es sur la
pile. Pour amÃ©liorer les performances dans cette situation, nous pouvons stocker
ces donnÃ©es sur le tas grÃ¢ce Ã  une boite. Ainsi, seul le petit pointeur vers les
donnÃ©es est copiÃ© sur la pile, alors que les donnÃ©es qu'il pointe restent Ã  leur
place sur le tas. La troisiÃ¨me situation dÃ©cris ce qu'on appelle un
<em>objet de trait</em> et le <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore --> dÃ©die une
section entiÃ¨re Ã  ce sujet. Donc ce que vous apprenez ici, vous le retrouverez Ã 
nouveau au chapitre 17Â !</p>
<!--
### Using a `Box<T>` to Store Data on the Heap
-->
<h3><a class="header" href="#utiliser-une-boxt-pour-stocker-des-donnÃ©es-sur-le-tas" id="utiliser-une-boxt-pour-stocker-des-donnÃ©es-sur-le-tas">Utiliser une <code>Box&lt;T&gt;</code> pour stocker des donnÃ©es sur le tas</a></h3>
<!--
Before we discuss this use case for `Box<T>`, weâ€™ll cover the syntax and how to
interact with values stored within a `Box<T>`.
-->
<p>Avant de parler de ce cas d'usage de <code>Box&lt;T&gt;</code>, nous devons voir sa syntaxe et
comment interagir avec les valeurs stockÃ©es dans un <code>Box&lt;T&gt;</code>.</p>
<!--
Listing 15-1 shows how to use a box to store an `i32` value on the heap:
-->
<p>L'encart 15-1 nous montre comment utiliser une boite pour stocker une valeur
<code>i32</code> sur le tasÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-1: Storing an `i32` value on the heap using a
box</span>
-->
<p><span class="caption">Encart 15-1Â : stocker une valeur <code>i32</code> sur le tas en
utilisant une boÃ®te</span></p>
<!--
We define the variable `b` to have the value of a `Box` that points to the
value `5`, which is allocated on the heap. This program will print `b = 5`; in
this case, we can access the data in the box similar to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as `b` does at the end of `main`, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).
-->
<p>Nous avons dÃ©fini la variable <code>b</code> pour avoir la valeur d'une <code>Box</code> qui pointe
sur la valeur <code>5</code>, qui est donc allouÃ©e sur le tas. Ce programme va afficher
<code>b = 5</code>Â ; dans ce cas, nous pouvons accÃ©der Ã  la donnÃ©e prÃ©sente dans la boite
de la mÃªme maniÃ¨re que nous le ferrions si elle Ã©tait sur la pile. Comme toute
valeur possÃ©dÃ©e, lorsque une boite sort de la portÃ©e, comme lorsque <code>b</code> le fait
Ã  la fin du <code>main</code>, elle sera dÃ©sallouÃ©e. Ce sera la boite qui sera dÃ©sallouÃ©e
en premier (elle est stockÃ©e sur la pile), puis ce sera au tour des donnÃ©es sur
lesquelles elle pointait (qui sont stockÃ©es sur le tas).</p>
<!--
Putting a single value on the heap isnâ€™t very useful, so you wonâ€™t use boxes by
themselves in this way very often. Having values like a single `i32` on the
stack, where theyâ€™re stored by default, is more appropriate in the majority of
situations. Letâ€™s look at a case where boxes allow us to define types that we
wouldnâ€™t be allowed to if we didnâ€™t have boxes.
-->
<p>DÃ©poser une seule valeur sur le tas n'est pas trÃ¨s utile, donc vous n'utiliserez
trÃ¨s rarement les boites de cette maniÃ¨re. Laisser les valeurs comme des <code>i32</code>
indÃ©pendantes sur la pile, oÃ¹ elles sont stockÃ©es par dÃ©faut, reste plus
appropriÃ© dans la majeure partie des situations. Regardons un cas oÃ¹ les boites
nous permettent de dÃ©finir des types que nous pourrions par le faire si nous
n'avions pas les boites.</p>
<!--
### Enabling Recursive Types with Boxes
-->
<h3><a class="header" href="#pouvoir-utiliser-des-types-rÃ©cursifs-grÃ¢ce-aux-boites" id="pouvoir-utiliser-des-types-rÃ©cursifs-grÃ¢ce-aux-boites">Pouvoir utiliser des types rÃ©cursifs grÃ¢ce aux boites</a></h3>
<!--
At compile time, Rust needs to know how much space a type takes up. One type
whose size canâ€™t be known at compile time is a *recursive type*, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesnâ€™t know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, you can have recursive types.
-->
<p>Au moment de la compilation, Rust a besoin de savoir combien s'espace prend un
type. Un des types dont la taille ne peut pas Ãªtre connu au moment de la
compilation est le <em>type rÃ©cursif</em>, dans lequel une valeur peut avoir une partie
de sa dÃ©finition qui a une valeur du mÃªme type qu'elle-mÃªme. Comme emboÃ®tement
de valeurs pourrait thÃ©oriquement se poursuivre Ã  l'infini, Rust ne sait pas
combien d'espace une valeur d'un type rÃ©cursif peut avoir besoin. Cependant, les
boites ont une taille connue, donc en utilisant une boite dans la dÃ©finition
d'un type rÃ©cursif, vous pouvez crÃ©er des types rÃ©cursifs.</p>
<!--
Letâ€™s explore the *cons list*, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
weâ€™ll define is straightforward except for the recursion; therefore, the
concepts in the example weâ€™ll work with will be useful any time you get into
more complex situations involving recursive types.
-->
<p>DÃ©couvrons maintenant la <em>liste de construction</em> (NdTÂ : cons list), qui est un
type de donnÃ©e courant dans les langages de programmation fonctionnels, comme
Ã©tant un exemple de type rÃ©cursif. Le type liste de construction que nous allons
dÃ©finir est plutÃ´t simple, sauf pour les cas de rÃ©cursivitÃ©Â ; par consÃ©quent,
les concepts dans l'exemple avec lequel nous allons travailler vous seront
utiles Ã  chaque fois que vous vous retrouverez dans des situations plus
complexes qui impliquent des types rÃ©cursifs.</p>
<!--
#### More Information About the Cons List
-->
<h4><a class="header" href="#en-savoir-plus-sur-kes-listes-de-construction" id="en-savoir-plus-sur-kes-listes-de-construction">En savoir plus sur kes listes de construction</a></h4>
<!--
A *cons list* is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the `cons` function (short for â€œconstruct functionâ€)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.
-->
<p>Une <em>liste de construction</em> est une structure de donnÃ©e qui provient du langage
de programmation Lisp et de ses dÃ©rivÃ©s. En Lisp, la fonction <code>cons</code> (qui est
une forme contractÃ©e de â€œfonction de constructionâ€) construit une nouvelle paire
Ã  partir de ses deux arguments, qui sont souvent une valeur individuelle et une
autre paire. Ces paires qui contiennent des paires forment des listes.</p>
<!--
The cons function concept has made its way into more general functional
programming jargon: â€œto cons *x* onto *y*â€ informally means to construct a new
container instance by putting the element *x* at the start of this new
container, followed by the container *y*.
-->
<p>Le concept de la fonction cons a fait son chemin dans le jargon plus gÃ©nÃ©ral de
la programmation fonctionnelleÂ : &quot;to cons <em>x</em> onto <em>y</em>&quot; signifie de maniÃ¨re
informelle de construire une nouvelle instance de conteneur en mettant l'Ã©lÃ©ment
<em>x</em> au dÃ©but de ce nouveau conteneur, suivi du conteneur <em>y</em>.</p>
<!--
Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called `Nil`
without a next item. A cons list is produced by recursively calling the `cons`
function. The canonical name to denote the base case of the recursion is `Nil`.
Note that this is not the same as the â€œnullâ€ or â€œnilâ€ concept in Chapter 6,
which is an invalid or absent value.
-->
<p>Chaque Ã©lÃ©ment dans une liste de construction contient deux Ã©lÃ©mentsÂ : la valeur
de l'Ã©lÃ©ment courant et celle de l'Ã©lÃ©ment suivant. Le dernier Ã©lÃ©ment dans la
liste contient seulement une valeur <code>Nil</code> sans aucun Ã©lÃ©ment suivant. Une
liste de construction est produite de maniÃ¨re rÃ©cursive en appelant la fonction
<code>cons</code>. Le nom canonique pour indiquer le cas de base de la rÃ©cursion est <code>Nil</code>.
Notez que ce n'est pas la mÃªme chose que les concepts â€œnullâ€ ou â€œnilâ€ du
chapitre 6, qui signale une valeur invalide ou absente.</p>
<!--
Although functional programming languages use cons lists frequently, the cons
list isnâ€™t a commonly used data structure in Rust. Most of the time when you
have a list of items in Rust, `Vec<T>` is a better choice to use. Other, more
complex recursive data types *are* useful in various situations, but by
starting with the cons list, we can explore how boxes let us define a recursive
data type without much distraction.
-->
<p>Bien que les langages de programmation fonctionnels utilisent les listes de
construction frÃ©quemment, la liste de construction n'est pas une structure de
donnÃ©e utilisÃ©e couramment en Rust. La plupart du temps lorsque vous avez une
liste d'Ã©lÃ©ments en Rust, <code>Vec&lt;T&gt;</code> s'avÃ¨re Ãªtre un meilleur choix Ã  faire.
Autrement, il existe des types de donnÃ©es rÃ©cursifs plus complexes <em>qui sont</em>
utiles dans d'autres situations, mais en commenÃ§ant avec les listes de
construction, nous pouvons dÃ©couvrir comment les boites nous permettent de
dÃ©finir un type de donnÃ©es rÃ©cursif sans Ãªtre trop perturbÃ© par la complexitÃ©.</p>
<!--
Listing 15-2 contains an enum definition for a cons list. Note that this code
wonâ€™t compile yet because the `List` type doesnâ€™t have a known size, which
weâ€™ll demonstrate.
-->
<p>L'encart 15-2 propose une dÃ©finition d'une Ã©numÃ©ration pour une liste de
construction. Notez que ce code ne se compile pas encore car le type <code>List</code> n'a
pas encore de taille connue, ce que nous allons voir ensuite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, List),
    Nil,
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of `i32` values</span>
-->
<p><span class="caption">Encart 15-2Â : premiÃ¨re tentative de dÃ©finition d'une
Ã©numÃ©ration pour reprÃ©senter une structure de donnÃ©es de liste de construction
de valeurs <code>i32</code></span></p>
<!--
> Note: Weâ€™re implementing a cons list that holds only `i32` values for the
> purposes of this example. We could have implemented it using generics, as we
> discussed in Chapter 10, to define a cons list type that could store values of
> any type.
-->
<blockquote>
<p>RemarqueÂ : nous implÃ©mentons une liste de construction qui stocke uniquement
des valeurs <code>i32</code> pour les besoins de cet exemple. Nous aurions pu
l'implÃ©menter en utilisant des gÃ©nÃ©riques, que nous avons vu chapitre 10, afin
de dÃ©finir une liste de construction qui pourrait stocker n'importe quel type.</p>
</blockquote>
<!--
Using the `List` type to store the list `1, 2, 3` would look like the code in
Listing 15-3:
-->
<p>L'utilisation du type <code>List</code> pour stocker la liste <code>1, 2, 3</code> ressemblerait au
code dans l'encart 15-3Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# enum List {
#     Cons(i32, List),
#     Nil,
# }
# 
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<!--
<span class="caption">Listing 15-3: Using the `List` enum to store the list `1,
2, 3`</span>
-->
<p><span class="caption">Encart 15-3Â : utilisation de l'Ã©numÃ©ration <code>List</code> pour
stocker la liste <code>1, 2, 3</code></span></p>
<!--
The first `Cons` value holds `1` and another `List` value. This `List` value is
another `Cons` value that holds `2` and another `List` value. This `List` value
is one more `Cons` value that holds `3` and a `List` value, which is finally
`Nil`, the non-recursive variant that signals the end of the list.
-->
<p>La premiÃ¨re valeur <code>Cons</code> stocke <code>1</code> et une autre valeur de <code>List</code>. Cette
valeur <code>List</code> est une autre valeur <code>Cons</code> qui stocke <code>2</code> et une autre valeur de
<code>List</code>. Cette valeur <code>List</code> n'est rien d'autre qu'une valeur <code>Cons</code> qui stocke
<code>3</code> et une valeur <code>List</code>, qui finalement est <code>Nil</code>, la variante non rÃ©cursive
qui signale la fin de la liste.</p>
<!--
If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:
-->
<p>Si nous essayons de compiler le code de l'encart 15-3, nous avons l'erreur de
l'encart 15-4Â :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 -- > src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable

error[E0391]: cycle detected when processing `List`
 -- > src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires processing `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable

error[E0391]: cycle detected when processing `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires processing `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
<span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span>
-->
<p><span class="caption">Encart 15-4Â : l'erreur que nous obtenons lorsque nous
essayons de dÃ©finir une Ã©numÃ©ration rÃ©cursive</span></p>
<!--
The error shows this type â€œhas infinite size.â€ The reason is that weâ€™ve defined
`List` with a variant that is recursive: it holds another value of itself
directly. As a result, Rust canâ€™t figure out how much space it needs to store a
`List` value. Letâ€™s break down why we get this error a bit. First, letâ€™s look
at how Rust decides how much space it needs to store a value of a non-recursive
type.
-->
<p>L'erreur explique que ce type â€œa une taille infinieâ€. La raison est que nous
avons dÃ©fini <code>List</code> avec une variante qui est rÃ©cursiveÂ : elle stocke
directement une autre valeur d'elle-mÃªme. Au final, Rust ne peut pas savoir
combien de place il a besoin pour stocker une valeur <code>List</code>. Analysons
pourquoi nous obtenons cette erreur. D'abord, regardons comment Rust dÃ©cide de
l'espace dont il a besoin pour stocker une valeur d'un type non rÃ©cursif.</p>
<!--
#### Computing the Size of a Non-Recursive Type
-->
<h4><a class="header" href="#calculer-la-taille-dun-type-non-rÃ©cursif" id="calculer-la-taille-dun-type-non-rÃ©cursif">Calculer la taille d'un type non rÃ©cursif</a></h4>
<!--
Recall the `Message` enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:
-->
<p>Rappelez-vous de l'Ã©numÃ©ration <code>Message</code> que nous avons dÃ©fini dans
l'encart 6-2 lorsque nous avons abordÃ© les dÃ©finitions des Ã©numÃ©rations au
chapitre 6Â :</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
To determine how much space to allocate for a `Message` value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that `Message::Quit` doesnâ€™t need any space, `Message::Move` needs enough
space to store two `i32` values, and so forth. Because only one variant will be
used, the most space a `Message` value will need is the space it would take to
store the largest of its variants.
-->
<p>Pour dÃ©terminer combien d'espace allouer pour une valeur <code>Message</code>, Rust
parcourt chaque variante pour voir quelle variante a besoin le plus d'espace.
Rust voit que <code>Message::Quit</code> n'a pas besoin d'espace, <code>Message::Move</code> a besoin
de suffisamment d'espace pour stocker deux valeurs <code>i32</code>, et ainsi de suite.
Comme une seule variante sera utilisÃ©e, le plus grand espace dont une valeur
de <code>Message</code> aura besoin sera l'espace que cela prendra de stocker la plus
grosse de ses variantes.</p>
<!--
Contrast this with what happens when Rust tries to determine how much space a
recursive type like the `List` enum in Listing 15-2 needs. The compiler starts
by looking at the `Cons` variant, which holds a value of type `i32` and a value
of type `List`. Therefore, `Cons` needs an amount of space equal to the size of
an `i32` plus the size of a `List`. To figure out how much memory the `List`
type needs, the compiler looks at the variants, starting with the `Cons`
variant. The `Cons` variant holds a value of type `i32` and a value of type
`List`, and this process continues infinitely, as shown in Figure 15-1.
-->
<p>Comparez cela avec ce qui se passe lorsque Rust essaye de dÃ©terminer combien
d'espace un type rÃ©cursif comme l'Ã©numÃ©ration <code>List</code> de l'encart 15-2 aurait
besoin. Le compilateur commence par regarder la variante <code>Cons</code>, qui stocke une
valeur de type <code>i32</code> et une valeur de type <code>List</code>. Ainsi, <code>Cons</code> a besoin d'une
quantitÃ© d'espace Ã©gale Ã  la taille d'un <code>i32</code> plus la taille d'une valeur
<code>List</code>. Pour savoir combien de mÃ©moire le type <code>List</code> a besoin, le compilateur
va regarder ses variantes, en commenÃ§ant avec la variante <code>Cons</code>. La variante
<code>Cons</code> stocke une valeur de type <code>i32</code> et une valeur de type <code>List</code>, et ce
processus continue Ã  l'infini, comme l'illustration 15-1.</p>
<!-- markdownlint-disable -->
<!--
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une liste de construction infinie"
    src="img/trpl15-01.svg"
    class="center"
    style="width: 50%;" /></p>
<!--
<span class="caption">Figure 15-1: An infinite `List` consisting of infinite
`Cons` variants</span>
-->
<p><span class="caption">Illustration 15-1Â : une <code>List</code> infinie qui contient des
variantes <code>Cons</code> infinies</span></p>
<!--
#### Using `Box<T>` to Get a Recursive Type with a Known Size
-->
<h4><a class="header" href="#utiliser-boxt-pour-crÃ©er-un-type-rÃ©cursif-avec-une-taille-finie" id="utiliser-boxt-pour-crÃ©er-un-type-rÃ©cursif-avec-une-taille-finie">Utiliser <code>Box&lt;T&gt;</code> pour crÃ©er un type rÃ©cursif avec une taille finie</a></h4>
<!--
Rust canâ€™t figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:
-->
<p>Rust ne peut pas calculer la quantitÃ© d'espace Ã  allouer pour les types
dÃ©finis rÃ©cursivement, donc le compilateur dÃ©clenche l'erreur de l'encart
15-4. Mais l'erreur renferme cette suggestion trÃ¨s utileÂ :</p>
<!--
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-- >
-->
<!--
```text
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable
```
-->
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<!--
In this suggestion, â€œindirectionâ€ means that instead of storing a value
directly, weâ€™ll change the data structure to store the value indirectly by
storing a pointer to the value instead.
-->
<p>Dans cette suggestion, â€œindirectionâ€ (NdTÂ : redirection) signifie que plutÃ´t de
stocker une valeur directement, nous devrions changer la structure des donnÃ©es
pour stocker Ã  la place un pointeur vers la valeur.</p>
<!--
Because a `Box<T>` is a pointer, Rust always knows how much space a `Box<T>`
needs: a pointerâ€™s size doesnâ€™t change based on the amount of data itâ€™s
pointing to. This means we can put a `Box<T>` inside the `Cons` variant instead
of another `List` value directly. The `Box<T>` will point to the next `List`
value that will be on the heap rather than inside the `Cons` variant.
Conceptually, we still have a list, created with lists â€œholdingâ€ other lists,
but this implementation is now more like placing the items next to one another
rather than inside one another.
-->
<p>Comme <code>Box&lt;T&gt;</code> est un pointeur, Rust connaÃ®t toujours combien d'espace un
<code>Box&lt;T&gt;</code> a besoinÂ : la taille d'un pointeur ne change pas, peu importe la
quantitÃ© de donnÃ©es sur lesquelles il pointe. Cela signifie que nous pouvons
insÃ©rer un <code>Box&lt;T&gt;</code> Ã  l'intÃ©rieur d'une variante <code>Cons</code> au lieu d'y mettre
directement une autre valeur <code>List</code>. Le <code>Box&lt;T&gt;</code> va pointer sur la prochaine
valeur <code>List</code> qui sera sur le tas plutÃ´t que d'Ãªtre dans la variante <code>Cons</code>.
ThÃ©oriquement, nous avons toujours une liste, crÃ©Ã©e avec des listes qui
â€œcontiennentâ€ d'autres listes, mais cette implÃ©mentation est ressemble plus
maintenant Ã  des Ã©lÃ©ments placÃ©s les uns Ã  cÃ´tÃ© des autres, plutÃ´t que les
uns dans les autres.</p>
<!--
We can change the definition of the `List` enum in Listing 15-2 and the usage
of the `List` in Listing 15-3 to the code in Listing 15-5, which will compile:
-->
<p>Nous pouvons changer la dÃ©finition de l'Ã©numÃ©ration <code>List</code> de l'encart 15-2 et
l'utilisation de <code>List</code> dans l'encart 15-3 pour le code de l'encart 15-5, qui
va se compilerÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FilenameÂ : src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-5: Definition of `List` that uses `Box<T>` in
order to have a known size</span>
-->
<p><span class="caption">Encart 15-5Â : dÃ©finition de <code>List</code> qui utilise <code>Box&lt;T&gt;</code>
dans le but d'avoir une taille connue</span></p>
<!--
The `Cons` variant will need the size of an `i32` plus the space to store the
boxâ€™s pointer data. The `Nil` variant stores no values, so it needs less space
than the `Cons` variant. We now know that any `List` value will take up the
size of an `i32` plus the size of a boxâ€™s pointer data. By using a box, weâ€™ve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a `List` value. Figure 15-2 shows what the `Cons` variant
looks like now.
-->
<p>La variante <code>Cons</code> va avoir besoin de l'espace d'un <code>i32</code> plus l'espace pour
stocker le pointeur vers la donnÃ©e de la boite. La variante <code>Nil</code> ne stocke pas
de valeurs, donc elle a besoin de moins d'espace que la variante <code>Cons</code>. Nous
savons maintenant que chaque valeur <code>List</code> va prendre la taille d'un <code>i32</code>
plus la taille d'un pointeur vers la donnÃ©e de la boite. En utilisant une boite,
vous avez arrÃªtÃ© la chaine infinie et rÃ©cursive, donc le compilateur peut
savoir l'espace dont il a besoin pour stocker une valeur <code>List</code>. L'illustration
15-2 montre Ã  quoi ressemble maintenant la variante <code>Cons</code>.</p>
<!--
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
-->
<p><img
    alt="Une liste de construction finie"
    src="img/trpl15-02.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-2: A `List` that is not infinitely sized
because `Cons` holds a `Box`</span>
-->
<p><span class="caption">Illustration 15-2Â : une <code>List</code> qui n'a pas de taille
infinie car <code>Cons</code> est une <code>Box</code></span></p>
<!--
Boxes provide only the indirection and heap allocation; they donâ€™t have any
other special capabilities, like those weâ€™ll see with the other smart pointer
types. They also donâ€™t have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. Weâ€™ll look at more use cases for boxes
in Chapter 17, too.
-->
<p>Les boites fournissent uniquement la redirection et l'allocation sur le tasÂ ;
elles n'ont pas d'autres fonctionnalitÃ©s, comme celles que nous verrons sur
d'autres types de pointeurs intelligents. Elles n'ont pas non plus de surcoÃ»t
sur les performances autre que ce qu'offrent ces capacitÃ©s spÃ©ciales, donc
elles sont utiles dans des cas comme les listes de construction oÃ¹ la
redirection est la seule fonctionnalitÃ© que nous avons besoin. Nous verrons
aussi plus de cas d'usages pour les boites dans le chapitre 17.</p>
<!--
The `Box<T>` type is a smart pointer because it implements the `Deref` trait,
which allows `Box<T>` values to be treated like references. When a `Box<T>`
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the `Drop` trait implementation. Letâ€™s explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types weâ€™ll discuss in the
rest of this chapter.
-->
<p>Le type <code>Box&lt;T&gt;</code> est un pointeur intelligent car il implÃ©mente le trait
<code>Deref</code>, qui permet aux valeurs <code>Box&lt;T&gt;</code> d'Ãªtre traitÃ©es comme des
rÃ©fÃ©rences. Lorsque une valeur <code>Box&lt;T&gt;</code> sort de la portÃ©e, les donnÃ©es sur le
tas que la boite pointait est aussi nettoyÃ© grÃ¢ce au trait <code>Drop</code>. Explorons
plus en dÃ©tail ces deux traits. Ces deux traits deviendrons encore plus
importants pour les fonctionnalitÃ©s offertes par les autres pointeurs
intelligents que nous verrons dans le reste de ce chapitre.</p>
<!-- markdownlint-disable -->
<!--
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<!-- markdownlint-restore -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--27" id="-attention-peinture-fraÃ®che--27">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/189">Pull Request</a>.</p>
</blockquote>
<!--
## Treating Smart Pointers Like Regular References with the `Deref` Trait
-->
<h2><a class="header" href="#considÃ©rer-les-pointeurs-intelligents-comme-des-rÃ©fÃ©rences-grÃ¢ce-au-trait-deref" id="considÃ©rer-les-pointeurs-intelligents-comme-des-rÃ©fÃ©rences-grÃ¢ce-au-trait-deref">ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait <code>Deref</code></a></h2>
<!--
Implementing the `Deref` trait allows you to customize the behavior of the
*dereference operator*, `*` (as opposed to the multiplication or glob
operator). By implementing `Deref` in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.
-->
<p>L'implÃ©mentation du trait <code>Deref</code> vous permet de personnaliser le comportement
de <em>l'opÃ©rateur de dÃ©rÃ©fÃ©rencement</em> <code>*</code> (qui n'est pas l'opÃ©rateur de
multiplication ou le joker global). En implÃ©mentant <code>Deref</code> de maniÃ¨re Ã  ce
qu'un pointeur intelligent puisse Ãªtre considÃ©rÃ© comme une rÃ©fÃ©rence classique,
vous pouvez Ã©crire du code qui fonctionne avec des rÃ©fÃ©rences mais aussi avec
des pointeurs intelligents.</p>
<!--
Letâ€™s first look at how the dereference operator works with regular references.
Then weâ€™ll try to define a custom type that behaves like `Box<T>`, and see why
the dereference operator doesnâ€™t work like a reference on our newly defined
type. Weâ€™ll explore how implementing the `Deref` trait makes it possible for
smart pointers to work in ways similar to references. Then weâ€™ll look at
Rustâ€™s *deref coercion* feature and how it lets us work with either references
or smart pointers.
-->
<p>Regardons d'abord comment l'opÃ©rateur de dÃ©rÃ©fÃ©rencement fonctionne avec des
rÃ©fÃ©rences classiques. Ensuite nous essayerons de dÃ©finir un type personnalisÃ©
qui se comporte comme <code>Box&lt;T&gt;</code>, et voir pourquoi l'opÃ©rateur de dÃ©rÃ©fÃ©rencement
ne fonctionne pas comme une rÃ©fÃ©rence sur notre type fraÃ®chement dÃ©fini. Nous
allons dÃ©couvrir comment implÃ©menter le trait <code>Deref</code> de maniÃ¨re Ã  ce qu'il soit
possible que les pointeurs intelligents fonctionnent comme les rÃ©fÃ©rences.
Ensuite nous verons la fonctionnalitÃ© d'<em>extrapolation de dÃ©rÃ©fÃ©rencement</em> de
Rust et voir comment elle nous permet de travailler Ã  la fois avec des
rÃ©fÃ©rences et des pointeurs intelligents.</p>
<!--
> Note: thereâ€™s one big difference between the `MyBox<T>` type weâ€™re about to
> build and the real `Box<T>`: our version will not store its data on the heap.
> We are focusing this example on `Deref`, so where the data is actually stored
> is less important than the pointer-like behavior.
-->
<blockquote>
<p>RemarqueÂ : il y a une grosse diffÃ©rence entre le type <code>MaBoite&lt;T&gt;</code> que nous
allons construire et la vraie <code>Box&lt;T&gt;</code>Â : notre version ne va pas stocker ses
donnÃ©es sur le tas. Nous allons concentrer cet exemple sur <code>Deref</code>, donc
l'endroit oÃ¹ est concrÃ¨tement stockÃ© la donnÃ©e est moins important que le
comportement similaire aux pointeurs.</p>
</blockquote>
<!--
### Following the Pointer to the Value with the Dereference Operator
-->
<h3><a class="header" href="#suivre-le-pointeur-vers-la-valeur-grÃ¢ce-Ã -lopÃ©rateur-de-dÃ©rÃ©fÃ©rencement" id="suivre-le-pointeur-vers-la-valeur-grÃ¢ce-Ã -lopÃ©rateur-de-dÃ©rÃ©fÃ©rencement">Suivre le pointeur vers la valeur grÃ¢ce Ã  l'opÃ©rateur de dÃ©rÃ©fÃ©rencement</a></h3>
<!--
A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an `i32` value and then use the dereference operator to follow the
reference to the data:
-->
<p>Une rÃ©fÃ©rence classique est un type de pointeur, et une maniÃ¨re de modÃ©liser un
pointeur est d'imaginer une flÃ¨che pointant vers une valeur stockÃ©e autre part.
Dans l'encart 15-6, nous crÃ©ons une rÃ©fÃ©rence vers une valeur <code>i32</code> et utilisons
ensuite l'opÃ©rateur de dÃ©rÃ©fÃ©rencement pour suivre la rÃ©fÃ©rence vers la donnÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an `i32` value</span>
-->
<p><span class="caption">Encart 15-6Â : utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement pour
suivre une rÃ©fÃ©rence vers une valeur <code>i32</code></span></p>
<!--
The variable `x` holds an `i32` value, `5`. We set `y` equal to a reference to
`x`. We can assert that `x` is equal to `5`. However, if we want to make an
assertion about the value in `y`, we have to use `*y` to follow the reference
to the value itâ€™s pointing to (hence *dereference*). Once we dereference `y`,
we have access to the integer value `y` is pointing to that we can compare with
`5`.
-->
<p>La variable <code>x</code> stocke une valeur <code>i32</code>Â : <code>5</code>. Nous avons assignÃ© Ã  <code>y</code> une
rÃ©fÃ©rence vers <code>x</code>. Nous pouvons faire une <code>assert</code> pour vÃ©rifier que <code>x</code> est
Ã©gal Ã  <code>5</code>. Cependant, si nous souhaitons faire une <code>assert</code> sur la valeur dans
<code>y</code>, nous devons utiliser <code>*y</code> pour suivre la rÃ©fÃ©rence vers la valeur sur
laquelle elle pointe (d'oÃ¹ le <em>dÃ©rÃ©fÃ©rencement</em>). Une fois que nous avons
dÃ©rÃ©fÃ©rencÃ© <code>y</code>, nous avons accÃ¨s Ã  la valeur de l'entier sur laquelle <code>y</code>
pointe afin que nous puissions la comparer avec <code>5</code>.</p>
<!--
If we tried to write `assert_eq!(5, y);` instead, we would get this compilation
error:
-->
<p>Si nous avions essayÃ© d'Ã©crire <code>assert_eq!(5, y);</code> Ã  la place, nous aurions
obtenu cette erreur de compilationÂ :</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 -- > src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Comparing a number and a reference to a number isnâ€™t allowed because theyâ€™re
different types. We must use the dereference operator to follow the reference
to the value itâ€™s pointing to.
-->
<p>Comparer un nombre et une rÃ©fÃ©rence vers un nombre n'est pas autorisÃ© car ils
sont de types diffÃ©rents. Nous devons utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement
pour suivre la rÃ©fÃ©rence vers la valeur sur laquelle elle pointe.</p>
<!--
### Using `Box<T>` Like a Reference
-->
<h3><a class="header" href="#utiliser-boxt-comme-Ã©tant-une-rÃ©fÃ©rence" id="utiliser-boxt-comme-Ã©tant-une-rÃ©fÃ©rence">Utiliser <code>Box&lt;T&gt;</code> comme Ã©tant une rÃ©fÃ©rence</a></h3>
<!--
We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a
reference; the dereference operator will work as shown in Listing 15-7:
-->
<p>Nous pouvons rÃ©Ã©crire le code l'encart 15-6 pour utiliser une <code>Box&lt;T&gt;</code> au lieu
d'une rÃ©fÃ©renceÂ ; l'opÃ©rateur de dÃ©rÃ©fÃ©rencement devrait fonctionner comme
montrÃ© dans l'encart 15-7Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-7: Using the dereference operator on a
`Box<i32>`</span>
-->
<p><span class="caption">Encart 15-7Â : utilisation de l'opÃ©rateur de
dÃ©rÃ©fÃ©rencement sur un <code>Box&lt;i32&gt;</code></span></p>
<!--
The only difference between Listing 15-7 and Listing 15-6 is that here we set
`y` to be an instance of a box pointing to a copied value of `x` rather than a
reference pointing to the value of `x`. In the last assertion, we can use the
dereference operator to follow the boxâ€™s pointer in the same way that we did
when `y` was a reference. Next, weâ€™ll explore what is special about `Box<T>`
that enables us to use the dereference operator by defining our own box type.
-->
<p>La seule diffÃ©rence entre l'encart 15-7 et l'encart 15-6 est qu'ici nous avons
fait en sorte que <code>y</code> soit une instance de boite qui pointe sur une copie de la
valeur de <code>x</code> plutÃ´t qu'avoir une rÃ©fÃ©rence vers la valeur de <code>x</code>. Dans la
derniÃ¨re assertion, nous pouvons utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement pour
suivre le pointeur de la boite de la mÃªme maniÃ¨re que nous l'avons fait lorsque
<code>y</code> Ã©tait une rÃ©fÃ©rence. Maintenant, nous allons regarder ce qu'il y a de si
spÃ©cial dans <code>Box&lt;T&gt;</code> qui nous permet d'utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement
en dÃ©finissant notre propre type de boite.</p>
<!--
### Defining Our Own Smart Pointer
-->
<h3><a class="header" href="#dÃ©finir-notre-propre-pointeur-intelligent" id="dÃ©finir-notre-propre-pointeur-intelligent">DÃ©finir notre propre pointeur intelligent</a></h3>
<!--
Letâ€™s build a smart pointer similar to the `Box<T>` type provided by the
standard library to experience how smart pointers behave differently from
references by default. Then weâ€™ll look at how to add the ability to use the
dereference operator.
-->
<p>Construisons un pointeur intelligent similaire au type <code>Box&lt;T&gt;</code> fourni par la
bibliothÃ¨que standard pour apprendre comment les pointeurs intelligents se
comportent diffÃ©remment des rÃ©fÃ©rences classiques. Ensuite nous regarderons
comment lui ajouter la possibilitÃ© d'utiliser l'opÃ©rateur de dÃ©rÃ©fÃ©rencement.</p>
<!--
The `Box<T>` type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a `MyBox<T>` type in the same way. Weâ€™ll also define a
`new` function to match the `new` function defined on `Box<T>`.
-->
<p>Le type <code>Box&lt;T&gt;</code> est essentiellement dÃ©fini comme Ã©tant une structure de tuple
d'un seul Ã©lÃ©ment, donc l'encart 15-8 dÃ©finit un type <code>MaBoite&lt;T&gt;</code> de la mÃªme
maniÃ¨re. Nous allons aussi dÃ©finir une fonction <code>new</code> pour correspondre Ã  la
fonction <code>new</code> dÃ©finie sur <code>Box&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MaBoite&lt;T&gt;(T);

impl&lt;T&gt; MaBoite&lt;T&gt; {
    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
        MaBoite(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-8: Defining a `MyBox<T>` type</span>
-->
<p><span class="caption">Encart 15-8Â : dÃ©finition du type <code>MaBoite&lt;T&gt;</code></span></p>
<!--
We define a struct named `MyBox` and declare a generic parameter `T`, because
we want our type to hold values of any type. The `MyBox` type is a tuple struct
with one element of type `T`. The `MyBox::new` function takes one parameter of
type `T` and returns a `MyBox` instance that holds the value passed in.
-->
<p>Nous dÃ©finissons une structure <code>MaBoite</code> et on dÃ©clare un paramÃ¨tre gÃ©nÃ©rique
<code>T</code>, car nous souhaitons que notre type stocke des valeurs de n'importe quel
type. Le type <code>MaBoite</code> est une structure de tuple avec un seul Ã©lÃ©ment de type
<code>T</code>. La fonction <code>MaBoite::new</code> prend un paramÃ¨tre de type <code>T</code> et retourne une
instance <code>MaBoite</code> qui stocke la valeur qui lui est passÃ©e.</p>
<!--
Letâ€™s try adding the `main` function in Listing 15-7 to Listing 15-8 and
changing it to use the `MyBox<T>` type weâ€™ve defined instead of `Box<T>`. The
code in Listing 15-9 wonâ€™t compile because Rust doesnâ€™t know how to dereference
`MyBox`.
-->
<p>Essayons d'ajouter la fonction <code>main</code> de l'encart 15-7 dans l'encart 15-8 et la
modifier pour utiliser le type <code>MaBoite&lt;T&gt;</code> que nous avons dÃ©fini Ã  la place de
<code>Box&lt;T&gt;</code>. Le code de l'encart 15-9 ne se compile pas car Rust ne sait pas
comment dÃ©rÃ©fÃ©rencer <code>MaBoite</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MaBoite::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<!--
<span class="caption">Listing 15-9: Attempting to use `MyBox<T>` in the same
way we used references and `Box<T>`</span>
-->
<p><span class="caption">Encart 15-9Â : tentative d'utiliser <code>MaBoite&lt;T&gt;</code> de la mÃªme
maniÃ¨re que nous avions utilisÃ© les rÃ©fÃ©rences et <code>Box&lt;T&gt;</code></span></p>
<!--
Hereâ€™s the resulting compilation error:
-->
<p>Voici l'erreur de compilation qui en rÃ©sulteÂ :</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  -- > src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MaBoite&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Our `MyBox<T>` type canâ€™t be dereferenced because we havenâ€™t implemented that
ability on our type. To enable dereferencing with the `*` operator, we
implement the `Deref` trait.
-->
<p>Notre type <code>MaBoite&lt;T&gt;</code> ne peut pas Ãªtre dÃ©rÃ©fÃ©rencÃ©e car nous n'avons pas
implÃ©mentÃ© cette fonctionnalitÃ© sur notre type. Pour permettre le
dÃ©rÃ©fÃ©rencement avec l'opÃ©rateur <code>*</code>, nous devons implÃ©menter le trait <code>Deref</code>.</p>
<!--
### Treating a Type Like a Reference by Implementing the `Deref` Trait
-->
<h3><a class="header" href="#considÃ©rer-un-type-comme-une-rÃ©fÃ©rence-en-implÃ©mentant-le-trait-deref" id="considÃ©rer-un-type-comme-une-rÃ©fÃ©rence-en-implÃ©mentant-le-trait-deref">ConsidÃ©rer un type comme une rÃ©fÃ©rence en implÃ©mentant le trait <code>Deref</code></a></h3>
<!--
As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the traitâ€™s required methods. The `Deref` trait, provided
by the standard library, requires us to implement one method named `deref` that
borrows `self` and returns a reference to the inner data. Listing 15-10
contains an implementation of `Deref` to add to the definition of `MyBox`:
-->
<p>Comme nous l'avons vu dans le chapitre 10, pour implÃ©menter un trait, nous
devons fournir les implÃ©mentations des mÃ©thodes nÃ©cessaires pour ce trait. Le
trait <code>Deref</code>, fourni par la bibliothÃ¨que standard, nÃ©cessite que nous
implÃ©mentions une mÃ©thode <code>deref</code> qui prend possession de <code>self</code> et retourne une
rÃ©fÃ©rence vers la donnÃ©e interne. L'encart 15-10 contient une implÃ©mentation de
<code>Deref</code> Ã  ajouter Ã  la dÃ©finition de <code>MaBoite</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn main() {
#     let x = 5;
#     let y = MyBox::new(x);
# 
#     assert_eq!(5, x);
#     assert_eq!(5, *y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MaBoite::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-10: Implementing `Deref` on `MyBox<T>`</span>
-->
<p><span class="caption">Encart 15-10Â : implÃ©mentation de <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code>
</span></p>
<!--
The `type Target = T;` syntax defines an associated type for the `Deref` trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you donâ€™t need to worry about them for now; weâ€™ll cover them in
more detail in Chapter 19.
-->
<p>La syntaxe <code>type Target = T;</code> dÃ©finit un type associÃ© pour le trait <code>Deref</code> Ã 
utiliser. Les types associÃ©s sont une maniÃ¨re lÃ©gÃ¨rement diffÃ©rente de dÃ©clarer
un paramÃ¨tre gÃ©nÃ©rique, mais vous n'avez pas Ã  vous prÃ©occuper d'eux pour le
momentÂ ; nous les verrons plus en dÃ©tail au chapitre 19.</p>
<!--
We fill in the body of the `deref` method with `&self.0` so `deref` returns a
reference to the value we want to access with the `*` operator. The `main`
function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles,
and the assertions pass!
-->
<p>Nous renseignons le corps de la mÃ©thode <code>deref</code> avec <code>&amp;self.0</code> afin que <code>deref</code>
retourne une rÃ©fÃ©rence vers la valeur que nous souhaitons accÃ©der avec
l'opÃ©rateur <code>*</code>. La fonction <code>main</code> de l'encart 15-9 qui appelle <code>*</code> sur la
valeur <code>MaBoite&lt;T&gt;</code> se compile dÃ©sormais, et le <code>assert</code> rÃ©ussit aussiÂ !</p>
<!--
Without the `Deref` trait, the compiler can only dereference `&` references.
The `deref` method gives the compiler the ability to take a value of any type
that implements `Deref` and call the `deref` method to get a `&` reference that
it knows how to dereference.
-->
<p>Sans le trait <code>Deref</code>, le compilateur peut seulement dÃ©rÃ©fÃ©rencer des rÃ©fÃ©rences
<code>&amp;</code>. La mÃ©thode <code>deref</code> donne la possibilitÃ© au compilateur d'obtenir la valeur
de n'importe quel type qui implÃ©mente <code>Deref</code> en appelant la mÃ©thode <code>deref</code>
pour obtenir une rÃ©fÃ©rence <code>&amp;</code> qu'il sait comment dÃ©rÃ©fÃ©rencer.</p>
<!--
When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this
code:
-->
<p>Lorsque nous avons prÃ©cisÃ© <code>*y</code> dans l'encart 15-9, Rust fait tourner ce code en
coulissesÂ :</p>
<!--
```rust,ignore
*(y.deref())
```
-->
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!--
Rust substitutes the `*` operator with a call to the `deref` method and then a
plain dereference so we donâ€™t have to think about whether or not we need to
call the `deref` method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
`Deref`.
-->
<p>Rust remplace l'opÃ©rateur <code>*</code> par un appel Ã  la mÃ©thode <code>deref</code> suivi par un
simple dÃ©rÃ©fÃ©rencement afin que nous n'ayons pas Ã  nous demander si nous devons
ou non appeler la mÃ©thode <code>deref</code>. Cette fonctionnalitÃ© de Rust nous permet
d'Ã©crire du code qui fonctionne de maniÃ¨re identique que nous ayons une
rÃ©fÃ©rence classique ou un type qui implÃ©mente <code>Deref</code>.</p>
<!--
The reason the `deref` method returns a reference to a value, and that the plain
dereference outside the parentheses in `*(y.deref())` is still necessary, is the
ownership system. If the `deref` method returned the value directly instead of
a reference to the value, the value would be moved out of `self`. We donâ€™t want
to take ownership of the inner value inside `MyBox<T>` in this case or in most
cases where we use the dereference operator.
-->
<p>La raison pour laquelle la mÃ©thode <code>deref</code> retourne une rÃ©fÃ©rence Ã  une valeur,
et que le dÃ©rÃ©fÃ©rencement du tout dans les parenthÃ¨ses externes de
<code>*(y.deref())</code> reste nÃ©cessaire, est le systÃ¨me de possession. Si la mÃ©thode
<code>deref</code> retournait la valeur directement au lieu d'une rÃ©fÃ©rence Ã  cette valeur,
la valeur serait <em>dÃ©placÃ©e</em> Ã  l'extÃ©rieur de <code>self</code>. Nous ne souhaitons pas
prendre possession de la valeur Ã  l'intÃ©rieur de <code>MaBoite&lt;T&gt;</code> dans ce cas ainsi
que la plupart des cas oÃ¹ nous utilisons l'opÃ©rateur de dÃ©rÃ©fÃ©rencement.</p>
<!--
Note that the `*` operator is replaced with a call to the `deref` method and
then a call to the `*` operator just once, each time we use a `*` in our code.
Because the substitution of the `*` operator does not recurse infinitely, we
end up with data of type `i32`, which matches the `5` in `assert_eq!` in
Listing 15-9.
-->
<p>Notez que l'opÃ©rateur <code>*</code> est remplacÃ© par un appel Ã  la mÃ©thode <code>deref</code> suivi
par un appel Ã  l'opÃ©rateur <code>*</code> une seule fois, Ã  chaque fois que nous utilisons
un <code>*</code> dans notre code. Comme la substitution de l'opÃ©rateur <code>*</code> ne s'effectue
pas de maniÃ¨re rÃ©cursive et infinie, nous rÃ©cupÃ©rerons une donnÃ©e de type <code>i32</code>,
qui correspond au <code>5</code> du <code>assert_eq!</code> de l'encart 15-9.</p>
<!--
### Implicit Deref Coercions with Functions and Methods
-->
<h3><a class="header" href="#extrapolation-de-dÃ©rÃ©fÃ©rencement-implicite-avec-les-fonctions-et-les-mÃ©thodes" id="extrapolation-de-dÃ©rÃ©fÃ©rencement-implicite-avec-les-fonctions-et-les-mÃ©thodes">Extrapolation de dÃ©rÃ©fÃ©rencement implicite avec les fonctions et les mÃ©thodes</a></h3>
<!--
*Deref coercion* is a convenience that Rust performs on arguments to functions
and methods. Deref coercion works only on types that implement the `Deref`
trait. Deref coercion converts such a type into a reference to another type.
For example, deref coercion can convert `&String` to `&str` because `String`
implements the `Deref` trait such that it returns `str`. Deref coercion happens
automatically when we pass a reference to a particular typeâ€™s value as an
argument to a function or method that doesnâ€™t match the parameter type in the
function or method definition. A sequence of calls to the `deref` method
converts the type we provided into the type the parameter needs.
-->
<p>L'<em>extrapolation de dÃ©rÃ©fÃ©rencement</em> est une commoditÃ© que Rust applique sur les
arguments des fonctions et des mÃ©thodes. L'extrapolation de dÃ©rÃ©fÃ©rencement
fonctionne uniquement avec un type qui implÃ©mente le trait <code>Deref</code>.
L'extrapolation de dÃ©rÃ©fÃ©rencement convertit ce type en une rÃ©fÃ©rence vers un
autre type. Par exemple, l'extrapolation de dÃ©rÃ©fÃ©rencement peut convertir
<code>&amp;String</code> en <code>&amp;str</code> car <code>String</code> implÃ©mente le trait <code>Deref</code> de sorte qu'il
puisse retourner <code>str</code>. L'extrapolation de dÃ©rÃ©fÃ©rencement s'applique
automatiquement lorsque nous passons une rÃ©fÃ©rence vers une valeur d'un type
particulier en argument d'une fonction ou d'une mÃ©thode qui ne correspond pas Ã 
ce type de paramÃ¨tre dans la dÃ©finition de la fonction ou de la mÃ©thode. Une
sÃ©rie d'appels Ã  la mÃ©thode <code>deref</code> convertit le type que nous donnons dans le
type que le paramÃ¨tre nÃ©cessite.</p>
<!--
Deref coercion was added to Rust so that programmers writing function and
method calls donâ€™t need to add as many explicit references and dereferences
with `&` and `*`. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.
-->
<p>L'extrapolation de dÃ©rÃ©fÃ©rencement a Ã©tÃ© ajoutÃ© Ã  Rust afin de permettre aux
dÃ©veloppeurs d'Ã©crire des appels de fonctions et de mÃ©thodes qui n'ont pas
besoin d'indiquer explicitement les rÃ©fÃ©rences et les dÃ©rÃ©fÃ©rencements avec <code>&amp;</code>
et <code>*</code>. La fonctionnalitÃ© d'extrapolation de dÃ©rÃ©fÃ©rencement nous permet aussi
d'Ã©crire plus de code qui peut fonctionner Ã  la fois pour les rÃ©fÃ©rences ou pour
les pointeurs intelligents.</p>
<!--
To see deref coercion in action, letâ€™s use the `MyBox<T>` type we defined in
Listing 15-8 as well as the implementation of `Deref` that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:
-->
<p>Pour voir l'extrapolation de dÃ©rÃ©fÃ©rencement en action, utilisons le type
<code>MaBoite&lt;T&gt;</code> que nous avons dÃ©fini dans l'encart 15-8 ainsi que l'implÃ©mentation
de <code>Deref</code> que nous avons ajoutÃ© dans l'encart 15-10. L'encart 15-11 montre la
dÃ©finition d'une fonction qui a un paramÃ¨tre qui est une slice de chaÃ®ne de
caractÃ¨resÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn saluer(nom: &amp;str) {
    println!(&quot;Salutations, {}Â !&quot;, nom);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-11: A `hello` function that has the parameter
`name` of type `&str`</span>
-->
<p><span class="caption">Encart 15-11Â : une fonction <code>saluer</code> qui prend en
paramÃ¨tre <code>nom</code> du type <code>&amp;str</code></span></p>
<!--
We can call the `hello` function with a string slice as an argument, such as
`hello("Rust");` for example. Deref coercion makes it possible to call `hello`
with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12:
-->
<p>Nous pouvons appeler la fonction <code>saluer</code> avec une slice de chaÃ®ne de caractÃ¨res
en argument, comme par exemple <code>saluer(&quot;Rust&quot;);</code>. L'extrapolation de
dÃ©rÃ©fÃ©rencement rend possible l'appel de <code>saluer</code> avec une rÃ©fÃ©rence Ã  une
valeur du type <code>MaBoite&lt;String&gt;</code>, comme dans l'encart 15-12Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {}Â !&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-12: Calling `hello` with a reference to a
`MyBox<String>` value, which works because of deref coercion</span>
-->
<p><span class="caption">Encart 15-12Â : appel Ã  <code>saluer</code> avec une rÃ©fÃ©rence Ã  une
valeur du type <code>MaBoite&lt;String&gt;</code>, qui fonctionne grÃ¢ce Ã  l'extrapolation de
dÃ©rÃ©fÃ©rencement</span></p>
<!--
Here weâ€™re calling the `hello` function with the argument `&m`, which is a
reference to a `MyBox<String>` value. Because we implemented the `Deref` trait
on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String`
by calling `deref`. The standard library provides an implementation of `Deref`
on `String` that returns a string slice, and this is in the API documentation
for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which
matches the `hello` functionâ€™s definition.
-->
<p>Ici nous appelons la fonction <code>saluer</code> avec l'argument <code>&amp;m</code>, qui est une
rÃ©fÃ©rence vers une valeur de type <code>MaBoite&lt;String&gt;</code>. Comme nous avons implÃ©mentÃ©
le trait <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code> dans l'encart 15-10, Rust peut transformer le
<code>&amp;MaBoite&lt;String&gt;</code> en <code>&amp;String</code> en appelant <code>deref</code>. La bibliothÃ¨que standard
fournit une implÃ©mentation de <code>Deref</code> sur <code>String</code> qui retourne une slice de
chaÃ®ne de caractÃ¨res, comme expliquÃ© dans la documentation de l'API de <code>Deref</code>.
Rust appelle Ã  nouveau <code>deref</code> pour transformer le <code>&amp;String</code> en <code>&amp;str</code>, qui
correspond Ã  la dÃ©finition de la fonction <code>saluer</code>.</p>
<!--
If Rust didnâ€™t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value
of type `&MyBox<String>`.
-->
<p>Si Rust n'avait pas implÃ©mentÃ© l'extrapolation de dÃ©rÃ©fÃ©rencement, nous aurions
dÃ» Ã©crire le code de l'encart 15-13 au lieu du code de l'encart 15-12 pour
appeler <code>saluer</code> avec une valeur du type <code>&amp;MaBoite&lt;String&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {}Â !&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;(*m)[..]);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-13: The code we would have to write if Rust
didnâ€™t have deref coercion</span>
-->
<p><span class="caption">Encart 15-13Â : le code que nous aurions dÃ» Ã©crire si Rust
n'avait pas d'extrapolation de dÃ©rÃ©fÃ©rencement</span></p>
<!--
The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and
`[..]` take a string slice of the `String` that is equal to the whole string to
match the signature of `hello`. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.
-->
<p>Le <code>(*m)</code> dÃ©rÃ©fÃ©rence la <code>MaBoite&lt;String&gt;</code> en une <code>String</code>. Ensuite le <code>&amp;</code> et le
<code>[..]</code> crÃ©ent une slice de chaÃ®ne de caractÃ¨res Ã  partir de la <code>String</code> qui est
Ã©gale Ã  l'intÃ©gralitÃ© du contenu de la <code>String</code>, ceci afin de correspondre Ã  la
signature de <code>saluer</code>. Le code sans l'extrapolation de dÃ©rÃ©fÃ©rencement est bien
plus difficile Ã  lire, Ã©crire et comprendre avec la prÃ©sence de tous ces
symboles. L'extrapolation de dÃ©rÃ©fÃ©rencement permet Ã  Rust d'automatiser ces
convertions pour nous.</p>
<!--
When the `Deref` trait is defined for the types involved, Rust will analyze the
types and use `Deref::deref` as many times as necessary to get a reference to
match the parameterâ€™s type. The number of times that `Deref::deref` needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!
-->
<p>Lorsque le trait <code>Deref</code> est dÃ©fini pour les types concernÃ©s, Rust va analyser
les types et utiliser <code>Deref::deref</code> autant de fois que nÃ©cessaire pour obtenir
une rÃ©fÃ©rence qui correspond au type du paramÃ¨tre. Le nombre de fois qu'il est
nÃ©cessaire d'insÃ©rer <code>Deref::deref</code> est rÃ©solu au moment de la compilation,
ainsi il n'y a pas de surcoÃ»t au moment de l'exÃ©cution pour bÃ©nÃ©ficier de
l'extrapolation de dÃ©rÃ©fÃ©rencementÂ !</p>
<!--
### How Deref Coercion Interacts with Mutability
-->
<h3><a class="header" href="#linteraction-de-lextrapolation-de-dÃ©rÃ©fÃ©rencement-avec-la-mutabilitÃ©" id="linteraction-de-lextrapolation-de-dÃ©rÃ©fÃ©rencement-avec-la-mutabilitÃ©">L'interaction de l'extrapolation de dÃ©rÃ©fÃ©rencement avec la mutabilitÃ©</a></h3>
<!--
Similar to how you use the `Deref` trait to override the `*` operator on
immutable references, you can use the `DerefMut` trait to override the `*`
operator on mutable references.
-->
<p>De la mÃªme maniÃ¨re que vous pouvez utiliser le trait <code>Deref</code> pour remplacer le
comportement de l'opÃ©rateur <code>*</code> sur les rÃ©fÃ©rences immuables, vous pouvez
utiliser le trait <code>DerefMut</code> pour remplacer le comportement de l'opÃ©rateur <code>*</code>
sur les rÃ©fÃ©rences mutables.</p>
<!--
Rust does deref coercion when it finds types and trait implementations in three
cases:
-->
<p>Rust procÃ¨de Ã  l'extrapolation de dÃ©rÃ©fÃ©rencement lorsqu'il trouve des types et
des implÃ©mentations de traits dans trois casÂ :</p>
<!--
* From `&T` to `&U` when `T: Deref<Target=U>`
* From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`
* From `&mut T` to `&U` when `T: Deref<Target=U>`
-->
<ul>
<li>Passer de <code>&amp;T</code> Ã  <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> Ã  <code>&amp;mut U</code> lorsque <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> Ã  <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<!--
The first two cases are the same except for mutability. The first case states
that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can
get a `&U` transparently. The second case states that the same deref coercion
happens for mutable references.
-->
<p>Les deux premiers cas sont exactement les mÃªmes, sauf pour la mutabilitÃ©. Le
premier cas signifie que si vous avez un <code>&amp;T</code> et que <code>T</code> implÃ©mente <code>Deref</code> pour
le type <code>U</code>, vous pouvez obtenir un <code>&amp;U</code> de maniÃ¨re transparente. Le second cas
signifie que la mÃªme extrapolation de dÃ©rÃ©fÃ©rencement se dÃ©roule pour les
rÃ©fÃ©rences mutables.</p>
<!--
The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is *not* possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldnâ€™t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules donâ€™t guarantee that. Therefore, Rust canâ€™t make the
assumption that converting an immutable reference to a mutable reference is
possible.
-->
<p>Le troisiÃ¨me cas est plus ardueÂ : Rust va aussi procÃ©der Ã  une extrapolation de
dÃ©rÃ©fÃ©rencement d'une rÃ©fÃ©rence immuable vers une rÃ©fÃ©rence mutable. A cause des
rÃ¨gles d'emprunt, si vous avez une rÃ©fÃ©rence mutable, cette rÃ©fÃ©rence mutable
doit Ãªtre la seule rÃ©fÃ©rence vers cette donnÃ©e (autrement, le programme ne peut
pas Ãªtre compilÃ©). Convertir une rÃ©fÃ©rence mutable vers une rÃ©fÃ©rence immuable
ne va jamais casser les rÃ¨gles d'emprunt. Convertir une rÃ©fÃ©rence immuable vers
une rÃ©fÃ©rence mutable nÃ©cessite que la rÃ©fÃ©rence immuable initiale soit la seule
rÃ©fÃ©rence immuable vers cette donnÃ©e, mais les rÃ¨gles d'emprunt n'empÃªchent pas
cela. Ainsi, Rust ne peut pas dÃ©duire que la conversion d'une rÃ©fÃ©rence immuable
vers une rÃ©fÃ©rence mutable soit possible.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--28" id="-attention-peinture-fraÃ®che--28">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/191">Pull Request</a>.</p>
</blockquote>
<!--
## Running Code on Cleanup with the `Drop` Trait
-->
<h2><a class="header" href="#exÃ©cuter-du-code-au-nettoyage-avec-le-trait-drop" id="exÃ©cuter-du-code-au-nettoyage-avec-le-trait-drop">ExÃ©cuter du code au nettoyage avec le trait <code>Drop</code></a></h2>
<!--
The second trait important to the smart pointer pattern is `Drop`, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the `Drop` trait on any type, and the code you
specify can be used to release resources like files or network connections.
Weâ€™re introducing `Drop` in the context of smart pointers because the
functionality of the `Drop` trait is almost always used when implementing a
smart pointer. For example, when a `Box<T>` is dropped it will deallocate the space
on the heap that the box points to.
-->
<p>Le second trait important pour les pointeurs intelligents est <code>Drop</code>, qui vous
permet de personnaliser ce qui se passe lorsqu'une valeur est en train de sortir
d'une portÃ©e. Vous pouvez fournir une implÃ©mentation du trait <code>Drop</code> sur
n'importe quel type, et le code que vous renseignez peut Ãªtre utilisÃ© pour
libÃ©rer des ressources comme des fichiers ou des connections rÃ©seau. Nous
prÃ©sentons <code>Drop</code> dans le contexte des pointeurs intelligents car la
fonctionnalitÃ© du trait <code>Drop</code> est quasiment systÃ©matiquement utilisÃ©
lorsque nous implÃ©mentons un pointeur intelligent. Par exemple, lorsqu'une
<code>Box&lt;T&gt;</code> est libÃ©rÃ©e, elle va dÃ©sallouer l'espace occupÃ© sur le tas sur lequel
la boite pointe.</p>
<!--
In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, you can specify that a
particular bit of code be run whenever a value goes out of scope, and the
compiler will insert this code automatically. As a result, you donâ€™t need to be
careful about placing cleanup code everywhere in a program that an instance of
a particular type is finished withâ€”you still wonâ€™t leak resources!
-->
<p>Dans certains langages, le dÃ©veloppeur doit appeler du code pour libÃ©rer la
mÃ©moire ou des ressources Ã  chaque fois qu'il finit d'utiliser une instance ou
un pointeur intelligent. S'il oublie de le faire, le systÃ¨me peut surcharger et
planter. Avec Rust, vous pouvez renseigner du code qui sera exÃ©cutÃ© Ã  chaque
fois qu'une valeur sort de la portÃ©e, et le compilateur va insÃ©rer
automatiquement ce code. Au final, vous n'avez pas besoin de concentrer votre
attention Ã  placer du code de nettoyage Ã  chaque fois qu'une instance d'un type
particulier n'est plus utilisÃ©e â€” vous ne risquez pas d'avoir des fuites de
ressourcesÂ !</p>
<!--
Specify the code to run when a value goes out of scope by implementing the
`Drop` trait. The `Drop` trait requires you to implement one method named
`drop` that takes a mutable reference to `self`. To see when Rust calls `drop`,
letâ€™s implement `drop` with `println!` statements for now.
-->
<p>Vous renseignez le code Ã  exÃ©cuter lorsqu'une valeur sort de la portÃ©e en
implÃ©mentant le trait <code>Drop</code>. Le trait <code>Drop</code> nÃ©cessite que vous implÃ©mentiez
une mÃ©thode <code>drop</code> qui prend en paramÃ¨tre une rÃ©fÃ©rence mutable Ã  <code>self</code>. Pour
visualiser lorsque Rust appelle <code>drop</code>, implÃ©mentons <code>drop</code> avec une instruction
<code>println!</code> Ã  l'intÃ©rieur, pour le moment.</p>
<!--
Listing 15-14 shows a `CustomSmartPointer` struct whose only custom
functionality is that it will print `Dropping CustomSmartPointer!` when the
instance goes out of scope. This example demonstrates when Rust runs the `drop`
function.
-->
<p>L'encart 15-14 montre une structure <code>PointeurPerso</code> dont la seule fonctionnalitÃ©
personnalisÃ©e est qu'elle va Ã©crire <code>Nettoyage d'un PointeurPersoÂ !</code> lorsque
l'instance sort de la portÃ©e. Cet exemple montre lorsque Rust exÃ©cute la
fonction <code>drop</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct PointeurPerso {
    donnee: String,
}

impl Drop for PointeurPerso {
    fn drop(&amp;mut self) {
        println!(&quot;Nettoyage d'un PointeurPerso avec la donnÃ©e `{}`Â !&quot;, self.donnee);
    }
}

fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    let d = PointeurPerso {
        donnee: String::from(&quot;d'autres trucs&quot;),
    };
    println!(&quot;PointeurPersos crÃ©Ã©s.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-14: A `CustomSmartPointer` struct that
implements the `Drop` trait where we would put our cleanup code</span>
-->
<p><span class="caption">Encart 15-14Â : Une structure <code>PointeurPerso</code> qui
implÃ©mente le trait <code>Drop</code> dans lequel nous plaÃ§ons notre code de nettoyage
</span></p>
<!--
The `Drop` trait is included in the prelude, so we donâ€™t need to bring it into
scope. We implement the `Drop` trait on `CustomSmartPointer` and provide an
implementation for the `drop` method that calls `println!`. The body of the
`drop` function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. Weâ€™re printing some text here to
demonstrate when Rust will call `drop`.
-->
<p>Le trait <code>Drop</code> est importÃ© dans l'Ã©tape prÃ©liminaire, donc nous n'avons pas
besoin de l'importer dans la portÃ©e. Nous implÃ©mentons le trait <code>Drop</code> sur
<code>PointeurPerso</code> et nous fournissons une implÃ©mentation de la mÃ©thode <code>drop</code> qui
appelle <code>println!</code>. Le corps de la fonction <code>drop</code> est l'endroit oÃ¹ vous placez
la logique que vous souhaitez exÃ©cuter lorsqu'une instance du type concernÃ© sort
de la portÃ©e. Ici nous affichons un petit texte pour visionner lorsque Rust
appelle <code>drop</code>.</p>
<!--
In `main`, we create two instances of `CustomSmartPointer` and then print
`CustomSmartPointers created`. At the end of `main`, our instances of
`CustomSmartPointer` will go out of scope, and Rust will call the code we put
in the `drop` method, printing our final message. Note that we didnâ€™t need to
call the `drop` method explicitly.
-->
<p>Dans le <code>main</code>, nous crÃ©ons deux instances de <code>PointeurPerso</code> et ensuite on
affiche <code>PointeurPerso crÃ©Ã©s</code>. A la fin du <code>main</code>, nos instances de
<code>PointeurPerso</code> vont sortir de la portÃ©e, et Rust va appeler le code que nous
avons placÃ© explicitement dans a mÃ©thode <code>drop</code>.</p>
<!--
When we run this program, weâ€™ll see the following output:
-->
<p>Lorsque nous exÃ©cutons ce programme, nous devrions voir la sortie suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
PointeurPersos crÃ©Ã©s.
Nettoyage d'un PointeurPerso avec la donnÃ©e `d'autres trucs`!
Nettoyage d'un PointeurPerso avec la donnÃ©e `des trucs`!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
PointeurPersos crÃ©Ã©s.
Nettoyage d'un PointeurPerso avec la donnÃ©e `d'autres trucs`!
Nettoyage d'un PointeurPerso avec la donnÃ©e `des trucs`!
</code></pre>
<!--
Rust automatically called `drop` for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so `d` was dropped before `c`. This example gives you a visual
guide to how the `drop` method works; usually you would specify the cleanup
code that your type needs to run rather than a print message.
-->
<p>Rust a appelÃ© automatiquement <code>drop</code> pour nous lorsque nos instances sont
sorties de la portÃ©e, et appelÃ© le code que nous avons renseignÃ©. Les variables
sont libÃ©rÃ©es dans l'ordre inverse Ã  leur crÃ©ation, donc <code>d</code> a Ã©tÃ© libÃ©rÃ© avant
<code>c</code>. Cet exemple vous fournit une illustration de comment la mÃ©thode <code>drop</code>
fonctionneÂ ; normalement vous devriez renseigner le code de nettoyage que votre
type a besoin d'exÃ©cuter plutÃ´t que d'afficher un message.</p>
<!--
### Dropping a Value Early with `std::mem::drop`
-->
<h3><a class="header" href="#libÃ©rer-prÃ©maturÃ©ment-une-valeur-avec-stdmemdrop" id="libÃ©rer-prÃ©maturÃ©ment-une-valeur-avec-stdmemdrop">LibÃ©rer prÃ©maturÃ©ment une valeur avec <code>std::mem::drop</code></a></h3>
<!--
Unfortunately, itâ€™s not straightforward to disable the automatic `drop`
functionality. Disabling `drop` isnâ€™t usually necessary; the whole point of the
`Drop` trait is that itâ€™s taken care of automatically. Occasionally, however,
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the `drop` method that
releases the lock so that other code in the same scope can acquire the lock.
Rust doesnâ€™t let you call the `Drop` traitâ€™s `drop` method manually; instead
you have to call the `std::mem::drop` function provided by the standard library
if you want to force a value to be dropped before the end of its scope.
-->
<p>Malheureusement, il n'est pas simple de dÃ©sactiver la fonctionnalitÃ© automatique
<code>drop</code>. La dÃ©sactivation de <code>drop</code> n'est gÃ©nÃ©ralement pas nÃ©cessaireÂ ; tout
l'intÃ©rÃªt du trait <code>Drop</code> est qu'il est pris en charge automatiquement.
Occasionnellement, cependant, vous pourriez avoir besoin de nettoyer
prÃ©maturÃ©ment une valeur. Un exemple est lorsque vous utilisez des pointeurs
intelligents qui gÃ¨rent un systÃ¨me de verrouillageÂ : vous pourriez vouloir
forcer la mÃ©thode <code>drop</code> qui libÃ¨re le verrou afin qu'un autre code dans la mÃªme
portÃ©e puisse prendre ce verrou. Rust ne vous autorise pas Ã  appeler
manuellement la mÃ©thode <code>drop</code> du trait <code>Drop</code>Â ; Ã  la place vous devez appeler
la fonction <code>std::mem::drop</code>, fournie par la bibliothÃ¨que standard, si vous
souhaitez forcer une valeur Ã  Ãªtre libÃ©rÃ©e avant la fin de sa portÃ©e.</p>
<!--
If we try to call the `Drop` traitâ€™s `drop` method manually by modifying the
`main` function from Listing 15-14, as shown in Listing 15-15, weâ€™ll get a
compiler error:
-->
<p>Si nous essayons d'appeler manuellement la mÃ©thode <code>drop</code> du trait <code>Drop</code> en
modifiant la fonction <code>main</code> de l'encart 15-14, comme dans l'encart 15-15, nous
aurons une erreur de compilationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct PointeurPerso {
#     donnee: String,
# }
# 
# impl Drop for PointeurPerso {
#     fn drop(&mut self) {
#         println!("Nettoyage d'un PointeurPerso avec la donnÃ©e `{}` !", self.donnee);
#     }
# }
# 
fn main() {
    let c = PointeurPerso {
        donnee: String::from("des trucs"),
    };
    println!("PointeurPerso crÃ©Ã©.");
    c.drop();
    println!("PointeurPerso libÃ©rÃ© avant la fin du main.");
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct PointeurPerso {
</span><span class="boring">    donnee: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for PointeurPerso {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Nettoyage d'un PointeurPerso avec la donnÃ©e `{}` !&quot;, self.donnee);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    println!(&quot;PointeurPerso crÃ©Ã©.&quot;);
    c.drop();
    println!(&quot;PointeurPerso libÃ©rÃ© avant la fin du main.&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 15-15: Attempting to call the `drop` method from
the `Drop` trait manually to clean up early</span>
-->
<p><span class="caption">Encart 15-15Â : tentative d'appel manuel Ã  la mÃ©thode
<code>drop</code> du trait <code>Drop</code> afin de nettoyer prÃ©maturÃ©ment</span></p>
<!--
When we try to compile this code, weâ€™ll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --> src/main.rs:16:7
<p>|
16 |     c.drop();
|       ^^^^ explicit destructor calls not allowed</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0040</code>.
error: could not compile <code>drop-example</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error message states that weâ€™re not allowed to explicitly call `drop`. The
error message uses the term *destructor*, which is the general programming term
for a function that cleans up an instance. A *destructor* is analogous to a
*constructor*, which creates an instance. The `drop` function in Rust is one
particular destructor.
-->
<p>Ce message d'erreur signifie que nous ne sommes pas autorisÃ©s Ã  appeler
explicitement <code>drop</code>. Le message d'erreur utilise le terme de <em>destructeur</em>
(<code>destructor</code>) qui est un terme gÃ©nÃ©ral de programmation qui dÃ©signe une
fonction qui nettoie une instance. Un <em>destructeur</em> est analogue Ã  un
<em>constructeur</em>, qui construit une instance. La fonction <code>drop</code> en Rust est un
destructeur particulier.</p>
<!--
Rust doesnâ€™t let us call `drop` explicitly because Rust would still
automatically call `drop` on the value at the end of `main`. This would be a
*double free* error because Rust would be trying to clean up the same value
twice.
-->
<p>Rust ne nous laisse pas appeler explicitement <code>drop</code> car Rust appellera toujours
automatiquement <code>drop</code> sur la valeur Ã  la fin du <code>main</code>. Cela serait une erreur
de <em>double libÃ©ration</em> car Rust va essayer de nettoyer la mÃªme valeur deux fois.</p>
<!--
We canâ€™t disable the automatic insertion of `drop` when a value goes out of
scope, and we canâ€™t call the `drop` method explicitly. So, if we need to force
a value to be cleaned up early, we can use the `std::mem::drop` function.
-->
<p>Nous ne pouvons pas dÃ©sactiver l'ajout automatique de <code>drop</code> lorsqu'une valeur
sort de la portÃ©e, et nous ne pouvons pas dÃ©sactiver explicitement la mÃ©thode
<code>drop</code>. Donc, si nous avons besoin de forcer une valeur Ã  Ãªtre nettoyÃ©e
prÃ©maturÃ©ment, nous pouvons utiliser la fonction <code>std::mem::drop</code>.</p>
<!--
The `std::mem::drop` function is different from the `drop` method in the `Drop`
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify `main` in Listing
15-15 to call the `drop` function, as shown in Listing 15-16:
-->
<p>La fonction <code>std::mem::drop</code> est diffÃ©rente de la mÃ©thode <code>drop</code> du trait
<code>Drop</code>. Nous pouvons l'appeler en lui passant en argument la valeur que nous
souhaitons libÃ©rer prÃ©maturÃ©ment. La fonction est prÃ©sente dans l'Ã©tape
prÃ©liminaire, donc nous pouvons modifier <code>main</code> de l'encart 15-15 pour appeler
la fonction <code>drop</code>, comme dans l'encart 15-16Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# struct PointeurPerso {
#     donnee: String,
# }
# 
# impl Drop for PointeurPerso {
#     fn drop(&mut self) {
#         println!("Nettoyage d'un PointeurPerso avec la donnÃ©e `{}` !", self.donnee);
#     }
# }
# 
fn main() {
    let c = PointeurPerso {
        donnee: String::from("des trucs"),
    };
    println!("PointeurPerso crÃ©Ã©.");
    drop(c);
    println!("PointeurPerso libÃ©rÃ© avant la fin du main.");
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct PointeurPerso {
</span><span class="boring">    donnee: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for PointeurPerso {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Nettoyage d'un PointeurPerso avec la donnÃ©e `{}` !&quot;, self.donnee);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    println!(&quot;PointeurPerso crÃ©Ã©.&quot;);
    drop(c);
    println!(&quot;PointeurPerso libÃ©rÃ© avant la fin du main.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-16: Calling `std::mem::drop` to explicitly
drop a value before it goes out of scope</span>
-->
<p><span class="caption">Encart 15-16Â : appel Ã  <code>std::mem::drop</code> pour libÃ©rer
explicitement une valeur avant qu'elle sorte de la portÃ©e</span></p>
<!--
Running this code will print the following:
-->
<p>L'exÃ©cution de code va afficher ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
PointeurPerso crÃ©Ã©.
Nettoyage d'un PointeurPerso avec la donnÃ©e `some data` !
PointeurPerso libÃ©rÃ© avant la fin du main.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
PointeurPerso crÃ©Ã©.
Nettoyage d'un PointeurPerso avec la donnÃ©e `some data` !
PointeurPerso libÃ©rÃ© avant la fin du main.
</code></pre>
<!--
The text ```Dropping CustomSmartPointer with data `some data`!``` is printed
between the `CustomSmartPointer created.` and `CustomSmartPointer dropped
before the end of main.` text, showing that the `drop` method code is called to
drop `c` at that point.
-->
<p>Le texte <code>Nettoyage d'un CustomSmartPointer avec la donnÃ©e `des trucs`Â !</code>
est affichÃ© entre <code>PointeurPerso crÃ©Ã©</code> et
<code>PointeurPerso libÃ©rÃ© avant la fin du main</code>, ce qui dÃ©montre que la mÃ©thode
<code>drop</code> a Ã©tÃ© appelÃ©e pour libÃ©rer <code>c</code> Ã  cet endroit.</p>
<!--
You can use code specified in a `Drop` trait implementation in many ways to
make cleanup convenient and safe: for instance, you could use it to create your
own memory allocator! With the `Drop` trait and Rustâ€™s ownership system, you
donâ€™t have to remember to clean up because Rust does it automatically.
-->
<p>Vous pouvez utiliser le code renseignÃ© dans une implÃ©mentation du trait <code>Drop</code>
de plusieurs maniÃ¨res afin de rendre le nettoyage pratique et sÃ»rÂ : par exemple,
vous pouvez l'utiliser pour crÃ©er votre propre alloueur de mÃ©moireÂ ! GrÃ¢ce au
trait <code>Drop</code> et le systÃ¨me de possession de Rust, vous n'avez pas Ã  vous
souvenir de nettoyer car Rust le fait automatiquement.</p>
<!--
You also donâ€™t have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that `drop` gets called only once when
the value is no longer being used.
-->
<p>Vous n'avez pas non plus Ã  vous soucier des problÃ¨mes rÃ©sultants du nettoyage
accidentel de valeurs toujours utilisÃ©esÂ : le systÃ¨me de possession assurant que
les rÃ©fÃ©rences sont toujours en vigueur assure Ã©galement que <code>drop</code> n'est appelÃ©
qu'une seule fois lorsque la valeur n'est plus utilisÃ©e.</p>
<!--
Now that weâ€™ve examined `Box<T>` and some of the characteristics of smart
pointers, letâ€™s look at a few other smart pointers defined in the standard
library.
-->
<p>Maintenant que nous avons examinÃ© <code>Box&lt;T&gt;</code> et certaines des caractÃ©ristiques des
pointeurs intelligents, dÃ©couvrons d'autres pointeurs intelligents dÃ©finis dans
la bibliothÃ¨que standard.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--29" id="-attention-peinture-fraÃ®che--29">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/192">Pull Request</a>.</p>
</blockquote>
<!--
## `Rc<T>`, the Reference Counted Smart Pointer
-->
<h2><a class="header" href="#rct-le-pointeur-intelligent-qui-compte-les-rÃ©fÃ©rences" id="rct-le-pointeur-intelligent-qui-compte-les-rÃ©fÃ©rences"><code>Rc&lt;T&gt;</code>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></h2>
<!--
In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldnâ€™t be cleaned up unless it doesnâ€™t have any
edges pointing to it.
-->
<p>Dans la majoritÃ© des cas, la possession est claireÂ : vous savez exactement
quelle variable possÃ¨de une valeur donnÃ©e. Cependant, il existe des cas oÃ¹ une
valeur puisse Ãªtre possÃ©dÃ©e par plusieurs propriÃ©taires. Par exemple, dans une
structure de donnÃ©es de courbes, plusieurs extrÃ©mitÃ©s peuvent pointer vers le
mÃªme noeud, et ce noeud est thÃ©oriquement possÃ©dÃ© par toutes les extrÃ©mitÃ©s qui
y pointent. Un noeud ne devrait pas Ãªtre nettoyÃ©, Ã  moins qu'il n'ait plus
d'extrÃ©mitÃ©s qui pointent sur lui.</p>
<!--
To enable multiple ownership, Rust has a type called `Rc<T>`, which is an
abbreviation for *reference counting*. The `Rc<T>` type keeps track of the
number of references to a value which determines whether or not a value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.
-->
<p>Pour permettre la possession multiple, Rust a le type <code>Rc&lt;T&gt;</code>, qui est une
abrÃ©viation pour <code>Reference Counting</code> <em>(compteur de rÃ©fÃ©rences)</em>. Le type
<code>Rc&lt;T&gt;</code> assure le suivi du nombre de rÃ©fÃ©rences vers une valeur, ce qui
dÃ©termine si la valeur est toujours utilisÃ©e ou non. S'il y a zÃ©ro rÃ©fÃ©rences
vers une valeur, la valeur peut Ãªtre nettoyÃ©e sans qu'aucune rÃ©fÃ©rence devienne
invalide.</p>
<!--
Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because itâ€™s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!
-->
<p>Imaginez que <code>Rc&lt;T&gt;</code> est comme une tÃ©lÃ©vision dans une salle commune. Lorsqu'une
personne entre pour regarder la tÃ©lÃ©vision, elle l'allume. Une autre rentre dans
la salle et regarde la tÃ©lÃ©vision. Lorsque la derniÃ¨re personne quitte la salle,
elle Ã©teint la tÃ©lÃ©vision car elle n'est plus utilisÃ©e. Si quelqu'un Ã©teint la
tÃ©lÃ©vision alors que d'autres continuent Ã  la regarder, il va y avoir du tapage
par les autres tÃ©lÃ©spectateursÂ !</p>
<!--
We use the `Rc<T>` type when we want to allocate some data on the heap for
multiple parts of our program to read and we canâ€™t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the dataâ€™s owner, and the normal ownership
rules enforced at compile time would take effect.
-->
<p>Nous utilisons le type <code>Rc&lt;T&gt;</code> lorsque nous souhaitons allouer une donnÃ©e sur le
tas pour que plusieurs Ã©lÃ©ments de notre programme puissent la lire et que nous
ne pouvons pas dÃ©terminer au moment de la compilation quel Ã©lÃ©ment va finir de
l'utiliser en dernier. Si nous savons quel Ã©lÃ©ment va finir en dernier, nous
pouvons juste faire en sorte que cet Ã©lÃ©ment prenne possession de la donnÃ©e, et
les rÃ¨gles de possession classiques qui s'appliquent au moment de la compilation
prendront effet.</p>
<!--
Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, weâ€™ll cover how to do reference counting in
multithreaded programs.
-->
<p>Notez que <code>Rc&lt;T&gt;</code> fonctionne uniquement dans des scÃ©narios Ã  un seul processus.
Lorsque nous verrons la concurrence au chapitre 16, nous verrons comment
procÃ©der au comptage de rÃ©fÃ©rences dans des programmes multi-processus.</p>
<!--
### Using `Rc<T>` to Share Data
-->
<h3><a class="header" href="#utiliser-rct-pour-partager-une-donnÃ©e" id="utiliser-rct-pour-partager-une-donnÃ©e">Utiliser <code>Rc&lt;T&gt;</code> pour partager une donnÃ©e</a></h3>
<!--
Letâ€™s return to our cons list example in Listing 15-5. Recall that we defined
it using `Box<T>`. This time, weâ€™ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:
-->
<p>Retournons Ã  notre exemple de liste de construction de l'encart 15-5.
Souvenez-vous que nous l'avons dÃ©fini en utilisant <code>Box&lt;T&gt;</code>. Cette fois-ci, nous
allons crÃ©er deux listes qui partagent tous les deux la propriÃ©tÃ© d'une
troisiÃ¨me liste. ThÃ©oriquement, cela ressemblera Ã  l'illustration 15-3Â :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Deux listes qui se partagent la propriÃ©tÃ© d'une troisiÃ¨me liste"
    src="img/trpl15-03.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of
a third list, `a`</span>
-->
<p><span class="caption">Illustration 15-3Â : deux listes, <code>b</code> et <code>c</code>, qui se
partagent la possession d'une troisiÃ¨me liste, <code>a</code></span></p>
<!--
Weâ€™ll create list `a` that contains 5 and then 10. Then weâ€™ll make two more
lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`
lists will then continue on to the first `a` list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.
-->
<p>Nous allons crÃ©er une liste <code>a</code> qui contient <code>5</code> et ensuite <code>10</code>. Ensuite, nous
allons crÃ©er deux autres listesÂ : <code>b</code> qui dÃ©marre avec <code>3</code> et <code>c</code> qui dÃ©marre
avec <code>4</code>. Les deux listes <code>b</code> et <code>c</code> vont ensuite continuer sur la premiÃ¨re
liste <code>a</code> qui contient dÃ©jÃ  <code>5</code> et <code>10</code>. Autrement dit, les deux listes vont se
partager la premiÃ¨re liste contenant <code>5</code> et <code>10</code>.</p>
<!--
Trying to implement this scenario using our definition of `List` with `Box<T>`
wonâ€™t work, as shown in Listing 15-17:
-->
<p>Si nous essayons d'implÃ©menter ce scÃ©nario en utilisant les dÃ©finitions de
<code>List</code> avec <code>Box&lt;T&gt;</code>, comme dans l'encart 15-17, cela ne va pas fonctionnerÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<!--
<span class="caption">Listing 15-17: Demonstrating weâ€™re not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>
-->
<p><span class="caption">Encart 15-17Â : dÃ©monstration que nous ne sommes pas
autorisÃ©s Ã  avoir deux listes qui utilisent <code>Box&lt;T&gt;</code> pour partager la propriÃ©tÃ©
d'une troisiÃ¨me liste</span></p>
<!--
When we compile this code, we get this error:
-->
<p>Lorsque nous compilons ce code, nous obtenons cette erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  -- > src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The `Cons` variants own the data they hold, so when we create the `b` list, `a`
is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when
creating `c`, weâ€™re not allowed to because `a` has been moved.
-->
<p>Les variantes <code>Cons</code> prennent possession des donnÃ©es qu'elles obteniennent, donc
lorsque nous avons crÃ©Ã© la liste <code>b</code>, <code>a</code> a Ã©tÃ© dÃ©placÃ©e dans <code>b</code> et <code>b</code> possÃ¨de
dÃ©sormais <code>a</code>. Ensuite, lorsque nous essayons d'utiliser <code>a</code> Ã  nouveau lorsque
nous crÃ©ons <code>c</code>, nous ne sommes pas autorisÃ©s Ã  le faire car <code>a</code> a Ã©tÃ© dÃ©placÃ©.</p>
<!--
We could change the definition of `Cons` to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldnâ€™t let us compile
`let a = Cons(10, &Nil);` for example, because the temporary `Nil` value would
be dropped before `a` could take a reference to it.
-->
<p>Nous pourrions changer la dÃ©finition de <code>Cons</code> pour stocker des rÃ©fÃ©rences Ã  la
place, mais ensuite nous aurions besoin de renseigner des paramÃ¨tres de durÃ©e de
vie. En renseignant les paramÃ¨tres de durÃ©e de vie, nous devrons dire que chaque
Ã©lÃ©ment dans la liste devrait vivre aussi longtemps que la liste entiÃ¨re. Le
vÃ©rificateur d'emprunt ne nous laisserait pas compiler <code>let a = Cons(10, &amp;Nil);</code>
par exemple, car la valeur temporaire <code>Nil</code> serait libÃ©rÃ©e avant que <code>a</code> puisse
obtenir une rÃ©fÃ©rence vers elle.</p>
<!--
Instead, weâ€™ll change our definition of `List` to use `Rc<T>` in place of
`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value
and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking
ownership of `a`, weâ€™ll clone the `Rc<List>` that `a` is holding, thereby
increasing the number of references from one to two and letting `a` and `b`
share ownership of the data in that `Rc<List>`. Weâ€™ll also clone `a` when
creating `c`, increasing the number of references from two to three. Every time
we call `Rc::clone`, the reference count to the data within the `Rc<List>` will
increase, and the data wonâ€™t be cleaned up unless there are zero references to
it.
-->
<p>A la place, nous allons changer la dÃ©finition de <code>List</code> pour utiliser <code>Rc&lt;T&gt;</code> Ã 
la place de <code>Box&lt;T&gt;</code>, comme dans l'encart 15-18. Chaque variante <code>Cons</code> va
maintenant possÃ©der une valeur et un <code>Rc&lt;T&gt;</code> pointant sur une <code>List</code>. Lorsque
nous crÃ©ons <code>b</code>, au lieu de prendre possession de <code>a</code>, nous allons cloner le
<code>Rc&lt;List&gt;</code> que <code>a</code> possÃ¨de, augmentant ainsi le nombre de rÃ©fÃ©rences de un Ã 
deux et permettant Ã  <code>a</code> et <code>b</code> de partager la propriÃ©tÃ© des donnÃ©es dans
<code>Rc&lt;List&gt;</code>. Nous allons aussi cloner <code>a</code> lorsque nous crÃ©ons <code>c</code>, augmentant le
nombre de rÃ©fÃ©rences de deux Ã  trois. Chaque fois que nous appelons <code>Rc::clone</code>,
le compteur de rÃ©fÃ©rences des donnÃ©es prÃ©sentes dans le <code>Rc&lt;List&gt;</code> va augmenter,
et les donnÃ©es ne seront pas nettoyÃ©es tant qu'il n'y aura pas zÃ©ro rÃ©fÃ©rences
vers elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FilenameÂ : src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>
-->
<p><span class="caption">Encart 15-18Â : une dÃ©finition de <code>List</code> qui utilise
<code>Rc&lt;T&gt;</code></span></p>
<!--
We need to add a `use` statement to bring `Rc<T>` into scope because itâ€™s not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.
-->
<p>Nous devons ajouter une instruction <code>use</code> pour importer <code>Rc&lt;T&gt;</code> dans la portÃ©e
car il n'est pas prÃ©sent dans l'Ã©tape prÃ©liminaire. Dans le <code>main</code>, nous crÃ©ons
la liste qui stocke <code>5</code> et <code>10</code> et la stocke dans une nouvelle <code>Rc&lt;List&gt;</code> dans
<code>a</code>. Ensuite lorsque nous crÃ©ons <code>b</code> et <code>c</code>, nous appelons la fonction
<code>Rc::clone</code> et passer une rÃ©fÃ©rence vers le <code>Rc&lt;List&gt;</code> de <code>a</code> en argument.</p>
<!--
We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rustâ€™s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesnâ€™t make a deep copy of all the data like most typesâ€™
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesnâ€™t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
`Rc::clone`.
-->
<p>Nous aurions pu appeler <code>a.clone()</code> plutÃ´t que <code>Rc::clone(&amp;a)</code>, mais la
convention en Rust est d'utiliser <code>Rc::clone</code> dans cette situation.
L'implÃ©mentation de <code>Rc::clone</code> ne fait pas une copie profonde de toutes les
donnÃ©es comme le fait la plupart des implÃ©mentations de <code>clone</code>. L'appel Ã 
<code>Rc:clone</code> augmente uniquement le compteur de rÃ©fÃ©rences, ce qui ne prend pas
beaucoup de temps. Les copies profondes des donnÃ©es peut prendre beaucoup de
temps. En utilisant <code>Rc::clone</code> pour les compteurs de rÃ©fÃ©rences, nous pouvons
distinguer visuellement un clonage qui fait une copie profonde d'un clonage qui
augmente uniquement le compteur de rÃ©fÃ©rences. Lorsque vous enquÃªtez sur des
problÃ¨mes de performances dans le code, vous pouvez ainsi Ã©carter les appels Ã 
<code>Rc::clone</code> des clonages Ã  copie profonde, que vous recherchez probablement.</p>
<!--
### Cloning an `Rc<T>` Increases the Reference Count
-->
<h3><a class="header" href="#cloner-une-rct-augmente-le-compteur-de-rÃ©fÃ©rence" id="cloner-une-rct-augmente-le-compteur-de-rÃ©fÃ©rence">Cloner une <code>Rc&lt;T&gt;</code> augmente le compteur de rÃ©fÃ©rence</a></h3>
<!--
Letâ€™s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.
-->
<p>Changeons notre exemple de l'encart 15-18 pour que nous puissions voir le
compteur de rÃ©fÃ©rences changer au fur et Ã  mesure que nous crÃ©ons et libÃ©rons
des rÃ©fÃ©rences vers le <code>Rc&lt;List&gt;</code> prÃ©sent dans <code>a</code>.</p>
<!--
In Listing 15-19, weâ€™ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope.
-->
<p>Dans l'encart 15-19, nous allons changer le <code>main</code> afin qu'il ait une portÃ©e
en son sein autour de <code>c</code>Â ; ainsi nous pourrons voir comment le compteur de
rÃ©fÃ©rences change lorsque <code>c</code> sort de la portÃ©e.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
# 
# use crate::List::{Cons, Nil};
# use std::rc::Rc;
# 
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;compteur aprÃ¨s la crÃ©ation de a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;compteur aprÃ¨s la crÃ©ation de b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;compteur aprÃ¨s la crÃ©ation de c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;compteur aprÃ¨s que c soit sortie de la portÃ©e = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-19: Printing the reference count</span>
-->
<p><span class="caption">Encart 15-19Â : affichage du compteur de rÃ©fÃ©rences</span></p>
<!--
At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; weâ€™ll see what `weak_count` is used for in the
[â€œPreventing Reference Cycles: Turning an `Rc<T>` into a
`Weak<T>`â€][preventing-ref-cycles]<!-- ignore -- > section.
-->
<p>A chaque Ã©tape du programme oÃ¹ le compteur de rÃ©fÃ©rences change, nous affichons
le compteur de rÃ©fÃ©rences, que nous pouvons obtenir en faisant appel Ã  la
fonction <code>Rc::strong_count</code>. Cette fonction s'appelle <code>strong_count</code> plutÃ´t que
<code>count</code> car le type <code>Rc&lt;T&gt;</code> a aussi un <code>weak_count</code>Â ; nous verrons Ã  quoi sert
ce <code>weak_count</code> dans
<a href="ch15-06-reference-cycles.html">la derniÃ¨re section de ce chapitre</a><!-- ignore -->.</p>
<!--
This code prints the following:
-->
<p>Ce code affiche ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
compteur aprÃ¨s la crÃ©ation de a = 1
compteur aprÃ¨s la crÃ©ation de b = 2
compteur aprÃ¨s la crÃ©ation de c = 3
compteur aprÃ¨s que c soit sortie de la portÃ©e = 2
</code></pre>
<!--
We can see that the `Rc<List>` in `a` has an initial reference count of 1; then
each time we call `clone`, the count goes up by 1. When `c` goes out of scope,
the count goes down by 1. We donâ€™t have to call a function to decrease the
reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.
-->
<p>Nous pouvons voir clairement que le <code>Rc&lt;List&gt;</code> dans <code>a</code> a un compteur de
rÃ©fÃ©rences initial Ã  <code>1</code>Â ; puis Ã  chaque fois que nous appelons <code>clone</code>, le
compteur augmente de 1. Nous n'avons pas Ã  appeler une fonction pour rÃ©duire le
compteur de rÃ©fÃ©rences, comme nous avons dÃ» le faire avec <code>Rc::clone</code> pour
augmenter compteurÂ : l'implÃ©mentation du trait <code>Drop</code> rÃ©duit le compteur de
rÃ©fÃ©rences automatiquement lorsqu'une valeur de <code>Rc&lt;T&gt;</code> sort de la portÃ©e.</p>
<!--
What we canâ€™t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.
-->
<p>Ce que nous ne voyons pas dans cet exemple est lorsque <code>b</code> et <code>a</code> sortent de la
portÃ©e Ã  la fin du <code>main</code>, le compteur vaut alors 0, et le <code>Rc&lt;List&gt;</code> est
nettoyÃ© complÃ¨tement Ã  ce moment. L'utilisation de <code>Rc&lt;T&gt;</code> permet Ã  une valeur
d'avoir plusieurs propriÃ©taires, et le compteur garantit que la valeur reste
en vigueur tant qu'au moins un propriÃ©taire existe encore.</p>
<!--
Via immutable references, `Rc<T>` allows you to share data between multiple
parts of your program for reading only. If `Rc<T>` allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, weâ€™ll discuss the interior mutability pattern and the `RefCell<T>`
type that you can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
-->
<p>GrÃ¢ce aux rÃ©fÃ©rences immuables, <code>Rc&lt;T&gt;</code> vous permet de partager des donnÃ©es
entre plusieurs Ã©lÃ©ments de votre programme pour uniquement les lire. Si <code>Rc&lt;T&gt;</code>
vous aurait aussi permis d'avoir des rÃ©fÃ©rences mutables, vous aurez alors
violÃ© une des rÃ¨gles d'emprunt vues au chapitre 4Â : les emprunts mutables
multiples Ã  une mÃªme donnÃ©e peuvent causer des accÃ¨s concurrents et des
incohÃ©rences. Cependant, pouvoir modifier des donnÃ©es reste trÃ¨s utileÂ ! Dans la
section suivante, nous allons voir le motif de mutabilitÃ© interne et le type
<code>RefCell&lt;T&gt;</code> que vous pouvez utiliser conjointement avec un <code>Rc&lt;T&gt;</code> pour pouvoir
travailler avec cette contrainte d'immuabilitÃ©.</p>
<!-- markdownlint-disable -->
<!--
[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
-->
<!-- markdownlint-restore -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--30" id="-attention-peinture-fraÃ®che--30">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/194">Pull Request</a>.</p>
</blockquote>
<!--
## `RefCell<T>` and the Interior Mutability Pattern
-->
<h2><a class="header" href="#refcellt-et-le-motif-de-mutabilitÃ©-interne" id="refcellt-et-le-motif-de-mutabilitÃ©-interne"><code>RefCell&lt;T&gt;</code> et le motif de mutabilitÃ© interne</a></h2>
<!--
*Interior mutability* is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
`unsafe` code inside a data structure to bend Rustâ€™s usual rules that govern
mutation and borrowing. We havenâ€™t yet covered unsafe code; we will in Chapter
19. We can use types that use the interior mutability pattern when we can
ensure that the borrowing rules will be followed at runtime, even though the
compiler canâ€™t guarantee that. The `unsafe` code involved is then wrapped in a
safe API, and the outer type is still immutable.
-->
<p>La <em>mutabilitÃ© interne</em> est un motif de conception en Rust qui vous permet de
muter une donnÃ©e mÃªme s'il existe des rÃ©fÃ©rences immuablesÂ ; normalement, cette
action n'est pas autorisÃ©e par les rÃ¨gles d'emprunt. Pour muter des donnÃ©es, le
motif utilise du code <code>unsafe</code> dans une structure de donnÃ©es pour contourner les
rÃ¨gles courantes de Rust qui gouvernent la mutation et l'emprunt. Nous n'avons
pas encore parlÃ© du code unsafeÂ ; nous le ferons au chapitre 19. Nous pouvons
utiliser des types qui utilisent le motif de mutabilitÃ© interne lorsque nous
pouvons Ãªtre sÃ»r que les rÃ¨gles d'emprunt seront suivies au moment de
l'exÃ©cution, mÃªme si le compilateur ne peut pas en Ãªtre sÃ»r. Le code <code>unsafe</code>
concernÃ© est ensuite incorporÃ© dans une API stable, et le type externe reste
immuable.</p>
<!--
Letâ€™s explore this concept by looking at the `RefCell<T>` type that follows the
interior mutability pattern.
-->
<p>DÃ©couvrons ce concept en examinant le type <code>RefCell&lt;T&gt;</code> qui applique le motif
de mutabilitÃ© interne.</p>
<!--
### Enforcing Borrowing Rules at Runtime with `RefCell<T>`
-->
<h3><a class="header" href="#appliquer-les-rÃ¨gles-demprunt-au-moment-de-lexÃ©cution-avec-refcellt" id="appliquer-les-rÃ¨gles-demprunt-au-moment-de-lexÃ©cution-avec-refcellt">Appliquer les rÃ¨gles d'emprunt au moment de l'exÃ©cution avec <code>RefCell&lt;T&gt;</code></a></h3>
<!--
Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the data
it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`?
Recall the borrowing rules you learned in Chapter 4:
-->
<p>Contrairement Ã  <code>Rc&lt;T&gt;</code>, le type <code>RefCell&lt;T&gt;</code> reprÃ©sente un seul propriÃ©taire
de la donnÃ©e qu'il contient. Donc, qu'est-ce qui rend <code>RefCell&lt;T&gt;</code> diffÃ©rent
d'un type comme <code>Box&lt;T&gt;</code>Â ? Souvenez-vous des rÃ¨gles d'emprunt que vous avez
appris au chapitre 4Â :</p>
<!--
* At any given time, you can have *either* (but not both of) one mutable
  reference or any number of immutable references.
* References must always be valid.
-->
<ul>
<li>A un instant donnÃ©, vous pouvez avoir <em>soit</em> (mais pas les deux) une
rÃ©fÃ©rence mutable, soit n'importe quelle quantitÃ© de rÃ©fÃ©rences immuables</li>
<li>Les rÃ©fÃ©rences doivent toujours Ãªtre en vigueur.</li>
</ul>
<!--
With references and `Box<T>`, the borrowing rulesâ€™ invariants are enforced at
compile time. With `RefCell<T>`, these invariants are enforced *at runtime*.
With references, if you break these rules, youâ€™ll get a compiler error. With
`RefCell<T>`, if you break these rules, your program will panic and exit.
-->
<p>Avec les rÃ©fÃ©rences et <code>Box&lt;T&gt;</code>, les rÃ¨gles d'emprunt obligatoires sont
appliquÃ©es au moment de la compilation. Avec <code>RefCell&lt;T&gt;</code>, ces obligations
sont appliquÃ©es <em>au moment de l'exÃ©cution</em>. Avec les rÃ©fÃ©rences, si vous ne
respectez pas ces rÃ¨gles, vous allez obtenir une erreur de compilation. Avec
<code>RefCell&lt;T&gt;</code>, si vous ne les respectez pas, votre programme va paniquer et se
fermer.</p>
<!--
The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rustâ€™s default.
-->
<p>Les avantages de vÃ©rifier les rÃ¨gles d'emprunt au moment de la compilation est
que les erreurs vont se produire plus tÃ´t dans le processus de dÃ©veloppement,
et il n'y a pas d'impact sur la performance Ã  l'exÃ©cution car toute l'analyse
a dÃ©jÃ  Ã©tÃ© faite au prÃ©alable. Pour ces raisons, la vÃ©rification des rÃ¨gles
d'emprunt au moment de compilation est le meilleur choix Ã  faire dans la
majoritÃ© des cas, ce qui explique pourquoi c'est le choix par dÃ©faut de Rust.</p>
<!--
The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.
-->
<p>L'avantage de vÃ©rifier les rÃ¨gles d'emprunt plutÃ´t Ã  l'exÃ©cution est que cela
permet certains scÃ©narios qui restent sÃ»rs pour la mÃ©moire, bien qu'interdites
Ã  cause des vÃ©rifications Ã  la compilation. L'analyse statique, comme le
compilateur Rust, est de nature prudente. Certaines propriÃ©tÃ©s du code sont
impossibles Ã  dÃ©tecter en analysant le codeÂ : l'exemple le plus connu est le
<em>problÃ¨me de l'arrÃªt</em>, qui dÃ©passe le cadre de ce livre mais qui reste un
sujet intÃ©ressant Ã  Ã©tudier.</p>
<!--
Because some analysis is impossible, if the Rust compiler canâ€™t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, itâ€™s conservative. If Rust accepted an incorrect program, users
wouldnâ€™t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The `RefCell<T>` type is useful when youâ€™re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.
-->
<p>Comme certaines analyses sont impossibles, si le compilateur Rust ne peut pas
s'assurer que le code respecte les rÃ¨gles d'emprunt, il risque de rejeter un
programme valideÂ ; dans ce sens, il est prudent. Si Rust accepte un programme
incorrecte, les utilisateurs ne pourront pas avoir confiance dans les
garanties qu'apporte Rust. Cependant, si Rust rejette un programme valide, le
dÃ©veloppeur sera importunÃ©, mais rien de catastrophique ne va se passer. Le
type <code>RefCell&lt;T&gt;</code> est utile lorsque vous Ãªtes sÃ»r que votre code suit bien
les rÃ¨gles d'emprunt mais que le compilateur est incapable de comprendre et
de garantir cela.</p>
<!--
Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. Weâ€™ll talk about how to get the functionality of `RefCell<T>` in a
multithreaded program in Chapter 16.
-->
<p>De la mÃªme maniÃ¨re que <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> sert uniquement pour des
scÃ©narios Ã  une seule tÃ¢che et va vous donner une erreur Ã  la compilation si
vous essayez de l'utiliser dans un contexte multitÃ¢ches. Nous verrons
comment bÃ©nÃ©ficier les des fonctionnalitÃ©s de <code>RefCell&lt;T&gt;</code> dans un programme
multi-processus au chapitre 16.</p>
<!--
Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:
-->
<p>Voici un rÃ©sumÃ© des raisons pour choisir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, ou <code>RefCell&lt;T&gt;</code>Â :</p>
<!--
* `Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>`
  have single owners.
* `Box<T>` allows immutable or mutable borrows checked at compile time; `Rc<T>`
  allows only immutable borrows checked at compile time; `RefCell<T>` allows
  immutable or mutable borrows checked at runtime.
* Because `RefCell<T>` allows mutable borrows checked at runtime, you can
  mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is
  immutable.
-->
<ul>
<li><code>Rc&lt;T&gt;</code> permet d'avoir plusieurs propriÃ©taires pour une mÃªme donnÃ©eÂ ;
<code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code> n'ont qu'un seul propriÃ©taire.</li>
<li><code>Box&lt;T&gt;</code> permet des emprunts immuables ou mutables Ã  la compilationÂ ;
<code>Rc&lt;T&gt;</code> permet uniquement des emprunts immuables, vÃ©rifiÃ©s Ã  la
compilationÂ ; <code>RefCell&lt;T&gt;</code> permet des emprunts immuables ou mutables,
vÃ©rifiÃ©s Ã  l'exÃ©cution.</li>
<li>Comme <code>RefCell&lt;T&gt;</code> permet des emprunts mutables, vÃ©rifiÃ©s Ã  l'exÃ©cution,
vous pouvez muter la valeur Ã  l'intÃ©rieur du <code>RefCell&lt;T&gt;</code> mÃªme si le
<code>RefCell&lt;T&gt;</code> est immuable.</li>
</ul>
<!--
Mutating the value inside an immutable value is the *interior mutability*
pattern. Letâ€™s look at a situation in which interior mutability is useful and
examine how itâ€™s possible.
-->
<p>Modifer une valeur Ã  l'intÃ©rieur d'une valeur immuable est ce qu'on appelle
le motif de <em>mutabilitÃ© interne</em>. DÃ©couvrons une situation pour laquelle la
mutabilitÃ© interne est utile est examinons comment c'est possible.</p>
<!--
### Interior Mutability: A Mutable Borrow to an Immutable Value
-->
<h3><a class="header" href="#mutabilitÃ©-interne--un-emprunt-mutable-dune-valeur-immuable" id="mutabilitÃ©-interne--un-emprunt-mutable-dune-valeur-immuable">MutabilitÃ© interneÂ : un emprunt mutable d'une valeur immuable</a></h3>
<!--
A consequence of the borrowing rules is that when you have an immutable value,
you canâ€™t borrow it mutably. For example, this code wonâ€™t compile:
-->
<p>Une des consÃ©quences des rÃ¨gles d'emprunt est que lorsque vous avez une valeur
immuable, vous ne pouvez pas emprunter sa mutabilitÃ©. Par exemple, ce code ne
va pas se compilerÂ :</p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    let y = &mut x;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<!--
If you tried to compile this code, youâ€™d get the following error:
-->
<p>Si vous essayez de compiler ce code, vous allez obtenir l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 -- > src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
valueâ€™s methods would not be able to mutate the value. Using `RefCell<T>` is
one way to get the ability to have interior mutability. But `RefCell<T>`
doesnâ€™t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, youâ€™ll get a `panic!` instead of
a compiler error.
-->
<p>Cependant, il existe des situations pour lesquelles il serait utile qu'une
valeur puisse se modifier elle-mÃªme dans ses propres mÃ©thodes mais qui semble
Ãªtre immuable pour le reste du code. Le code Ã  l'extÃ©rieur des mÃ©thodes de la
valeur n'est pas capable de modifier la valeur. L'utilisation de <code>RefCell&lt;T&gt;</code>
est une maniÃ¨re de pouvoir procÃ©der Ã  des mutations internes. Mais
<code>RefCell&lt;T&gt;</code> ne contourne pas complÃ¨tement les rÃ¨gles d'empruntÂ : le
vÃ©rificateur d'emprunt du compilateur permet cette mutabilitÃ© interne, et les
rÃ¨gles d'emprunt sont plutÃ´t vÃ©rifiÃ©es Ã  l'exÃ©cution. Si vous violez les
rÃ¨gles, vous allez provoquer un <code>panic!</code> plutÃ´t que d'avoir une erreur de
compilation.</p>
<!--
Letâ€™s work through a practical example where we can use `RefCell<T>` to mutate
an immutable value and see why that is useful.
-->
<p>Voyons un exemple pratique dans lequel nous pouvons utiliser <code>RefCell&lt;T&gt;</code> pour
modifier une valeur immuable et voir en quoi cela est utile.</p>
<!--
#### A Use Case for Interior Mutability: Mock Objects
-->
<h4><a class="header" href="#un-cas-dutilisation-de-la-mutabilitÃ©-interne--le-mock-object" id="un-cas-dutilisation-de-la-mutabilitÃ©-interne--le-mock-object">Un cas d'utilisation de la mutabilitÃ© interneÂ : le mock object</a></h4>
<!--
A *test double* is the general programming concept for a type used in place of
another type during testing. *Mock objects* are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.
-->
<p>Un <em>double de test</em> est un concept de programmation gÃ©nÃ©ral pour un type
utilisÃ© Ã  la place d'un autre type pendant des tests. Un <em>mock object</em> est un
type particulier de double de test qui enregistre ce qui se passe lors d'un
test afin que vous puissiez vÃ©rifier que les actions se sont passÃ©es
correctement.</p>
<!--
Rust doesnâ€™t have objects in the same sense as other languages have objects,
and Rust doesnâ€™t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.
-->
<p>Rust n'a pas d'objets dans le sens qu'entendent les autres langages qui ont
des objets, et Rust n'a pas de fonctionnalitÃ© de mock object construit dans
la bibliothÃ¨que standard comme l'entendent d'autres langages. Cependant, vous
pouvez trÃ¨s bien crÃ©er une structure qui va rÃ©pondre aux mÃªmes besoins qu'un
mock object.</p>
<!--
Hereâ€™s the scenario weâ€™ll test: weâ€™ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
userâ€™s quota for the number of API calls theyâ€™re allowed to make, for example.
-->
<p>Voici le scÃ©nario que nous allons testerÂ : nous allons crÃ©er une bibliothÃ¨que
qui traque une valeur par rapport Ã  une valeur maximale et envoie des messages
en fonction de la proximitÃ© de la valeur courante. Cette bibliothÃ¨que peut
Ãªtre utilisÃ©e pour suivre un quota d'un utilisateur pour le nombre d'appels
aux API qu'il est autorisÃ© Ã  faire, par exemple.</p>
<!--
Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesnâ€™t need to know
that detail. All it needs is something that implements a trait weâ€™ll provide
called `Messenger`. Listing 15-20 shows the library code:
-->
<p>Notre bibliothÃ¨que va seulement fournir la fonctionnalitÃ© de suivi en fonction
de la valeur maximale et quels seront les messages Ã  chaque moment. Les
applications qui utiliseront notre bibliothÃ¨que devront fournir un mÃ©canisme
pour envoyer les messagesÂ : l'application peut afficher le message dans
l'application, l'envoyer par email, l'envoyer par SMS, ou autre chose. La
bibliothÃ¨que n'a pas Ã  se charger de ce dÃ©tail. Tout ce que ce mÃ©canisme doit
faire est d'implÃ©menter un trait <code>Messager</code> que nous allons fournir. L'encart
15-20 propose du code pour cette bibliothÃ¨queÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messager {
    fn envoyer(&amp;self, msg: &amp;str);
}

pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
    messager: &amp;'a T,
    valeur: usize,
    max: usize,
}

impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
where
    T: Messager,
{
    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
        TraqueurDeLimite {
            messager,
            valeur: 0,
            max,
        }
    }

    pub fn set_valeur(&amp;mut self, valeur: usize) {
        self.valeur = valeur;

        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;

        if pourcentage_du_maximum &gt;= 1.0 {
            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
        } else if pourcentage_du_maximum &gt;= 0.9 {
            self.messager
                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
        } else if pourcentage_du_maximum &gt;= 0.75 {
            self.messager
                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span>
-->
<p><span class="caption">Encart 15-20Â : une bibliothÃ¨que qui suit la proximitÃ©
d'une valeur avec une valeur maximale et avertit lorsque cette valeur atteint
un certain seuil</span></p>
<!--
One important part of this code is that the `Messenger` trait has one method
called `send` that takes an immutable reference to `self` and the text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the `set_value` method
on the `LimitTracker`. We can change what we pass in for the `value` parameter,
but `set_value` doesnâ€™t return anything for us to make assertions on. We want
to be able to say that if we create a `LimitTracker` with something that
implements the `Messenger` trait and a particular value for `max`, when we pass
different numbers for `value`, the messenger is told to send the appropriate
messages.
-->
<p>La partie la plus importante de ce code est celle oÃ¹ le trait <code>Messager</code> a une
mÃ©thode qui fait appel Ã  <code>envoyer</code> en prenant une rÃ©fÃ©rence immuable Ã  <code>self</code>
ainsi que le texte du message. C'est l'interface que notre mock object doit
avoir. L'autre partie importante est lorsque nous souhaitons tester le
comportement de la mÃ©thode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code>. Nous pouvons
changer ce que nous envoyons dans le paramÃ¨tre <code>valeur</code>, mais <code>set_valeur</code> ne
nous retourne rien qui nous permet de le vÃ©rifier. Nous voulons pouvoir dire que
si nous crÃ©ons un <code>TraqueurDeLimite</code> avec quelque chose qui implÃ©mente le trait
<code>Messager</code> et une valeur prÃ©cise pour <code>max</code>, lorsque nous passons diffÃ©rents
nombres pour <code>valeur</code>, que le messager puisse confirmer l'envoi des messages
correspondants.</p>
<!--
We need a mock object that, instead of sending an email or text message when we
call `send`, will only keep track of the messages itâ€™s told to send. We can
create a new instance of the mock object, create a `LimitTracker` that uses the
mock object, call the `set_value` method on `LimitTracker`, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker wonâ€™t allow it:
-->
<p>Nous avons besoin d'un mock object qui, au lieu d'envoyer un email ou un SMS
lorsque nous faisons appel Ã  <code>envoyer</code>, va seulement enregistrer les messages
qu'on lui demande d'envoyer. Nous pouvons crÃ©er une nouvelle instance du mock
object, crÃ©er un <code>TraqueurDeLimite</code> qui utilise le mock object, faire appel Ã  la
mÃ©thode <code>set_value</code> sur le <code>TraqueurDeLimite</code>, et ensuite vÃ©rifier que le mock
object a bien les messages que nous attendions. L'encart 15-21 montre une
tentative d'implÃ©mentation d'un mock object qui fait ceci, mais le vÃ©rificateur
d'emprunt ne nous autorise pas Ã  le faireÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MessagerMock {
        messages_envoyes: Vec&lt;String&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: vec![],
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        let messager_mock = MessagerMock::new();
        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);

        traqueur.set_valeur(80);

        assert_eq!(messager_mock.messages_envoyes.len(), 1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-21: An attempt to implement a `MockMessenger`
that isnâ€™t allowed by the borrow checker</span>
-->
<p><span class="caption">Encart 15-21Â : une tentative d'implÃ©mentation d'un
<code>MessagerMock</code> qui n'est pas autorisÃ© par le vÃ©rificateur d'emprunt</span></p>
<!--
This test code defines a `MockMessenger` struct that has a `sent_messages`
field with a `Vec` of `String` values to keep track of the messages itâ€™s told
to send. We also define an associated function `new` to make it convenient to
create new `MockMessenger` values that start with an empty list of messages. We
then implement the `Messenger` trait for `MockMessenger` so we can give a
`MockMessenger` to a `LimitTracker`. In the definition of the `send` method, we
take the message passed in as a parameter and store it in the `MockMessenger`
list of `sent_messages`.
-->
<p>Ce code de test dÃ©finit une structure <code>MessagerMock</code> qui a un champ
<code>messages_envoyes</code> qui est un <code>Vec</code> de valeurs <code>String</code>, afin d'y enregistrer
les messages qui lui sont envoyÃ©s. Nous dÃ©finissons Ã©galement une fonction
associÃ©e <code>new</code> pour faciliter la crÃ©ation de valeurs <code>MessagerMock</code> qui
commencent avec une liste vide de messages. Nous implÃ©mentons ensuite le trait
<code>Messager</code> sur <code>MessagerMock</code> afin de donner un <code>MessagerMock</code> Ã  un
<code>TraqueurDeLimite</code>. Dans la dÃ©finition de la mÃ©thode <code>envoyer</code>, nous prenons
le message envoyÃ© en paramÃ¨tre et nous le stockons dans la liste
<code>messages_envoyes</code> du <code>MessagerMock</code>.</p>
<!--
In the test, weâ€™re testing what happens when the `LimitTracker` is told to set
`value` to something that is more than 75 percent of the `max` value. First, we
create a new `MockMessenger`, which will start with an empty list of messages.
Then we create a new `LimitTracker` and give it a reference to the new
`MockMessenger` and a `max` value of 100. We call the `set_value` method on the
`LimitTracker` with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the `MockMessenger` is keeping track
of should now have one message in it.
-->
<p>Dans le test, nous vÃ©rifions ce qui se passe lorsque le <code>TraqueurDeLimite</code>
doit atteindre une valeur qui est supÃ©rieure Ã  75 pourcent de la valeur <code>max</code>.
D'abord, nous crÃ©ons un nouveau <code>MessagerMock</code>, qui va dÃ©marrer avec une liste
vide de messages. Ensuite, nous crÃ©ons un nouveau <code>TraqueurDeLimite</code> et nous
lui donnons une rÃ©fÃ©rence vers ce <code>MessagerMock</code> et une valeur <code>max</code> de 100.
Nous appelons la mÃ©thode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code> avec une
valeur de 80, qui est plus grande que 75 pourcent de 100. Enfin, nous
vÃ©rifions que la liste de messages qu'a enregistrÃ© le <code>MessagerMock</code> a bien
un message Ã  l'intÃ©rieur.</p>
<!--
However, thereâ€™s one problem with this test, as shown here:
-->
<p>Cependant, il reste un problÃ¨me avec ce test, qui est montrÃ© ci-dessousÂ :</p>
<!--
```text
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference
  -- > src/lib.rs:58:13
   |
57 |         fn send(&self, message: &str) {
   |                 ----- help: consider changing this to be a mutable reference: `&mut self`
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-text">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.messages_envoyes` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
57 |         fn envoyer(&amp;self, message: &amp;str) {
   |                    ----- help: consider changing this to be a mutable reference: `&amp;mut self`
58 |             self.messages_envoyes.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
We canâ€™t modify the `MockMessenger` to keep track of the messages, because the
`send` method takes an immutable reference to `self`. We also canâ€™t take the
suggestion from the error text to use `&mut self` instead, because then the
signature of `send` wouldnâ€™t match the signature in the `Messenger` trait
definition (feel free to try and see what error message you get).
-->
<p>Nous ne pouvons pas modifier le <code>MessagerMock</code> pour enregistrer les messages,
car la mÃ©thode <code>envoyer</code> utilise une rÃ©fÃ©rence immuable Ã  <code>self</code>. Nous ne
pouvons pas non plus suivre la suggestion du texte d'erreur pour utiliser
<code>&amp;mut self</code> Ã  la place, car ensuite la signature de <code>envoyer</code> ne va pas
correspondre Ã  la signature de la dÃ©finition du trait <code>Messager</code> (essayez et
vous constaterez le message d'erreur que vous obtiendrez).</p>
<!--
This is a situation in which interior mutability can help! Weâ€™ll store the
`sent_messages` within a `RefCell<T>`, and then the `send` message will be
able to modify `sent_messages` to store the messages weâ€™ve seen. Listing 15-22
shows what that looks like:
-->
<p>C'est une situation dans laquelle la mutabilitÃ© interne peut nous aiderÂ !
Nous allons stocker <code>messages_envoyes</code> dans une <code>RefCell&lt;T&gt;</code>, et ensuite le
message de <code>envoyer</code> pourra modifier <code>messages_envoyes</code> pour stocker les
messages que nous avons avons vu. L'encart 15-22 montre Ã  quoi cela peut
ressemblerÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MessagerMock {
        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: RefCell::new(vec![]),
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        // -- partie masquÃ©e ici --
<span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span>
        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-22: Using `RefCell<T>` to mutate an inner
value while the outer value is considered immutable</span>
-->
<p><span class="caption">Encart 15-22Â : utilisation du <code>RefCell&lt;T&gt;</code> pour muter
une valeur interne que les valeurs externes considÃ¨rent comme immuable
</span></p>
<!--
The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of
`Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>`
instance around the empty vector.
-->
<p>Le champ <code>messages_envoyes</code> est maintenant du type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> au
lieu de <code>Vec&lt;String&gt;</code>. Dans la fonction <code>new</code>, nous crÃ©ons une nouvelle
instance de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> autour du vecteur vide.</p>
<!--
For the implementation of the `send` method, the first parameter is still an
immutable borrow of `self`, which matches the trait definition. We call
`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a
mutable reference to the value inside the `RefCell<Vec<String>>`, which is
the vector. Then we can call `push` on the mutable reference to the vector to
keep track of the messages sent during the test.
-->
<p>En ce qui concerne l'implÃ©mentation de la mÃ©thode <code>envoyer</code>, le premier
paramÃ¨tre est toujours un emprunt immuable de <code>self</code>, ce qui correspond Ã  la
dÃ©finition du trait. Nous appelons la mÃ©thode <code>borrow_mut</code> sur le
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> prÃ©sent dans <code>self.messages_envoyes</code> pour obtenir une
rÃ©fÃ©rence mutable vers la valeur prÃ©sente dans le <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, qui
correspond au vecteur. Ensuite, nous appelons <code>push</code> sur la rÃ©fÃ©rence mutable
vers le vecteur pour enregistrer le message envoyÃ© pendant le test.</p>
<!--
The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get an
immutable reference to the vector.
-->
<p>Le dernier changement que nous devons appliquer est dans la vÃ©rificationÂ :
pour savoir combien d'Ã©lÃ©ments sont prÃ©sents dans le vecteur, nous faisons
appel Ã  <code>borrow</code> de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> pour obtenir une rÃ©fÃ©rence
immuable vers le vecteur.</p>
<!--
Now that youâ€™ve seen how to use `RefCell<T>`, letâ€™s dig into how it works!
-->
<p>Maintenant que vous avez appris Ã  utiliser <code>RefCell&lt;T&gt;</code>, regardons comment il
fonctionneÂ !</p>
<!--
#### Keeping Track of Borrows at Runtime with `RefCell<T>`
-->
<h4><a class="header" href="#suivre-les-emprunts-Ã -lexÃ©cution-avec-refcellt" id="suivre-les-emprunts-Ã -lexÃ©cution-avec-refcellt">Suivre les emprunts Ã  l'exÃ©cution avec <code>RefCell&lt;T&gt;</code></a></h4>
<!--
When creating immutable and mutable references, we use the `&` and `&mut`
syntax, respectively. With `RefCell<T>`, we use the `borrow` and `borrow_mut`
methods, which are part of the safe API that belongs to `RefCell<T>`. The
`borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut`
returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so we
can treat them like regular references.
-->
<p>Lorsque nous crÃ©ons des rÃ©fÃ©rences immuables et mutables, nous utilisons
respectivement les syntaxes <code>&amp;</code> et <code>&amp;mut</code>. Avec <code>RefCell&lt;T&gt;</code>, nous utilisons
les mÃ©thodes <code>borrow</code> et <code>borrow_mut</code>, qui font partie de l'API stable de
<code>RefCell&lt;T&gt;</code>. La mÃ©thode <code>borrow</code> retourne un pointeur intelligent du type
<code>Ref&lt;T&gt;</code> et <code>borrow_mut</code> retourne le pointeur intelligent du type <code>RefMut&lt;T&gt;</code>.
Les deux implÃ©mentent <code>Deref</code>, donc nous pouvons les considÃ©rer comme des
rÃ©fÃ©rences classiques.</p>
<!--
The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart
pointers are currently active. Every time we call `borrow`, the `RefCell<T>`
increases its count of how many immutable borrows are active. When a `Ref<T>`
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, `RefCell<T>` lets us have many immutable
borrows or one mutable borrow at any point in time.
-->
<p>Le <code>RefCell&lt;T&gt;</code> suit combien de pointeurs intelligents <code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>
sont actuellement actifs. A chaque fois que nous faisons appel Ã  <code>borrow</code>, le
<code>RefCell&lt;T&gt;</code> augmente son compteur du nombre d'emprunts immuables qui existent.
Lorsqu'une valeur <code>Ref&lt;T&gt;</code> sort de la portÃ©e, le compteur d'emprunts immuables
est dÃ©crÃ©mentÃ© de un. <code>RefCell&lt;T&gt;</code> nous permet d'avoir autant d'emprunts
immuables ou alors un seul emprunt mutable au mÃªme moment, exactement comme les
rÃ¨gles d'emprunt Ã  la compilation.</p>
<!--
If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of `RefCell<T>` will panic at
runtime. Listing 15-23 shows a modification of the implementation of `send` in
Listing 15-22. Weâ€™re deliberately trying to create two mutable borrows active
for the same scope to illustrate that `RefCell<T>` prevents us from doing this
at runtime.
-->
<p>Si nous ne respectons pas ces rÃ¨gles, l'implÃ©mentation de <code>RefCell&lt;T&gt;</code> va
paniquer Ã  l'exÃ©cution plutÃ´t que d'avoir une erreur de compilation comme nous
l'aurions avec des rÃ©fÃ©rences classiques. L'encart 15-23 nous montre une
modification apportÃ©e Ã  l'implÃ©mentation de <code>envoyer</code> de l'encart 15-22. Nous
essayons dÃ©libÃ©rÃ©ment de crÃ©er deux emprunts mutables actifs dans la mÃªme
portÃ©e pour montrer que <code>RefCell&lt;T&gt;</code> nous empÃªche de faire ceci Ã  l'exÃ©cution.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,panics
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
#     use std::cell::RefCell;
# 
#     struct MockMessenger {
#         sent_messages: RefCell<Vec<String>>,
#     }
# 
#     impl MockMessenger {
#         fn new() -> MockMessenger {
#             MockMessenger {
#                 sent_messages: RefCell::new(vec![]),
#             }
#         }
#     }
# 
    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
# 
#     #[test]
#     fn it_sends_an_over_75_percent_warning_message() {
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);
# 
#         assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
#     }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;ErreurÂ : vous avez dÃ©passÃ© votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgentÂ : vous avez utilisÃ© 90% de votre quotaÂ !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;AvertissementÂ : vous avez utilisÃ© 75% de votre quotaÂ !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MessagerMock {
</span><span class="boring">        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MessagerMock {
</span><span class="boring">        fn new() -&gt; MessagerMock {
</span><span class="boring">            MessagerMock {
</span><span class="boring">                messages_envoyes: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            let mut premier_emprunt = self.messages_envoyes.borrow_mut();
            let mut second_emprunt = self.messages_envoyes.borrow_mut();

            premier_emprunt.push(String::from(message));
            second_emprunt.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
</span><span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that `RefCell<T>` will panic</span>
-->
<p><span class="caption">Encart 15-23Â : crÃ©ation de deux rÃ©fÃ©rences mutables dans
la mÃªme portÃ©e pour voir si <code>RefCell&lt;T&gt;</code> va paniquer</span></p>
<!--
We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned
from `borrow_mut`. Then we create another mutable borrow in the same way in the
variable `two_borrow`. This makes two mutable references in the same scope,
which isnâ€™t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:
-->
<p>Nous crÃ©ons une variable <code>premier_emprunt</code> pour le pointeur intelligent
<code>RefMut&lt;T&gt;</code> retournÃ© par <code>borrow_mut</code>. Ensuite nous crÃ©ons un autre emprunt de
la mÃªme maniÃ¨re, qui s'appelle <code>second_emprunt</code>. Cela fait deux rÃ©fÃ©rences
mutables dans la mÃªme portÃ©e, ce qui n'est pas autorisÃ©. Lorsque nous lanÃ§ons
les tests sur notre bibliothÃ¨que, le code de l'encart 15-23 va se compiler
sans erreur, mais les tests vont Ã©chouerÂ :</p>
<!--
```console
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent ... FAILED

failures:

---- tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Notice that the code panicked with the message `already borrowed:
BorrowMutError`. This is how `RefCell<T>` handles violations of the borrowing
rules at runtime.
-->
<p>Remarquez que le code a paniquÃ© avec le message
<code>already borrowed: BorrowMutError</code> (NdTÂ : <code>dÃ©jÃ  empruntÃ©</code>). C'est ainsi que
<code>RefCell&lt;T&gt;</code> gÃ¨re les violations des rÃ¨gles d'emprunt Ã  l'exÃ©cution.</p>
<!--
Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until your code was deployed to production. Also, your code would incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using `RefCell<T>` makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while youâ€™re using it in a context where only immutable
values are allowed. You can use `RefCell<T>` despite its trade-offs to get more
functionality than regular references provide.
-->
<p>La dÃ©tection des erreurs d'emprunt Ã  l'exÃ©cution plutÃ´t qu'Ã  la compilation
signifie que vous allez trouver une erreur dans votre code plus tard dans le
processus de dÃ©veloppement et peut-Ãªtre mÃªme pas avant que votre code soit
dÃ©ployÃ© en production. De plus, votre code va subir une petite perte de
performances Ã  l'exÃ©cution en raison du contrÃ´le des emprunts Ã  l'exÃ©cution
plutÃ´t qu'Ã  la compilation. Cependant, l'utilisation de <code>RefCell&lt;T&gt;</code> rend
possible l'Ã©criture d'un mock object qui peut se modifier lui-mÃªme afin
d'enregistrer les messages qu'il a vu passer alors que vous l'utilisez dans un
contexte oÃ¹ seules les valeurs immuables sont permises. Vous pouvez utiliser
<code>RefCell&lt;T&gt;</code> malgrÃ© ses inconvÃ©nients pour obtenir plus de fonctionnalitÃ©s
que celles qu'offre une rÃ©fÃ©rence classique.</p>
<!--
### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>`
-->
<h3><a class="header" href="#permettre-plusieurs-propriÃ©taires-de-donnÃ©es-mutables-en-combinant-rct-et-refcellt" id="permettre-plusieurs-propriÃ©taires-de-donnÃ©es-mutables-en-combinant-rct-et-refcellt">Permettre plusieurs propriÃ©taires de donnÃ©es mutables en combinant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code></a></h3>
<!--
A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that
`Rc<T>` lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you can
get a value that can have multiple owners *and* that you can mutate!
-->
<p>Il est courant d'utiliser <code>RefCell&lt;T&gt;</code> en tandem avec <code>Rc&lt;T&gt;</code>. Rappelez-vous
que <code>Rc&lt;T&gt;</code> vous permet d'avoir plusieurs propriÃ©taires d'une mÃªme donnÃ©e, mais
qu'il vous donne seulement un accÃ¨s immuable Ã  cette donnÃ©e. Si vous avez un
<code>Rc&lt;T&gt;</code> qui contient un <code>RefCell&lt;T&gt;</code>, vous pouvez obtenir une valeur qui peut
avoir plusieurs propriÃ©taires <em>et</em> que vous pouvez modifierÂ !</p>
<!--
For example, recall the cons list example in Listing 15-18 where we used
`Rc<T>` to allow multiple lists to share ownership of another list. Because
`Rc<T>` holds only immutable values, we canâ€™t change any of the values in the
list once weâ€™ve created them. Letâ€™s add in `RefCell<T>` to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
`RefCell<T>` in the `Cons` definition, we can modify the value stored in all
the lists:
-->
<p>Souvenez-vous de l'exemple de la liste de construction de l'encart 15-18 oÃ¹ nous
avions utilisÃ© <code>Rc&lt;T&gt;</code> pour permettre d'avoir plusieurs listes de se partager la
possession d'une autre liste. Comme <code>Rc&lt;T&gt;</code> stocke seulement des valeurs
immuables, nous ne pouvons changer aucune valeur dans la liste une fois que
nous l'avons crÃ©Ã©. Ajoutons un <code>RefCell&lt;T&gt;</code> pour pouvoir changer les valeurs
dans les listes. L'encart 15-24 nous montre ceci en ajoutant un <code>RefCell&lt;T&gt;</code>
dans la dÃ©finition de <code>Cons</code>, nous pouvons ainsi modifier les valeurs stockÃ©es
dans n'importe quelle listeÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let valeur = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valeur), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *valeur.borrow_mut() += 10;

    println!(&quot;a aprÃ¨s les opÃ©rations = {:?}&quot;, a);
    println!(&quot;b aprÃ¨s les opÃ©rations = {:?}&quot;, b);
    println!(&quot;c aprÃ¨s les opÃ©rations = {:?}&quot;, c);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-24: Using `Rc<RefCell<i32>>` to create a
`List` that we can mutate</span>
-->
<p><span class="caption">Encart 15-24Â : utilisation de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> pour
crÃ©er une <code>List</code> que nous pouvons modifier</span></p>
<!--
We create a value that is an instance of `Rc<RefCell<i32>>` and store it in a
variable named `value` so we can access it directly later. Then we create a
`List` in `a` with a `Cons` variant that holds `value`. We need to clone
`value` so both `a` and `value` have ownership of the inner `5` value rather
than transferring ownership from `value` to `a` or having `a` borrow from
`value`.
-->
<p>Nous crÃ©ons une valeur qui est une instance de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> et nous la
stockons dans une variable <code>valeur</code> afin que nous puissions y avoir accÃ¨s plus
tard. Ensuite, nous crÃ©ons une <code>List</code> dans <code>a</code> avec une variante de <code>Cons</code> qui
utilise <code>valeur</code>. Nous devons utiliser clone sur <code>valeur</code> afin que <code>a</code> et
<code>valeur</code> soient toutes les deux propriÃ©taires de la valeur interne <code>5</code> plutÃ´t
que d'avoir Ã  transfÃ©rer la possession de <code>valeur</code> Ã  <code>a</code> ou avoir <code>a</code> qui
emprunte <code>valeur</code>.</p>
<!--
We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, they
can both refer to `a`, which is what we did in Listing 15-18.
-->
<p>Nous insÃ©rons la liste <code>a</code> dans un <code>Rc&lt;T&gt;</code> pour que lorsque nous crÃ©ons <code>b</code> et
<code>c</code>, elles puissent toutes les deux utiliser <code>a</code>, ce que nous avions dÃ©jÃ  fait
dans l'encart 15-18.</p>
<!--
After weâ€™ve created the lists in `a`, `b`, and `c`, we add 10 to the value in
`value`. We do this by calling `borrow_mut` on `value`, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
[â€œWhereâ€™s the `->` Operator?â€][wheres-the---operator]<!-- ignore -- >) to
dereference the `Rc<T>` to the inner `RefCell<T>` value. The `borrow_mut`
method returns a `RefMut<T>` smart pointer, and we use the dereference operator
on it and change the inner value.
-->
<p>AprÃ¨s avoir crÃ©Ã© les listes dans <code>a</code>, <code>b</code>, et <code>c</code>, nous ajoutons 10 Ã  la valeur
dans <code>valeur</code>. Nous faisons cela en appelant <code>borrow_mut</code> sur <code>valeur</code>, ce qui
utilise la fonctionnalitÃ© de dÃ©rÃ©fÃ©rencement automatique que nous avons vu au
chapitre 5 (voir la section
<a href="ch05-03-method-syntax.html#o%C3%B9-est-lop%C3%A9rateur---">â€œOÃ¹ est l'opÃ©rateur -&gt; ?â€</a><!-- ignore -->) pour
dÃ©rÃ©fÃ©rencer le <code>Rc&lt;T&gt;</code> dans la valeur interne <code>RefCell&lt;T&gt;</code>. La mÃ©thode
<code>borrow_mut</code> retourne un pointeur intelligent <code>RefMut&lt;T&gt;</code>, et nous utilisons
l'opÃ©rateur de dÃ©rÃ©fÃ©rencement sur lui pour changer sa valeur interne.</p>
<!--
When we print `a`, `b`, and `c`, we can see that they all have the modified
value of 15 rather than 5:
-->
<p>Lorsque nous affichons <code>a</code>, <code>b</code> et <code>c</code>, nous pouvons constater qu'elles ont
toutes la valeur modifiÃ©e de 15 au lieu de 5Â :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a aprÃ¨s les opÃ©rations = Cons(RefCell { value: 15 }, Nil)
b aprÃ¨s les opÃ©rations = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c aprÃ¨s les opÃ©rations = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<!--
This technique is pretty neat! By using `RefCell<T>`, we have an outwardly
immutable `List` value. But we can use the methods on `RefCell<T>` that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and itâ€™s
sometimes worth trading a bit of speed for this flexibility in our data
structures.
-->
<p>Cette technique est plutÃ´t ingÃ©nieuseÂ ! En utilisant <code>RefCell&lt;T&gt;</code>, nous avons
une valeur <code>List</code> qui est immuable de l'extÃ©rieur. Mais nous pouvons utiliser
les mÃ©thodes de <code>RefCell&lt;T&gt;</code> qui nous donne accÃ¨s Ã  sa mutabilitÃ© interne afin
que nous puissions modifier notre donnÃ©e lorsque nous en avons besoin. Les
vÃ©rifications des rÃ¨gles d'emprunt Ã  l'exÃ©cution nous protÃ¨gent des accÃ¨s
concurrents, et il est parfois intÃ©ressant de sacrifier un peu de vitesse pour
cette flexibilitÃ© dans nos structures de donnÃ©es.</p>
<!--
The standard library has other types that provide interior mutability, such as
`Cell<T>`, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the `Cell<T>`. Thereâ€™s also
`Mutex<T>`, which offers interior mutability thatâ€™s safe to use across threads;
weâ€™ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.
-->
<p>La bibliothÃ¨que standard a d'autres types qui fournissent de la mutabilitÃ©
interne, comme <code>Cell&lt;T&gt;</code>, qui est similaire sauf qu'au lieu de fournir des
rÃ©fÃ©rences Ã  la valeur interne, la valeur est copiÃ©e Ã  l'intÃ©rieur et Ã 
l'extÃ©rieur du <code>Cell&lt;T&gt;</code>. Il existe aussi <code>Mutex&lt;T&gt;</code> qui offre de la mutabilitÃ©
interne qui est sÃ©curisÃ©e pour une utilisation partagÃ©e entre plusieures
tÃ¢chesÂ ; nous allons voir son utilisation au chapitre 16. Plongez-vous dans la
documentation de la bibliothÃ¨que standard pour plus de dÃ©tails entre ces
diffÃ©rents types.</p>
<!--
[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--31" id="-attention-peinture-fraÃ®che--31">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/195">Pull Request</a>.</p>
</blockquote>
<!--
## Reference Cycles Can Leak Memory
-->
<h2><a class="header" href="#les-boucles-de-rÃ©fÃ©rences-qui-peuvent-provoquer-des-fuites-de-mÃ©moire" id="les-boucles-de-rÃ©fÃ©rences-qui-peuvent-provoquer-des-fuites-de-mÃ©moire">Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></h2>
<!--
Rustâ€™s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a *memory leak*).
Preventing memory leaks entirely is not one of Rustâ€™s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using `Rc<T>`
and `RefCell<T>`: itâ€™s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.
-->
<p>Les garanties de sÃ©curitÃ© de la mÃ©moire de Rust rendent difficile, mais pas
impossible, la crÃ©ation accidentelle de mÃ©moire qui n'est jamais nettoyÃ©e
(aussi appelÃ©e <em>fuite de mÃ©moire</em>). Eviter absolument les fuites de mÃ©moire
n'est pas une des garanties de Rust comme c'est le cas pour l'accÃ¨s
concurrent Ã  la compilation, ce qui signifie que les fuites de mÃ©moire ne
sont dangereuses, pour Rust. Nous pouvons constater que Rust permet les fuites
de mÃ©moire en utilisant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code>Â : il est possible de crÃ©er des
rÃ©fÃ©rences oÃ¹ les Ã©lÃ©ments se rÃ©fÃ¨rent entre eux de maniÃ¨re cyclique. Cela
crÃ©e des fuites de mÃ©moire car le compteur de rÃ©fÃ©rences de chaque Ã©lÃ©ment
dans la boucle de rÃ©fÃ©rences ne vaudra jamais 0, et les valeurs ne seront
jamais libÃ©rÃ©es.</p>
<!--
### Creating a Reference Cycle
-->
<h3><a class="header" href="#crÃ©er-une-boucle-de-rÃ©fÃ©rences" id="crÃ©er-une-boucle-de-rÃ©fÃ©rences">CrÃ©er une boucle de rÃ©fÃ©rences</a></h3>
<!--
Letâ€™s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the `List` enum and a `tail` method in Listing
15-25:
-->
<p>Voyons comment une boucle de rÃ©fÃ©rences peut exister et comment l'Ã©viter, en
commenÃ§ant par la dÃ©finition de l'Ã©numÃ©ration <code>List</code> et la mÃ©thode <code>parcourir</code>
de l'encart 15-25Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 15-25: A cons list definition that holds a
`RefCell<T>` so we can modify what a `Cons` variant is referring to</span>
-->
<p><span class="caption">Encart 15-25Â : une liste de construction qui stocke une
<code>RefCell&lt;T&gt;</code> pour que nous puissions modifier ce sur quoi une variante <code>Cons</code>
pointe</span></p>
<!--
Weâ€™re using another variation of the `List` definition from Listing 15-5. The
second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that
instead of having the ability to modify the `i32` value as we did in Listing
15-24, we want to modify which `List` value a `Cons` variant is pointing to.
Weâ€™re also adding a `tail` method to make it convenient for us to access the
second item if we have a `Cons` variant.
-->
<p>Nous utilisons une autre variation de la dÃ©finition de <code>List</code> de l'encart 15-5.
Le second Ã©lÃ©ment dans la variante <code>Cons</code> est maintenant un
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, ce qui signifie qu'au lieu de pouvoir modifier la valeur
<code>i32</code> comme nous l'avions fait dans l'encart 15-24, nous modifions ce sur quoi
une variante <code>Cons</code> pointe (qui reste une valeur <code>List</code>). Nous ajoutons
Ã©galement une mÃ©thode <code>parcourir</code> pour nous faciliter l'accÃ¨s au second Ã©lÃ©ment
si nous avons une variante <code>Cons</code>.</p>
<!--
In Listing 15-26, weâ€™re adding a `main` function that uses the definitions in
Listing 15-25. This code creates a list in `a` and a list in `b` that points to
the list in `a`. Then it modifies the list in `a` to point to `b`, creating a
reference cycle. There are `println!` statements along the way to show what the
reference counts are at various points in this process.
-->
<p>Dans l'encart 15-26, nous ajoutons une fonction <code>main</code> qui utilise les
dÃ©finitions de l'encart 15-25. Ce code crÃ©e une liste dans <code>a</code> et une liste
dans <code>b</code> qui pointe sur la liste de <code>a</code>. Ensuite, on modifie la liste de <code>a</code>
pour pointer sur <code>b</code>, ce qui crÃ©e une boucle de rÃ©fÃ©rences. Il y a aussi des
instructions <code>println!</code> tout du long pour montrer la valeur des compteurs de
rÃ©fÃ©rences Ã  diffÃ©rents endroits du processus.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use crate::List::{Cons, Nil};
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell<Rc<List>>),
#     Nil,
# }
# 
# impl List {
#     fn tail(&self) -> Option<&RefCell<Rc<List>>> {
#         match self {
#             Cons(_, item) => Some(item),
#             Nil => None,
#         }
#     }
# }
# 
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;compteur initial de a = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;prochain Ã©lÃ©ment de a = {:?}&quot;, a.parcourir());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;compteur de a aprÃ¨s crÃ©ation de b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;compteur initial de b = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;prochain Ã©lÃ©ment de b = {:?}&quot;, b.parcourir());

    if let Some(lien) = a.parcourir() {
        *lien.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;compteur de b aprÃ¨s avoir changÃ© a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;compteur de a aprÃ¨s avoir changÃ© a = {}&quot;, Rc::strong_count(&amp;a));

    // DÃ©commentez la ligne suivante pour constater que nous sommes dans
    // une boucle de rÃ©fÃ©rences, cela fera dÃ©border la pile
    // println!(&quot;prochain Ã©lÃ©ment de a = {:?}&quot;, a.parcourir());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-26: Creating a reference cycle of two `List`
values pointing to each other</span>
-->
<p><span class="caption">Encart 15-26Â : crÃ©ation d'une boucle de rÃ©fÃ©rences de
deux valeurs <code>List</code> qui se pointent mutuellement dessus</span></p>
<!--
We create an `Rc<List>` instance holding a `List` value in the variable `a`
with an initial list of `5, Nil`. We then create an `Rc<List>` instance
holding another `List` value in the variable `b` that contains the value 10 and
points to the list in `a`.
-->
<p>Nous crÃ©ons une instance <code>Rc&lt;List&gt;</code> qui stocke une valeur <code>List</code> dans la
variable <code>a</code> avec une valeur initiale de <code>5, Nil</code>. Nous crÃ©ons ensuite une
instance <code>Rc&lt;List&gt;</code> qui stocke une autre valeur <code>List</code> dans la variable <code>b</code>
qui contient la valeur 10 et pointe vers la liste dans <code>a</code>.</p>
<!--
We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We
do that by using the `tail` method to get a reference to the
`RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use
the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside
from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`.
-->
<p>Nous modifions <code>a</code> afin qu'elle pointe sur <code>b</code> au lieu de <code>Nil</code>, ce qui crÃ©e
une boucle. Nous faisons ceci en utilisant la mÃ©thode <code>parcourir</code> pour obtenir
une rÃ©fÃ©rence au <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> prÃ©sent dans <code>a</code>, que nous plaÃ§ons dans la
variable <code>link</code>. Ensuite nous utilisons la mÃ©thode <code>borrow_mut</code> sur le
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> pour changer la valeur prÃ©sente en son sein par une
<code>Rc&lt;List&gt;</code> qui stocke une valeur <code>Nil</code> vers le <code>Rc&lt;List&gt;</code> prÃ©sent dans <code>b</code>.</p>
<!--
When we run this code, keeping the last `println!` commented out for the
moment, weâ€™ll get this output:
-->
<p>Lorsque nous exÃ©cutons ce code, en gardant le dernier <code>println!</code> commentÃ©
pour le moment, nous obtenons ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
compteur initial de a = 1
prochain Ã©lÃ©ment de a = Some(RefCell { value: Nil })
compteur de a aprÃ¨s crÃ©ation de b = 2
compteur initial de b = 1
prochain Ã©lÃ©ment de b = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
compteur de b aprÃ¨s avoir changÃ© a = 2
compteur de a aprÃ¨s avoir changÃ© a = 2
</code></pre>
<!--
The reference count of the `Rc<List>` instances in both `a` and `b` are 2
after we change the list in `a` to point to `b`. At the end of `main`, Rust
will try to drop `b` first, which will decrease the count of the `Rc<List>`
instance in `b` by 1.
-->
<p>Les compteurs de rÃ©fÃ©rences des instances de <code>Rc&lt;List&gt;</code> valent tous les deux 2
pour <code>a</code> et <code>b</code> aprÃ¨s avoir modifiÃ© <code>a</code> pour qu'elle pointe sur <code>b</code>. A la fin
du <code>main</code>, Rust va nettoyer d'abord <code>b</code>, ce qui va rÃ©duire le compteur de
l'instance <code>Rc&lt;List&gt;</code> de <code>b</code> de 1.</p>
<!--
However, because `a` is still referencing the `Rc<List>` that was in `b`, that
`Rc<List>` has a count of 1 rather than 0, so the memory the `Rc<List>` has on
the heap wonâ€™t be dropped. The memory will just sit there with a count of 1,
forever. To visualize this reference cycle, weâ€™ve created a diagram in Figure
15-4.
-->
<p>Cependant, comme <code>a</code> pointe toujours sur le <code>Rc&lt;List&gt;</code> qui Ã©tait sur <code>b</code>, le
compteur de son <code>Rc&lt;List&gt;</code> vaudra toujours 1 au lieu de 0, donc la mÃ©moire de
sur le tas de ce <code>Rc&lt;List&gt;</code> ne sera pas nettoyÃ©. La mÃ©moire va juste rester ici
avec un compteur Ã  1, pour toujours. Pour reprÃ©senter la boucle de rÃ©fÃ©rences,
nous avons crÃ©Ã© un diagramme dans l'illustration 15-4.</p>
<!--
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
-->
<p><img
    alt="Une boucle de rÃ©fÃ©rences de listes"
    src="img/trpl15-04.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-4: A reference cycle of lists `a` and `b`
pointing to each other</span>
-->
<p><span class="caption">Illustration 15-4Â : une boucle de rÃ©fÃ©rences entre les
listes <code>a</code> et <code>b</code> qui se pointent mutuellement dessus</span></p>
<!--
If you uncomment the last `println!` and run the program, Rust will try to
print this cycle with `a` pointing to `b` pointing to `a` and so forth until it
overflows the stack.
-->
<p>Si vous dÃ©commentez le dernier <code>println!</code> et que vous exÃ©cutez le programme,
Rust va essayer d'afficher cette boucle avec <code>a</code> qui pointe sur <code>b</code> qui pointe
sur <code>a</code> ... et ainsi de suite jusqu'Ã  ce que cela fasse dÃ©border la pile.</p>
<!--
In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle arenâ€™t very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.
-->
<p>Dans ce cas, juste aprÃ¨s que nous ayons crÃ©Ã© la boucle de rÃ©fÃ©rences, le
programme se termine. Les consÃ©quences de cette boucle ne sont dÃ©sastreuses.
Cependant, si un programme plus complexe alloue beaucoup de mÃ©moire dans une
boucle de rÃ©fÃ©rences et la garde pendant longtemps, le programme va utiliser
bien plus de mÃ©moire qu'il a besoin et pourrait surcharger le systÃ¨me, qui
devrait Ã©puiser la mÃ©moire disponible.</p>
<!--
Creating reference cycles is not easily done, but itâ€™s not impossible either.
If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you donâ€™t create cycles; you canâ€™t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.
-->
<p>La crÃ©ation de boucles de rÃ©fÃ©rences n'est pas facile Ã  rÃ©aliser, mais n'est pas
non plus impossible. Si vous avez des valeurs <code>RefCell&lt;T&gt;</code> qui contiennent des
valeurs <code>Rc&lt;T&gt;</code> ou combinaisons similaires de types emboÃ®tÃ©es avec de la
mutabilitÃ© interne et du comptage de rÃ©fÃ©rences, vous devez vous assurer que
vous ne crÃ©ez pas de bouclesÂ ; vous ne pouvez pas compter sur Rust pour les
dÃ©tecter. La crÃ©ation de boucle de rÃ©fÃ©rences devrait Ãªtre un bogue de logique
de votre programme dont vous devriez rÃ©duire le risque en pratiquant des tests
automatisÃ©s, des revues de code, ainsi que d'autres pratiques de dÃ©veloppement.</p>
<!--
Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references donâ€™t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want `Cons`
variants to own their list, so reorganizing the data structure isnâ€™t possible.
Letâ€™s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.
-->
<p>Une autre solution pour Ã©viter les boucles de rÃ©fÃ©rences est de rÃ©organiser vos
structures de donnÃ©es afin que certaines rÃ©fÃ©rences prennent possession et
d'autres non. Par consÃ©quent, vous pouvez obtenir des boucles de certaines
rÃ©fÃ©rences qui prennent possession ou d'autres rÃ©fÃ©rences qui ne prennent pas
possession, et seules celles qui prennent possession dÃ©cident si oui ou non une
valeur peut Ãªtre libÃ©rÃ©e. Dans l'encart 15-25, nous voulons toujours que les
variantes <code>Cons</code> possÃ¨dent leur propre liste, donc il est impossible de
rÃ©organiser la structure des donnÃ©es. Voyons maintenant un exemple qui utilise
des branches constituÃ©es de nÅ“uds parents et enfants pour voir lorsque les
liens qui ne prennent pas possession sont appropriÃ©s pour Ã©viter les boucles de
rÃ©fÃ©rences.</p>
<!--
### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`
-->
<h3><a class="header" href="#eviter-les-boucles-de-rÃ©fÃ©rences--transformer-un-rct-en-weakt" id="eviter-les-boucles-de-rÃ©fÃ©rences--transformer-un-rct-en-weakt">Eviter les boucles de rÃ©fÃ©rencesÂ : transformer un <code>Rc&lt;T&gt;</code> en <code>Weak&lt;T&gt;</code></a></h3>
<!--
So far, weâ€™ve demonstrated that calling `Rc::clone` increases the
`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned
up if its `strong_count` is 0. You can also create a *weak reference* to the
value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a
reference to the `Rc<T>`. When you call `Rc::downgrade`, you get a smart
pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the
`Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1.
The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>`
references exist, similar to `strong_count`. The difference is the `weak_count`
doesnâ€™t need to be 0 for the `Rc<T>` instance to be cleaned up.
-->
<p>PrÃ©cÃ©demment, nous avons dÃ©montrÃ© que l'appel Ã  <code>Rc::clone</code> augmente le
<code>strong_count</code> d'une instance de <code>Rc&lt;T&gt;</code>, et une instance <code>Rc&lt;T&gt;</code> est nettoyÃ©e
seulement si son <code>strong_count</code> est Ã  0. Vous pouvez aussi crÃ©er un <em>pointeur
faible</em> (NdTÂ : d'oÃ¹ le <code>weak</code>) vers la valeur prÃ©sente dans une instance <code>Rc&lt;T&gt;</code>
en appelant <code>Rc::downgrade</code> et en lui passant une rÃ©fÃ©rence vers le <code>Rc&lt;T&gt;</code>.
Lorsque vous faites appel Ã  <code>Rc::downgrade</code>, vous obtenez un pointeur
intelligent du type <code>Weak&lt;T&gt;</code>. PlutÃ´t que d'augmenter le <code>strong_count</code> de
l'instance de 1, l'appel Ã  <code>Rc::downgrade</code> augmente le <code>weak_count</code> de 1. Le
type <code>Rc&lt;T&gt;</code> utilise le <code>weak_count</code> pour compter combien de rÃ©fÃ©rences
<code>Weak&lt;T&gt;</code> existent, de la mÃªme maniÃ¨re que <code>strong_count</code>. La diffÃ©rence rÃ©side
dans le fait que <code>weak_count</code> n'a pas besoin d'Ãªtre 0 pour que l'instance
<code>Rc&lt;T&gt;</code> soit nettoyÃ©e.</p>
<!--
Strong references are how you can share ownership of an `Rc<T>` instance. Weak
references donâ€™t express an ownership relationship. They wonâ€™t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.
-->
<p>Les rÃ©fÃ©rences fortes dÃ©signent la maniÃ¨re de partager la propriÃ©tÃ© d'une
instance <code>Rc&lt;T&gt;</code>. Les pointeurs faibles ne dÃ©signent pas le lien qui prend
possession. Ils ne vont provoquer de boucle de rÃ©fÃ©rences car n'importe quelle
boucle qui implique des pointeurs faibles se terminera lorsque le compteur de
rÃ©fÃ©rences fortes liÃ© vaudra 0.</p>
<!--
Because the value that `Weak<T>` references might have been dropped, to do
anything with the value that a `Weak<T>` is pointing to, you must make sure the
value still exists. Do this by calling the `upgrade` method on a `Weak<T>`
instance, which will return an `Option<Rc<T>>`. Youâ€™ll get a result of `Some`
if the `Rc<T>` value has not been dropped yet and a result of `None` if the
`Rc<T>` value has been dropped. Because `upgrade` returns an `Option<Rc<T>>`,
Rust will ensure that the `Some` case and the `None` case are handled, and
there wonâ€™t be an invalid pointer.
-->
<p>Comme la valeur contenue dans une rÃ©fÃ©rence <code>Weak&lt;T&gt;</code> peut Ãªtre libÃ©rÃ©e, pour
pouvoir faire quelque chose avec cette valeur, vous devez vous assurer qu'elle
existe toujours. Vous pouvez faire ceci en appelant la mÃ©thode <code>upgrade</code> sur
une instance <code>Weak&lt;T&gt;</code>, qui va retourner une <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Ce rÃ©sultat
retournera <code>Some</code> si la valeur <code>Rc&lt;T&gt;</code> n'a pas encore Ã©tÃ© libÃ©rÃ©e, et un <code>None</code>
si la valeur <code>Rc&lt;T&gt;</code> a Ã©tÃ© libÃ©rÃ©e. Comme <code>upgrade</code> retourne une
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust va s'assurer que les cas de <code>Some</code> et de <code>None</code> sont bien
gÃ©rÃ©s, et qu'il n'existe pas de pointeur invalide.</p>
<!--
As an example, rather than using a list whose items know only about the next
item, weâ€™ll create a tree whose items know about their children items *and*
their parent items.
-->
<p>Par exemple, plutÃ´t que d'utiliser une liste dont les Ã©lÃ©ments ne connaissent
que les Ã©lÃ©ments suivants, nous allons crÃ©er un arbre dont les Ã©lÃ©ments
connaissent les Ã©lÃ©ments enfants <em>et</em> leurs Ã©lÃ©ments parents.</p>
<!--
#### Creating a Tree Data Structure: a `Node` with Child Nodes
-->
<h4><a class="header" href="#crÃ©er-une-structure-darbre-de-donnÃ©es--un-noeud-avec-des-nÅ“uds-enfants" id="crÃ©er-une-structure-darbre-de-donnÃ©es--un-noeud-avec-des-nÅ“uds-enfants">CrÃ©er une structure d'arbre de donnÃ©esÂ : un <code>Noeud</code> avec des nÅ“uds enfants</a></h4>
<!--
To start, weâ€™ll build a tree with nodes that know about their child nodes.
Weâ€™ll create a struct named `Node` that holds its own `i32` value as well as
references to its children `Node` values:
-->
<p>Pour commencer, nous allons crÃ©er un arbre avec des nÅ“uds qui connaissent
leurs nÅ“uds enfants. Nous allons crÃ©er une structure <code>Noeud</code> qui contient sa
propre valeur ainsi que les rÃ©fÃ©rences vers ses <code>Noeud</code> enfantsÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         children: RefCell::new(vec![]),
#     });
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<!--
We want a `Node` to own its children, and we want to share that ownership with
variables so we can access each `Node` in the tree directly. To do this, we
define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to
modify which nodes are children of another node, so we have a `RefCell<T>` in
`children` around the `Vec<Rc<Node>>`.
-->
<p>Nous souhaitons qu'un <code>Noeud</code> prenne possession de ses enfants, et nous
souhaitons partager la possession avec des variables afin d'accÃ©der directement
Ã  chaque <code>Noeud</code> de l'arbre. Pour pouvoir faire ceci, nous dÃ©finissons les
Ã©lÃ©ments du <code>Vec&lt;T&gt;</code> pour Ãªtre des valeurs du type <code>Rc&lt;Noeud&gt;</code>. Nous souhaitons
Ã©galement modifier tel nÅ“ud est enfant de tel autre nÅ“ud, donc nous plaÃ§ons
un <code>RefCell&lt;T&gt;</code> dans <code>enfants</code> qui contient ce <code>Vec&lt;Rc&lt;Noeud&gt;&gt;</code>.</p>
<!--
Next, weâ€™ll use our struct definition and create one `Node` instance named
`leaf` with the value 3 and no children, and another instance named `branch`
with the value 5 and `leaf` as one of its children, as shown in Listing 15-27:
-->
<p>Ensuite, nous allons utiliser notre dÃ©finition de structure et crÃ©er une
instance de <code>Noeud</code> qui s'appellera <code>feuille</code> avec la valeur <code>3</code> et sans
enfant, comme dans l'encart 15-27Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FilenameÂ : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        enfants: RefCell::new(vec![]),
    });

    let branche = Rc::new(Noeud {
        valeur: 5,
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-27: Creating a `leaf` node with no children
and a `branch` node with `leaf` as one of its children</span>
-->
<p><span class="caption">Encart 15-27Â : crÃ©ation d'un nÅ“ud <code>feuille</code> sans aucun
enfant et un nÅ“ud <code>branche</code> avec <code>feuille</code> comme enfant</span></p>
<!--
We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the
`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from
`branch` to `leaf` through `branch.children`, but thereâ€™s no way to get from
`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and
doesnâ€™t know theyâ€™re related. We want `leaf` to know that `branch` is its
parent. Weâ€™ll do that next.
-->
<p>Nous crÃ©ons un clone du <code>Rc&lt;Noeud&gt;</code> dans <code>feuille</code> et nous le stockons dans
<code>branche</code>, ce qui signifie que le <code>Noeud</code> dans <code>feuille</code> a maintenant deux
propriÃ©tairesÂ : <code>feuille</code> et <code>branche</code>. Nous pouvons obtenir <code>feuille</code> Ã  partir
de <code>branche</code> en utilisant <code>branche.feuille</code>, mais il n'y a pas de moyen
d'obtenir <code>branche</code> Ã  partir de <code>feuille</code>. La raison est que <code>feuille</code> n'a pas
de rÃ©fÃ©rence vers <code>branche</code> et ne sait pas s'ils sont liÃ©s. Nous voulons que
<code>feuille</code> sache quelle <code>branche</code> est son parent. C'est ce que nous allons faire
dÃ¨s maintenant.</p>
<!--
#### Adding a Reference from a Child to Its Parent
-->
<h4><a class="header" href="#ajouter-une-rÃ©fÃ©rence-Ã -un-enfant-vers-son-parent" id="ajouter-une-rÃ©fÃ©rence-Ã -un-enfant-vers-son-parent">Ajouter une rÃ©fÃ©rence Ã  un enfant vers son parent</a></h4>
<!--
To make the child node aware of its parent, we need to add a `parent` field to
our `Node` struct definition. The trouble is in deciding what the type of
`parent` should be. We know it canâ€™t contain an `Rc<T>`, because that would
create a reference cycle with `leaf.parent` pointing to `branch` and
`branch.children` pointing to `leaf`, which would cause their `strong_count`
values to never be 0.
-->
<p>Pour que le nÅ“ud enfant connaisse son parent, nous devons ajouter un champ
<code>parent</code> vers notre dÃ©finition de structure <code>Noeud</code>. La difficultÃ© ici est de
choisir quel sera le type de <code>parent</code>. Nous savons qu'il ne peut pas contenir
de <code>Rc&lt;T&gt;</code>, car cela crÃ©era une boucle de rÃ©fÃ©rence avec <code>feuille.parent</code> qui
pointe sur <code>branche</code> et <code>branche.enfant</code> qui pointe sur <code>feuille</code>, ce qui va
faire que leurs valeurs <code>strong_count</code> ne sera jamais Ã  0.</p>
<!--
Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!
-->
<p>En concevant le lien d'une autre maniÃ¨re, un nÅ“ud parent devrait prendre
possession de ses enfantsÂ : si un nÅ“ud parent est libÃ©rÃ©, ses nÅ“uds enfants
devraient aussi Ãªtre libÃ©rÃ©s. Cependant, un enfant ne devrait pas prendre
possession de son parentÂ : si nous libÃ©rons un nÅ“ud enfant, le parent doit
toujours exister. C'est donc un cas d'emploi pour les pointeurs faiblesÂ !</p>
<!--
So instead of `Rc<T>`, weâ€™ll make the type of `parent` use `Weak<T>`,
specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks
like this:
-->
<p>Donc, plutÃ´t qu'un <code>Rc&lt;T&gt;</code>, nous allons faire en sorte que le type de <code>parent</code>
soit un <code>Weak&lt;T&gt;</code>, plus prÃ©cisÃ©ment un <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code>. Maintenant,
la dÃ©finition de notre structure <code>Noeud</code> devrait ressembler Ã  ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![]),
#     });
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# 
#     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<!--
A node will be able to refer to its parent node but doesnâ€™t own its parent.
In Listing 15-28, we update `main` to use this new definition so the `leaf`
node will have a way to refer to its parent, `branch`:
-->
<p>Un nÅ“ud devrait pouvoir avoir une rÃ©fÃ©rence vers son nÅ“ud parent, mais il ne
devrait pas prendre possession de son parent. Dans l'encart 15-28, nous mettons
Ã  jour cette nouvelle dÃ©finition pour que le nÅ“ud <code>feuille</code> puisse avoir un
moyen de pointer vers son parent, <code>branche</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());

    let branche = Rc::new(Noeud {
        valeur: 5,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });

    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-28: A `leaf` node with a weak reference to its
parent node `branch`</span>
-->
<p><span class="caption">Encart 15-28Â : un nÅ“ud <code>feuille</code> avec un pointeur faible
vers son nÅ“ud parent, <code>branche</code></span></p>
<!--
Creating the `leaf` node looks similar to how creating the `leaf` node looked
in Listing 15-27 with the exception of the `parent` field: `leaf` starts out
without a parent, so we create a new, empty `Weak<Node>` reference instance.
-->
<p>La crÃ©ation du nÅ“ud <code>feuille</code> semble Ãªtre identique Ã  la crÃ©ation du nÅ“ud
<code>feuille</code> de l'encart 15-27, sauf pour le champ <code>parent</code>Â : <code>feuille</code> commence
sans parent, donc nous crÃ©ons une nouvelle instance de rÃ©fÃ©rence de type
<code>Weak&lt;Noeud&gt;</code>, qui est vide.</p>
<!--
At this point, when we try to get a reference to the parent of `leaf` by using
the `upgrade` method, we get a `None` value. We see this in the output from the
first `println!` statement:
-->
<p>A ce moment-lÃ , lorsque nous essayons d'obtenir une rÃ©fÃ©rence vers le parent de
<code>feuille</code> en utilisant la mÃ©thode <code>upgrade</code>, nous obtenons une valeur <code>None</code>.
Nous constatons cela dans la premiÃ¨re instruction <code>println!</code> sur la sortieÂ :</p>
<!--
```text
leaf parent = None
```
-->
<pre><code class="language-text">parent de la feuille = None
</code></pre>
<!--
When we create the `branch` node, it will also have a new `Weak<Node>`
reference in the `parent` field, because `branch` doesnâ€™t have a parent node.
We still have `leaf` as one of the children of `branch`. Once we have the
`Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>`
reference to its parent. We use the `borrow_mut` method on the
`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the
`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from
the `Rc<Node>` in `branch.`
-->
<p>Lorsque nous crÃ©ons le nÅ“ud <code>branche</code>, il va aussi avoir une nouvelle
rÃ©fÃ©rence <code>Weak&lt;Noeud&gt;</code> dans le champ <code>parent</code>, car <code>branche</code> n'a pas de nÅ“ud
parent. Nous avons nÃ©anmoins <code>feuille</code> dans <code>enfants</code> de <code>branche</code>. Une fois
que nous avons l'instance de <code>Noeud</code> dans <code>branche</code>, nous pouvons modifier
<code>feuille</code> pour lui donner une rÃ©fÃ©rence <code>Weak&lt;Noeud&gt;</code> vers son parent. Nous
utilisons la mÃ©thode <code>borrow_mut</code> sur la <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code> du champ
<code>parent</code> de <code>feuille</code>, et ensuite nous utilisons la fonction <code>Rc::downgrade</code>
pour crÃ©er une rÃ©fÃ©rence de type <code>Weak&lt;Node&gt;</code> vers <code>branche</code> Ã  partir du
<code>Rc&lt;Noeud&gt;</code> prÃ©sent dans <code>branche</code>.</p>
<!--
When we print the parent of `leaf` again, this time weâ€™ll get a `Some` variant
holding `branch`: now `leaf` can access its parent! When we print `leaf`, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:
-->
<p>Lorsque nous affichons Ã  nouveau le parent de <code>feuille</code>, cette fois nous
obtenons la variante <code>Some</code> qui contient <code>branche</code>Â : dÃ©sormais, <code>feuille</code> peut
accÃ©der Ã  son parentÂ ! Lorsque nous affichons <code>feuille</code>, nous avons aussi Ã©vitÃ©
la boucle qui aurait probablement fini en dÃ©bordement de pile comme nous
l'avions expÃ©rimentÃ© dans l'encart 15-26Â ; les rÃ©fÃ©rences <code>Weak&lt;Noeud&gt;</code>
s'Ã©crivent <code>(Weak)</code>Â :</p>
<!--
```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```
-->
<pre><code class="language-text">parent de la feuille = Some(Noeud { valeur: 5, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [Noeud { valeur: 3, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [] } }] } })
</code></pre>
<!--
The lack of infinite output indicates that this code didnâ€™t create a reference
cycle. We can also tell this by looking at the values we get from calling
`Rc::strong_count` and `Rc::weak_count`.
-->
<p>L'absence d'une sortie infinie nous confirme que ce code ne crÃ©e pas de boucle
de rÃ©fÃ©rences. Nous pouvons aussi le constater en affichant les valeurs que
nous pouvons obtenir en faisant appel Ã  <code>Rc::strong_count</code> et <code>Rc::weak_count</code>.</p>
<!--
#### Visualizing Changes to `strong_count` and `weak_count`
-->
<h4><a class="header" href="#visualiser-les-modifications-de-strong_count-et-weak_count" id="visualiser-les-modifications-de-strong_count-et-weak_count">Visualiser les modifications de <code>strong_count</code> et <code>weak_count</code></a></h4>
<!--
Letâ€™s look at how the `strong_count` and `weak_count` values of the `Rc<Node>`
instances change by creating a new inner scope and moving the creation of
`branch` into that scope. By doing so, we can see what happens when `branch` is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:
-->
<p>Regardons comment changent les valeurs <code>strong_count</code> et <code>weak_count</code> des
instances de <code>Rc&lt;Noeud&gt;</code> en crÃ©ant une portÃ©e interne et en dÃ©plaÃ§ant la
crÃ©ation de <code>branche</code> dans cette portÃ©e. En faisant ceci, nous pourrons
constater ce qui se passe lorsque <code>branche</code> est crÃ©Ã©e et lorsqu'elle sera
libÃ©rÃ©e lorsqu'elle sortira de la portÃ©e. Ces modifications sont prÃ©sentÃ©es
dans l'encart 15-29Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );

    {
        let branche = Rc::new(Noeud {
            valeur: 5,
            parent: RefCell::new(Weak::new()),
            enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
        });

        *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

        println!(
            &quot;branche strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branche),
            Rc::weak_count(&amp;branche),
        );

        println!(
            &quot;feuille strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;feuille),
            Rc::weak_count(&amp;feuille),
        );
    }

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-29: Creating `branch` in an inner scope and
examining strong and weak reference counts</span>
-->
<p><span class="caption">Encart 15-29Â : crÃ©ation de <code>branche</code> dans une portÃ©e
interne et vÃ©rification des compteurs de rÃ©fÃ©rences strong et weak</span></p>
<!--
After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak
count of 0. In the inner scope, we create `branch` and associate it with
`leaf`, at which point when we print the counts, the `Rc<Node>` in `branch`
will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing
to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, weâ€™ll see
it will have a strong count of 2, because `branch` now has a clone of the
`Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak
count of 0.
-->
<p>AprÃ¨s la crÃ©ation de <code>feuille</code>, son <code>Rc&lt;Noeud&gt;</code> a le compteur strong Ã  1 et le
compteur weak Ã  0. Dans la portÃ©e interne, nous crÃ©ons <code>branche</code> et l'associons
Ã  <code>feuille</code>, et Ã  partir de lÃ , lorsque nous affichons les compteurs, le
<code>Rc&lt;Noeud&gt;</code> dans <code>branche</code> aura le compteur strong Ã  1 et le compteur weak Ã  1
(pour que <code>feuille.parent</code> pointe sur <code>branche</code> avec un <code>Weak&lt;Noeud&gt;</code>). Lorsque
nous affichons les compteurs dans <code>feuille</code> nous constatons qu'il a le compteur
strong Ã  2, car <code>branche</code> a maintenant un clone du <code>Rc&lt;Noeud&gt;</code> de <code>feuille</code>
stockÃ© dans <code>branche.enfants</code>, mais a toujours le compteur weak Ã  0.</p>
<!--
When the inner scope ends, `branch` goes out of scope and the strong count of
the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1
from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we
donâ€™t get any memory leaks!
-->
<p>Lorsque la portÃ©e interne se termine, <code>branche</code> sort de la portÃ©e et le
compteur strong de <code>Rc&lt;Noeud&gt;</code> dÃ©croÃ®t Ã  0, donc son <code>Noeud</code> est libÃ©rÃ©. Le
compteur weak Ã  1 de <code>feuille.parent</code> n'a aucune rÃ©percussion suite Ã  la
libÃ©ration ou non du <code>Noeud</code>, donc nous ne sommes pas dans une situation de
fuite de mÃ©moireÂ !</p>
<!--
If we try to access the parent of `leaf` after the end of the scope, weâ€™ll get
`None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong
count of 1 and a weak count of 0, because the variable `leaf` is now the only
reference to the `Rc<Node>` again.
-->
<p>Si nous essayons d'accÃ©der au parent de <code>feuille</code> aprÃ¨s la fin de la portÃ©e,
nous allons Ã  nouveau obtenir <code>None</code>. A la fin du programme, le <code>Rc&lt;Noeud&gt;</code>
dans <code>feuille</code> a son compteur strong Ã  1 et son compteur weak Ã  0, car la
variable <code>feuille</code> est Ã  nouveau la seule rÃ©fÃ©rence au <code>Rc&lt;Noeud&gt;</code>.</p>
<!--
All of the logic that manages the counts and value dropping is built into
`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By
specifying that the relationship from a child to its parent should be a
`Weak<T>` reference in the definition of `Node`, youâ€™re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.
-->
<p>Toute cette logique qui gÃ¨re les compteurs et les libÃ©rations des valeurs est
intÃ©grÃ©e dans <code>Rc&lt;T&gt;</code> et <code>Weak&lt;T&gt;</code> et leurs implÃ©mentations du trait <code>Drop</code>. En
prÃ©cisant dans la dÃ©finition de <code>Noeud</code> que le lien entre un enfant et son
parent doit Ãªtre une rÃ©fÃ©rence <code>Weak&lt;T&gt;</code>, vous pouvez avoir des nÅ“uds parents
qui pointent sur des nÅ“uds enfants et vice versa sans risquer de crÃ©er des
boucles de rÃ©fÃ©rences et des fuites de mÃ©moire.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-14" id="rÃ©sumÃ©-14">RÃ©sumÃ©</a></h2>
<!--
This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
`Box<T>` type has a known size and points to data allocated on the heap. The
`Rc<T>` type keeps track of the number of references to data on the heap so
that data can have multiple owners. The `RefCell<T>` type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.
-->
<p>Ce chapitre a expliquÃ© l'utilisation des pointeurs intelligents pour appliquer
diffÃ©rentes garanties et compromis que celles qu'applique Rust par dÃ©faut avec
les rÃ©fÃ©rences classiques. Le type <code>Box&lt;T&gt;</code> a une taille connue et pointe sur
une donnÃ©e allouÃ©e sur le tas. Le type <code>Rc&lt;T&gt;</code> compte le nombre de rÃ©fÃ©rences
vers une donnÃ©e prÃ©sente sur le tas afin que cette donnÃ©e puisse avoir
plusieurs propriÃ©taires. Le type <code>RefCell&lt;T&gt;</code> nous permet de l'utiliser lorsque
nous avons besoin d'un type immuable mais que nous avons besoin de changer une
valeur interne Ã  ce type, grÃ¢ce Ã  sa fonctionnalitÃ© de mutabilitÃ© interneÂ ;
elle nous permet aussi d'appliquer les rÃ¨gles d'emprunt Ã  l'exÃ©cution plutÃ´t
qu'Ã  la compilation.</p>
<!--
Also discussed were the `Deref` and `Drop` traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using `Weak<T>`.
-->
<p>Nous avons aussi vu les traits <code>Deref</code> et <code>Drop</code>, qui offrent des
fonctionnalitÃ©s trÃ¨s importantes aux pointeurs intelligents. Nous avons
expÃ©rimentÃ© les boucles de rÃ©fÃ©rences qui peuvent causer des fuites de mÃ©moire
et nous avons vu comment les Ã©viter en utilisant <code>Weak&lt;T&gt;</code>.</p>
<!--
If this chapter has piqued your interest and you want to implement your own
smart pointers, check out [â€œThe Rustonomiconâ€][nomicon] for more useful
information.
-->
<p>Si ce chapitre a Ã©veillÃ© votre curiositÃ© et que vous souhaitez mettre en Å“uvre
vos propres pointeurs intelligents, visitez <a href="https://doc.rust-lang.org/nomicon/index.html">â€œThe Rustonomiconâ€</a> pour
en savoir plus.</p>
<!--
Next, weâ€™ll talk about concurrency in Rust. Youâ€™ll even learn about a few new
smart pointers.
-->
<p>Au chapitre suivant, nous allons parler de concurrence en Rust. Vous
dÃ©couvrirez peut-Ãªtre mÃªme quelques nouveaux pointeurs intelligents ...</p>
<!--
[nomicon]: ../nomicon/index.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--32" id="-attention-peinture-fraÃ®che--32">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/196">Pull Request</a>.</p>
</blockquote>
<!--
# Fearless Concurrency
-->
<h1><a class="header" href="#la-concurrence-sans-craintes" id="la-concurrence-sans-craintes">La concurrence sans craintes</a></h1>
<!--
Handling concurrent programming safely and efficiently is another of Rustâ€™s
major goals. *Concurrent programming*, where different parts of a program
execute independently, and *parallel programming*, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.
-->
<p>Le dÃ©veloppement sÃ©curisÃ© et efficace dans des contextes de concurrence est un
autre objectif majeur de Rust. La <em>programmation concurrente</em>, dans laquelle
diffÃ©rentes parties d'un programme s'exÃ©cutent de maniÃ¨re indÃ©pendente, et le
<em>parallÃ©lisme</em>, dans lequel diffÃ©rentes parties d'un programme s'exÃ©cutent en
mÃªme temps, sont devenus des pratiques de plus en plus importantes au fur et Ã 
mesure que les ordinateurs tirent parti de leurs processeurs multiples.
Historiquement, le dÃ©veloppement dans ces contextes est difficile et favorise
les erreursÂ : Rust compte bien changer la donne.</p>
<!--
Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety *and* concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while youâ€™re working on it rather than potentially after it has been
shipped to production. Weâ€™ve nicknamed this aspect of Rust *fearless*
*concurrency*. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.
-->
<p>Au dÃ©but, l'Ã©quipe de Rust pensait que garantir la sÃ©curitÃ© de la mÃ©moire et
Ã©viter les problÃ¨mes de concurrence Ã©taient deux challenges distincts qui
devaient Ãªtre rÃ©solus de maniÃ¨re diffÃ©rentes. Avec le temps, l'Ã©quipe a
dÃ©couvert que les systÃ¨mes de possession et de type sont des jeux d'outils
puissants qui aident Ã  sÃ©curiser la mÃ©moire <em>et</em> Ã  rÃ©gler des problÃ¨mes de
concurrenceÂ ! En exploitant la possession et la vÃ©rification de type, de
nombreuses erreurs de concurrence deviennent des erreurs Ã  la compilation en
Rust plutÃ´t que des erreurs Ã  l'exÃ©cution. Ainsi, plutÃ´t que d'avoir Ã  passer
beaucoup de votre temps Ã  tenter de reproduire les circonstances exactes dans
lesquelles un bogue de concurrence s'est produit Ã  l'exÃ©cution, le code
incorrecte va refuser de se compiler et va vous afficher une erreur expliquant
le problÃ¨me. Au final, vous pouvez corriger votre code pendant que vous
travaillez dessus plutÃ´t que d'avoir Ã  le faire Ã  posteriori aprÃ¨s qu'il ai
potentiellement Ã©tÃ© livrÃ© en production. Nous avons surnommÃ© cet aspect de Rust
la <em>concurrence sans craintes</em>. La concurrence sans craintes vous permet
d'Ã©crire du code dÃ©pourvu de bogues subtils et il sera facile de le remanier
sans risquer d'introduire de nouveaux bogues.</p>
<!--
> Note: For simplicityâ€™s sake, weâ€™ll refer to many of the problems as
> *concurrent* rather than being more precise by saying *concurrent and/or
> parallel*. If this book were about concurrency and/or parallelism, weâ€™d be
> more specific. For this chapter, please mentally substitute *concurrent
> and/or parallel* whenever we use *concurrent*.
-->
<blockquote>
<p>RemarqueÂ : pour des raisons de simplicitÃ©, nous allons dÃ©signer la plupart
des problÃ¨mes par <em>des problÃ¨mes de concurrence</em> plutÃ´t que d'Ãªtre trop
prÃ©cis en disant <em>des problÃ¨mes de concurrence et/ou de parallÃ©lisme</em>. Si ce
livre traitait spÃ©cifiquement de concurrence et/ou de parallÃ©lisme, nous
serions plus prÃ©cis. Pour ce chapitre, veuillez garder Ã  l'esprit que nous
parlons de <em>concurrence et/ou de parallÃ©lisme</em> Ã  chaque fois que nous
parlerons de <em>concurrence</em>.</p>
</blockquote>
<!--
Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages, because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.
-->
<p>De nombreux langages sont dogmatiques sur les solutions qu'ils offrent pour
gÃ©rer les problÃ¨mes de concurrence. Par exemple, Erlang a une fonctionnalitÃ©
Ã©lÃ©gante de passage de messages pour la concurrence mais a une faÃ§on Ã©trange
de partager un Ã©tat entre les tÃ¢ches. Ne proposer qu'un sous-ensemble de
solutions possibles est une stratÃ©gie acceptable pour les langages de haut
niveau, car un langage de haut niveau offre des avantages en sacrifiant
certains contrÃ´les pour Ãªtre plus accessibles. Cependant, les langages de bas
niveau sont censÃ©s fournir la solution la plus performante dans n'importe
quelle situation donnÃ©e et proposer moins de facilitÃ©s sur le matÃ©riel.
Cependant, Rust offre une gamme d'outils rÃ©pondre aux problÃ¨mes de toutes les
maniÃ¨res possibles pour vos besoins du moment.</p>
<!--
Here are the topics weâ€™ll cover in this chapter:
-->
<p>Voici les sujets que nous allons aborder dans ce chapitreÂ :</p>
<!--
* How to create threads to run multiple pieces of code at the same time
* *Message-passing* concurrency, where channels send messages between threads
* *Shared-state* concurrency, where multiple threads have access to some piece
  of data
* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to
  user-defined types as well as types provided by the standard library
-->
<ul>
<li>Comment crÃ©er des tÃ¢ches pour exÃ©cuter plusieurs parties de code en mÃªme temps</li>
<li>Le <em>passage de message</em> en concurrence, qui permet Ã  plusieurs tÃ¢ches
d'accÃ©der Ã  la mÃªme donnÃ©e</li>
<li>Les traits <code>Sync</code> et <code>Send</code>, qui Ã©tendent les garanties de Rust sur la
concurrence autant Ã  des types dÃ©finis par les utilisateurs que par ceux qui
sont fournis par la bibliothÃ¨que standard</li>
</ul>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--33" id="-attention-peinture-fraÃ®che--33">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/197">Pull Request</a>.</p>
</blockquote>
<!--
## Using Threads to Run Code Simultaneously
-->
<h2><a class="header" href="#utiliser-les-tÃ¢ches-pour-exÃ©cuter-simultanÃ©ment-du-code" id="utiliser-les-tÃ¢ches-pour-exÃ©cuter-simultanÃ©ment-du-code">Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></h2>
<!--
In most current operating systems, an executed programâ€™s code is run in a
*process*, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called *threads*.
-->
<p>Dans la plupart des systÃ¨mes d'exploitation actuels, le code d'un programme
exÃ©cutÃ© dans un <em>processus</em>, et le systÃ¨me d'exploitation gÃ¨re plusieurs
processus Ã  la fois. Dans votre programme, vous pouvez vous aussi avoir des
parties indÃ©pendantes qui s'exÃ©cutent simultanÃ©ment. Les Ã©lÃ©ments qui font
fonctionner ces parties indÃ©pendantes sont appelÃ©s les <em>tÃ¢ches</em>.</p>
<!--
Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, thereâ€™s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:
-->
<p>Le dÃ©coupage des calculs de votre programme dans plusieurs tÃ¢ches peut
amÃ©liorer sa performance car le programme fait plusieurs choses Ã  la fois, mais
cela rajoute aussi de la complexitÃ©. Comme les tÃ¢ches peuvent s'exÃ©cuter de
maniÃ¨re simultanÃ©e, il n'y a pas de garantie absolue sur l'ordre d'exÃ©cution
de vos diffÃ©rentes parties de votre code. Cela peut poser des problÃ¨mes,
commeÂ :</p>
<!--
* Race conditions, where threads are accessing data or resources in an
  inconsistent order
* Deadlocks, where two threads are waiting for each other to finish using a
  resource the other thread has, preventing both threads from continuing
* Bugs that happen only in certain situations and are hard to reproduce and fix
  reliably
-->
<ul>
<li>Les situations de concurrence, durant lesquelles les tÃ¢ches accÃ¨dent Ã  une
donnÃ©e ou ressource dans un ordre incohÃ©rent</li>
<li>Des interblocages, durant lesquels deux tÃ¢ches attendent mutuellement que
l'autre finit d'utiliser une ressource que l'autre tÃ¢che utilise, bloquant
les deux tÃ¢ches de progresser</li>
<li>Des bogues qui surgissent uniquement dans certaines situations et qui sont
difficiles Ã  reproduire et corriger durablement</li>
</ul>
<!--
Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.
-->
<p>Rust cherche Ã  attÃ©nuer les effets indÃ©sirables de l'utilisation des tÃ¢ches,
mais le dÃ©veloppement dans un contexte multitÃ¢ches exige toujours une attention
particuliÃ¨re et nÃ©cessite une structure de code diffÃ©rente de celle pour des
programmes qui s'exÃ©cutent dans une seule tÃ¢che.</p>
<!--
Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called *1:1*,
meaning one operating system thread per one language thread.
-->
<p>Les langages de programmation implÃ©mentent les tÃ¢ches de diffÃ©rentes maniÃ¨res.
De nombreux systÃ¨mes d'exploitation offrent des API pour crÃ©er des nouvelles
tÃ¢ches. L'appel Ã  cet API du systÃ¨me d'exploitation pour crÃ©er des tÃ¢ches par
un langage est parfois qualifiÃ© de <em>1:1</em>, ce qui signifie une tÃ¢che du systÃ¨me
d'exploitation par tÃ¢che dans le langage de programmation.</p>
<!--
Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as *green* threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the
green-threaded model is called the *M:N* model: there are `M` green threads per
`N` operating system threads, where `M` and `N` are not necessarily the same
number.
-->
<p>De nombreux langages de programmation fournissent leur propre implÃ©mentation
spÃ©ciale des tÃ¢ches. Les tÃ¢ches fournies par un langage de programmation
s'appelle une tÃ¢che <em>virtuelle</em>, et les langages qui utilisent ces tÃ¢ches
virtuelles vont les exÃ©cuter dans diffÃ©rentes tÃ¢ches du systÃ¨me d'exploitation.
C'est pourquoi le modÃ¨le des tÃ¢ches virtuelles est appelÃ© modÃ¨le <em>M:N</em>Â : il y a
<code>M</code> tÃ¢ches virtuelles pour <code>N</code> tÃ¢ches du systÃ¨me d'exploitation, dans lequel
<code>M</code> et <code>N</code> ne sont pas nÃ©cessairement le mÃªme nombre.</p>
<!--
Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. *Runtime* is a confusing term and can
have different meanings in different contexts.
-->
<p>Chaque modÃ¨le a ses propres avantages et compromis, et le compromis le plus
important pour Rust est la prise en charge de l'environnement d'exÃ©cution.
<em>Environnement d'exÃ©cution</em> est un terme qui peut prÃªter Ã  confusion et avoir
diffÃ©rentes significations dans diffÃ©rents contextes.</p>
<!--
In this context, by *runtime* we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has â€œno runtime,â€ they often
mean â€œsmall runtime.â€ Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.
-->
<p>Dans ce contexte, lorsque nous parlons <em>d'environnement exÃ©cution</em>, nous
entendons le code qui est intÃ©grÃ© par le langage dans chaque binaire. Ce code
peut Ãªtre plus ou moins vaste en fonction du langage, mais chaque langage non
assembleur aura une certaine quantitÃ© de code d'environnement exÃ©cution. Pour
cette raison, lorsque les gens disent couramment d'un langage n'a pas
â€œd'environnement d'exÃ©cutionâ€, ils entendent trÃ¨s souvent â€œfaible environnement
d'exÃ©cutionâ€. Les faibles environnements d'exÃ©cution ont moins de
fonctionnalitÃ©s mais ont l'avantage d'avoir des bibliothÃ¨ques plus petites, ce
qui facilite la combinaison du langage avec un autre et dans plus de contextes.
Contrairement Ã  de nombreux langages de programmation qui acceptent d'augmenter
la taille de l'environnement d'exÃ©cution pour plus de fonctionnalitÃ©s, Rust a
besoin d'avoir un environnement d'exÃ©cution presque inexistant et ne doit pas
faire de compromis sur ses capacitÃ©s Ã  faire appel au C, afin de conserver ses
performances.</p>
<!--
The green-threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.
-->
<p>Le modÃ¨le de tÃ¢ches virtuelles M:N nÃ©cessite un plus grand environnement
d'exÃ©cution pour gÃ©rer les tÃ¢ches. C'est pourquoi la bibliothÃ¨que standard de
Rust fournit seulement une implÃ©mentation 1:1. Comme Rust est un langage
bas-niveau, il existe des crates qui implÃ©mentent des tÃ¢ches M:N si vous
prÃ©fÃ©rez compenser des pertes de performances pour plus de maÃ®trise dans
l'exÃ©cution des tÃ¢ches et moins de consÃ©quences pour les changements de
contextes.</p>
<!--
Now that weâ€™ve defined threads in Rust, letâ€™s explore how to use the
thread-related API provided by the standard library.
-->
<p>Maintenant que nous avons dÃ©fini ce qu'Ã©taient les tÃ¢ches en Rust, dÃ©couvrons
comment utiliser les API liÃ©es aux tÃ¢ches fournies par la bibliothÃ¨que
standard.</p>
<!--
### Creating a New Thread with `spawn`
-->
<h3><a class="header" href="#crÃ©er-une-nouvelle-tÃ¢che-avec-spawn" id="crÃ©er-une-nouvelle-tÃ¢che-avec-spawn">CrÃ©er une nouvelle tÃ¢che avec <code>spawn</code></a></h3>
<!--
To create a new thread, we call the `thread::spawn` function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:
-->
<p>Pour crÃ©er une nouvelle tÃ¢che, nous appelons la fonction <code>thread::spawn</code> et
nous lui passons une fermeture (nous avons vu les fermetures au chapitre 13)
qui contient le code que nous souhaitons exÃ©cuter dans la nouvelle tÃ¢che.
L'exemple dans l'encart 16-1 affiche du texte Ã  partir de la tÃ¢che principale
et un autre texte Ã  partir d'une nouvelle tÃ¢cheÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour nÂ°{} Ã  partir de la nouvelle tÃ¢cheÂ !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour nÂ°{} Ã  partir de la tÃ¢che principaleÂ !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span>
-->
<p><span class="caption">Encart 16-1Â : crÃ©ation d'une nouvelle tÃ¢che pour afficher
une chose pendant que la tÃ¢che principale affiche autre chose</span></p>
<!--
Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:
-->
<p>Remarquez d'avec cette fonction, la nouvelle tÃ¢che s'arrÃªtera lorsque la tÃ¢che
principale s'arrÃªtera, qu'elle ai fini ou non de s'exÃ©cuter. La sortie de ce
programme peut Ãªtre diffÃ©rente Ã  chaque fois, mais il devrait ressembler Ã 
ceciÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour nÂ°1 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°1 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°2 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°3 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°3 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°4 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°5 Ã  partir de la nouvelle tÃ¢cheÂ !
</code></pre>
<!--
The calls to `thread::sleep` force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isnâ€™t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until `i` is 9, it only got to 5
before the main thread shut down.
-->
<p>L'appel Ã  <code>thread::sleep</code> force une tÃ¢che Ã  mettre en pause son exÃ©cution
pendant une petite durÃ©e, permettant Ã  une autre tÃ¢che de s'exÃ©cuter. Les
tÃ¢ches se relaieront probablement, mais ce n'est pas garantiÂ : cela dÃ©pend de
comment votre systÃ¨me d'exploitation agence les tÃ¢ches. Lors de cette
exÃ©cution, la tÃ¢che principale a d'abord Ã©cris, mÃªme si l'instruction
d'Ã©criture de la nouvelle tÃ¢che apparaÃ®t en premier dans le code. Et mÃªme si
nous avons demandÃ© Ã  la nouvelle tÃ¢che d'Ã©crire jusqu'Ã  ce que <code>i</code> vaut <code>9</code>,
elle l'a fait seulement jusqu'Ã  <code>5</code>, avant que la tÃ¢che principale s'arrÃªte.</p>
<!--
If you run this code and only see output from the main thread, or donâ€™t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.
-->
<p>Si vous exÃ©cutez ce code et que vous ne voyez que du texte provenant de la
tÃ¢che principale, ou que vous ne voyez aucun chevauchement, essayez d'augmenter
les nombres dans les intervalles pour donner plus d'opportunitÃ©s au systÃ¨me
d'exploitation pour basculer entre les tÃ¢ches.</p>
<!--
### Waiting for All Threads to Finish Using `join` Handles
-->
<h3><a class="header" href="#attendre-que-toutes-les-tÃ¢ches-aient-fini-en-utilisant-join" id="attendre-que-toutes-les-tÃ¢ches-aient-fini-en-utilisant-join">Attendre que toutes les tÃ¢ches aient fini en utilisant <code>join</code></a></h3>
<!--
The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also canâ€™t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!
-->
<p>Le code dans l'encart 16-1 non seulement stoppe la nouvelle tÃ¢che prÃ©maturÃ©ment
la plupart du temps Ã  cause de la fin de la tÃ¢che principale, mais elle ne
garantit pas non plus que la nouvelle tÃ¢che va s'exÃ©cuter une seule fois. La
raison Ã  cela est qu'il n'y a pas de garantie sur l'ordre dans lequel les
tÃ¢ches vont s'exÃ©cuterÂ !</p>
<!--
We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of `thread::spawn` in a variable.
The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned
value that, when we call the `join` method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we created
in Listing 16-1 and call `join` to make sure the spawned thread finishes before
`main` exits:
-->
<p>Nous pouvons rÃ©gler le problÃ¨me des nouvelles tÃ¢ches qui ne s'exÃ©cutent pas, ou
pas complÃ¨tement, en sauvegardant la valeur de retour de <code>thread::spawn</code> dans
une variable. Le type de retour de <code>thread::span</code> est <code>JoinHandle</code>. Un
<code>JoinHandle</code> est une valeur possÃ©dÃ©e qui, lorsque nous appelons la mÃ©thode
<code>join</code> sur elle, va attendre que ses tÃ¢ches finissent. L'encart 16-2 montre
comment utiliser le <code>JoinHandle</code> de la tÃ¢che que nous avons crÃ©Ã© dans l'encart
16-1 en appelant la mÃ©thode <code>join</code> pour s'assurer que la nouvelle tÃ¢che finit
bien avant que <code>main</code> se termineÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour nÂ°{} Ã  partir de la nouvelle tÃ¢cheÂ !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour nÂ°{} Ã  partir de la tÃ¢che principaleÂ !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-2: Saving a `JoinHandle` from `thread::spawn`
to guarantee the thread is run to completion</span>
-->
<p><span class="caption">Encart 16-2Â : sauvegarde d'un <code>JoinHandle</code> d'un
<code>thread::spawn</code> pour garantir que la tÃ¢che est exÃ©cutÃ©e jusqu'Ã  la fin</span></p>
<!--
Calling `join` on the handle blocks the thread currently running until the
thread represented by the handle terminates. *Blocking* a thread means that
thread is prevented from performing work or exiting. Because weâ€™ve put the call
to `join` after the main threadâ€™s `for` loop, running Listing 16-2 should
produce output similar to this:
-->
<p>L'appel Ã  <code>join</code> sur le manipulateur bloque la tÃ¢che qui s'exÃ©cute actuellement
jusqu'Ã  ce que la tÃ¢che reprÃ©sentÃ©e par le manipulateur se termine. <em>Bloquer</em>
une tÃ¢che signifie que cette tÃ¢che est privÃ©e d'accomplir un quelconque travail
ou de se terminer. Comme nous avons insÃ©rÃ© l'appel Ã  <code>join</code> aprÃ¨s la boucle
<code>for</code> de la tÃ¢che principale, l'exÃ©cution de l'encart 16-2 devrait produire un
rÃ©sultat similaire Ã  celui-ciÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour nÂ°1 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°1 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°3 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°3 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°5 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°6 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°7 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°8 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°9 Ã  partir de la nouvelle tÃ¢cheÂ !
</code></pre>
<!--
The two threads continue alternating, but the main thread waits because of the
call to `handle.join()` and does not end until the spawned thread is finished.
-->
<p>Les deux tÃ¢ches continuent Ã  alterner, mais la tÃ¢che principale attends Ã  cause
de l'appel Ã  <code>manipulateur.join()</code> et ne se termine pas avant que la nouvelle
tÃ¢che soit finie.</p>
<!--
But letâ€™s see what happens when we instead move `handle.join()` before the
`for` loop in `main`, like this:
-->
<p>Mais voyons maintenant ce qui se passe lorsque nous dÃ©plaÃ§ons le
<code>manipulateur.join()</code> avant la boucle <code>for</code> du <code>main</code> comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour nÂ°{} Ã  partir de la nouvelle tÃ¢cheÂ !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    manipulateur.join().unwrap();

    for i in 1..5 {
        println!(&quot;Bonjour nÂ°{} Ã  partir de la tÃ¢che principaleÂ !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
The main thread will wait for the spawned thread to finish and then run its
`for` loop, so the output wonâ€™t be interleaved anymore, as shown here:
-->
<p>La tÃ¢che principale va attendre que la nouvelle tÃ¢che se finisse et ensuite
exÃ©cuter sa boucle <code>for</code>, ainsi la sortie ne sera plus chevauchÃ©e, comme
ci-dessousÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```
-->
<pre><code class="language-text">Bonjour nÂ°1 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°2 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°3 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°5 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°6 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°7 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°8 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°9 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°1 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°3 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°4 Ã  partir de la tÃ¢che principaleÂ !
</code></pre>
<!--
Small details, such as where `join` is called, can affect whether or not your
threads run at the same time.
-->
<p>Des petits dÃ©tails, comme l'endroit oÃ¹ <code>join</code> est appelÃ©, peuvent dÃ©terminer si
vos tÃ¢ches peuvent Ãªtre exÃ©cutÃ©es ou non en mÃªme temps.</p>
<!--
### Using `move` Closures with Threads
-->
<h3><a class="header" href="#utiliser-les-fermetures-move-avec-les-tÃ¢ches" id="utiliser-les-fermetures-move-avec-les-tÃ¢ches">Utiliser les fermetures <code>move</code> avec les tÃ¢ches</a></h3>
<!--
The `move` closure is often used alongside `thread::spawn` because it allows
you to use data from one thread in another thread.
-->
<p>La fermeture <code>move</code> est souvent utilisÃ© avec <code>thread::spawn</code> car elle vous
permet d'utiliser une donnÃ©e d'une tÃ¢che dans une autre tÃ¢che.</p>
<!--
In Chapter 13, we mentioned we can use the `move` keyword before the parameter
list of a closure to force the closure to take ownership of the values it uses
in the environment. This technique is especially useful when creating new
threads in order to transfer ownership of values from one thread to another.
-->
<p>Au chapitre 13, nous avons Ã©voquÃ© que nous pouvions utiliser le mot-clÃ© <code>move</code>
avant la liste des paramÃ¨tres d'une fermeture pour forcer la fermeture Ã 
prendre possession des valeurs de son environnement qu'elle utilise. Cette
technique est particuliÃ¨rement utile lorsque nous crÃ©ons des nouvelles tÃ¢ches
pour pouvoir transfÃ©rer la possession des valeurs d'une tÃ¢che Ã  une autre.</p>
<!--
Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no
arguments: weâ€™re not using any data from the main thread in the spawned
threadâ€™s code. To use data from the main thread in the spawned thread, the
spawned threadâ€™s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this wonâ€™t yet work, as youâ€™ll see in a moment.
-->
<p>Remarquez dans l'encart 16-1 que la fermeture que nous donnons Ã  <code>thread::span</code>
ne prends pas d'argumentsÂ : nous n'utilisons aucune donnÃ©e de la tÃ¢che
principale dans le code de la nouvelle tÃ¢che. Pour utiliser des donnÃ©es de la
tÃ¢che principale dans la nouvelle tÃ¢che, la fermeture de la nouvelle tÃ¢che doit
capturer les valeurs dont elle a besoin. L'encart 16-3 montre une tentative de
crÃ©ation d'un vecteur dans la tÃ¢che principale et l'utilisation dans la
nouvelle tÃ¢che. Cependant, cela ne fonctionne pas encore, comme vous allez le
constater bientÃ´t.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span>
-->
<p><span class="caption">Encart 16-3Â : tentative d'utilisation d'un vecteur crÃ©Ã©
par la tÃ¢che principale dans une autre tÃ¢che</span></p>
<!--
The closure uses `v`, so it will capture `v` and make it part of the closureâ€™s
environment. Because `thread::spawn` runs this closure in a new thread, we
should be able to access `v` inside that new thread. But when we compile this
example, we get the following error:
-->
<p>La fermeture utilise <code>v</code>, donc elle va capturer <code>v</code> et l'intÃ©grer dans son
environnement. Comme <code>thread::spawn</code> exÃ©cute cette fermeture dans une nouvelle
tÃ¢che, nous devrions pouvoir accÃ©der Ã  <code>v</code> dans cette nouvelle tÃ¢che. Mais
lorsque nous compilons cet exemple, nous obtenons l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 -- > src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 -- > src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let manipulateur = thread::spawn(|| {
  |                                      ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let manipulateur = thread::spawn(|| {
  |  ________________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rust *infers* how to capture `v`, and because `println!` only needs a reference
to `v`, the closure tries to borrow `v`. However, thereâ€™s a problem: Rust canâ€™t
tell how long the spawned thread will run, so it doesnâ€™t know if the reference
to `v` will always be valid.
-->
<p>Rust <em>dÃ©duit</em> comment capturer <code>v</code>, et comme <code>println!</code> n'a besoin que d'une
rÃ©fÃ©rence Ã  <code>v</code>, la fermeture essaye d'emprunter <code>v</code>. Cependant, il y a un
problÃ¨meÂ : Rust ne peut pas savoir combien de temps la tÃ¢che va s'exÃ©cuter,
donc il ne peut pas savoir si la rÃ©fÃ©rence Ã  <code>v</code> sera toujours valide.</p>
<!--
Listing 16-4 provides a scenario thatâ€™s more likely to have a reference to `v`
that wonâ€™t be valid:
-->
<p>L'encart 16-4 propose un scÃ©nario qui est plus encleint Ã  avoir une rÃ©fÃ©rence Ã 
<code>v</code> qui ne sera plus valideÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
    });

    drop(v); // oh, nonÂ !

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to `v` from a main thread that drops `v`</span>
-->
<p><span class="caption">Encart 16-4Â : une tÃ¢che dont la fermeture essaye de
capturer une rÃ©fÃ©rence Ã  <code>v</code> Ã  partir de la tÃ¢che principale, qui va ensuite
libÃ©rer <code>v</code></span></p>
<!--
If we were allowed to run this code, thereâ€™s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to `v` inside, but the main thread immediately drops
`v`, using the `drop` function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, `v` is no longer valid, so a reference to it
is also invalid. Oh no!
-->
<p>Si nous Ã©tions autorisÃ©s Ã  exÃ©cuter ce code, il y aurait une possibilitÃ© que
la nouvelle tÃ¢che serait immÃ©diatement placÃ©e en arriÃ¨re-plan sans Ãªtre
exÃ©cutÃ©e du tout. La nouvelle tÃ¢che a une rÃ©fÃ©rence Ã  <code>v</code> en son sein, mais la
tÃ¢che principale libÃ¨re immÃ©diatement <code>v</code>, en utilisant la fonction <code>drop</code> que
nous avons vu au chapitre 15. Ensuite, lorsque la nouvelle tÃ¢che commence Ã 
s'exÃ©cuter, <code>v</code> n'est plus en vigueur, donc une rÃ©fÃ©rence Ã  cette derniÃ¨re est
elle aussi invalideÂ !</p>
<!--
To fix the compiler error in Listing 16-3, we can use the error messageâ€™s
advice:
-->
<p>Pour corriger l'erreur de compilation de l'encart 16-3, nous pouvons appliquer
le conseil du message d'erreurÂ :</p>
<!--
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-- >
-->
<!--
```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
```
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let manipulateur = thread::spawn(move || {
  |                                      ^^^^^^^
</code></pre>
<!--
By adding the `move` keyword before the closure, we force the closure to take
ownership of the values itâ€™s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:
-->
<p>En ajoutant le mot-clÃ© <code>move</code> avant la fermeture, nous forÃ§ons la fermeture Ã 
prendre possession des valeurs qu'elle utilise au lieu de laisser Rust en
dÃ©duire qu'il doit emprunter les valeurs. Les modifications Ã  l'encart 16-3
proposÃ©es dans l'encart 16-5 devraient se compiler et s'exÃ©cuter comme prÃ©vuÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(move || {
        println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-5: Using the `move` keyword to force a closure
to take ownership of the values it uses</span>
-->
<p><span class="caption">Encart 16-5Â : utilisation du mot-clÃ© <code>move</code> pour forcer
une fermeture Ã  prendre possession des valeurs qu'elle utilise</span></p>
<!--
What would happen to the code in Listing 16-4 where the main thread called
`drop` if we use a `move` closure? Would `move` fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isnâ€™t allowed for a different reason. If we added `move` to the closure, we
would move `v` into the closureâ€™s environment, and we could no longer call
`drop` on it in the main thread. We would get this compiler error instead:
-->
<p>Qu'est-ce qui arriverait au code de l'encart 16-4 dans lequel la tÃ¢che
principale fait appel Ã  <code>drop</code> si nous utilisions la fermeture avec <code>move</code>Â ?
Est-ce que le <code>move</code> va rÃ©soudre ce problÃ¨meÂ ? Malheureusement, nonÂ ; nous
obtiendrions une erreur diffÃ©rente parce que ce que l'encart 16-4 essaye de
faire n'est pas autorisÃ© pour diffÃ©rentes raisons. Si nous ajoutions <code>move</code> Ã  la
fermeture, nous dÃ©placerions <code>v</code> dans l'environnement de la fermeture, et nous
ne pourrions plus appeler <code>drop</code> sur <code>v</code> dans la tÃ¢che principale. Nous
obtiendrons Ã  la place cette erreur de compilationÂ :</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  -- > src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {:?}", v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let manipulateur = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
   |                                             - variable moved due to use in closure
...
10 |     drop(v); // oh, nonÂ !
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  -- &gt; src/main.rs:10:10
   |
6  |     let manipulateur = thread::spawn(move || {
   |                                      ------- value moved (into closure) here
...
10 |     drop(v); // oh non, le vecteur est libÃ©rÃ©Â !
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<!--
Rustâ€™s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing `v` for the
thread, which meant the main thread could theoretically invalidate the spawned
threadâ€™s reference. By telling Rust to move ownership of `v` to the spawned
thread, weâ€™re guaranteeing Rust that the main thread wonâ€™t use `v` anymore. If
we change Listing 16-4 in the same way, weâ€™re then violating the ownership
rules when we try to use `v` in the main thread. The `move` keyword overrides
Rustâ€™s conservative default of borrowing; it doesnâ€™t let us violate the
ownership rules.
-->
<p>Les rÃ¨gles de possession de Rust nous ont encore sauvÃ© la miseÂ ! Nous obtenons
une erreur du code l'encart 16-3 car Rust a Ã©tÃ© conservateur et a juste empruntÃ©
<code>v</code> Ã  la tÃ¢che, ce qui signifie que la tÃ¢che principale peut thÃ©oriquement
neutraliser la rÃ©fÃ©rence de la tÃ¢che crÃ©e. En demandant Ã  Rust de dÃ©placer la
possession de <code>v</code> Ã  la nouvelle tÃ¢che, nous avons garanti Ã  Rust que la tÃ¢che
principale n'utiliserait plus <code>v</code>. Si nous changeons l'encart 16-4 de la mÃªme
maniÃ¨re, nous violons les rÃ¨gles de possession lorsque nous essayons d'utiliser
<code>v</code> dans la tÃ¢che principale. Le mot-clÃ© <code>move</code> remplace le comportement
d'emprunt conservateur par dÃ©fautÂ ; il ne nous laisse pas enfreindre les rÃ¨gles
d'emprunt.</p>
<!--
With a basic understanding of threads and the thread API, letâ€™s look at what we
can *do* with threads.
-->
<p>Avec cette connaissance de base des tÃ¢ches et de leur API, dÃ©couvrons ce que
nous pouvons <em>faire</em> avec les tÃ¢ches.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--34" id="-attention-peinture-fraÃ®che--34">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/198">Pull Request</a>.</p>
</blockquote>
<!--
## Using Message Passing to Transfer Data Between Threads
-->
<h2><a class="header" href="#utiliser-lenvoi-de-messages-pour-transfÃ©rer-des-donnÃ©es-entre-les-tÃ¢ches" id="utiliser-lenvoi-de-messages-pour-transfÃ©rer-des-donnÃ©es-entre-les-tÃ¢ches">Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></h2>
<!--
One increasingly popular approach to ensuring safe concurrency is *message
passing*, where threads or actors communicate by sending each other messages
containing data. Hereâ€™s the idea in a slogan from [the Go language
documentation](https://golang.org/doc/effective_go.html#concurrency): 
â€œDo not communicate by sharing memory; instead, share memory by communicating.â€
-->
<p>Une approche de plus en plus populaire pour garantir la sÃ©curitÃ© de la
concurrence est l'<em>envoi de message</em>, avec lequel les tÃ¢ches ou les acteurs
communiquent en envoyant aux autres des messages contenant des donnÃ©es. Voici
l'idÃ©e rÃ©sumÃ©e, tirÃ©e d'un slogan provenant de <a href="https://golang.org/doc/effective_go.html#concurrency">la documentation du langage
Go</a>Â : â€œNe communiquez pas
en partageant la mÃ©moireÂ ; partagez plutÃ´t la mÃ©moire en communiquantâ€.</p>
<!--
One major tool Rust has for accomplishing message-sending concurrency is the
*channel*, a programming concept that Rustâ€™s standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or boat into a stream, it will travel downstream to the end of the
waterway.
-->
<p>Un des outils majeurs que Rust a pour accomplir l'envoi de messages pour la
concurrence est le <em>canal</em>, un concept de programmation dont la bibliothÃ¨que
standard de Rust fournit une implÃ©mentation. Vous pouvez imaginer un canal de
programmation comme Ã©tant un canal d'eau, comme un ruisseau ou une riviÃ¨re. Si
vous posez quelque chose comme un canard en plastique ou un bateau sur un
ruisseau, il se dÃ©placera en descendant le long la voie d'eau.</p>
<!--
A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of your code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be *closed* if either the transmitter or receiver half is
dropped.
-->
<p>Un canal de programmation est divisÃ© en deux partiesÂ : un transmetteur et un
receveur. La partie du transmetteur est le lieu en amont oÃ¹ vous dÃ©posez les
canards en plastique sur la riviÃ¨re et la partie du receveur est oÃ¹ les
canards en plastique finissent leur voyage. Une partie de votre code fait appel
Ã  des mÃ©thodes sur le transmetteur avec les donnÃ©es que vous souhaitez envoyer,
et une autre partie attends les messages Ã  l'arrivÃ©e. Un canal est dit <em>fermÃ©</em>
lorsque la partie correspondante au transmetteur ou la partie du rÃ©cepteur est
libÃ©rÃ©e.</p>
<!--
Here, weâ€™ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. Weâ€™ll be sending simple values between threads using a channel
to illustrate the feature. Once youâ€™re familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.
-->
<p>Ici, nous allons concevoir un programme qui a une tÃ¢che pour gÃ©nÃ©rer des
valeurs et les envoyer dans un canal, et une autre tÃ¢che qui va recevoir les
valeurs et les afficher. Nous allons envoyer de simples valeurs entre les
tÃ¢ches en utilisant un canal pour illustrer cette fonctionnalitÃ©. Une fois que
vous serez familier avec cette technique, vous pourrez utiliser les canaux
pour crÃ©er un systÃ¨me de dialogue en ligne ou un systÃ¨me oÃ¹ de nombreuses
tÃ¢ches font chacune une partie d'un gros calcul et envoient leur rÃ©sultat Ã  une
tÃ¢che chargÃ©e d'agrÃ©ger ces rÃ©sultats.</p>
<!--
First, in Listing 16-6, weâ€™ll create a channel but not do anything with it.
Note that this wonâ€™t compile yet because Rust canâ€™t tell what type of values we
want to send over the channel.
-->
<p>Pour commencer, dans l'encart 16-6, nous allons crÃ©er un canal mais nous
n'allons rien faire avec. Remarquez qu'il ne se compilera pas encore car Rust
ne peut pas savoir le type de valeurs que nous souhaitons envoyer dans le
canal.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<!--
<span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to `tx` and `rx`</span>
-->
<p><span class="caption">Encart 16-6Â : crÃ©ation d'un canal et assignation de ses
deux parties Ã  <code>tx</code> et <code>rx</code></span></p>
<!--
We create a new channel using the `mpsc::channel` function; `mpsc` stands for
*multiple producer, single consumer*. In short, the way Rustâ€™s standard library
implements channels means a channel can have multiple *sending* ends that
produce values but only one *receiving* end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. Weâ€™ll start with a single
producer for now, but weâ€™ll add multiple producers when we get this example
working.
-->
<p>Nous crÃ©ons un nouveau canal en utilisant la fonction <code>mpsc::channel</code>Â ; <code>mpsc</code>
signifie <em>multiple producer, single consumer</em>, c'est-Ã -dire
<em>plusieurs producteurs, un seul consommateur</em>. En bref, la faÃ§on dont la
bibliothÃ¨que standard de Rust a implÃ©mentÃ© ces canaux permet d'avoir plusieurs
extrÃ©mitÃ©s <em>Ã©mettrices</em> qui produisent des valeurs, mais seulement une seule
extrÃ©mitÃ© <em>rÃ©ceptrice</em> qui consomme ces valeurs. Immaginez plusieurs ruisseaux
qui se rejoignent en une seule grosse riviÃ¨reÂ : tout ce qui est dÃ©posÃ© sur les
ruisseaux va finir dans une seule riviÃ¨re Ã  la fin. Nous allons commencer avec
un seul producteur pour le moment, mais nous allons ajouter d'autres
producteurs lorsque notre exemple fonctionnera.</p>
<!--
The `mpsc::channel` function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations `tx`
and `rx` are traditionally used in many fields for *transmitter* and *receiver*
respectively, so we name our variables as such to indicate each end. Weâ€™re
using a `let` statement with a pattern that destructures the tuples; weâ€™ll
discuss the use of patterns in `let` statements and destructuring in Chapter
18. Using a `let` statement this way is a convenient approach to extract the
pieces of the tuple returned by `mpsc::channel`.
-->
<p>La fonction <code>mpsc::channel</code> retourne un tuple, le premier Ã©lÃ©ment est celui qui
permet d'envoyer et le second est celui qui reÃ§oit. Les abbrÃ©viations <code>tx</code> et
<code>rx</code> sont utilisÃ©s traditionnellement dans de nombreux domaines pour signifier
respectivement <em>transmetteur</em> et <em>rÃ©cepteur</em>, nous avons donc nommÃ© nos
variables comme ceci pour marquer chaque Ã©lÃ©ment.  Nous utilisons une
instruction <code>let</code> avec un motif qui dÃ©structure les tuplesÂ ; nous allons voir
l'utilisation des motifs dans les instructions <code>let</code> et la dÃ©structuration au
chapitre 18. L'utilisation d'une instruction <code>let</code> de cette maniÃ¨re est une
approche facile pour extraire les Ã©lÃ©ments du tuple retournÃ© par
<code>mpsc::channel</code>.</p>
<!--
Letâ€™s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.
-->
<p>DÃ©plaÃ§ons maintenant l'Ã©lÃ©ment de transmission dans une nouvelle tÃ¢che et
faisons-lui envoyer une chaÃ®ne de caractÃ¨res afin que la nouvelle tÃ¢che
communique avec la tÃ¢che principale, comme dans l'encart 16-7. C'est comme
poser un canard en plastique sur l'amont de la riviÃ¨re ou envoyer un message
instantanÃ© d'une tÃ¢che Ã  une autre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-7: Moving `tx` to a spawned thread and sending
â€œhiâ€</span>
-->
<p><span class="caption">Encart 16-7Â : dÃ©placement de <code>tx</code> dans la nouvelle tÃ¢che
et envoi de â€œsalutâ€</span></p>
<!--
Again, weâ€™re using `thread::spawn` to create a new thread and then using `move`
to move `tx` into the closure so the spawned thread owns `tx`. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.
-->
<p>Nous utilisons Ã  nouveau <code>thread::spawn</code> pour crÃ©er une nouvelle tÃ¢che et
ensuite utiliser <code>move</code> pour dÃ©placer <code>tx</code> dans la fermeture afin que la
nouvelle tÃ¢che possÃ¨de dÃ©sormais ``tx`. La nouvelle tÃ¢che a besoin de possÃ©der
la partie Ã©mettrice du canal pour Ãªtre en capacitÃ© d'envoyer des messages
dans ce canal.</p>
<!--
The transmitting end has a `send` method that takes the value we want to send.
The `send` method returns a `Result<T, E>` type, so if the receiving end has
already been dropped and thereâ€™s nowhere to send a value, the send operation
will return an error. In this example, weâ€™re calling `unwrap` to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.
-->
<p>La partie Ã©mettrice a une mÃ©thode <code>send</code> qui prend en argument la valeur que
nous souhaitons envoyer. La mÃ©thode <code>send</code> retourne un type <code>Result&lt;T, E&gt;</code>,
donc si la partie rÃ©ceptrice a dÃ©jÃ  Ã©tÃ© libÃ©rÃ©e et qu'il n'y a nulle part oÃ¹
envoyer la valeur, l'opÃ©ration d'envoi va retourner une erreur. Dans cet
exemple, nous faisons appel Ã  <code>unwrap</code> pour paniquer en cas d'erreur. Mais dans
un vrai programme, nous devrions gÃ©rer ce cas correctementÂ : retournez au
chapitre 9 pour revoir les stratÃ©gies pour gÃ©rer correctement les erreurs.</p>
<!--
In Listing 16-8, weâ€™ll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.
-->
<p>Dans l'encart 16-8, nous allons obtenir la valeur de l'extrÃ©mitÃ© rÃ©ceptrice du
canal dans la tÃ¢che principale. C'est comme rÃ©cupÃ©rer le canard en plastique
dans l'eau Ã  la fin de la riviÃ¨re, ou rÃ©cupÃ©rer un message instantanÃ©.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a reÃ§uÂ : {}&quot;, recu);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-8: Receiving the value â€œhiâ€ in the main thread
and printing it</span>
-->
<p><span class="caption">Encart 16-8Â : rÃ©ception de la valeur â€œsalutâ€ dans la
tÃ¢che principale pour l'afficher</span></p>
<!--
The receiving end of a channel has two useful methods: `recv` and `try_recv`.
Weâ€™re using `recv`, short for *receive*, which will block the main threadâ€™s
execution and wait until a value is sent down the channel. Once a value is
sent, `recv` will return it in a `Result<T, E>`. When the sending end of the
channel closes, `recv` will return an error to signal that no more values will
be coming.
-->
<p>La partie rÃ©ception d'un canal a deux modes intÃ©ressantsÂ : <code>recv</code> et
<code>try_recv</code>. Nous avons utilisÃ© <code>recv</code>, un raccourci pour <em>recevoir</em>, qui va
bloquer l'exÃ©cution de la tÃ¢che principale et attendre jusqu'Ã  ce qu'une valeur
soit envoyÃ©e dans le canal. Une fois qu'une valeur est envoyÃ©e, <code>recv</code> va
la retourner dans un <code>Result&lt;T, E&gt;</code>. Lorsque la partie transmission du canal se
ferme, <code>recv</code> va retourner une erreur pour signaler qu'il n'y aura plus de
valeurs qui arriveront.</p>
<!--
The `try_recv` method doesnâ€™t block, but will instead return a `Result<T, E>`
immediately: an `Ok` value holding a message if one is available and an `Err`
value if there arenâ€™t any messages this time. Using `try_recv` is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls `try_recv` every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.
-->
<p>La mÃ©thode <code>try_recv</code> ne bloque pas, mais va plutÃ´t retourner immÃ©diatement un
<code>Result&lt;T, E&gt;</code>Â : une valeur <code>Ok</code> qui contiendra un message s'il y en a un de
disponible, et une valeur <code>Err</code> s'il n'y a pas de message cette fois-ci.
L'utilisation de <code>try_recv</code> est pratique si cette tÃ¢che Ã  d'autres choses Ã 
faire pendant qu'elle attend les messagesÂ : nous pouvons ainsi Ã©crire une
boucle qui appelle rÃ©guliÃ¨rement <code>try_recv</code>, gÃ¨re le message s'il y en a un, et
sinon fait d'autres choses jusqu'Ã  ce qu'elle vÃ©rifiera Ã  nouveau.</p>
<!--
Weâ€™ve used `recv` in this example for simplicity; we donâ€™t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.
-->
<p>Nous avons utilisÃ© <code>recv</code> dans cet exemple pour des raisons de simplicitÃ©Â ;
nous n'avons rien d'autres Ã  faire dans la tÃ¢che principale que d'attendre les
messages, donc bloquer la tÃ¢che principale est acceptable.</p>
<!--
When we run the code in Listing 16-8, weâ€™ll see the value printed from the main
thread:
-->
<p>Lorsque nous exÃ©cutons le code de l'encart 16-8, nous allons voir la valeur
s'afficher grÃ¢ce Ã  la tÃ¢che principaleÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
```
-->
<pre><code class="language-text">On a reÃ§uÂ : salut
</code></pre>
<!--
Perfect!
-->
<p>C'est parfait ainsiÂ !</p>
<!--
### Channels and Ownership Transference
-->
<h3><a class="header" href="#les-canaux-et-le-transfert-de-possession" id="les-canaux-et-le-transfert-de-possession">Les canaux et le transfert de possession</a></h3>
<!--
The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Letâ€™s do
an experiment to show how channels and ownership work together to prevent
problems: weâ€™ll try to use a `val` value in the spawned thread *after* weâ€™ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isnâ€™t allowed:
-->
<p>Les rÃ¨gles de possession jouent un rÃ´le vital dans l'envoi de messages car
elles vous aident Ã  Ã©crire du code sÃ»r et concurrent. RÃ©flÃ©chir Ã  la possession
avec vos programmes Rust vous offre l'avantage d'Ã©viter des erreurs de
dÃ©veloppement avec la concurrence. Faisons une expÃ©rience pour montrer comment
la possession et les canaux fonctionnent ensemble pour Ã©viter les problÃ¨mesÂ :
nous allons essayer d'utiliser la <code>valeur</code> dans la nouvelle tÃ¢che <em>aprÃ¨s</em> que
nous l'ayons envoyÃ© dans le canal. Essayez de compiler le code de l'encart 16-9
pour dÃ©couvrir pourquoi ce code n'est pas autorisÃ©Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;hi&quot;);
        tx.send(valeur).unwrap();
        println!(&quot;valeur vaut {}&quot;, valeur);
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a reÃ§uÂ : {}&quot;, recu);
}
</code></pre>
<!--
<span class="caption">Listing 16-9: Attempting to use `val` after weâ€™ve sent it
down the channel</span>
-->
<p><span class="caption">Encart 16-9Â : tentative d'utiliser <code>valeur</code> aprÃ¨s que
nous l'ayons envoyÃ© dans le canal</span></p>
<!--
Here, we try to print `val` after weâ€™ve sent it down the channel via `tx.send`.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other threadâ€™s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:
-->
<p>Ici, nous essayons d'afficher <code>valeur</code> aprÃ¨s que nous l'ayons envoyÃ© dans le
canal avec <code>tx.send</code>. Ce serait une mauvaise idÃ©e de permettre celaÂ : une fois
que la valeur a Ã©tÃ© envoyÃ©e Ã  une autre tÃ¢che, cette tÃ¢che peut la modifier ou
la libÃ©rer avant que nous essayons de l'utiliser Ã  nouveau. Il est possible que
des modifications de l'autre tÃ¢che puissent causer des erreurs ou des rÃ©sultats
inattendus Ã  cause de donnÃ©es incohÃ©rentes ou manquantes. Toutefois, Rust nous
affiche une erreur si nous essayons de compiler le code de l'encart 16-9Â :</p>
<!--
```console
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  -- > src/main.rs:10:31
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `std::string::String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {}", val);
   |                               ^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `valeur`
  --&gt; src/main.rs:10:31
   |
8  |         let valeur = String::from(&quot;salut&quot;);
   |             ------ move occurs because `valeur` has type `std::string::String`, which does not implement the `Copy` trait
9  |         tx.send(valeur).unwrap();
   |                 ------ value moved here
10 |         println!(&quot;valeur vaut {}&quot;, valeur);
   |                                    ^^^^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Our concurrency mistake has caused a compile time error. The `send` function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.
-->
<p>Notre erreur de concurrence a provoquÃ© une erreur Ã  la compilation. La fonction
<code>send</code> prend possession de ses paramÃ¨tres, et lorsque la valeur est dÃ©placÃ©e,
le rÃ©cepteur en prend possession. Cela nous Ã©vite d'utiliser Ã  nouveau
accidentellement la valeur aprÃ¨s l'avoir envoyÃ©eÂ ; le systÃ¨me de possession
vÃ©rifie que tout est en ordre.</p>
<!--
### Sending Multiple Values and Seeing the Receiver Waiting
-->
<h3><a class="header" href="#envoyer-plusieurs-valeurs-et-voir-le-rÃ©cepteur-les-attendre" id="envoyer-plusieurs-valeurs-et-voir-le-rÃ©cepteur-les-attendre">Envoyer plusieurs valeurs et voir le rÃ©cepteur les attendre</a></h3>
<!--
The code in Listing 16-8 compiled and ran, but it didnâ€™t clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 weâ€™ve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.
-->
<p>Le code de l'encart 16-8 s'est compilÃ© et exÃ©cutÃ©, mais il ne nous a pas
clairement indiquÃ© que deux tÃ¢ches sÃ©parÃ©es communiquaient entre elles via le
canal. Dans l'encart 16-10 nous avons fait quelques modifications qui prouvent
que le code de l'encart 16-8 est exÃ©cutÃ© avec de la concurrenceÂ : la nouvelle
tÃ¢che va maintenant envoyer plusieurs messages et faire une pause d'une seconde
entre chaque message.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;Ã  partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle tÃ¢che&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a reÃ§uÂ : {}&quot;, recu);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span>
-->
<p><span class="caption">Encart 16-10Â : envoi de plusieurs messages en faisant une
pause entre chacun</span></p>
<!--
This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the `thread::sleep` function with a `Duration` value of
1 second.
-->
<p>Cette fois-ci, la nouvelle tÃ¢che a un vecteur de chaÃ®nes de caractÃ¨res que nous
souhaitons envoyer Ã  la tÃ¢che principale. Nous itÃ©rons sur celui-ci, on les
envoie individuellement, et on fait une pause entre chaque envoi en appelant la
fonction <code>thread::sleep</code> avec une valeur <code>Duration</code> de 1 seconde.</p>
<!--
In the main thread, weâ€™re not calling the `recv` function explicitly anymore:
instead, weâ€™re treating `rx` as an iterator. For each value received, weâ€™re
printing it. When the channel is closed, iteration will end.
-->
<p>Dans la tÃ¢che principale, nous n'appelons plus explicitement la fonction
<code>recv</code>Â : Ã  la place, nous utilisons <code>rx</code> comme un itÃ©rateur. Pour chaque valeur
reÃ§ue, nous l'affichons. Lorsque le canal se fermera, l'itÃ©ration se terminera.</p>
<!--
When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:
-->
<p>Lorsque nous exÃ©cutons le code de l'encart 16-10, nous devrions voir la sortie
suivante, avec une pause de 1 seconde entre chaque ligneÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: from
Got: the
Got: thread
```
-->
<pre><code class="language-text">On a reÃ§uÂ : salutations
On a reÃ§uÂ : Ã  partir
On a reÃ§uÂ : de la
On a reÃ§uÂ : nouvelle tÃ¢che
</code></pre>
<!--
Because we donâ€™t have any code that pauses or delays in the `for` loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.
-->
<p>Comme nous n'avons pas de code qui met en pause ou retarde la boucle <code>for</code> de
la tÃ¢che principale, nous pouvons dire que la tÃ¢che principale est en attente
de rÃ©ception des valeurs de la part de la nouvelle tÃ¢che.</p>
<!--
### Creating Multiple Producers by Cloning the Transmitter
-->
<h3><a class="header" href="#crÃ©er-plusieurs-producteurs-en-clonant-le-transmetteur" id="crÃ©er-plusieurs-producteurs-en-clonant-le-transmetteur">CrÃ©er plusieurs producteurs en clonant le transmetteur</a></h3>
<!--
Earlier we mentioned that `mpsc` was an acronym for *multiple producer,
single consumer*. Letâ€™s put `mpsc` to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:
-->
<p>PrÃ©cÃ©demment, nous avions Ã©voquÃ© que <code>mpsc</code> Ã©tait un acronyme pour
<em>multiple producer, single consumer</em>. Mettons <code>mpsc</code> en Å“uvre en Ã©largissant le
code de l'encart 16-10 pour crÃ©er plusieurs tÃ¢ches qui vont toutes envoyer des
valeurs au mÃªme rÃ©cepteur. Nous pouvons faire ceci en clonant la partie
Ã©mettrice du canal, comme dans l'encart 16-11Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&tx);
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }

    // --snip--
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // -- partie masquÃ©e ici --

    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&amp;tx);
    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;Ã  partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle tÃ¢che&quot;),
        ];

        for valeur in valeurs {
            tx1.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;encore plus&quot;),
            String::from(&quot;de messages&quot;),
            String::from(&quot;pour&quot;),
            String::from(&quot;vous&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a reÃ§uÂ : {}&quot;, recu);
    }

    // -- partie masquÃ©e ici --
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span>
-->
<p><span class="caption">Encart 16-11Â : envoi de plusieurs messages Ã  partir de
plusieurs producteurs</span></p>
<!--
This time, before we create the first spawned thread, we call `clone` on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.
-->
<p>Cette fois-ci, avant de crÃ©er la premiÃ¨re nouvelle tÃ¢che, nous appelons <code>clone</code>
sur la partie Ã©mettrice du canal. Cela va nous donner un nouveau transmetteur
que nous pourrons passer Ã  la seconde nouvelle tÃ¢che. Cela va nous donner deux
tÃ¢ches, chacune envoyant des messages diffÃ©rents Ã  la partie rÃ©ceptrice du
canal.</p>
<!--
When you run the code, your output should look something like this:
-->
<p>Lorsque vous exÃ©cuterez ce code, votre sortie devrait ressembler Ã  ceciÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```
-->
<pre><code class="language-text">On a reÃ§uÂ : salutations
On a reÃ§uÂ : encore plus
On a reÃ§uÂ : de messages
On a reÃ§uÂ : pour
On a reÃ§uÂ : Ã  partir
On a reÃ§uÂ : de la
On a reÃ§uÂ : nouvelle tÃ¢che
On a reÃ§uÂ : pour vous
</code></pre>
<!--
You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
`thread::sleep`, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.
-->
<p>Vous pourrez peut-Ãªtre constater que les valeurs sont dans un autre ordre chez
vousÂ ; cela dÃ©pend de votre systÃ¨me. C'est ce qui rend la concurrence aussi
intÃ©ressante que difficile. Si vous jouez avec la valeur de <code>thread::sleep</code> en
lui donnant diffÃ©rentes valeurs dans diffÃ©rentes tÃ¢ches, chaque exÃ©cution sera
encore moins dÃ©terminÃ©e et crÃ©era une sortie diffÃ©rente Ã  chaque fois.</p>
<!--
Now that weâ€™ve looked at how channels work, letâ€™s look at a different method of
concurrency.
-->
<p>Maintenant que nous avons dÃ©couvert le fonctionnement des canaux, examinons un
autre genre de concurrence.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--35" id="-attention-peinture-fraÃ®che--35">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/199">Pull Request</a>.</p>
</blockquote>
<!--
## Shared-State Concurrency
-->
<h2><a class="header" href="#le-partage-dÃ©tat-en-concurrence" id="le-partage-dÃ©tat-en-concurrence">Le partage d'Ã©tat en concurrence</a></h2>
<!--
Message passing is a fine way of handling concurrency, but itâ€™s not the only
one. Consider this part of the slogan from the Go language documentation again:
â€œdo not communicate by sharing memory.â€
-->
<p>L'envoi de messages est un assez bon moyen de gestion de la concurrence, mais il
n'y a pas qu'un seul. Repensons Ã  cette partie du slogan de la documentation du
langage GoÂ : â€œne communiquez pas en partageant la mÃ©moireâ€.</p>
<!--
What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?
-->
<p>A quoi ressemble le partage de mÃ©moire pour communiquerÂ ? De plus, pourquoi les
partisans de l'envoi de messages ne devraient pas l'utiliser et faire plutÃ´t
le contraireÂ ?</p>
<!--
In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rustâ€™s type system
and ownership rules greatly assist in getting this management correct. For an
example, letâ€™s look at mutexes, one of the more common concurrency primitives
for shared memory.
-->
<p>De maniÃ¨re gÃ©nÃ©rale, les canaux dans les langages de programmation ressemble Ã 
la possession unique, car une fois que vous avez transfÃ©rÃ© une valeur dans un
canal, vous ne pouvez plus utiliser cette valeur. Le partage de mÃ©moire en
concurrence est comme de la possession multipleÂ : plusieurs tÃ¢ches peuvent
accÃ©der au mÃªme endroit de la mÃ©moire en mÃªme temps. Comme vous l'avez vu au
chapitre 15, dans lequel les pointeurs intelligents rendent possible la
possession multiple, la possession multiple peut rajouter de la complexitÃ© car
ces diffÃ©rents propriÃ©taires ont besoin d'Ãªtre gÃ©rÃ©s. Le systÃ¨me de type de Rust
et les rÃ¨gles de possession aident beaucoup Ã  les gÃ©rer correctement. Par
exemple, dÃ©couvrons les mutex, une des primitives les plus courantes pour
partager la mÃ©moire.</p>
<!--
### Using Mutexes to Allow Access to Data from One Thread at a Time
-->
<h3><a class="header" href="#utiliser-les-mutex-pour-permettre-laccÃ¨s-Ã -la-donnÃ©e-Ã -une-seule-tÃ¢che-Ã -la-fois" id="utiliser-les-mutex-pour-permettre-laccÃ¨s-Ã -la-donnÃ©e-Ã -une-seule-tÃ¢che-Ã -la-fois">Utiliser les mutex pour permettre l'accÃ¨s Ã  la donnÃ©e Ã  une seule tÃ¢che Ã  la fois</a></h3>
<!--
*Mutex* is an abbreviation for *mutual exclusion*, as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutexâ€™s *lock*. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as *guarding* the data it holds via the locking system.
-->
<p><em>Mutex</em> est une abrÃ©viation pour <em>mutual exclusion</em>, ce qui veut dire qu'un
mutex ne permet qu'Ã  une seule tÃ¢che d'accÃ©der Ã  une donnÃ©e en mÃªme temps. Pour
accÃ©der Ã  la donnÃ©e dans un mutex, une tÃ¢che doit d'abord signaler qu'elle
souhaite y accÃ©der en demandant l'obtention du <em>verrou</em> du mutex. Le verrou est
une structure de donnÃ©e qui fait partie du mutex qui assure le suivi de qui a
actuellement accÃ¨s Ã  la donnÃ©e. Par consÃ©quent, le mutex est qualifiÃ© de
<em>gardien</em> de la donnÃ©e qu'il renferme via le systÃ¨me de verrou.</p>
<!--
Mutexes have a reputation for being difficult to use because you have to
remember two rules:
-->
<p>Les mutex ont la rÃ©putation d'Ãªtre difficiles Ã  utiliser car vous devez veiller
Ã  deux rÃ¨glesÂ :</p>
<!--
* You must attempt to acquire the lock before using the data.
* When youâ€™re done with the data that the mutex guards, you must unlock the
  data so other threads can acquire the lock.
-->
<ul>
<li>Vous devez obtenir le verrou avant d'utiliser la donnÃ©e.</li>
<li>Lorsque vous avez fini avec la donnÃ©e que le mutex garde, vous devez
dÃ©verrouiller la donnÃ©e afin que d'autres tÃ¢ches puissent obtenir le verrou.</li>
</ul>
<!--
For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when theyâ€™re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel wonâ€™t work
as planned!
-->
<p>Pour faire une mÃ©taphore de la vie courante d'un mutex, imaginez une table ronde
lors d'une confÃ©rence avec un seul microphone. Avant qu'un participant puisse
parler, il doit demander ou signaler qu'il veut utiliser le micro. Lorsqu'il
obtient le micro, il peut parler aussi longtemps qu'il le souhaite et ensuite
passer le micro au prochain participant qui a demandÃ© Ã  pouvoir parler. Si un
participant oublie de rendre le micro aprÃ¨s avoir fini de parler, personne
d'autre ne peut parler. Si la gestion du micro partagÃ© se passe mal, la table
ronde ne fonctionnera pas comme prÃ©vuÂ !</p>
<!--
Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rustâ€™s type
system and ownership rules, you canâ€™t get locking and unlocking wrong.
-->
<p>La gestion des mutex peut devenir incroyable compliquÃ©e, c'est pourquoi tant de
personnes sont partisanes des canaux. Cependant, grÃ¢ce au systÃ¨me de type de
Rust et aux rÃ¨gles de possession, vous ne pouvez pas vous tromper dans le
verrouillage et dÃ©verrouillage.</p>
<!--
#### The API of `Mutex<T>`
-->
<h4><a class="header" href="#lapi-des-mutext" id="lapi-des-mutext">L'API des <code>Mutex&lt;T&gt;</code></a></h4>
<!--
As an example of how to use a mutex, letâ€™s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:
-->
<p>Pour illustrer l'utilisation d'un mutex, commenÃ§ons par utiliser un mutex dans
le contexte d'une seule tÃ¢che, comme dans l'encart 16-12Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut nombre = m.lock().unwrap();
        *nombre = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-12: Exploring the API of `Mutex<T>` in a
single-threaded context for simplicity</span>
-->
<p><span class="caption">Encart 16-12Â : dÃ©couverte de l'API de <code>Mutex&lt;T&gt;</code> dans le
contexte d'une seule tÃ¢che pour raison de simplicitÃ©</span></p>
<!--
As with many types, we create a `Mutex<T>` using the associated function `new`.
To access the data inside the mutex, we use the `lock` method to acquire the
lock. This call will block the current thread so it canâ€™t do any work until
itâ€™s our turn to have the lock.
-->
<p>Comme avec beaucoup de types, nous crÃ©ons un <code>Mutex&lt;T&gt;</code> en utilisant la
fonction associÃ©e <code>new</code>. Pour accÃ©der Ã  la donnÃ©e dans le mutex, nous utilisons
la mÃ©thode <code>lock</code> pour obtenir le verrou. Cela va bloquer la tÃ¢che courante,
donc elle ne s'exÃ©cutera plus tant que ce n'est Ã  notre tour d'avoir le verrou.</p>
<!--
The call to `lock` would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so weâ€™ve chosen to
`unwrap` and have this thread panic if weâ€™re in that situation.
-->
<p>L'appel Ã  <code>lock</code> va Ã©chouer dans le cas oÃ¹ une autre tÃ¢che qui avait le verrou
paniquerait. Dans ce cas, personne ne pourra obtenir le verrou, donc nous avons
choisi d'utiliser <code>unwrap</code> pour faire en sorte que cette tÃ¢che panique si elle
est dans cette situation.</p>
<!--
After weâ€™ve acquired the lock, we can treat the return value, named `num` in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in `m`: `Mutex<i32>` is not an
`i32`, so we *must* acquire the lock to be able to use the `i32` value. We
canâ€™t forget; the type system wonâ€™t let us access the inner `i32` otherwise.
-->
<p>AprÃ¨s avoir obtenu le verrou, nous pouvons utiliser la valeur de retour comme
une rÃ©fÃ©rence mutable vers la donnÃ©e, qui s'appellera <code>nombre</code> dans ce cas. Le
systÃ¨me de type s'assure que nous obtenons le verrou avant d'utiliser la valeur
prÃ©sente dans <code>m</code>Â : le <code>Mutex&lt;i32&gt;</code> n'est pas un <code>i32</code>, donc nous <em>devons</em>
obtenir le verrou pour pouvoir utiliser la valeur <code>i32</code>. Nous ne pouvons pas
l'oublierÂ ; le systÃ¨me de type ne nous laissera pas accÃ©der au <code>i32</code> Ã 
l'intÃ©rieur de toute faÃ§on.</p>
<!--
As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the call
to `lock` *returns* a smart pointer called `MutexGuard`, wrapped in a
`LockResult` that we handled with the call to `unwrap`. The `MutexGuard` smart
pointer implements `Deref` to point at our inner data; the smart pointer also
has a `Drop` implementation that releases the lock automatically when a
`MutexGuard` goes out of scope, which happens at the end of the inner scope in
Listing 16-12. As a result, we donâ€™t risk forgetting to release the lock and
blocking the mutex from being used by other threads because the lock release
happens automatically.
-->
<p>Comme vous pouvez vous en douter, <code>Mutex&lt;T&gt;</code> est un pointeur intelligent. Plus
prÃ©cisÃ©ment, l'appel Ã  <code>lock</code> <em>retourne</em> un pointeur intelligent <code>MutexGuard</code>,
intÃ©grÃ© dans un <code>LockResult</code> que nous avons gÃ©rÃ© en faisant appel Ã  <code>unwrap</code>.
Le pointeur intelligent <code>MutexGuard</code> implÃ©mente <code>Deref</code> pour pouvoir pointer
sur la donnÃ©e interneÂ ; ce pointeur intelligent implÃ©mente aussi <code>Drop</code> qui
libÃ¨re le verrou automatiquement lorsqu'un <code>MutexGuard</code> sort de la portÃ©e, ce
qui arrive Ã  la fin de la portÃ©e interne dans l'encart 16-12. Au final, nous ne
risquons d'oublier de rendre le verrou et ainsi bloquer l'utilisation du mutex
par les autres tÃ¢ches car la libÃ©ration du verrou se produit automatiquement.</p>
<!--
After dropping the lock, we can print the mutex value and see that we were able
to change the inner `i32` to 6.
-->
<p>AprÃ¨s avoir libÃ©rÃ© le verrou, nous pouvons afficher la valeur dans le mutex et
constater que nous avons pu changer la valeur interne du <code>i32</code> Ã  <code>6</code>.</p>
<!--
#### Sharing a `Mutex<T>` Between Multiple Threads
-->
<h4><a class="header" href="#partager-un-mutext-entre-plusieurs-tÃ¢ches" id="partager-un-mutext-entre-plusieurs-tÃ¢ches">Partager un <code>Mutex&lt;T&gt;</code> entre plusieurs tÃ¢ches</a></h4>
<!--
Now, letâ€™s try to share a value between multiple threads using `Mutex<T>`.
Weâ€™ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. The next example in Listing 16-13 will have
a compiler error, and weâ€™ll use that error to learn more about using
`Mutex<T>` and how Rust helps us use it correctly.
-->
<p>Essayons maintenant de partager une valeur entre plusieurs tÃ¢ches en utilisant
<code>Mutex&lt;T&gt;</code>. Nous allons faire fonctionner 10 tÃ¢ches et faire en sorte que
chacune augmente la valeur du compteur de 1, donc le compteur va passer de 0
Ã  10. Le prochain exemple dans l'encart 16-13 dÃ©bouchera sur une erreur de
compilation, et nous allons utiliser cette erreur pour en apprendre plus sur
l'utilisation de <code>Mutex&lt;T&gt;</code> et sur comment Rust nous aide Ã  l'utiliser
correctement.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let compteur = Mutex::new(0);
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;ResultatÂ : {}&quot;, *compteur.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a `Mutex<T>`</span>
-->
<p><span class="caption">Encart 16-13Â : dix tÃ¢ches qui augmentent chacune un
compteur gardÃ© par un <code>Mutex&lt;T&gt;</code></span></p>
<!--
We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we
did in Listing 16-12. Next, we create 10 threads by iterating over a range
of numbers. We use `thread::spawn` and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the `Mutex<T>`
by calling the `lock` method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, `num` will go out of scope and release the
lock so another thread can acquire it.
-->
<p>Nous avons crÃ©Ã© une variable <code>compteur</code> pour stocker un <code>i32</code> dans un
<code>Mutex&lt;T&gt;</code>, comme nous l'avons fait dans l'encart 16-12. Ensuite, nous crÃ©ons
10 tÃ¢ches en itÃ©rant sur un intervalle de nombres. Nous utilisons
<code>thread::spawn</code> et nous donnons Ã  toutes les tÃ¢ches la mÃªme fermeture, qui
dÃ©place le compteur dans la tÃ¢che, obtient le verrou sur le <code>Mutex&lt;T&gt;</code> en
faisant appel Ã  la mÃ©thode <code>lock</code>, et on ajoute ensuite 1 Ã  la valeur prÃ©sente
dans le mutex. Lorsqu'une tÃ¢che finit d'exÃ©cuter sa fermeture, <code>nombre</code> va
sortir de la portÃ©e et va libÃ©rer le verrou afin qu'une autre tÃ¢che puisse
l'obtenir.</p>
<!--
In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call `join` on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.
-->
<p>Dans la tÃ¢che principale, nous collectons tous les manipulateurs. Ensuite,
comme nous l'avions fait dans l'encart 16-2, nous faisons appel Ã  <code>join</code> sur
chaque manipulateur pour s'assurer que toutes les tÃ¢ches ont fini. Une fois que
c'est le cas, la tÃ¢che principale va obtenir le verrou et afficher le rÃ©sultat
de ce programme.</p>
<!--
We hinted that this example wouldnâ€™t compile. Now letâ€™s find out why!
-->
<p>Nous avions mentionnÃ© que cet exemple ne se compilerait pas. DÃ©couvrons
maintenant pourquoiÂ !</p>
<!--
```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  -- > src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `std::sync::Mutex<i32>`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `compteur`
  --&gt; src/main.rs:9:36
   |
5  |     let compteur = Mutex::new(0);
   |         -------- move occurs because `compteur` has type `std::sync::Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let manipulateur = thread::spawn(move || {
   |                                          ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut nombre = compteur.lock().unwrap();
   |                              -------- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error message states that the `counter` value was moved in the previous
iteration of the loop. So Rust is telling us that we canâ€™t move the ownership
of lock `counter` into multiple threads. Letâ€™s fix the compiler error with a
multiple-ownership method we discussed in Chapter 15.
-->
<p>Le message d'erreur signale que la valeur <code>compteur</code> a Ã©tÃ© dÃ©placÃ©e dans
l'itÃ©ration prÃ©cÃ©dente de la boucle. Donc Rust nous explique qu'il ne peut
pas dÃ©placer la possession du verrou de <code>compteur</code> dans plusieurs tÃ¢ches.
Corrigeons cette erreur de compilation avec une mÃ©thode pour avoir plusieurs
propriÃ©taires que nous avons vu au chapitre 15.</p>
<!--
#### Multiple Ownership with Multiple Threads
-->
<h4><a class="header" href="#plusieurs-propriÃ©taires-avec-plusieurs-tÃ¢ches" id="plusieurs-propriÃ©taires-avec-plusieurs-tÃ¢ches">Plusieurs propriÃ©taires avec plusieurs tÃ¢ches</a></h4>
<!--
In Chapter 15, we gave a value multiple owners by using the smart pointer
`Rc<T>` to create a reference counted value. Letâ€™s do the same here and see
what happens. Weâ€™ll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and clone
the `Rc<T>` before moving ownership to the thread. Now that weâ€™ve seen the
errors, weâ€™ll also switch back to using the `for` loop, and weâ€™ll keep the
`move` keyword with the closure.
-->
<p>Dans le chapitre 15, nous avons assignÃ© plusieurs propriÃ©taires Ã  une valeur
en utilisant le pointeur intelligent <code>Rc&lt;T&gt;</code> pour crÃ©er un compteur de
rÃ©fÃ©rence. Faisons la mÃªme chose ici et voyons ce qui se passe. Nous allons
intÃ©grer le <code>Mutex&lt;T&gt;</code> dans un <code>Rc&lt;T&gt;</code> dans l'encart 16-14 et cloner le <code>Rc&lt;T&gt;</code>
avant de dÃ©placer sa possession Ã  la tÃ¢che. Maintenant que nous avons vu les
erreurs, nous allons aussi revenir Ã  l'utilisation de la boucle <code>for</code> et nous
allons garder le mot-clÃ© <code>move</code> dans la fermeture.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let compteur = Rc::new(Mutex::new(0));
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let compteur = Rc::clone(&amp;compteur);
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;RÃ©sultatÂ : {}&quot;, *compteur.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-14: Attempting to use `Rc<T>` to allow
multiple threads to own the `Mutex<T>`</span>
-->
<p><span class="caption">Encart 16-14Â : tentative d'utilisation d'un <code>Rc&lt;T&gt;</code> pour
nous permettre d'utiliser plusieurs tÃ¢ches qui possÃ©deront le <code>Mutex&lt;T&gt;</code></span></p>
<!--
Once again, we compile and get... different errors! The compiler is teaching us
a lot.
-->
<p>A nouveau, nous compilons et nous obtenons ... une erreur diffÃ©renteÂ ! Le
compilateur nous en apprend beaucoup.</p>
<!--
```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
   -- > src/main.rs:11:22
    |
11  |         let handle = thread::spawn(move || {
    |                      ^^^^^^^^^^^^^ `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
    |
    = help: within `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc<std::sync::Mutex<i32>>]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::sync::Mutex<i32>>`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc<std::sync::Mutex<i32>>]`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |         let manipulateur = thread::spawn(move || {
    |                            ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Wow, that error message is very wordy! Hereâ€™s the important part to focus
on: `` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. The compiler
is also telling us the reason why: ``the trait `Send` is not implemented for
`Rc<Mutex<i32>>` ``. Weâ€™ll talk about `Send` in the next section: itâ€™s one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.
-->
<p>Ouah, ce message d'erreur est trÃ¨s bavardÂ ! Voici la partie la plus importante
sur laquelle se concentrerÂ :
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. Le compilateur
nous indique aussi pour quelle raisonÂ :
<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>. Nous allons voir
<code>Send</code> dans la prochaine sectionÂ : c'est l'un des traits qui garantissent que le
type que nous utilisons avec les tÃ¢ches est prÃ©vu pour Ãªtre utilisÃ© dans des
situations de concurrence.</p>
<!--
Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>`
manages the reference count, it adds to the count for each call to `clone` and
subtracts from the count when each clone is dropped. But it doesnâ€™t use any
concurrency primitives to make sure that changes to the count canâ€™t be
interrupted by another thread. This could lead to wrong countsâ€”subtle bugs that
could in turn lead to memory leaks or a value being dropped before weâ€™re done
with it. What we need is a type exactly like `Rc<T>` but one that makes changes
to the reference count in a thread-safe way.
-->
<p>Malheureusement, <code>Rc&lt;T&gt;</code> n'est pas sÃ»r pour l'utilisation entre des tÃ¢ches.
Lorsque <code>Rc&lt;T&gt;</code> gÃ¨re le compteur de rÃ©fÃ©rences, il incrÃ©mente le compteur autant
de fois que nous avons fait appel Ã  <code>clone</code> et dÃ©crÃ©mente le compteur Ã  chaque
fois qu'un clone est libÃ©rÃ©. Mais il n'utilise pas de primitives de concurrence
pour s'assurer que les changements faits au compteur ne peuvent pas Ãªtre
interrompus par une autre tÃ¢che. Cela pourrait provoquer subtilement des bogues
Ã  cause d'une mauvaise gestion du compteur, qui pourraient provoquer des fuites
de mÃ©moire ou faire en sorte qu'une valeur soit libÃ©rÃ©e avant que nous ayons
fini de l'utiliser. Nous avons besoin d'un type exactement comme <code>Rc&lt;T&gt;</code> mais
qui procÃ¨de aux changements du compteur de rÃ©fÃ©rences de maniÃ¨re sÃ»r dans des
situations concurrentes.</p>
<!--
#### Atomic Reference Counting with `Arc<T>`
-->
<h4><a class="header" href="#compteur-de-rÃ©fÃ©rence-atomique-avec-arct" id="compteur-de-rÃ©fÃ©rence-atomique-avec-arct">Compteur de rÃ©fÃ©rence atomique avec <code>Arc&lt;T&gt;</code></a></h4>
<!--
Fortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in
concurrent situations. The *a* stands for *atomic*, meaning itâ€™s an *atomically
reference counted* type. Atomics are an additional kind of concurrency
primitive that we wonâ€™t cover in detail here: see the standard library
documentation for [`std::sync::atomic`] for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.
-->
<p>Heureusement, <code>Arc&lt;T&gt;</code> <em>est</em> un type comme <code>Rc&lt;T&gt;</code> qui est sÃ»r lors de
situations concurrentes. Le <em>A</em> signifie <em>atomique</em>, ce qui signifie que c'est
le type <em>compteur de rÃ©fÃ©rences atomique</em>. L'atome est une sorte de primitive
concurrente que nous n'allons pas aborder en dÃ©tails iciÂ : rendez-vous dans la
documentation de la bibliothÃ¨que standard sur <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a> pour en
savoir plus. Pour le moment, vous avez juste besoin de retenir que les atomes
fonctionnent comme les types primitifs mais qui son sÃ»rs pour l'Ã©change entre
les tÃ¢ches.</p>
<!--
[`std::sync::atomic`]: ../std/sync/atomic/index.html
-->
<!--
You might then wonder why all primitive types arenâ€™t atomic and why standard
library types arenâ€™t implemented to use `Arc<T>` by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If youâ€™re just performing operations on values within a
single thread, your code can run faster if it doesnâ€™t have to enforce the
guarantees atomics provide.
-->
<p>Vous vous demandez pourquoi tous les types primitifs ne sont pas atomiques et
pourquoi les types de la bibliothÃ¨que standard ne sont pas implÃ©mentÃ©s en
utilisant <code>Arc&lt;T&gt;</code> par dÃ©faut. La raison Ã  cela est que la sÃ©curitÃ© entre les
tÃ¢ches a un coÃ»t sur les performances que vous n'Ãªtes prÃªt Ã  payer que lorsque
vous en avez besoin. Si vous procÃ©dez Ã  des opÃ©rations sur des valeurs
uniquement dans une seule tÃ¢che, votre code va s'exÃ©cuter plus vite car il n'a
pas besoin de garantir de que les atomes fournissent.</p>
<!--
Letâ€™s return to our example: `Arc<T>` and `Rc<T>` have the same API, so we fix
our program by changing the `use` line, the call to `new`, and the call to
`clone`. The code in Listing 16-15 will finally compile and run:
-->
<p>Retournons Ã  notre exempleÂ : <code>Arc&lt;T&gt;</code> et <code>Rc&lt;T&gt;</code> ont la mÃªme API, donc
corrigeons notre programme en changeant la ligne <code>use</code>, l'appel Ã  <code>new</code>, et
l'appel Ã  <code>clone</code>. Le code dans l'encart 16-15 va finalement se compiler et
s'exÃ©cuterÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let compteur = Arc::new(Mutex::new(0));
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let compteur = Arc::clone(&amp;compteur);
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;RÃ©sultatÂ : {}&quot;, *compteur.lock().unwrap());
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-15: Using an `Arc<T>` to wrap the `Mutex<T>`
to be able to share ownership across multiple threads</span>
-->
<p><span class="caption">Encart 16-15Â : utilisation d'un <code>Arc&lt;T&gt;</code> pour englober
le <code>Mutex&lt;T&gt;</code> afin de partager la possession entre plusieurs tÃ¢ches</span></p>
<!--
This code will print the following:
-->
<p>Ce code va finalement afficher ceciÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Result: 10
```
-->
<pre><code class="language-text">ResultatÂ : 10
</code></pre>
<!--
We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about `Mutex<T>` and thread safety. You could also use this
programâ€™s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a `Mutex<T>` to have each
thread update the final result with its part.
-->
<p>Nous y sommes arrivÃ©sÂ ! Nous avons comptÃ© de 0 Ã  10, ce qui ne semble pas trÃ¨s
impressionnant, mais cela nous a appris beaucoup sur <code>Mutex&lt;T&gt;</code> et la sÃ©curitÃ©
entre les tÃ¢ches. Vous pouvez aussi utiliser cette structure de programme pour
procÃ©der Ã  des opÃ©rations plus complexes que simplement incrÃ©menter un
compteur. En utilisant cette stratÃ©gie, vous pouvez diviser un calcul en
diffÃ©rentes parties, rÃ©partir ces parties sur des tÃ¢ches, et ensuite utiliser
un <code>Mutex&lt;T&gt;</code> pour faire en sorte que chaque tÃ¢che mette Ã  jour le rÃ©sultat
final avec sa propre partie.</p>
<!--
### Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`
-->
<h3><a class="header" href="#similaritÃ©s-entre-refcelltrct-et-mutextarct" id="similaritÃ©s-entre-refcelltrct-et-mutextarct">SimilaritÃ©s entre <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> et <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<!--
You might have noticed that `counter` is immutable but we could get a mutable
reference to the value inside it; this means `Mutex<T>` provides interior
mutability, as the `Cell` family does. In the same way we used `RefCell<T>` in
Chapter 15 to allow us to mutate contents inside an `Rc<T>`, we use `Mutex<T>`
to mutate contents inside an `Arc<T>`.
-->
<p>Vous avez peut-Ãªtre constatÃ© que <code>compteur</code> est immuable mais que nous pouvons
obtenir une rÃ©fÃ©rence mutable vers la valeur qu'il renfermeÂ ; cela signifie que
<code>Mutex&lt;T&gt;</code> a une mutabilitÃ© interne, comme le fait la famille des <code>Cell</code>. De la
mÃªme maniÃ¨re que nous avons utilisÃ© <code>RefCell&lt;T&gt;</code> au chapitre 15 pour nous
permettre de changer le contenu dans un <code>Rc&lt;T&gt;</code>, nous utilisons <code>Mutex&lt;T&gt;</code> pour
modifier le contenu d'un <code>Arc&lt;T&gt;</code>.</p>
<!--
Another detail to note is that Rust canâ€™t protect you from all kinds of logic
errors when you use `Mutex<T>`. Recall in Chapter 15 that using `Rc<T>` came
with the risk of creating reference cycles, where two `Rc<T>` values refer to
each other, causing memory leaks. Similarly, `Mutex<T>` comes with the risk of
creating *deadlocks*. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If youâ€™re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for `Mutex<T>` and `MutexGuard` offers
useful information.
-->
<p>Un autre dÃ©tail Ã  souligner est Rust ne peut pas vous protÃ©ger de tous les
genres d'erreurs de logique lorsque vous utilisez <code>Mutex&lt;T&gt;</code>. Souvenez-vous
que le chapitre 15 utilisait <code>Rc&lt;T&gt;</code> avec le risque de crÃ©er des boucles de
rÃ©fÃ©rences, dans lesquelles deux valeurs <code>Rc&lt;T&gt;</code> se rÃ©fÃ©reraient l'une Ã 
l'autre, ce qui provoquait des fuites de mÃ©moire. De la mÃªme maniÃ¨re,
l'utilisation de <code>Mutex&lt;T&gt;</code> risque de crÃ©er des <em>interblocages</em>. Cela se produit
lorsqu'une opÃ©ration nÃ©cessite de verrouiller deux ressources et que deux tÃ¢ches
ont chacune un des deux verrous, ce qui fait qu'elles s'attendent mutuellement
pour toujours. Si vous Ãªtes intÃ©ressÃ©s par les interblocages, essayez de crÃ©er
un programme Rust qui a un interblocageÂ ; recherchez ensuite des stratÃ©gies pour
pallier aux interblocages dans n'importe quel langage et implÃ©mentez-les en
Rust. La documentation de l'API de la bibliothÃ¨que standard pour <code>Mutex&lt;T&gt;</code> et
<code>MutexGuard</code> offre des informations prÃ©cieuses Ã  ce sujet.</p>
<!--
Weâ€™ll round out this chapter by talking about the `Send` and `Sync` traits and
how we can use them with custom types.
-->
<p>Nous allons terminer ce chapitre en parlant des traits <code>Send</code> et <code>Sync</code> et
voir comment nous pouvons les utiliser sur des types personnalisÃ©s.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--36" id="-attention-peinture-fraÃ®che--36">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/202">Pull Request</a>.</p>
</blockquote>
<!--
## Extensible Concurrency with the `Sync` and `Send` Traits
-->
<h2><a class="header" href="#etendre-la-concurrence-avec-les-traits-sync-et-send" id="etendre-la-concurrence-avec-les-traits-sync-et-send">Etendre la concurrence avec les traits <code>Sync</code> et <code>Send</code></a></h2>
<!--
Interestingly, the Rust language has *very* few concurrency features. Almost
every concurrency feature weâ€™ve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.
-->
<p>Curieusement, le langage Rust a <em>trÃ¨s</em> peu de fonctionnalitÃ©s de concurrence.
La plupart des fonctionnalitÃ©s de concurrence que nous avons vu prÃ©cÃ©demment
dans ce chapitre font partie de la bibliothÃ¨que standard, pas du langage. Vos
options pour gÃ©rer la concurrence ne sont pas limitÃ©es Ã  celles du langage ou
de la bibliothÃ¨que standardÂ ; vous pouvez aussi Ã©crire vos propres
fonctionnalitÃ©s de concurrence ou utiliser celles qui ont Ã©tÃ© Ã©crites par
d'autres.</p>
<!--
However, two concurrency concepts are embedded in the language: the
`std::marker` traits `Sync` and `Send`.
-->
<p>Cependant, deux concepts de concurrence sont intÃ©grÃ©s dans le langageÂ : les
traits <code>Sync</code> et <code>Send</code> de <code>std::marker</code>.</p>
<!--
### Allowing Transference of Ownership Between Threads with `Send`
-->
<h3><a class="header" href="#permettre-le-transfert-de-possession-entre-les-tÃ¢ches-avec-send" id="permettre-le-transfert-de-possession-entre-les-tÃ¢ches-avec-send">Permettre le transfert de possession entre les tÃ¢ches avec <code>Send</code></a></h3>
<!--
The `Send` marker trait indicates that ownership of the type implementing
`Send` can be transferred between threads. Almost every Rust type is `Send`,
but there are some exceptions, including `Rc<T>`: this cannot be `Send` because
if you cloned an `Rc<T>` value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, `Rc<T>` is implemented for use in single-threaded situations
where you donâ€™t want to pay the thread-safe performance penalty.
-->
<p>Le trait <code>Send</code> indique que la possession du type qui implÃ©mente <code>Send</code> peut
Ãªtre transfÃ©rÃ© entre plusieurs tÃ¢ches. Presque tous les types de Rust
implÃ©mentent <code>Send</code>, mais il subsiste quelques exceptions, comme <code>Rc&lt;T&gt;</code>Â : il
ne peut pas implÃ©menter <code>Send</code> car si vous clonez une valeur <code>Rc&lt;T&gt;</code> et que
vous essayez de transfÃ©rer la possession de ce clone Ã  une autre tÃ¢che, les
deux tÃ¢ches peuvent modifier le compteur de rÃ©fÃ©rence en mÃªme temps. Pour cette
raison, <code>Rc&lt;T&gt;</code> est prÃ©vu pour une utilisation dans des situations qui
nÃ©cessitent qu'une seule tÃ¢che dans lesquelles vous n'avez pas besoin de subir
le coÃ»t sur la performance imposÃ© par la sÃ©curitÃ© entre les tÃ¢ches.</p>
<!--
Therefore, Rustâ€™s type system and trait bounds ensure that you can never
accidentally send an `Rc<T>` value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error `the trait Send is not implemented for
Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is `Send`, the code
compiled.
-->
<p>Toutefois, le systÃ¨me de type et de traits liÃ©s de Rust garantit que vous ne
pourrez jamais envoyer accidentellement en toute insÃ©curitÃ© une valeur <code>Rc&lt;T&gt;</code>
entre des tÃ¢ches. Lorsque nous avons essayÃ© de faire cela dans l'encart 16-14,
nous avons obtenu l'erreur
<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Lorsque nous l'avons
changÃ© pour un <code>Arc&lt;T&gt;</code>, qui implÃ©mente <code>Send</code>, le code s'est compilÃ©.</p>
<!--
Any type composed entirely of `Send` types is automatically marked as `Send` as
well. Almost all primitive types are `Send`, aside from raw pointers, which
weâ€™ll discuss in Chapter 19.
-->
<p>Tous les types composÃ©s entiÃ¨rement d'autres types qui implÃ©mentent <code>Send</code> sont
automatiquement marquÃ©s comme <code>Send</code> eux-aussi. Presque la plupart des types
primitifs sont <code>Send</code>, Ã  part les pointeurs bruts, ce que nous avons verrons au
chapitre 19.</p>
<!--
### Allowing Access from Multiple Threads with `Sync`
-->
<h3><a class="header" href="#permettre-laccÃ¨s-Ã -plusieurs-tÃ¢ches-avec-sync" id="permettre-laccÃ¨s-Ã -plusieurs-tÃ¢ches-avec-sync">Permettre l'accÃ¨s Ã  plusieurs tÃ¢ches avec <code>Sync</code></a></h3>
<!--
The `Sync` marker trait indicates that it is safe for the type implementing
`Sync` to be referenced from multiple threads. In other words, any type `T` is
`Sync` if `&T` (a reference to `T`) is `Send`, meaning the reference can be
sent safely to another thread. Similar to `Send`, primitive types are `Sync`,
and types composed entirely of types that are `Sync` are also `Sync`.
-->
<p>Le trait <code>Sync</code> indique qu'il est sÃ»r d'avoir une rÃ©fÃ©rence dans plusieurs
tÃ¢ches vers le type qui implÃ©mente <code>Sync</code>. Autrement dit, n'importe quel type
<code>T</code> implÃ©mente <code>Sync</code> si <code>&amp;T</code> (une rÃ©fÃ©rence vers <code>T</code>) implÃ©mente <code>Send</code>, ce
qui signifie que la rÃ©fÃ©rence peut Ãªtre envoyÃ©e en toute sÃ©curitÃ© Ã  une autre
tÃ¢che. De la mÃªme maniÃ¨re que <code>Send</code>, les types primitifs implÃ©mentent <code>Sync</code>,
et les types composÃ©s entiÃ¨rement d'autres types qui implÃ©mentent <code>Sync</code> sont
eux-mÃªmes <code>Sync</code>.</p>
<!--
The smart pointer `Rc<T>` is also not `Sync` for the same reasons that itâ€™s not
`Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and the
family of related `Cell<T>` types are not `Sync`. The implementation of borrow
checking that `RefCell<T>` does at runtime is not thread-safe. The smart
pointer `Mutex<T>` is `Sync` and can be used to share access with multiple
threads as you saw in the [â€œSharing a `Mutex<T>` Between Multiple
Threadsâ€][sharing-a-mutext-between-multiple-threads]<!-- ignore -- > section.
-->
<p>Le pointeur intelligent <code>Rc&lt;T&gt;</code> n'implÃ©mente pas non plus <code>Sync</code> pour les mÃªmes
raisons qu'il n'implÃ©mente pas <code>Send</code>. Le type <code>RefCell&lt;T&gt;</code> (que nous avons vu
au chapitre 15) la famille liÃ©e aux types <code>Cell&lt;T&gt;</code> n'implÃ©mentent pas <code>Sync</code>.
L'implÃ©mentation du vÃ©rificateur d'emprunt que fait <code>RefCell&lt;T&gt;</code> Ã  l'exÃ©cution
n'est pas sÃ»re entre plusieurs tÃ¢ches. Le pointeur intelligent <code>Mutex&lt;T&gt;</code>
implÃ©mente <code>Sync</code> et peut Ãªtre utilisÃ© pour partager l'accÃ¨s entre plusieurs
tÃ¢ches, comme vous l'avez vu dans la section prÃ©cÃ©dente.</p>
<!--
### Implementing `Send` and `Sync` Manually Is Unsafe
-->
<h3><a class="header" href="#implÃ©menter-manuellement-send-et-sync-nest-pas-sÃ»r" id="implÃ©menter-manuellement-send-et-sync-nest-pas-sÃ»r">ImplÃ©menter manuellement <code>Send</code> et <code>Sync</code> n'est pas sÃ»r</a></h3>
<!--
Because types that are made up of `Send` and `Sync` traits are automatically
also `Send` and `Sync`, we donâ€™t have to implement those traits manually. As
marker traits, they donâ€™t even have any methods to implement. Theyâ€™re just
useful for enforcing invariants related to concurrency.
-->
<p>Comme les types qui sont constituÃ©s de types implÃ©mentant les traits <code>Send</code> et
<code>Sync</code> sont automatiquement des <code>Send</code> et <code>Sync</code>, nous n'avons pas Ã 
implÃ©menter manuellement ces traits. Comme ce sont des traits de marquage, ils
n'ont mÃªme pas de mÃ©thodes Ã  implÃ©menter. Ils sont uniquement utiles pour
appliquer les rÃ¨gles de concurrence.</p>
<!--
Manually implementing these traits involves implementing unsafe Rust code.
Weâ€™ll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of `Send` and
`Sync` parts requires careful thought to uphold the safety guarantees. [â€œThe
Rustonomiconâ€][nomicon] has more information about these guarantees and how to
uphold them.
-->
<p>L'implÃ©mentation manuelle de ces traits implique de faire du code Rust non
sÃ©curisÃ©. Nous allons voir le code Rust non sÃ©curisÃ© dans le chapitre 19Â ; pour
l'instant l'information Ã  retenir est que construire de nouveaux types
pour la concurrence constituÃ©s d'Ã©lÃ©ments qui n'implÃ©mentent pas <code>Send</code> et
<code>Sync</code> nÃ©cessite une rÃ©flexion approfondie pour respecter les garanties de
sÃ©curitÃ©. <a href="https://doc.rust-lang.org/nomicon/index.html">â€œThe Rustonomiconâ€</a> contient plus d'informations Ã  propos de
ces garanties et comment les faire appliquer.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-15" id="rÃ©sumÃ©-15">RÃ©sumÃ©</a></h2>
<!--
This isnâ€™t the last youâ€™ll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.
-->
<p>Ce n'est pas la derniÃ¨re fois que vous allez rencontrer de la concurrence dans
ce livreÂ : le projet du chapitre 20 va utiliser les concepts de ce chapitre dans
une situation plus rÃ©aliste que les petits exemples que nous avons utilisÃ©s ici.</p>
<!--
As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.
-->
<p>Nous l'avons dit prÃ©cÃ©demment, comme les outils pour gÃ©rer la concurrence de
Rust ne sont pas directement intÃ©grÃ©s dans le langage, de nombreuses solutions
pour de la concurrence sont implÃ©mentÃ©es dans des crates. Elles Ã©voluent plus
rapidement que la bibliothÃ¨que standard, donc assurez-vous de rechercher en
ligne des crates modernes et Ã  la pointe de la technologie Ã  utiliser dans des
situations multitÃ¢ches.</p>
<!--
The Rust standard library provides channels for message passing and smart
pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions wonâ€™t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!
-->
<p>La bibliothÃ¨que standard de Rust fournit les canaux pour l'envoi de messages et
les types de pointeurs intelligents, comme <code>Mutex&lt;T&gt;</code> et <code>Arc&lt;T&gt;</code>, qui sont sÃ»r
Ã  utiliser en concurrence. Le systÃ¨me de type et le vÃ©rificateur d'emprunt sont
lÃ  pour s'assurer que le code utilisÃ© dans ces solutions ne vont pas conduire Ã 
des situations de concurrence ou utiliser des rÃ©fÃ©rences qui ne sont plus en
vigueur. Une fois que votre code se compile, vous pouvez Ãªtre assurÃ© qu'il
fonctionnera bien sur plusieurs tÃ¢ches sans avoir les genres de bogues
<em>difficiles Ã  traquer</em> qui sont monnaie courante dans les autres langages. Le
dÃ©veloppement en concurrence n'est un domaine qui ne devrait plus faire peurÂ :
lancez-vous et appliquez la concurrence Ã  vos programmes sans en avoir crainteÂ !</p>
<!--
Next, weâ€™ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, weâ€™ll discuss how Rustâ€™s idioms
relate to those you might be familiar with from object-oriented programming.
-->
<p>Au chapitre suivant, nous allons voir des techniques adaptÃ©es pour modÃ©liser des
problÃ¨mes et structurer votre solution au fur et Ã  mesure que vos programmes en
Rust grandissent. De plus, nous analyserons les liens qui peuvent exister entre
les idÃ©es de Rust et celles avec lesquelles vous Ãªtes peut-Ãªtre familier en
programmation orientÃ©e objet.</p>
<!--
[sharing-a-mutext-between-multiple-threads]:
ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads
[nomicon]: ../nomicon/index.html
-->
<!--
# Object Oriented Programming Features of Rust
-->
<h1><a class="header" href="#les-fonctionnalitÃ©s-orientÃ©es-objet-de-rust" id="les-fonctionnalitÃ©s-orientÃ©es-objet-de-rust">Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></h1>
<!--
Object-oriented programming (OOP) is a way of modeling programs. Objects came
from Simula in the 1960s. Those objects influenced Alan Kayâ€™s programming
architecture in which objects pass messages to each other. He coined the term
*object-oriented programming* in 1967 to describe this architecture. Many
competing definitions describe what OOP is; some definitions would classify
Rust as object oriented, but other definitions would not. In this chapter,
weâ€™ll explore certain characteristics that are commonly considered object
oriented and how those characteristics translate to idiomatic Rust. Weâ€™ll then
show you how to implement an object-oriented design pattern in Rust and discuss
the trade-offs of doing so versus implementing a solution using some of Rustâ€™s
strengths instead.
-->
<p>La programmation orientÃ©e objet (POO) est une faÃ§on de concevoir des programmes.
Les objets sont apparus dans Simula dans les annÃ©es 1960. Ces objets ont
influencÃ© l'architecture de programmation d'Alan Kay dans laquelle les objets
s'envoient des messages. Il a inventÃ© le terme <em>programmation orientÃ©e objet</em> en
1967 pour dÃ©crire cette architecture. Plusieurs dÃ©finitions de la POO
s'opposentÂ ; Rust est considÃ©rÃ© comme orientÃ© objet selon certaines dÃ©finitions
mais pas par d'autres. Dans ce chapitre, nous examinerons certaines
caractÃ©ristiques gÃ©nÃ©ralement considÃ©rÃ©es comme orientÃ©es objet et nous verrons
comment ces caractÃ©ristiques se traduisent en code Rust traditionnel. Puis nous
vous montrerons comment implÃ©menter un patron de conception orientÃ© objet en
Rust et nous comparerons les avantages et inconvÃ©nients de faire cela plutÃ´t que
d'implÃ©menter une solution qui utilise quelques points forts de Rust.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--37" id="-attention-peinture-fraÃ®che--37">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/220">Pull Request</a>.</p>
</blockquote>
<!--
## Characteristics of Object-Oriented Languages
-->
<h2><a class="header" href="#les-caractÃ©ristiques-des-langages-orientÃ©s-objet" id="les-caractÃ©ristiques-des-langages-orientÃ©s-objet">Les caractÃ©ristiques des langages orientÃ©s objet</a></h2>
<!--
There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Letâ€™s look at what each of those characteristics means and whether
Rust supports it.
-->
<p>Les dÃ©veloppeurs ne se sont jamais entendus sur les fonctionnalitÃ©s qu'un
langage doit avoir pour Ãªtre considÃ©rÃ© orientÃ© objet. Rust est influencÃ© par
de nombreux paradigmes de programmation, y compris la POOÂ ; par exemple, nous
avons examinÃ© les fonctionnalitÃ©s issues de la programmation fonctionnelle au
chapitre 13. On peut vraisemblablement dire que les langages orientÃ©s objet ont
plusieurs caractÃ©ristiques en commun, comme les objets, l'encapsulation et
l'hÃ©ritage. Examinons chacune de ces caractÃ©ristiques et regardons si Rust
les supporte.</p>
<!--
### Objects Contain Data and Behavior
-->
<h3><a class="header" href="#les-objets-contiennent-des-donnÃ©es-et-suivent-un-comportement" id="les-objets-contiennent-des-donnÃ©es-et-suivent-un-comportement">Les objets contiennent des donnÃ©es et suivent un comportement</a></h3>
<!--
The book *Design Patterns: Elements of Reusable Object-Oriented Software* by
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
Professional, 1994) colloquially referred to as *The Gang of Four* book, is a
catalog of object-oriented design patterns. It defines OOP this way:
-->
<p>Le livre <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>
d'Erich Gamma, Richard Helm, Ralph Johnson, et John Vlissides (Addison-Wesley
Professional, 1994) que l'on surnomme le livre du <em>Gang of Four</em>, est un
catalogue de patrons de conception orientÃ©s objet. Il dÃ©finit la POO ainsiÂ :</p>
<!--
> Object-oriented programs are made up of objects. An *object* packages both
> data and the procedures that operate on that data. The procedures are
> typically called *methods* or *operations*.
-->
<blockquote>
<p>Les programmes orientÃ©s objet sont constituÃ©s d'objets. Un <em>objet</em> regroupe
des donnÃ©es ainsi que les procÃ©dures qui opÃ¨rent sur ces donnÃ©es. Ces
procÃ©dures sont typiquement appelÃ©es <em>mÃ©thodes</em> ou <em>opÃ©rations</em>.</p>
</blockquote>
<!--
Using this definition, Rust is object oriented: structs and enums have data,
and `impl` blocks provide methods on structs and enums. Even though structs and
enums with methods arenâ€™t *called* objects, they provide the same
functionality, according to the Gang of Fourâ€™s definition of objects.
-->
<p>Si l'on se tient Ã  cette dÃ©finition, Rust est orientÃ© objetÂ : les structures et
les Ã©numÃ©rations ont des donnÃ©es, et les blocs <code>impl</code> leur fournissent des
mÃ©thodes. Bien que les structures et les Ã©numÃ©rations avec des mÃ©thodes ne soient pas qualifiÃ©es
d'objets, elles en ont les fonctionnalitÃ©s, d'aprÃ¨s la dÃ©finition des objets par
le <em>Gang of Four</em>.</p>
<!--
### Encapsulation that Hides Implementation Details
-->
<h3><a class="header" href="#lencapsulation-qui-masque-les-dÃ©tails-dimplÃ©mentation" id="lencapsulation-qui-masque-les-dÃ©tails-dimplÃ©mentation">L'encapsulation qui masque les dÃ©tails d'implÃ©mentation</a></h3>
<!--
Another aspect commonly associated with OOP is the idea of *encapsulation*,
which means that the implementation details of an object arenâ€™t accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldnâ€™t be able to reach into
the objectâ€™s internals and change data or behavior directly. This enables the
programmer to change and refactor an objectâ€™s internals without needing to
change the code that uses the object.
-->
<p>Un autre aspect qu'on associe souvent Ã  la POO est l'idÃ©e d'<em>encapsulation</em>, ce
qui signifie que les dÃ©tails d'implÃ©mentation d'un objet ne sont pas accessibles
au code utilisant cet objet. Ainsi, la seule faÃ§on d'interagir avec un objet est
via son API publiqueÂ ; le code qui utilise l'objet ne devrait pas pouvoir
accÃ©der aux Ã©lÃ©ments internes d'un objet et changer directement ses donnÃ©es ou
son comportement. Cela permet au dÃ©veloppeur de changer et remanier les Ã©lÃ©ments
internes d'un objet sans avoir Ã  changer le code qui utilise cet objet.</p>
<!--
We discussed how to control encapsulation in Chapter 7: we can use the `pub`
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct `AveragedCollection` that has a field containing a vector
of `i32` values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesnâ€™t have to be computed
on demand whenever anyone needs it. In other words, `AveragedCollection` will
cache the calculated average for us. Listing 17-1 has the definition of the
`AveragedCollection` struct:
-->
<p>Nous avons abordÃ© la faÃ§on de contrÃ´ler l'encapsulation au chapitre 7Â : on peut
utiliser le mot-clÃ© <code>pub</code> pour dÃ©cider quels modules, types, fonctions et
mÃ©thodes de notre code devraient Ãªtre publicsÂ ; par dÃ©faut, tout le reste est
privÃ©. Par exemple, nous pouvons dÃ©finir une structure <code>CollectionMoyennee</code> qui
a un champ contenant un vecteur de valeurs <code>i32</code>. La structure peut aussi avoir
un champ qui contient la moyenne des valeurs dans le vecteur de sorte qu'il ne
soit pas nÃ©cessaire de recalculer la moyenne Ã  chaque fois que quelqu'un en a
besoin. En d'autres termes, <code>CollectionMoyennee</code> va mettre en cache la moyenne
calculÃ©e pour nous. L'encart 17-1 contient la dÃ©finition de la structure
<code>CollectionMoyennee</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CollectionMoyennee {
    liste: Vec&lt;i32&gt;,
    moyenne: f64,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-1: An `AveragedCollection` struct that
maintains a list of integers and the average of the items in the
collection</span>
-->
<p><span class="caption">Encart 17-1Â : Une structure <code>CollectionMoyennee</code> qui
contient une liste d'entiers et la moyenne des Ã©lÃ©ments de la collection</span></p>
<!--
The struct is marked `pub` so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing `add`, `remove`, and `average` methods
on the struct, as shown in Listing 17-2:
-->
<p>La structure est marquÃ©e <code>pub</code> de sorte que d'autres codes puissent l'utiliser,
mais les champs au sein de la structure restent privÃ©s. C'est important dans ce
cas puisque nous voulons nous assurer que lorsqu'une valeur est ajoutÃ©e ou
retirÃ©e dans la liste, la moyenne soit aussi mise Ã  jour. Nous le faisons en
implÃ©mentant les mÃ©thodes <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sur la structure,
comme le montre l'encart 17-2Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct AveragedCollection {
#     list: Vec<i32>,
#     average: f64,
# }
# 
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct CollectionMoyennee {
</span><span class="boring">    liste: Vec&lt;i32&gt;,
</span><span class="boring">    moyenne: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionMoyennee {
    pub fn ajouter(&amp;mut self, valeur: i32) {
        self.liste.push(valeur);
        self.mettre_a_jour_moyenne();
    }

    pub fn retirer(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let resultat = self.liste.pop();
        match resultat {
            Some(valeur) =&gt; {
                self.mettre_a_jour_moyenne();
                Some(valeur)
            }
            None =&gt; None,
        }
    }

    pub fn moyenne(&amp;self) -&gt; f64 {
        self.moyenne
    }

    fn mettre_a_jour_moyenne(&amp;mut self) {
        let total: i32 = self.liste.iter().sum();
        self.moyenne = total as f64 / self.liste.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-2: Implementations of the public methods
`add`, `remove`, and `average` on `AveragedCollection`</span>
-->
<p><span class="caption">Encart 17-2Â : ImplÃ©mentations des mÃ©thodes publiques
<code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sur <code>CollectionMoyennee</code></span></p>
<!--
The public methods `add`, `remove`, and `average` are the only ways to access
or modify data in an instance of `AveragedCollection`. When an item is added
to `list` using the `add` method or removed using the `remove` method, the
implementations of each call the private `update_average` method that handles
updating the `average` field as well.
-->
<p>Les mÃ©thodes publiques <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sont les seules faÃ§ons
d'accÃ©der ou de modifier les donnÃ©es d'une instance de <code>CollectionMoyennee</code>.
Lorsqu'un Ã©lÃ©ment est ajoutÃ© Ã  <code>liste</code> en utilisant la mÃ©thode <code>ajouter</code> ou
retirÃ© en utilisant la mÃ©thode <code>retirer</code>, l'implÃ©mentation de chacune de ces
mÃ©thodes appelle la mÃ©thode privÃ©e <code>mettre_a_jour_moyenne</code> qui met Ã  jour le
champ <code>moyenne</code> Ã©galement.</p>
<!--
We leave the `list` and `average` fields private so there is no way for
external code to add or remove items to the `list` field directly; otherwise,
the `average` field might become out of sync when the `list` changes. The
`average` method returns the value in the `average` field, allowing external
code to read the `average` but not modify it.
-->
<p>Nous laissons les champs <code>liste</code> et <code>moyenne</code> privÃ©s pour qu'il soit impossible
pour du code externe d'ajouter ou de retirer des Ã©lÃ©ments dans notre champ
<code>liste</code> directementÂ ; sinon, le champ <code>moyenne</code> pourrait ne plus Ãªtre
synchronisÃ© lorsque la liste change. La mÃ©thode <code>moyenne</code> renvoie la valeur du
champ <code>moyenne</code>, ce qui permet au code externe de lire le champ <code>moyenne</code> mais
pas de le modifier.</p>
<!--
Because weâ€™ve encapsulated the implementation details of the struct
`AveragedCollection`, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a `HashSet<i32>` instead of a
`Vec<i32>` for the `list` field. As long as the signatures of the `add`,
`remove`, and `average` public methods stay the same, code using
`AveragedCollection` wouldnâ€™t need to change. If we made `list` public instead,
this wouldnâ€™t necessarily be the case: `HashSet<i32>` and `Vec<i32>` have
different methods for adding and removing items, so the external code would
likely have to change if it were modifying `list` directly.
-->
<p>Puisque nous avons encapsulÃ© les dÃ©tails d'implÃ©mentation de la structure
<code>CollectionMoyennee</code>, nous pourrons aisÃ©ment en changer quelques aspects, tels
que la structure de donnÃ©es, Ã  l'avenir. Par exemple, nous pourrions utiliser
un <code>HashSet&lt;i32&gt;</code> plutÃ´t qu'un <code>Vec&lt;i32&gt;</code> pour le champ <code>liste</code>. Du moment que
les signatures des mÃ©thodes publiques <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> restent
les mÃªmes, du code qui utilise <code>CollectionMoyennee</code> n'aurait pas besoin de
changer. En revanche, si nous avions fait en sorte que <code>liste</code> soit publique, cela n'aurait pas Ã©tÃ©
forcÃ©ment le casÂ : <code>HashSet&lt;i32&gt;</code> et <code>Vec&lt;i32&gt;</code> ont des mÃ©thodes diffÃ©rentes
pour ajouter et retirer des Ã©lÃ©ments, donc il aurait vraisemblablement fallu
changer le code externe s'il modifiait directement <code>liste</code>.</p>
<!--
If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use `pub` or not for
different parts of code enables encapsulation of implementation details.
-->
<p>Si l'encapsulation est une condition nÃ©cessaire pour qu'un langage soit
considÃ©rÃ© orientÃ© objet, alors Rust satisfait cette condition. La possibilitÃ©
d'utiliser <code>pub</code> ou non pour diffÃ©rentes parties de notre code permet
d'encapsuler les dÃ©tails d'implÃ©mentation.</p>
<!--
### Inheritance as a Type System and as Code Sharing
-->
<h3><a class="header" href="#lhÃ©ritage-comme-systÃ¨me-de-type-et-comme-partage-de-code" id="lhÃ©ritage-comme-systÃ¨me-de-type-et-comme-partage-de-code">L'hÃ©ritage comme systÃ¨me de type et comme partage de code</a></h3>
<!--
*Inheritance* is a mechanism whereby an object can inherit from another
objectâ€™s definition, thus gaining the parent objectâ€™s data and behavior without
you having to define them again.
-->
<p>L'<em>hÃ©ritage</em> est un mÃ©canisme selon lequel un objet peut hÃ©riter de la
dÃ©finition d'un autre objet, acquÃ©rant ainsi les donnÃ©es et le comportement de
l'objet pÃ¨re sans que l'on ait besoin de les redÃ©finir.</p>
<!--
If a language must have inheritance to be an object-oriented language, then
Rust is not one. There is no way to define a struct that inherits the parent
structâ€™s fields and method implementations. However, if youâ€™re used to having
inheritance in your programming toolbox, you can use other solutions in Rust,
depending on your reason for reaching for inheritance in the first place.
-->
<p>Si un langage doit avoir de l'hÃ©ritage pour Ãªtre un langage orientÃ© objet, alors
Rust n'en est pas un. Il est impossible de dÃ©finir une structure qui hÃ©rite des
champs et de l'implÃ©mentation des mÃ©thodes de la structure mÃ¨re. Cependant, si
vous avez l'habitude d'utiliser l'hÃ©ritage dans vos programmes, vous pouvez
utiliser d'autres solutions en Rust, selon la raison pour laquelle vous vous
Ãªtes tournÃ© vers l'hÃ©ritage en premier lieu.</p>
<!--
You choose inheritance for two main reasons. One is for reuse of code: you can
implement particular behavior for one type, and inheritance enables you to
reuse that implementation for a different type. You can share Rust code using
default trait method implementations instead, which you saw in Listing 10-14
when we added a default implementation of the `summarize` method on the
`Summary` trait. Any type implementing the `Summary` trait would have the
`summarize` method available on it without any further code. This is similar to
a parent class having an implementation of a method and an inheriting child
class also having the implementation of the method. We can also override the
default implementation of the `summarize` method when we implement the
`Summary` trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.
-->
<p>Il y a deux principales raisons de choisir l'hÃ©ritage. La premiÃ¨re raison est la
rÃ©utilisation de codeÂ : vous pouvez implÃ©menter un comportement particulier pour
un type, et l'hÃ©ritage vous permet de rÃ©utiliser cette implÃ©mentation sur un
autre type. Ã€ la place, vous pouvez partager du code Rust en utilisant des
implÃ©mentations de mÃ©thodes de trait par dÃ©faut, comme nous l'avons vu dans
l'encart 10-14 lorsque nous avons ajoutÃ© une implÃ©mentation par dÃ©faut de la
mÃ©thode <code>resumer</code> sur le trait <code>Resumable</code>. La mÃ©thode <code>resumer</code> serait alors
disponible sur tout type implÃ©mentant le trait <code>Resumable</code> sans avoir besoin de
rajouter du code. C'est comme si vous aviez une classe mÃ¨re avec
l'implÃ©mentation d'une mÃ©thode et une classe fille avec une autre implÃ©mentation
de cette mÃ©thode. On peut aussi remplacer l'implÃ©mentation par dÃ©faut de la
mÃ©thode <code>resumer</code> quand on implÃ©mente le trait <code>Resumable</code>, un peu comme une
classe fille qui remplace l'implÃ©mentation d'une mÃ©thode hÃ©ritÃ©e d'une classe
mÃ¨re.</p>
<!--
The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called *polymorphism*, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.
-->
<p>L'autre raison d'utiliser l'hÃ©ritage concerne le systÃ¨me de typesÂ : pour
permettre Ã  un type fils d'Ãªtre utilisÃ© Ã  la place d'un type pÃ¨re. Cela
s'appelle le <em>polymorphisme</em>, ce qui veut dire qu'on peut substituer plusieurs
objets entre eux Ã  l'exÃ©cution s'ils partagent certaines caractÃ©ristiques.</p>
<!--
> ### Polymorphism
>
> To many people, polymorphism is synonymous with inheritance. But itâ€™s
> actually a more general concept that refers to code that can work with data
> of multiple types. For inheritance, those types are generally subclasses.
>
> Rust instead uses generics to abstract over different possible types and
> trait bounds to impose constraints on what those types must provide. This is
> sometimes called *bounded parametric polymorphism*.
-->
<blockquote>
<h3><a class="header" href="#polymorphisme" id="polymorphisme">Polymorphisme</a></h3>
<p>Pour beaucoup de gens, le polymorphisme est synonyme d'hÃ©ritage. Mais il
s'agit en fait d'un principe plus gÃ©nÃ©ral qui se rapporte au code manipulant
des donnÃ©es de divers types. Pour l'hÃ©ritage, ces types sont gÃ©nÃ©ralement des
classes filles (ou <em>sous-classes</em>).</p>
<p>Ã€ la place, Rust utilise la gÃ©nÃ©ricitÃ© pour construire des abstractions des diffÃ©rents types et
traits liÃ©s possibles pour imposer des contraintes sur ce que ces types
doivent fournir. Cela est parfois appelÃ© <em>polymorphisme paramÃ©trique bornÃ©</em>.</p>
</blockquote>
<!--
Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because itâ€™s often at risk of sharing more code
than necessary. Subclasses shouldnâ€™t always share all characteristics of their
parent class but will do so with inheritance. This can make a programâ€™s design
less flexible. It also introduces the possibility of calling methods on
subclasses that donâ€™t make sense or that cause errors because the methods donâ€™t
apply to the subclass. In addition, some languages will only allow a subclass
to inherit from one class, further restricting the flexibility of a programâ€™s
design.
-->
<p>L'hÃ©ritage est rÃ©cemment tombÃ© en disgrÃ¢ce en tant que solution de conception
dans plusieurs langages de programmation parce qu'il conduit souvent Ã  partager
plus de code que nÃ©cessaire. Les classes mÃ¨res ne devraient pas toujours
partager toutes leurs caractÃ©ristiques avec leurs classes filles, mais elles y
sont obligÃ©es avec l'hÃ©ritage. Cela peut rendre la conception d'un programme
moins flexible. De plus, cela introduit la possibilitÃ© d'appeler des mÃ©thodes
sur des classes filles qui n'ont aucun sens ou qui entraÃ®nent des erreurs parce
que les mÃ©thodes ne s'appliquent pas Ã  la classe fille. De plus, certains
langages ne permettront Ã  une classe fille d'hÃ©riter que d'une seule classe, ce
qui restreint d'autant plus la flexibilitÃ© de la conception d'un programme.</p>
<!--
For these reasons, Rust takes a different approach, using trait objects instead
of inheritance. Letâ€™s look at how trait objects enable polymorphism in Rust.
-->
<p>VoilÃ  pourquoi Rust suit une autre approche, en utilisant des objets traits
plutÃ´t que l'hÃ©ritage. Jetons un Å“il Ã  la faÃ§on dont les objets traits
permettent le polymorphisme en Rust.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--38" id="-attention-peinture-fraÃ®che--38">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/231">Pull Request</a>.</p>
</blockquote>
<!--
## Using Trait Objects That Allow for Values of Different Types
-->
<h2><a class="header" href="#utiliser-les-objets-traits-qui-permettent-des-valeurs-de-types-diffÃ©rents" id="utiliser-les-objets-traits-qui-permettent-des-valeurs-de-types-diffÃ©rents">Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></h2>
<!--
In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-10 where
we defined a `SpreadsheetCell` enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.
-->
<p>Au chapitre 8, nous avions mentionnÃ© qu'une limite des vecteurs est qu'ils ne
peuvent stocker des Ã©lÃ©ments que d'un seul type. Nous avions contournÃ© le
problÃ¨me dans l'encart 8-10 en dÃ©finissant une Ã©numÃ©ration <code>Cellule</code> avec des
variantes pouvant contenir des entiers, des flottants et du texte. Ainsi, on
pouvait stocker diffÃ©rents types de donnÃ©es dans chaque cellule et quand mÃªme
avoir un vecteur qui reprÃ©sentait une rangÃ©e de cellules. C'est une trÃ¨s bonne
solution quand nos Ã©lÃ©ments interchangeables ne possÃ¨dent qu'un ensemble bien
dÃ©terminÃ© de types que nous connaissons lors de la compilation de notre code.</p>
<!--
However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, weâ€™ll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a `draw` method on each one to draw it to the
screenâ€”a common technique for GUI tools. Weâ€™ll create a library crate called
`gui` that contains the structure of a GUI library. This crate might include
some types for people to use, such as `Button` or `TextField`. In addition,
`gui` users will want to create their own types that can be drawn: for
instance, one programmer might add an `Image` and another might add a
`SelectBox`.
-->
<p>Cependant, nous avons parfois envie que l'utilisateur de notre bibliothÃ¨que
puisse Ã©tendre l'ensemble des types valides dans une situation donnÃ©e. Pour
montrer comment nous pourrions y parvenir, crÃ©ons un exemple d'outil d'interface
graphique (GUI) qui itÃ¨re sur une liste d'Ã©lÃ©ments et appelle une mÃ©thode
<code>afficher</code> sur chacun d'entre eux pour l'afficher Ã  l'Ã©cran â€” une technique
courante pour les outils d'interface graphique. CrÃ©ons une <em>crate</em> de
bibliothÃ¨que appelÃ©e <code>gui</code> qui contient la structure d'une bibliothÃ¨que
d'interface graphique. Cette <em>crate</em> pourrait inclure des types que les usagers
pourront utiliser, tels que <code>Bouton</code> ou <code>ChampDeTexte</code>. De plus, les
utilisateurs de <code>gui</code> voudront crÃ©er leurs propres types qui pourront Ãªtre
affichÃ©sÂ : par exemple, un dÃ©veloppeur pourrait ajouter une <code>Image</code> et un autre
pourrait ajouter une <code>ListeDeroulante</code>.</p>
<!--
We wonâ€™t implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we canâ€™t
know and define all the types other programmers might want to create. But we do
know that `gui` needs to keep track of many values of different types, and it
needs to call a `draw` method on each of these differently typed values. It
doesnâ€™t need to know exactly what will happen when we call the `draw` method,
just that the value will have that method available for us to call.
-->
<p>Nous n'implÃ©menterons pas une vÃ©ritable bibliothÃ¨que d'interface graphique pour
cet exemple, mais nous verrons comment les morceaux pourraient s'assembler. Au
moment d'Ã©crire la bibliothÃ¨que, nous ne pouvons pas savoir ni dÃ©finir tous les
types que les autres dÃ©veloppeurs auraient envie de crÃ©er. Mais nous savons que
<code>gui</code> doit gÃ©rer plusieurs valeurs de types diffÃ©rents et qu'elle
doit appeler la mÃ©thode <code>afficher</code> sur chacune de ces valeurs de types
diffÃ©rents. Il n'a pas besoin de savoir exactement ce qui arrivera quand on
appellera la mÃ©thode <code>afficher</code>, mais seulement de savoir que la valeur aura
cette mÃ©thode que nous pourrons appeler.</p>
<!--
To do this in a language with inheritance, we might define a class named
`Component` that has a method named `draw` on it. The other classes, such as
`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus
inherit the `draw` method. They could each override the `draw` method to define
their custom behavior, but the framework could treat all of the types as if
they were `Component` instances and call `draw` on them. But because Rust
doesnâ€™t have inheritance, we need another way to structure the `gui` library to
allow users to extend it with new types.
-->
<p>Pour faire ceci dans un langage avec de l'hÃ©ritage, nous pourrions dÃ©finir une
classe <code>Composant</code> qui a une mÃ©thode <code>afficher</code>. Les autres
classes, telles que <code>Bouton</code>, <code>Image</code> et <code>ListeDeroulante</code>, hÃ©riteraient de
<code>Composant</code> et hÃ©riteraient ainsi de la mÃ©thode <code>afficher</code>. Elles pourraient
toutes redÃ©finir la mÃ©thode <code>afficher</code> avec leur comportement personnalisÃ©,
mais l'environnement de dÃ©veloppement pourrait considÃ©rer tous les types comme des instances de
<code>Composant</code> et appeler <code>afficher</code> sur chacun d'entre eux. Mais puisque Rust n'a
pas d'hÃ©ritage, il nous faut un autre moyen de structurer la bibliothÃ¨que <code>gui</code>
pour permettre aux utilisateurs de la prolonger avec de nouveaux types.</p>
<!--
### Defining a Trait for Common Behavior
-->
<h3><a class="header" href="#dÃ©finir-un-trait-pour-du-comportement-commun" id="dÃ©finir-un-trait-pour-du-comportement-commun">DÃ©finir un trait pour du comportement commun</a></h3>
<!--
To implement the behavior we want `gui` to have, weâ€™ll define a trait named
`Draw` that will have one method named `draw`. Then we can define a vector that
takes a *trait object*. A trait object points to both an instance of a type
implementing our specified trait as well as a table used to look up trait
methods on that type at runtime. We create a trait object by specifying some
sort of pointer, such as a `&` reference or a `Box<T>` smart pointer, then the
`dyn` keyword, and then specifying the relevant trait. (Weâ€™ll talk about the
reason trait objects must use a pointer in Chapter 19 in the section
[â€œDynamically Sized Types and the `Sized` Trait.â€][dynamically-sized]<!--
ignore -- >) We can use trait objects in place of a generic or concrete type.
Wherever we use a trait object, Rustâ€™s type system will ensure at compile time
that any value used in that context will implement the trait objectâ€™s trait.
Consequently, we donâ€™t need to know all the possible types at compile time.
-->
<p>Pour implÃ©menter le comportement que nous voulons donner Ã  <code>gui</code>, nous
dÃ©finirons un trait nommÃ© <code>Affichable</code> qui aura une mÃ©thode nommÃ©e <code>afficher</code>.
Puis nous dÃ©finirons un vecteur qui prend un <em>objet trait</em>. Un objet trait
pointe Ã  la fois vers une instance d'un type implÃ©mentant le trait indiquÃ© ainsi
que vers une table utilisÃ©e pour chercher les mÃ©thodes de trait de ce type Ã 
l'exÃ©cution. Nous crÃ©ons un objet trait en indiquant une sorte de pointeur, tel
qu'une rÃ©fÃ©rence <code>&amp;</code> ou un pointeur intelligent <code>Box&lt;T&gt;</code>, puis le mot-clÃ© <code>dyn</code>
et enfin le trait en question. (Nous expliquerons pourquoi les objets traits
doivent utiliser un pointeur dans <a href="ch19-04-advanced-types.html">une section</a><!-- ignore -->
du chapitre 19.) Nous pouvons
utiliser des objets traits Ã  la place d'un type gÃ©nÃ©rique ou concret. Partout oÃ¹
nous utilisons un objet trait, le systÃ¨me de types de Rust s'assurera Ã  la
compilation que n'importe quelle valeur utilisÃ©e dans ce contexte implÃ©mentera
le trait de l'objet trait. Ainsi, il n'est pas nÃ©cessaire de connaÃ®tre tous les
types possibles Ã  la compilation.</p>
<!--
Weâ€™ve mentioned that in Rust, we refrain from calling structs and enums
â€œobjectsâ€ to distinguish them from other languagesâ€™ objects. In a struct or
enum, the data in the struct fields and the behavior in `impl` blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects *are* more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we canâ€™t add data to
a trait object. Trait objects arenâ€™t as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.
-->
<p>Nous avons mentionnÃ© qu'en Rust, nous nous abstenons de qualifier les structures
et Ã©numÃ©rations d'<em>objets</em> pour les distinguer des objets des autres langages.
Dans une structure ou une Ã©numÃ©ration, les donnÃ©es dans les champs de la
structure et le comportement dans les blocs <code>impl</code> sont sÃ©parÃ©s, alors que dans
d'autres langages, les donnÃ©es et le comportement se combinent en un concept
souvent qualifiÃ© d'objet. En revanche, les objets traits ressemblent davantage
aux objets des autres langages dans le sens oÃ¹ ils combinent des donnÃ©es et du
comportement. Mais les objets traits diffÃ¨rent des objets traditionnels dans le
sens oÃ¹ on ne peut pas ajouter des donnÃ©es Ã  un objet trait. Les objets traits
ne sont gÃ©nÃ©ralement pas aussi utiles que les objets des autres langagesÂ : leur
but spÃ©cifique est de permettre de construire des abstractions de comportements
communs.</p>
<!--
Listing 17-3 shows how to define a trait named `Draw` with one method named
`draw`:
-->
<p>L'encart 17-3 illustre la faÃ§on de dÃ©finir un trait nommÃ© <code>Affichable</code> avec une
mÃ©thode nommÃ©e <code>afficher</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait Draw {
    fn draw(&self);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Affichable {
    fn afficher(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Affichable {
    fn afficher(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-3: Definition of the `Draw` trait</span>
-->
<p><span class="caption">Encart 17-3Â : dÃ©finition du trait <code>Affichable</code></span></p>
<!--
This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
`Screen` that holds a vector named `components`. This vector is of type
`Box<dyn Draw>`, which is a trait object; itâ€™s a stand-in for any type inside
a `Box` that implements the `Draw` trait.
-->
<p>Cette syntaxe devrait vous rappeler nos discussions sur comment dÃ©finir des
traits au chapitre 10. Puis vient une nouvelle syntaxeÂ : l'encart 17-4 dÃ©finit
une structure <code>Ecran</code> qui contient un vecteur <code>composants</code>. Ce
vecteur est du type <code>Box&lt;dyn Affichable&gt;</code>, qui est un objet traitÂ ; c'est un
bouche-trou pour n'importe quel type au sein d'un <code>Box</code> qui implÃ©mente le trait
<code>Affichable</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Ecran {
    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-4: Definition of the `Screen` struct with a
`components` field holding a vector of trait objects that implement the `Draw`
trait</span>
-->
<p><span class="caption">Encart 17-4Â : dÃ©finition de la structure <code>Ecran</code> avec un
champ <code>composants</code> contenant un vecteur d'objets traits qui implÃ©mentent le
trait <code>Affichable</code></span></p>
<!--
On the `Screen` struct, weâ€™ll define a method named `run` that will call the
`draw` method on each of its `components`, as shown in Listing 17-5:
-->
<p>Sur la structure <code>Ecran</code>, nous allons dÃ©finir une mÃ©thode nommÃ©e <code>executer</code> qui
appellera la mÃ©thode <code>afficher</code> sur chacun de ses <code>composants</code>, comme l'illustre
l'encart 17-5 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
# pub struct Screen {
#     pub components: Vec<Box<dyn Draw>>,
# }
# 
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Ecran {
</span><span class="boring">    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Ecran {
    pub fn executer(&amp;self) {
        for composant in self.composants.iter() {
            composant.afficher();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-5: A `run` method on `Screen` that calls the
`draw` method on each component</span>
-->
<p><span class="caption">Encart 17-5Â : une mÃ©thode <code>executer</code> sur <code>Ecran</code> qui
appelle la mÃ©thode <code>afficher</code> sur chaque composant</span></p>
<!--
This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the `Screen` struct using a generic type and a trait bound
as in Listing 17-6:
-->
<p>Cela ne fonctionne pas de la mÃªme maniÃ¨re que d'utiliser une structure avec un
paramÃ¨tre de type gÃ©nÃ©rique avec des traits liÃ©s. Un paramÃ¨tre de type gÃ©nÃ©rique
ne peut Ãªtre remplacÃ© que par un seul type concret Ã  la fois, tandis que les
objets traits permettent Ã  plusieurs types concrets de remplacer l'objet trait Ã 
l'exÃ©cution. Par exemple, nous aurions pu dÃ©finir la structure <code>Ecran</code> en
utilisant un type gÃ©nÃ©rique et un trait liÃ© comme dans l'encart 17-6Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Ecran&lt;T: Affichable&gt; {
    pub composants: Vec&lt;T&gt;,
}

impl&lt;T&gt; Ecran&lt;T&gt;
where
    T: Affichable,
{
    pub fn executer(&amp;self) {
        for composant in self.composants.iter() {
            composant.afficher();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-6: An alternate implementation of the `Screen`
struct and its `run` method using generics and trait bounds</span>
-->
<p><span class="caption">Encart 17-6Â : une implÃ©mentation diffÃ©rente de la
structure <code>Ecran</code> et de sa mÃ©thode <code>executer</code> en utilisant la gÃ©nÃ©ricitÃ© et les
traits liÃ©s</span></p>
<!--
This restricts us to a `Screen` instance that has a list of components all of
type `Button` or all of type `TextField`. If youâ€™ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.
-->
<p>Cela nous restreint Ã  une instance de <code>Ecran</code> qui a une liste de composants qui
sont soit tous de type <code>Bouton</code>, soit tous de type <code>ChampDeTexte</code>. Si vous ne
voulez que des collections homogÃ¨nes, il est prÃ©fÃ©rable d'utiliser la gÃ©nÃ©ricitÃ©
et les traits liÃ©s parce que les dÃ©finitions seront monomorphisÃ©es Ã  la
compilation pour utiliser les types concrets.</p>
<!--
On the other hand, with the method using trait objects, one `Screen` instance
can hold a `Vec<T>` that contains a `Box<Button>` as well as a
`Box<TextField>`. Letâ€™s look at how this works, and then weâ€™ll talk about the
runtime performance implications.
-->
<p>D'un autre cÃ´tÃ©, en utilisant des objets traits, une instance de <code>Ecran</code> peut
contenir un <code>Vec&lt;T&gt;</code> qui contient Ã  la fois un <code>Box&lt;Bouton&gt;</code> et un
<code>Box&lt;ChampDeTexte&gt;</code>. Regardons comment cela fonctionne, puis nous parlerons
ensuite du coÃ»t en performances Ã  l'exÃ©cution.</p>
<!--
### Implementing the Trait
-->
<h3><a class="header" href="#implÃ©menter-le-trait" id="implÃ©menter-le-trait">ImplÃ©menter le trait</a></h3>
<!--
Now weâ€™ll add some types that implement the `Draw` trait. Weâ€™ll provide the
`Button` type. Again, actually implementing a GUI library is beyond the scope
of this book, so the `draw` method wonâ€™t have any useful implementation in its
body. To imagine what the implementation might look like, a `Button` struct
might have fields for `width`, `height`, and `label`, as shown in Listing 17-7:
-->
<p>Ajoutons maintenant quelques types qui implÃ©mentent le trait <code>Affichable</code>. Nous
fournirons le type <code>Bouton</code>. Encore une fois, implÃ©menter une vraie bibliothÃ¨que
d'interface graphique dÃ©passe la portÃ©e de ce livre, alors la mÃ©thode <code>afficher</code>
n'aura pas d'implÃ©mentation utile dans son corps. Pour imaginer Ã  quoi pourrait
ressembler l'implÃ©mentation, une structure <code>Bouton</code> pourrait avoir des champs
<code>largeur</code>, <code>hauteur</code> et <code>libelle</code>, comme l'illustre l'encart 17-7Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
# pub struct Screen {
#     pub components: Vec<Box<dyn Draw>>,
# }
# 
# impl Screen {
#     pub fn run(&self) {
#         for component in self.components.iter() {
#             component.draw();
#         }
#     }
# }
# 
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a button
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Ecran {
</span><span class="boring">    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Ecran {
</span><span class="boring">    pub fn executer(&amp;self) {
</span><span class="boring">        for composant in self.composants.iter() {
</span><span class="boring">            composant.afficher();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Bouton {
    pub largeur: u32,
    pub hauteur: u32,
    pub libelle: String,
}

impl Affichable for Bouton {
    fn afficher(&amp;self) {
        // code servant vraiment Ã  afficher un bouton
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-7: A `Button` struct that implements the
`Draw` trait</span>
-->
<p><span class="caption">Encart 17-7Â : une structure <code>Bouton</code> qui implÃ©mente le
trait <code>Affichable</code></span></p>
<!--
The `width`, `height`, and `label` fields on `Button` will differ from the
fields on other components, such as a `TextField` type, that might have those
fields plus a `placeholder` field instead. Each of the types we want to draw on
the screen will implement the `Draw` trait but will use different code in the
`draw` method to define how to draw that particular type, as `Button` has here
(without the actual GUI code, which is beyond the scope of this chapter). The
`Button` type, for instance, might have an additional `impl` block containing
methods related to what happens when a user clicks the button. These kinds of
methods wonâ€™t apply to types like `TextField`.
-->
<p>Les champs <code>largeur</code>, <code>hauteur</code> et <code>libelle</code> de <code>Bouton</code> pourront ne pas Ãªtre
les mÃªmes que ceux d'autres composants, comme un type <code>ChampDeTexte</code>, qui
pourrait avoir ces champs plus un champ <code>texte_de_substitution</code> Ã  la place.
Chacun des types que nous voudrons afficher Ã  l'Ã©cran implÃ©mentera le trait
<code>Affichable</code> mais utilisera du code diffÃ©rent dans la mÃ©thode <code>afficher</code> pour
dÃ©finir comment afficher ce type en particulier, comme c'est le cas de <code>Bouton</code>
ici (sans le vrai code d'implÃ©mentation, qui dÃ©passe le cadre de ce chapitre).
Le type <code>Bouton</code>, par exemple, pourrait avoir un bloc <code>impl</code> supplÃ©mentaire
contenant des mÃ©thodes en lien Ã  ce qui arrive quand un utilisateur clique sur
le bouton. Ce genre de mÃ©thodes ne s'applique pas Ã  des types comme
<code>ChampDeTexte</code>.</p>
<!--
If someone using our library decides to implement a `SelectBox` struct that has
`width`, `height`, and `options` fields, they implement the `Draw` trait on the
`SelectBox` type as well, as shown in Listing 17-8:
-->
<p>Si un utilisateur de notre bibliothÃ¨que dÃ©cide d'implÃ©menter une structure
<code>ListeDeroulante</code> avec des champs <code>largeur</code>, <code>hauteur</code> et <code>options</code>, il
implÃ©mentera Ã©galement le trait <code>Affichable</code> sur le type <code>ListeDeroulante</code>,
comme dans l'encart 17-8Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
    }
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore">use gui::Affichable;

struct ListeDeroulante {
    largeur: u32,
    hauteur: u32,
    options: Vec&lt;String&gt;,
}

impl Affichable for ListeDeroulante {
    fn afficher(&amp;self) {
        // code servant vraiment Ã  afficher une liste dÃ©roulante
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 17-8: Another crate using `gui` and implementing
the `Draw` trait on a `SelectBox` struct</span>
-->
<p><span class="caption">Encart 17-8Â : une autre <em>crate</em> utilisant <code>gui</code> et
implÃ©mentant le trait <code>Affichable</code> sur une structure <code>ListeDeroulante</code></span></p>
<!--
Our libraryâ€™s user can now write their `main` function to create a `Screen`
instance. To the `Screen` instance, they can add a `SelectBox` and a `Button`
by putting each in a `Box<T>` to become a trait object. They can then call the
`run` method on the `Screen` instance, which will call `draw` on each of the
components. Listing 17-9 shows this implementation:
-->
<p>L'utilisateur de notre bibliothÃ¨que peut maintenant Ã©crire sa fonction <code>main</code>
pour crÃ©er une instance de <code>Ecran</code>. Il peut ajouter Ã  l'instance de <code>Ecran</code> une
<code>ListeDeroulante</code> ou un <code>Bouton</code> en les mettant chacun dans un <code>Box&lt;T&gt;</code> pour en
faire des objets traits. Il peut ensuite appeler la mÃ©thode <code>executer</code> sur
l'instance de <code>Ecran</code>, qui appellera <code>afficher</code> sur chacun de ses composants.
L'encart 17-9 montre cette implÃ©mentationÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use gui::Draw;
# 
# struct SelectBox {
#     width: u32,
#     height: u32,
#     options: Vec<String>,
# }
# 
# impl Draw for SelectBox {
#     fn draw(&self) {
#         // code to actually draw a select box
#     }
# }
# 
use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use gui::Affichable;
</span><span class="boring">
</span><span class="boring">struct ListeDeroulante {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Affichable for ListeDeroulante {
</span><span class="boring">    fn afficher(&amp;self) {
</span><span class="boring">        // code servant vraiment Ã  afficher une liste dÃ©roulante
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Bouton, Ecran};

fn main() {
    let ecran = Ecran {
        composants: vec![
            Box::new(ListeDeroulante {
                largeur: 75,
                hauteur: 10,
                options: vec![
                    String::from(&quot;Oui&quot;),
                    String::from(&quot;Peut-Ãªtre&quot;),
                    String::from(&quot;Non&quot;),
                ],
            }),
            Box::new(Bouton {
                largeur: 50,
                hauteur: 10,
                libelle: String::from(&quot;OK&quot;),
            }),
        ],
    };

    ecran.executer();
}
</code></pre>
<!--
<span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span>
-->
<p><span class="caption">Encart 17-9Â : utilisation d'objets traits pour stocker des
valeurs de types diffÃ©rents qui implÃ©mentent le mÃªme trait</span></p>
<!--
When we wrote the library, we didnâ€™t know that someone might add the
`SelectBox` type, but our `Screen` implementation was able to operate on the
new type and draw it because `SelectBox` implements the `Draw` trait, which
means it implements the `draw` method.
-->
<p>Quand nous avons Ã©crit la bibliothÃ¨que, nous ne savions pas que quelqu'un
pourrait y ajouter le type <code>ListeDeroulante</code>, mais notre implÃ©mentation de
<code>Ecran</code> a pu opÃ©rer sur le nouveau type et l'afficher parce que
<code>ListeDeroulante</code> implÃ©mente le trait <code>Affichable</code>, ce qui veut dire qu'elle
implÃ©mente la mÃ©thode <code>afficher</code>.</p>
<!--
This conceptâ€”of being concerned only with the messages a value responds to
rather than the valueâ€™s concrete typeâ€”is similar to the concept of *duck
typing* in dynamically typed languages: if it walks like a duck and quacks
like a duck, then it must be a duck! In the implementation of `run` on `Screen`
in Listing 17-5, `run` doesnâ€™t need to know what the concrete type of each
component is. It doesnâ€™t check whether a component is an instance of a `Button`
or a `SelectBox`, it just calls the `draw` method on the component. By
specifying `Box<dyn Draw>` as the type of the values in the `components`
vector, weâ€™ve defined `Screen` to need values that we can call the `draw`
method on.
-->
<p>Ce concept â€” se prÃ©occuper uniquement des messages auxquels une valeur rÃ©pond
plutÃ´t que du type concret de la valeur â€” est similaire au concept du <em>duck
typing</em> (â€œtypage canardâ€) dans les langages typÃ©s dynamiquementÂ : si Ã§a marche
comme un canard et que Ã§a fait coin-coin comme un canard, alors Ã§a doit Ãªtre un
canardÂ ! Dans l'implÃ©mentation de <code>executer</code> sur <code>Ecran</code> dans l'encart 17-5,
<code>executer</code> n'a pas besoin de connaÃ®tre le type concret de chaque composant. Elle
ne vÃ©rifie pas si un composant est une instance de <code>Bouton</code> ou de
<code>ListeDeroulante</code>, elle ne fait qu'appeler la mÃ©thode <code>afficher</code> sur le
composant. En spÃ©cifiant <code>Box&lt;dyn Affichable&gt;</code> comme type des valeurs dans le
vecteur <code>composants</code>, nous avons dÃ©fini que <code>Ecran</code> n'avait besoin que de valeurs
sur lesquelles on peut appeler la mÃ©thode <code>afficher</code>.</p>
<!--
The advantage of using trait objects and Rustâ€™s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesnâ€™t implement a method but we call it anyway. Rust wonâ€™t compile
our code if the values donâ€™t implement the traits that the trait objects need.
-->
<p>L'avantage d'utiliser les objets traits et le systÃ¨me de types de Rust pour
Ã©crire du code plutÃ´t que d'utiliser le <em>duck typing</em> est que nous n'avons
jamais besoin de vÃ©rifier si une valeur implÃ©mente une mÃ©thode en particulier Ã 
l'exÃ©cution, ni de s'inquiÃ©ter d'avoir des erreurs si une valeur n'implÃ©mente
pas une mÃ©thode mais qu'on l'appelle quand mÃªme. Rust ne compilera pas notre
code si les valeurs n'implÃ©mentent pas les traits requis par les objets traits.</p>
<!--
For example, Listing 17-10 shows what happens if we try to create a `Screen`
with a `String` as a component:
-->
<p>Par exemple, l'encart 17-10 montre ce qui arrive si on essaie de crÃ©er un
<code>Ecran</code> avec une <code>String</code> comme composantÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use gui::Ecran;

fn main() {
    let ecran = Ecran {
        composants: vec![Box::new(String::from(&quot;Salut&quot;))],
    };

    ecran.executer();
}
</code></pre>
<!--
<span class="caption">Listing 17-10: Attempting to use a type that doesnâ€™t
implement the trait objectâ€™s trait</span>
-->
<p><span class="caption">Encart 17-10Â : tentative d'utiliser un type qui
n'implÃ©mente pas le trait de l'objet trait</span></p>
<!--
Weâ€™ll get this error because `String` doesnâ€™t implement the `Draw` trait:
-->
<p>Nous aurons cette erreur parce que <code>String</code> n'implÃ©mente pas le trait
<code>Affichable</code>Â :</p>
<!--
```console
$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
 -- > src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `gui::Draw` is not implemented for `std::string::String`
  |
  = note: required for the cast to the object type `dyn gui::Draw`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `std::string::String: gui::Affichable` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         composants: vec![Box::new(String::from(&quot;Salut&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `gui::Affichable` is not implemented for `std::string::String`
  |
  = note: required for the cast to the object type `dyn gui::Affichable`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error lets us know that either weâ€™re passing something to `Screen` we
didnâ€™t mean to pass and we should pass a different type or we should implement
`Draw` on `String` so that `Screen` is able to call `draw` on it.
-->
<p>L'erreur nous fait savoir que soit nous passons quelque chose Ã  <code>Ecran</code> que nous
ne voulions pas lui passer et nous devrions lui passer un type diffÃ©rent, soit
nous devrions implÃ©menter <code>Affichable</code> sur <code>String</code> de sorte que <code>Ecran</code> puisse
appeler <code>afficher</code> dessus.</p>
<!--
### Trait Objects Perform Dynamic Dispatch
-->
<h3><a class="header" href="#les-objets-traits-effectuent-de-la-rÃ©partition-dynamique" id="les-objets-traits-effectuent-de-la-rÃ©partition-dynamique">Les objets traits effectuent de la rÃ©partition dynamique</a></h3>
<!--
Recall in the [â€œPerformance of Code Using
Genericsâ€][performance-of-code-using-generics]<!-- ignore -- > section in
Chapter 10 our discussion on the monomorphization process performed by the
compiler when we use trait bounds on generics: the compiler generates
nongeneric implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing *static dispatch*, which is when the compiler knows
what method youâ€™re calling at compile time. This is opposed to *dynamic
dispatch*, which is when the compiler canâ€™t tell at compile time which method
youâ€™re calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call.
-->
<p>Rappelez-vous de notre discussion dans <a href="ch10-01-syntax.html">une
section</a><!-- ignore --> du
chapitre 10 Ã  propos du processus de monomorphisation effectuÃ© par le
compilateur quand nous utilisons des traits liÃ©s sur des gÃ©nÃ©riquesÂ : le
compilateur gÃ©nÃ¨re des implÃ©mentations non gÃ©nÃ©riques de fonctions et de
mÃ©thodes pour chaque type concret que nous utilisons Ã  la place d'un paramÃ¨tre
de type gÃ©nÃ©rique. Le code rÃ©sultant de la monomorphisation effectue du
<em>dispatch statique</em>, c'est-Ã -dire quand le compilateur sait quelle mÃ©thode
vous appelez Ã  la compilation. Cela s'oppose au <em>dispatch dynamique</em>,
c'est-Ã -dire quand le compilateur ne peut pas dÃ©terminer Ã  la compilation quelle
mÃ©thode vous appelez. Dans les cas de rÃ©partition dynamique, le compilateur Ã©met du
code qui devra dÃ©terminer Ã  l'exÃ©cution quelle mÃ©thode appeler.</p>
<!--
When we use trait objects, Rust must use dynamic dispatch. The compiler doesnâ€™t
know all the types that might be used with the code that is using trait
objects, so it doesnâ€™t know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesnâ€™t occur with static dispatch. Dynamic dispatch also prevents the compiler
from choosing to inline a methodâ€™s code, which in turn prevents some
optimizations. However, we did get extra flexibility in the code that we wrote
in Listing 17-5 and were able to support in Listing 17-9, so itâ€™s a trade-off
to consider.
-->
<p>Quand nous utilisons des objets traits, Rust doit utiliser de la rÃ©partition
dynamique. Le compilateur ne connaÃ®t pas tous les types qui pourraient Ãªtre
utilisÃ©s avec le code qui utilise des objets traits, donc il ne sait pas quelle
mÃ©thode implÃ©mentÃ©e sur quel type il doit appeler. Ã€ la place, lors de l'exÃ©cution, Rust
utilise les pointeurs Ã  l'intÃ©rieur de l'objet trait pour savoir quelle mÃ©thode
appeler. Il y a un coÃ»t Ã  l'exÃ©cution lors de la recherche de cette mÃ©thode qui
n'a pas lieu avec la rÃ©partition statique. La rÃ©partition dynamique empÃªche en outre
le compilateur de choisir de remplacer un appel de mÃ©thode par le code de cette
mÃ©thode, ce qui empÃªche par ricochet certaines optimisations. Cependant, cela a
permis de rendre plus flexible le code que nous avons Ã©crit dans l'encart 17-5
et que nous avons pu supporter dans l'encart 17-9, donc c'est un compromis Ã 
envisager.</p>
<!--
### Object Safety Is Required for Trait Objects
-->
<h3><a class="header" href="#la-sÃ»retÃ©-au-sens-de-lobjet-est-nÃ©cessaire-pour-les-objets-traits" id="la-sÃ»retÃ©-au-sens-de-lobjet-est-nÃ©cessaire-pour-les-objets-traits">La sÃ»retÃ© au sens de l'objet est nÃ©cessaire pour les objets traits</a></h3>
<!--
You can only make *object-safe* traits into trait objects. Some complex rules
govern all the properties that make a trait object safe, but in practice, only
two rules are relevant. A trait is object safe if all the methods defined in
the trait have the following properties:
-->
<p>On ne peut transformer en objets traits que les traits <em>sÃ»rs au sens de
l'objet</em> (<em>object-safe</em>). Quelques rÃ¨gles complexes rÃ©gissent toutes les
propriÃ©tÃ©s qui rendent un objet trait sÃ»r au sens de l'objet, mais en pratique,
seules deux rÃ¨gles sont pertinentes. Un trait est sÃ»r au sens de l'objet si
toutes les mÃ©thodes dÃ©finies sur le trait ont les propriÃ©tÃ©s suivantesÂ :</p>
<!--
* The return type isnâ€™t `Self`.
* There are no generic type parameters.
-->
<ul>
<li>Le type de retour n'est pas <code>Self</code>.</li>
<li>Il n'y a pas de paramÃ¨tres de type gÃ©nÃ©riques.</li>
</ul>
<!--
The `Self` keyword is an alias for the type weâ€™re implementing the traits or
methods on. Trait objects must be object safe because once youâ€™ve used a trait
object, Rust no longer knows the concrete type thatâ€™s implementing that trait.
If a trait method returns the concrete `Self` type, but a trait object forgets
the exact type that `Self` is, there is no way the method can use the original
concrete type. The same is true of generic type parameters that are filled in
with concrete type parameters when the trait is used: the concrete types become
part of the type that implements the trait. When the type is forgotten through
the use of a trait object, there is no way to know what types to fill in the
generic type parameters with.
-->
<p>Le mot-clÃ© <code>Self</code> est un alias pour le type sur lequel nous implÃ©mentons les
traits ou les mÃ©thodes. Les objets traits doivent Ãªtre sÃ»rs au sens de l'objet
parce qu'une fois qu'on a utilisÃ© un objet trait, Rust ne sait plus quel est le
type concret qui implÃ©mente ce trait. Si une mÃ©thode de trait retourne le type
concret <code>Self</code>, mais qu'un objet trait oublie le type exact reprÃ©sentÃ© par
<code>Self</code>, il est impossible pour la mÃ©thode d'utiliser le type concret d'origine.
Il en va de mÃªme pour les paramÃ¨tres de type gÃ©nÃ©riques qui sont remplacÃ©s par
des paramÃ¨tres de type concrets quand le trait est utilisÃ©Â : les types concrets
deviennent partie intÃ©grante du type qui implÃ©mente le trait. Lorsque le type
est oubliÃ© Ã  cause de l'utilisation d'un objet trait, il devient impossible de
savoir par quels types remplacer les paramÃ¨tres de type gÃ©nÃ©riques.</p>
<!--
An example of a trait whose methods are not object safe is the standard
libraryâ€™s `Clone` trait. The signature for the `clone` method in the `Clone`
trait looks like this:
-->
<p>Un exemple de trait dont les mÃ©thodes ne sont pas sÃ»res au sens de l'objet est
le trait <code>Clone</code> de la bibliothÃ¨que standard. La signature de la mÃ©thode <code>clone</code>
du trait <code>Clone</code> ressemble Ã  ceciÂ :</p>
<!--
```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `String` type implements the `Clone` trait, and when we call the `clone`
method on an instance of `String` we get back an instance of `String`.
Similarly, if we call `clone` on an instance of `Vec<T>`, we get back an
instance of `Vec<T>`. The signature of `clone` needs to know what type will
stand in for `Self`, because thatâ€™s the return type.
-->
<p>Le type <code>String</code> implÃ©mente le trait <code>Clone</code>, et quand on appelle la mÃ©thode
<code>clone</code> sur une instance de <code>String</code>, on rÃ©cupÃ¨re une instance de <code>String</code>. De
mÃªme, si on appelle <code>clone</code> sur une instance de <code>Vec&lt;T&gt;</code>, on rÃ©cupÃ¨re une
instance de <code>Vec&lt;T&gt;</code>. La signature de <code>clone</code> doit savoir Ã  quel type correspond
<code>Self</code>, puisqu'il s'agit du type de retour.</p>
<!--
The compiler will indicate when youâ€™re trying to do something that violates the
rules of object safety in regard to trait objects. For example, letâ€™s say we
tried to implement the `Screen` struct in Listing 17-4 to hold types that
implement the `Clone` trait instead of the `Draw` trait, like this:
-->
<p>Le compilateur vous prÃ©viendra lorsque vous essayez de faire quelque chose qui
enfreint les rÃ¨gles de sÃ»retÃ© au sens de l'objet lors de l'utilisation des objets traits.
Par exemple, supposons que nous avons essayÃ© d'implÃ©menter la structure <code>Ecran</code>
de l'encart 17-4 en la faisant contenir des types qui implÃ©mentent le trait
<code>Clone</code> plutÃ´t que le trait <code>Affichable</code>, comme ceciÂ :</p>
<!--
```rust,ignore,does_not_compile
pub struct Screen {
    pub components: Vec<Box<dyn Clone>>,
}
```
-->
<pre><code class="language-rust ignore does_not_compile">pub struct Ecran {
    pub composants: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
</code></pre>
<!--
We would get this error:
-->
<p>Nous aurions obtenu cette erreurÂ :</p>
<!--
```console
$ cargo build
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 -- > src/lib.rs:2:5
  |
2 |     pub components: Vec<Box<dyn Clone>>,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0038`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub composants: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0038`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error means you canâ€™t use this trait as a trait object in this way. If
youâ€™re interested in more details on object safety, see [Rust RFC 255].
-->
<p>Cette erreur signifie que l'on ne peut pas utiliser ce trait comme d'un objet
trait de cette faÃ§on. Si vous souhaitez connaÃ®tre plus de dÃ©tails sur la sÃ»retÃ©
au sens de l'objet, rÃ©fÃ©rez-vous Ã  la <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255 de Rust</a> (en
anglais).</p>
<!-- markdownlint-disable -->
<!--
[Rust RFC 255]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md

[performance-of-code-using-generics]:
ch10-01-syntax.html#performance-of-code-using-generics
[dynamically-sized]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait
-->
<!-- markdownlint-restore -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--39" id="-attention-peinture-fraÃ®che--39">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
## Implementing an Object-Oriented Design Pattern
-->
<h2><a class="header" href="#implÃ©menter-un-patron-de-conception-orientÃ©-objet" id="implÃ©menter-un-patron-de-conception-orientÃ©-objet">ImplÃ©menter un patron de conception orientÃ©-objet</a></h2>
<!--
The *state pattern* is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of *state objects*, and the valueâ€™s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.
-->
<p>Le <em>patron Ã©tat</em> est un patron de conception issu de l'orientÃ© objet. Le point
essentiel du modÃ¨le est qu'une valeur a un Ã©tat interne, qui est reprÃ©sentÃ© par
un ensemble <em>d'Ã©tats</em>, et le comportement de la valeur change en fonction de son
Ã©tat interne. Les objets Ã©tat partagent des fonctionnalitÃ©sÂ : en Rust, bien sÃ»r,
nous utilisons des structures et des traits plutÃ´t que des objets et de
l'hÃ©ritage. Chaque objet Ã©tat est responsable de son propre comportement et
dÃ©cide lorsqu'il doit changer pour un autre Ã©tat. La valeur contenue dans un
objet Ã©tat ne sait rien sur les diffÃ©rents comportements des Ã©tats et ne sait
pas quand il va changer d'Ã©tat.</p>
<!--
Using the state pattern means when the business requirements of the program
change, we wonâ€™t need to change the code of the value holding the state or the
code that uses the value. Weâ€™ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Letâ€™s look
at an example of the state design pattern and how to use it in Rust.
-->
<p>L'utilisation du patron Ã©tat signifie que lorsque les prÃ©-requis du mÃ©tier du
programme ont changÃ©, nous n'avons pas besoin de changer le code Ã  l'intÃ©rieur
de l'objet Ã©tat ou le code qui utilise l'objet. Nous avons juste besoin de
modifier le code dans un des objets Ã©tat pour changer son fonctionnement ou pour
ajouter d'autres objets Ã©tat. Voyons un exemple du patron Ã©tat et comment
l'utiliser en Rust.</p>
<!--
Weâ€™ll implement a blog post workflow in an incremental way. The blogâ€™s final
functionality will look like this:
-->
<p>Nous allons implÃ©menter un processus de publication de billets de blogs de
maniÃ¨re incrÃ©mentale. Les fonctionnalitÃ©s finales du blog seront les suivantesÂ :</p>
<!--
1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts canâ€™t
   accidentally be published.
-->
<ol>
<li>Un billet de blog commence par un brouillon vide.</li>
<li>Lorsque le brouillon est terminÃ©, une relecture du billet est demandÃ©e.</li>
<li>Lorsqu'un billet est approuvÃ©, il est publiÃ©.</li>
<li>Seuls les billets de blog publiÃ©s retournent du contenu Ã  afficher, donc les
billets non approuvÃ©s ne peuvent pas Ãªtre publiÃ©s accidentellement.</li>
</ol>
<!--
Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before weâ€™ve requested a review, the post
should remain an unpublished draft.
-->
<p>Tous les autres changements effectuÃ©s sur un billet n'auront pas d'effet. Par
exemple, si nous essayons d'approuver un brouillon de billet de blog avant
d'avoir demandÃ© une relecture, le billet devrait rester Ã  l'Ã©tat de brouillon
non publiÃ©.</p>
<!--
Listing 17-11 shows this workflow in code form: this is an example usage of the
API weâ€™ll implement in a library crate named `blog`. This wonâ€™t compile yet
because we havenâ€™t implemented the `blog` crate yet.
-->
<p>L'encart 17-11 prÃ©sente ce processus de publication sous forme de codeÂ : c'est
un exemple d'utilisation de l'API que nous allons implÃ©menter dans une crate de
bibliothÃ¨que <code>blog</code>. Elle ne va pas encore se compiler car nous n'avons pas
encore implÃ©mentÃ© la crate <code>blog</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.demander_relecture();
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.approuver();
    assert_eq!(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our `blog` crate to have</span>
-->
<p><span class="caption">Encart 17-11Â : du code qui montre le comportement attendu
de notre crate <code>blog</code></span></p>
<!--
We want to allow the user to create a new draft blog post with `Post::new`.
Then we want to allow text to be added to the blog post while itâ€™s in the draft
state. If we try to get the postâ€™s content immediately, before approval,
nothing should happen because the post is still a draft. Weâ€™ve added
`assert_eq!` in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
`content` method, but weâ€™re not going to write tests for this example.
-->
<p>Nous voulons permettre Ã  l'utilisateur de crÃ©er un nouveau brouillon de billet
de blog avec <code>Billet::new</code>. Ensuite nous voulons qu'il puisse ajouter du texte
au billet de blog tant qu'il est Ã  l'Ã©tat de brouillon. Si nous essayons
d'obtenir immÃ©diatement le contenu du billet, avant qu'il soit relu, rien ne va
se passer car le billet est toujours un brouillon. Nous avons ajoutÃ© des
<code>assert_eq!</code> dans le code pour les besoins de la dÃ©monstration. Un excellent
test unitaire pour cela serait de vÃ©rifier qu'un brouillon de billet de blog
retourne bien une chaÃ®ne de caractÃ¨res vide Ã  partir de la mÃ©thode <code>contenu</code>,
mais nous n'allons pas Ã©crire de tests pour cet exemple.</p>
<!--
Next, we want to enable a request for a review of the post, and we want
`content` to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when `content` is called.
-->
<p>Ensuite, nous voulons permettre de demander une relecture du billet, et nous
souhaitons que <code>contenu</code> retourne toujours une chaÃ®ne de caractÃ¨res vide pendant
que nous attendons la relecture. Lorsque la relecture du billet est approuvÃ©e,
il doit Ãªtre publiÃ©, ce qui signifie que le texte du billet doit Ãªtre retournÃ©
lors de l'appel Ã  <code>contenu</code>.</p>
<!--
Notice that the only type weâ€™re interacting with from the crate is the `Post`
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
inâ€”draft, waiting for review, or published. Changing from one state to another
will be managed internally within the `Post` type. The states change in
response to the methods called by our libraryâ€™s users on the `Post` instance,
but they donâ€™t have to manage the state changes directly. Also, users canâ€™t
make a mistake with the states, like publishing a post before itâ€™s reviewed.
-->
<p>Remarquez que le seul type avec lequel nous interagissons avec la crate est le
type <code>Billet</code>. Ce type va utiliser le patron Ã©tat et va hÃ©berger une valeur qui
sera un des trois objets Ã©tat reprÃ©sentant les diffÃ©rents Ã©tats dans lesquels
passent un billetÂ : brouillon, en attente de relecture, ou publiÃ©. Le changement
d'un Ã©tat Ã  un autre sera gÃ©rÃ© en interne du type <code>Billet</code>. Les Ã©tats vont
changer suite aux mÃ©thodes appelÃ©es par les utilisateurs de notre bibliothÃ¨que
sur l'instance de <code>Billet</code>, mais ils n'ont pas Ã  gÃ©rer directement les
changements d'Ã©tat. De plus, les utilisateurs ne peuvent pas faire d'erreur avec
les Ã©tats, comme par exemple publier un billet avant qu'il soit relu.</p>
<!--
### Defining `Post` and Creating a New Instance in the Draft State
-->
<h3><a class="header" href="#dÃ©finir-billet-et-crÃ©er-une-nouvelle-instance-Ã -lÃ©tat-de-brouillon" id="dÃ©finir-billet-et-crÃ©er-une-nouvelle-instance-Ã -lÃ©tat-de-brouillon">DÃ©finir <code>Billet</code> et crÃ©er une nouvelle instance Ã  l'Ã©tat de brouillon</a></h3>
<!--
Letâ€™s get started on the implementation of the library! We know we need a
public `Post` struct that holds some content, so weâ€™ll start with the
definition of the struct and an associated public `new` function to create an
instance of `Post`, as shown in Listing 17-12. Weâ€™ll also make a private
`State` trait. Then `Post` will hold a trait object of `Box<dyn State>`
inside an `Option<T>` in a private field named `state`. Youâ€™ll see why the
`Option<T>` is necessary in a bit.
-->
<p>CommenÃ§ons l'implÃ©mentation de la bibliothÃ¨queÂ ! Nous savons que nous aurons
besoin d'une structure publique <code>Billet</code> qui hÃ©berge du contenu, donc nous
allons commencer par dÃ©finir cette structure et une fonction publique <code>new</code> qui
lui est associÃ©e pour crÃ©er une instance de <code>Billet</code>, comme dans l'encart 17-12.
Nous allons aussi crÃ©er un trait privÃ© <code>Etat</code>. Ensuite <code>Billet</code> devra avoir un
champ privÃ© <code>etat</code> pour y loger une <code>Option&lt;T&gt;</code> contenant un objet trait de
<code>Box&lt;dyn Etat&gt;</code>. Nous verrons plus tard l'intÃ©rÃªt du <code>Option&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Billet {
    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; Billet {
        Billet {
            etat: Some(Box::new(Brouillon {})),
            contenu: String::new(),
        }
    }
}

trait Etat {}

struct Brouillon {}

impl Etat for Brouillon {}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-12: Definition of a `Post` struct and a `new`
function that creates a new `Post` instance, a `State` trait, and a `Draft`
struct</span>
-->
<p><span class="caption">Encart 17-12Â : dÃ©finition d'une structure <code>Billet</code> et
d'une fonction <code>new</code> qui crÃ©e une nouvelle instance de <code>Billet</code>, un trait
<code>Etat</code>, et une structure <code>Brouillon</code></span></p>
<!--
The `State` trait defines the behavior shared by different post states, and the
`Draft`, `PendingReview`, and `Published` states will all implement the `State`
trait. For now, the trait doesnâ€™t have any methods, and weâ€™ll start by defining
just the `Draft` state because that is the state we want a post to start in.
-->
<p>Le trait <code>Etat</code> dÃ©finit le comportement partagÃ© par plusieurs Ã©tats de billet,
et les Ã©tats <code>Brouillon</code>, <code>EnRelecture</code>, et <code>Publier</code> vont tous implÃ©menter le
trait <code>Etat</code>. Pour l'instant, le trait n'a pas de mÃ©thode, et nous allons
commencer par dÃ©finir uniquement l'Ã©tat <code>Brouillon</code> car c'est l'Ã©tat dans lequel
nous voulons crÃ©er un nouveau billet.</p>
<!--
When we create a new `Post`, we set its `state` field to a `Some` value that
holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This
ensures whenever we create a new instance of `Post`, it will start out as a
draft. Because the `state` field of `Post` is private, there is no way to
create a `Post` in any other state! In the `Post::new` function, we set the
`content` field to a new, empty `String`.
-->
<p>Lorsque nous crÃ©ons un nouveau <code>Billet</code>, nous assignons Ã  son champ <code>etat</code> une
valeur <code>Some</code> qui contient une <code>Box</code>. Cette <code>Box</code> pointe sur une nouvelle
instance de la structure <code>Brouillon</code>. Cela garantira qu'Ã  chaque fois que nous
crÃ©ons une nouvelle instance de <code>Billet</code>, elle commencera Ã  l'Ã©tat de brouillon.
Comme le champ <code>etat</code> de <code>Billet</code> est privÃ©, il n'y a pas d'autre maniÃ¨re de
crÃ©er un <code>Billet</code> dans un autre Ã©tatÂ ! Dans la fonction <code>Billet::new</code>, nous
assignons une nouvelle <code>String</code> vide au champ <code>contenu</code>.</p>
<!--
### Storing the Text of the Post Content
-->
<h3><a class="header" href="#stocker-le-texte-du-contenu-du-billet" id="stocker-le-texte-du-contenu-du-billet">Stocker le texte du contenu du billet</a></h3>
<!--
Listing 17-11 showed that we want to be able to call a method named
`add_text` and pass it a `&str` that is then added to the text content of the
blog post. We implement this as a method rather than exposing the `content`
field as `pub`. This means we can implement a method later that will control
how the `content` fieldâ€™s data is read. The `add_text` method is pretty
straightforward, so letâ€™s add the implementation in Listing 17-13 to the `impl
Post` block:
-->
<p>L'encart 17-11 a montrÃ© que nous souhaitons appeler une mÃ©thode <code>ajouter_texte</code>
et lui passer un <code>&amp;str</code> qui est ensuite ajoutÃ© au contenu textuel du billet de
blog. Nous implÃ©mentons ceci avec une mÃ©thode plutÃ´t que d'exposer publiquement
le champ <code>contenu</code> avec <code>pub</code>. Cela signifie que nous pouvons implÃ©menter une
mÃ©thode plus tard qui va contrÃ´ler comment le champ <code>contenu</code> sera lu. La
mÃ©thode <code>ajouter_texte</code> est assez simple, donc ajoutons son implÃ©mentation dans
le bloc <code>Billet</code> de l'encart 17-13Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-13: Implementing the `add_text` method to add
text to a postâ€™s `content`</span>
-->
<p><span class="caption">Encart 17-13Â : implÃ©mentation de la mÃ©thode
<code>ajouter_texte</code> pour ajouter du texte au <code>contenu</code> d'un billet</span></p>
<!--
The `add_text` method takes a mutable reference to `self`, because weâ€™re
changing the `Post` instance that weâ€™re calling `add_text` on. We then call
`push_str` on the `String` in `content` and pass the `text` argument to add to
the saved `content`. This behavior doesnâ€™t depend on the state the post is in,
so itâ€™s not part of the state pattern. The `add_text` method doesnâ€™t interact
with the `state` field at all, but it is part of the behavior we want to
support.
-->
<p>La mÃ©thode <code>ajouter_texte</code> prend en argument une rÃ©fÃ©rence mutable vers <code>self</code>,
car nous changeons l'instance <code>Billet</code> sur laquelle nous appelons
<code>ajouter_texte</code>. Nous faisons ensuite appel Ã  <code>push_str</code> sur le <code>String</code> dans
<code>contenu</code> et nous y envoyons l'argument <code>texte</code> pour l'ajouter au <code>contenu</code> dÃ©jÃ 
stockÃ©. Ce comportement ne dÃ©pend pas de l'Ã©tat dans lequel est le billet, donc
cela ne fait pas partie du patron Ã©tat. La mÃ©thode <code>ajouter_texte</code> n'interagit
pas du tout avec le champ <code>etat</code>, mais c'est volontaire.</p>
<!--
### Ensuring the Content of a Draft Post Is Empty
-->
<h3><a class="header" href="#sassurer-que-le-contenu-dun-brouillon-est-vide" id="sassurer-que-le-contenu-dun-brouillon-est-vide">S'assurer que le contenu d'un brouillon est vide</a></h3>
<!--
Even after weâ€™ve called `add_text` and added some content to our post, we still
want the `content` method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 17-11. For now, letâ€™s
implement the `content` method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. Weâ€™ll change this later
once we implement the ability to change a postâ€™s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:
-->
<p>MÃªme si nous avons appelÃ© <code>ajouter_texte</code> et ajoutÃ© du contenu dans notre
billet, nous voulons que la mÃ©thode <code>contenu</code> retourne toujours une slice de
chaÃ®ne de caractÃ¨res vide car le billet est toujours Ã  l'Ã©tat de brouillon,
comme le montre la ligne 7 de l'encart 17-11. ImplÃ©mentons maintenant la mÃ©thode
<code>contenu</code> de la maniÃ¨re la plus simple qui rÃ©pond Ã  cette consigneÂ : toujours
retourner un slice de chaÃ®ne de caractÃ¨res vide. Nous la changerons plus tard
lorsque nous implÃ©menterons la capacitÃ© de changer l'Ã©tat d'un billet afin qu'il
puisse Ãªtre publiÃ©. Pour l'instant, les billets ne peuvent qu'Ãªtre Ã  l'Ã©tat de
brouillon, donc le contenu du billet devrait toujours Ãªtre vide. L'encart 17-14
montre l'implÃ©mentation de ceciÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        ""
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-14: Adding a placeholder implementation for
the `content` method on `Post` that always returns an empty string slice</span>
-->
<p><span class="caption">Encart 17-14Â : ajout d'une implÃ©mentation de la mÃ©thode
<code>contenu</code> sur <code>Billet</code> qui va toujours retourner une slice de chaÃ®ne de
caractÃ¨res vide</span></p>
<!--
With this added `content` method, everything in Listing 17-11 up to line 7
works as intended.
-->
<p>Avec cette mÃ©thode <code>contenu</code> ajoutÃ©e, tout ce qu'il y a dans l'encart 17-11
fonctionne comme prÃ©vu jusqu'Ã  la ligne 7.</p>
<!--
### Requesting a Review of the Post Changes Its State
-->
<h3><a class="header" href="#demander-une-relecture-du-billet-va-changer-son-Ã©tat" id="demander-une-relecture-du-billet-va-changer-son-Ã©tat">Demander une relecture du billet va changer son Ã©tat</a></h3>
<!--
Next, we need to add functionality to request a review of a post, which should
change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:
-->
<p>Ensuite, nous avons besoin d'ajouter une fonctionnalitÃ© pour demander la
relecture d'un billet, qui devrait changer son Ã©tat de <code>Brouillon</code> Ã 
<code>EnRelecture</code>. L'encart 17-15 montre ce codeÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.demander_relecture())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(EnRelecture {})
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-15: Implementing `request_review` methods on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-15Â : implÃ©mentation des mÃ©thodes
<code>demander_relecture</code> sur <code>Billet</code> et le trait <code>Etat</code></span></p>
<!--
We give `Post` a public method named `request_review` that will take a mutable
reference to `self`. Then we call an internal `request_review` method on the
current state of `Post`, and this second `request_review` method consumes the
current state and returns a new state.
-->
<p>Nous installons la mÃ©thode publique <code>demander_relecture</code> sur <code>Billet</code> qui va
prendre en argument une rÃ©fÃ©rence mutable Ã  <code>self</code>. Ensuite nous appelons la
mÃ©thode interne <code>demander_relecture</code> sur l'Ã©tat interne de <code>Billet</code>, et cette
seconde mÃ©thode <code>demander_relecture</code> consomme l'Ã©tat en cours et applique un
nouvel Ã©tat.</p>
<!--
Weâ€™ve added the `request_review` method to the `State` trait; all types that
implement the trait will now need to implement the `request_review` method.
Note that rather than having `self`, `&self`, or `&mut self` as the first
parameter of the method, we have `self: Box<Self>`. This syntax means the
method is only valid when called on a `Box` holding the type. This syntax takes
ownership of `Box<Self>`, invalidating the old state so the state value of the
`Post` can transform into a new state.
-->
<p>Nous avons ajoutÃ© la mÃ©thode <code>demander_relecture</code> sur le trait <code>Etat</code>Â ; tous les
types qui implÃ©mentent le trait vont maintenant devoir implÃ©menter la mÃ©thode
<code>demander_relecture</code>. Remarquez qu'au lieu d'avoir <code>self</code>, <code>&amp;self</code>, ou
<code>&amp;mut self</code> en premier paramÃ¨tre de la mÃ©thode, nous avons <code>self: Box&lt;Self&gt;</code>.
Cette syntaxe signifie que la mÃ©thode est valide uniquement lorsqu'on l'appelle
sur une <code>Box</code> qui contient ce type. Cette syntaxe prend possession de
<code>Box&lt;Self&gt;</code>, ce qui annule l'ancien Ã©tat du <code>Billet</code> qui peut changer pour un
nouvel Ã©tat.</p>
<!--
To consume the old state, the `request_review` method needs to take ownership
of the state value. This is where the `Option` in the `state` field of `Post`
comes in: we call the `take` method to take the `Some` value out of the `state`
field and leave a `None` in its place, because Rust doesnâ€™t let us have
unpopulated fields in structs. This lets us move the `state` value out of
`Post` rather than borrowing it. Then weâ€™ll set the postâ€™s `state` value to the
result of this operation.
-->
<p>Pour consommer l'ancien Ã©tat, la mÃ©thode <code>demander_relecture</code> a besoin de
prendre possession de la valeur d'Ã©tat. C'est ce Ã  quoi sert le <code>Option</code> dans le
champ <code>etat</code> de <code>Billet</code>Â : nous faisons appel Ã  la mÃ©thode <code>take</code> pour obtenir
la valeur dans le <code>Some</code> du champ <code>etat</code> et le remplacer par <code>None</code>, car Rust ne
nous permet pas d'avoir des champs non renseignÃ©s dans des structures. Cela nous
permet d'extraire la valeur de <code>etat</code> d'un <code>Billet</code>, plutÃ´t que de l'emprunter.
Ensuite, nous allons rÃ©affecter le rÃ©sultat de cette opÃ©ration Ã  <code>etat</code> du
<code>Billet</code> concernÃ©.</p>
<!--
We need to set `state` to `None` temporarily rather than setting it directly
with code like `self.state = self.state.request_review();` to get ownership of
the `state` value. This ensures `Post` canâ€™t use the old `state` value after
weâ€™ve transformed it into a new state.
-->
<p>Nous devons assigner temporairement <code>None</code> Ã  <code>etat</code> plutÃ´t que de lui donner
directement avec code comme <code>self.etat = self.etat.demander_relecture();</code> car
nous voulons prendre possession de la valeur <code>etat</code>. Cela garantit que <code>Billet</code>
ne peut pas utiliser l'ancienne valeur de <code>etat</code> aprÃ¨s qu'on ai changÃ© cet Ã©tat.</p>
<!--
The `request_review` method on `Draft` needs to return a new, boxed instance of
a new `PendingReview` struct, which represents the state when a post is waiting
for a review. The `PendingReview` struct also implements the `request_review`
method but doesnâ€™t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the `PendingReview` state, it
should stay in the `PendingReview` state.
-->
<p>La mÃ©thode <code>demander_relecture</code> sur <code>Brouillon</code> doit retourner une nouvelle
instance d'une structure <code>EnRelecture</code> dans une <code>Box</code>, qui reprÃ©sente l'Ã©tat
lorsqu'un billet est en attente de relecture. La structure <code>EnRelecture</code>
implÃ©mente elle aussi la mÃ©thode <code>demander_relecture</code> mais ne fait aucune
modification. A la place, il se retourne lui-mÃªme, car lorsque nous demandons
une relecture sur un billet dÃ©jÃ  Ã  l'Ã©tat <code>EnRelecture</code>, il doit rester Ã  l'Ã©tat
<code>EnRelecture</code>.</p>
<!--
Now we can start seeing the advantages of the state pattern: the
`request_review` method on `Post` is the same no matter its `state` value. Each
state is responsible for its own rules.
-->
<p>DÃ©sormais nous commenÃ§ons Ã  voir les avantages du patron Ã©tatÂ : la mÃ©thode
<code>demander_relecture</code> sur <code>Billet</code> est la mÃªme peu importe la valeur de son
<code>etat</code>. Chaque Ã©tat est maÃ®tre de son fonctionnement.</p>
<!--
Weâ€™ll leave the `content` method on `Post` as is, returning an empty string
slice. We can now have a `Post` in the `PendingReview` state as well as in the
`Draft` state, but we want the same behavior in the `PendingReview` state.
Listing 17-11 now works up to line 10!
-->
<p>Nous allons conserver la mÃ©thode <code>contenu</code> sur <code>Billet</code> comme elle l'est, elle
va continuer Ã  retourner une slice de chaÃ®ne de caractÃ¨res vide. Nous pouvons
maintenant avoir un <code>Billet</code> Ã  l'Ã©tat <code>Brouillon</code> ou <code>EnRelecture</code>, mais nous
voulons qu'il suive le mÃªme comportement lorsqu'il est dans l'Ã©tat
<code>EnRelecture</code>. L'encart 17-11 fonctionne maintenant jusqu'Ã  la ligne 10Â !</p>
<!--
### Adding the `approve` Method that Changes the Behavior of `content`
-->
<h3><a class="header" href="#ajouter-une-mÃ©thode-approuver-qui-change-le-comportement-de-contenu" id="ajouter-une-mÃ©thode-approuver-qui-change-le-comportement-de-contenu">Ajouter une mÃ©thode <code>approuver</code> qui change le comportement de <code>contenu</code></a></h3>
<!--
The `approve` method will be similar to the `request_review` method: it will
set `state` to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:
-->
<p>La mÃ©thode <code>approuver</code> ressemble Ã  la mÃ©thode <code>demander_relecture</code>Â : elle va
changer <code>etat</code> pour la valeur que l'Ã©tat actuel retournera lorsque cet Ã©tat est
approuvÃ©, comme le montre l'encart 17-16Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approuver(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.approuver())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(Publier {})
    }
}

struct Publier {}

impl Etat for Publier {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }

    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-16: Implementing the `approve` method on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-16Â : implÃ©mentation de la mÃ©thode <code>approuver</code>
sur <code>Billet</code> et sur le trait <code>Etat</code></span></p>
<!--
We add the `approve` method to the `State` trait and add a new struct that
implements `State`, the `Published` state.
-->
<p>Nous avons ajoutÃ© la mÃ©thode <code>approuver</code> au trait <code>Etat</code> et ajoutÃ© une nouvelle
structure <code>Publier</code>, qui implÃ©mente <code>Etat</code>.</p>
<!--
Similar to `request_review`, if we call the `approve` method on a `Draft`, it
will have no effect because it will return `self`. When we call `approve` on
`PendingReview`, it returns a new, boxed instance of the `Published` struct.
The `Published` struct implements the `State` trait, and for both the
`request_review` method and the `approve` method, it returns itself, because
the post should stay in the `Published` state in those cases.
-->
<p>Comme pour <code>demander_relecture</code>, si nous faisons appel Ã  la mÃ©thode <code>approuver</code>
sur un <code>Brouillon</code>, cela n'aura pas d'effet car elle va retourner <code>self</code>.
Lorsque nous appellerons <code>approuver</code> sur <code>EnRelecture</code>, elle va retourner une
nouvelle instance de la structure <code>Publier</code> dans une instance de <code>Box</code>. La
structure <code>Publier</code> implÃ©mente le trait <code>Etat</code>, et pour chacune des mÃ©thodes
<code>demander_relecture</code> et <code>approuver</code>, elle va retourner elle-mÃªme, car le billet
doit rester Ã  l'Ã©tat <code>Publier</code> dans ce cas-lÃ .</p>
<!--
Now we need to update the `content` method on `Post`: if the state is
`Published`, we want to return the value in the postâ€™s `content` field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:
-->
<p>Nous devons maintenant modifier la mÃ©thode <code>contenu</code> sur <code>Billet</code>Â : si l'Ã©tat
est <code>Publier</code>, nous voulons retourner la valeur du champ <code>contenu</code> du billetÂ ;
sinon nous retournons une slice de chaÃ®ne de caractÃ¨res vide, comme dans
l'encart 17-17Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
}
# 
# trait State {
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# }
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
# struct Published {}
# 
# impl State for Published {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        self.etat.as_ref().unwrap().contenu(self)
    }
    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait Etat {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Publier {}
</span><span class="boring">
</span><span class="boring">impl Etat for Publier {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 17-17: Updating the `content` method on `Post` to
delegate to a `content` method on `State`</span>
-->
<p><span class="caption">Encart 17-17Â : correction de la mÃ©thode <code>contenu</code> de
<code>Billet</code> pour dÃ©lÃ©guer Ã  la mÃ©thode <code>contenu</code> de <code>Etat</code></span></p>
<!--
Because the goal is to keep all these rules inside the structs that implement
`State`, we call a `content` method on the value in `state` and pass the post
instance (that is, `self`) as an argument. Then we return the value that is
returned from using the `content` method on the `state` value.
-->
<p>Comme notre but est de conserver toutes ces rÃ¨gles dans les structures qui
implÃ©mentent <code>Etat</code>, nous appelons une mÃ©thode <code>contenu</code> sur la valeur de
<code>etat</code> et nous lui passons en argument l'instance du billet (avec le <code>self</code>).
Nous retournons ensuite la valeur retournÃ©e par la mÃ©thode <code>contenu</code> sur la
valeur de <code>etat</code>.</p>
<!-- markdownlint-disable -->
<!--
We call the `as_ref` method on the `Option` because we want a reference to the
value inside the `Option` rather than ownership of the value. Because `state`
is an `Option<Box<dyn State>>`, when we call `as_ref`, an `Option<&Box<dyn State>>` is
returned. If we didnâ€™t call `as_ref`, we would get an error because we canâ€™t
move `state` out of the borrowed `&self` of the function parameter.
-->
<!-- markdownlint-enable -->
<p>Nous faisons appel Ã  la mÃ©thode <code>as_ref</code> sur <code>Option</code> car nous voulons une
rÃ©fÃ©rence vers la valeur dans <code>Option</code> plutÃ´t que d'en prendre possession. Comme
<code>etat</code> est un <code>Option&lt;Box&lt;dyn Etat&gt;&gt;</code>, lorsque nous faisons appel Ã  <code>as_ref</code>,
une <code>Option&lt;&amp;Box&lt;dyn Etat&gt;&gt;</code> est retournÃ©e. Si nous n'avions pas fait appel Ã 
<code>as_ref</code>, nous aurions obtenu une erreur car nous ne pouvons pas dÃ©placer
<code>etat</code> du <code>&amp;self</code>, qui est empruntÃ©, qui provient des paramÃ¨tres de la fonction.</p>
<!--
We then call the `unwrap` method, which we know will never panic, because we
know the methods on `Post` ensure that `state` will always contain a `Some`
value when those methods are done. This is one of the cases we talked about in
the [â€œCases In Which You Have More Information Than the
Compilerâ€][more-info-than-rustc]<!-- ignore -- > section of Chapter 9 when we
know that a `None` value is never possible, even though the compiler isnâ€™t able
to understand that.
-->
<p>Nous faisons ensuite appel Ã  la mÃ©thode <code>unwrap</code>, mais nous savons qu'elle ne
va jamais paniquer, car nous savons que les mÃ©thodes sur <code>Billet</code> vont toujours
garantir que <code>etat</code> contiendra toujours une valeur <code>Some</code> lorsqu'elles seront
utilisÃ©es. C'est un des cas dont nous avons parlÃ© dans
<a href="ch09-03-to-panic-or-not-to-panic.html">une section</a><!-- ignore --> du chapitre 9 lorsque nous
savions qu'une valeur <code>None</code> ne serait jamais possible, mÃªme si le compilateur
n'est pas capable de le comprendre.</p>
<!-- markdownlint-disable -->
<!--
At this point, when we call `content` on the `&Box<dyn State>`, deref coercion will
take effect on the `&` and the `Box` so the `content` method will ultimately be
called on the type that implements the `State` trait. That means we need to add
`content` to the `State` trait definition, and that is where weâ€™ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:
-->
<!-- markdownlint-enable -->
<p>A partir de lÃ , lorsque nous faisons appel Ã  <code>contenu</code> sur <code>&amp;Box&lt;dyn Etat&gt;</code>,
l'extrapolation de dÃ©rÃ©fÃ©rencement va s'appliquer sur le <code>&amp;</code> et le <code>Box</code> pour
que la mÃ©thode <code>contenu</code> puisse finalement Ãªtre appelÃ©e sur le type qui
implÃ©mente le trait <code>Etat</code>. Cela signifie que nous devons ajouter <code>contenu</code> Ã  la
dÃ©finition du trait <code>Etat</code>, et que c'est ici que nous allons placer la logique
pour le contenu Ã  retourner en fonction de quel Ã©tat nous avons, comme le montre
l'encart 17-18Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         self.state.as_ref().unwrap().content(self)
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
# }
# 
trait State {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

// --snip--
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
struct Published {}

impl State for Published {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.etat.as_ref().unwrap().contenu(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait Etat {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Publier {}

impl Etat for Publier {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &amp;billet.contenu
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-18: Adding the `content` method to the `State`
trait</span>
-->
<p><span class="caption">Encart 17-18Â : ajout de la mÃ©thode <code>contenu</code> sur le trait
<code>Etat</code></span></p>
<!--
We add a default implementation for the `content` method that returns an empty
string slice. That means we donâ€™t need to implement `content` on the `Draft`
and `PendingReview` structs. The `Published` struct will override the `content`
method and return the value in `post.content`.
-->
<p>Nous avons ajoutÃ© une implÃ©mentation par dÃ©faut pour la mÃ©thode <code>contenu</code> qui
retourne une slice de chaÃ®ne de caractÃ¨res vide. Cela nous permet de ne pas
avoir Ã  implÃ©menter <code>contenu</code> sur les structures <code>Brouillon</code> et <code>EnRelecture</code>.
La structure <code>Publier</code> va remplacer la mÃ©thode <code>contenu</code> et retourner la valeur
prÃ©sente dans <code>billet.contenu</code>.</p>
<!--
Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. Weâ€™re taking a reference to a `post` as an argument and returning a
reference to part of that `post`, so the lifetime of the returned reference is
related to the lifetime of the `post` argument.
-->
<p>Remarquez aussi que nous devons annoter des durÃ©es de vie sur cette mÃ©thode,
comme nous l'avons vu au chapitre 10. Nous allons prendre en argument une
rÃ©fÃ©rence au <code>billet</code> et retourner une rÃ©fÃ©rence Ã  une partie de ce <code>billet</code>,
donc la durÃ©e de vie retournÃ©e par la rÃ©fÃ©rence est liÃ©e Ã  la durÃ©e de vie de
l'argument <code>billet</code>.</p>
<!--
And weâ€™re doneâ€”all of Listing 17-11 now works! Weâ€™ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout `Post`.
-->
<p>Et nous avons maintenant terminÃ©, tout le code de l'encart 17-11 fonctionne,
dÃ©sormaisÂ ! Nous avons implÃ©mentÃ© le patron Ã©tat avec les rÃ¨gles de notre
processus de publication dÃ©finies pour notre blog. La logique des rÃ¨gles sont
intÃ©grÃ©es dans les objets Ã©tat plutÃ´t que d'Ãªtre dispersÃ©e un peu partout dans
<code>Billet</code>.</p>
<!--
### Trade-offs of the State Pattern
-->
<h3><a class="header" href="#les-dÃ©savantages-du-patron-Ã©tat" id="les-dÃ©savantages-du-patron-Ã©tat">Les dÃ©savantages du patron Ã©tat</a></h3>
<!--
Weâ€™ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on `Post` know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the `State`
trait on the `Published` struct.
-->
<p>Nous avons dÃ©montrÃ© que Rust est capable d'implÃ©menter le patron Ã©tat qui est
orientÃ© objet pour regrouper les diffÃ©rents types de comportement qu'un billet
doit avoir Ã  chaque Ã©tat. Les mÃ©thodes sur <code>Billet</code> ne savent rien des
diffÃ©rents comportements. De la maniÃ¨re dont nous avons organisÃ© le code, nous
n'avons qu'Ã  regarder Ã  un seul endroit pour connaÃ®tre les diffÃ©rents
comportements qu'un billet publiÃ© va suivreÂ : l'implÃ©mentation du trait <code>Etat</code>
sur la structure <code>Publier</code>.</p>
<!--
If we were to create an alternative implementation that didnâ€™t use the state
pattern, we might instead use `match` expressions in the methods on `Post` or
even in the `main` code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those `match` expressions
would need another arm.
-->
<p>Si nous aurions utilitÃ© une autre faÃ§on d'implÃ©menter ces rÃ¨gles sans utiliser
le patron Ã©tat, nous aurions dÃ» utiliser des expressions <code>match</code> dans les
mÃ©thodes de <code>Billet</code> ou mÃªme dans le code du <code>main</code> qui vÃ©rifie que l'Ã©tat du
billet et les comportements associÃ©s aux changements d'Ã©tats. Cela aurait eu
pour consÃ©quence d'avoir Ã  regarder Ã  diffÃ©rents endroits pour comprendre toutes
les consÃ©quences de la publication d'un billetÂ ! Et ce code grossira au fur et
Ã  mesure que nous ajouterons des Ã©tatsÂ : chaque expression <code>match</code> devra avoir
des nouvelles branches pour ces nouveaux Ã©tats.</p>
<!--
With the state pattern, the `Post` methods and the places we use `Post` donâ€™t
need `match` expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.
-->
<p>Avec le patron Ã©tat, les mÃ©thodes de <code>Billet</code> et les endroits oÃ¹ nous utilisons
<code>Billet</code> n'ont pas besoin d'expressions <code>match</code>, et pour ajouter un nouvel Ã©tat,
nous avons seulement besoin d'ajouter une nouvelle structure et d'implÃ©menter
les mÃ©thodes du trait sur cette structure.</p>
<div id="suggestions-implementations">
<!--
The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:
-->
<p>L'implÃ©mentation qui utilise le patron Ã©tat est facile Ã  amÃ©liorer pour ajouter
plus de fonctionnalitÃ©s. Pour dÃ©couvrir la simplicitÃ© de maintenance du code qui
utilise le patron Ã©tat, essayez d'accomplir certaines de ces suggestionsÂ :</p>
<!--
* Add a `reject` method that changes the postâ€™s state from `PendingReview` back
  to `Draft`.
* Require two calls to `approve` before the state can be changed to `Published`.
* Allow users to add text content only when a post is in the `Draft` state.
  Hint: have the state object responsible for what might change about the
  content but not responsible for modifying the `Post`.
-->
<ul>
<li>Ajouter une mÃ©thode <code>rejeter</code> qui fait retourner l'Ã©tat d'un billet de
<code>EnRelecture</code> en <code>Brouillon</code>.</li>
<li>Attendre deux appels Ã  <code>approuver</code> avant que l'Ã©tat puisse Ãªtre changÃ© en
<code>Publier</code>.</li>
<li>Permettre aux utilisateurs pour ajouter du contenu textuel uniquement
lorsqu'un billet est Ã  l'Ã©tat <code>Brouillon</code>. AstuceÂ : l'objet Ã©tat est
responsable de ce qui peut changer dans le contenu mais pas responsable de la
modification de <code>Billet</code>.</li>
</ul>
</div>
<!--
One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between `PendingReview` and `Published`, such as `Scheduled`,
we would have to change the code in `PendingReview` to transition to
`Scheduled` instead. It would be less work if `PendingReview` didnâ€™t need to
change with the addition of a new state, but that would mean switching to
another design pattern.
-->
<p>Un dÃ©savantage du patron Ã©tat est que comme les Ã©tats implÃ©mentent les
transitions en les Ã©tats, certains des Ã©tats sont reliÃ©s entre eux. Si nous
ajoutons un nouvel Ã©tat entre <code>EnRelecture</code> et <code>Publier</code>, comme <code>Planifier</code>,
nous devrions alors changer le code dans <code>EnRelecture</code> pour qu'il passe ensuite
Ã  l'Ã©tat <code>Planifier</code> Ã  la place de <code>Publier</code>. Cela reprÃ©sentera moins de travail
si <code>EnRelecture</code> n'a pas besoin de changer lorsqu'on ajoute un nouvel Ã©tat, mais
cela signifiera alors qu'il faut changer de patron.</p>
<!--
Another downside is that weâ€™ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
`request_review` and `approve` methods on the `State` trait that return `self`;
however, this would violate object safety, because the trait doesnâ€™t know what
the concrete `self` will be exactly. We want to be able to use `State` as a
trait object, so we need its methods to be object safe.
-->
<p>Un autre dÃ©savantage et que nous avons de la logique en double. Pour Ã©viter ces
doublons, nous devrions essayer de faire en sorte que les mÃ©thodes
<code>demander_relecture</code> et <code>approuver</code> qui retournent <code>self</code> deviennent les
implÃ©mentations par dÃ©faut sur le trait <code>Etat</code>Â ; cependant, cela violera la
sÃ©curitÃ© des objets, car le trait ne sait pas ce qu'est exactement <code>self</code>. Nous
voulons pouvoir utiliser <code>Etat</code> en tant qu'objet trait, donc nous avons besoin
que ses mÃ©thodes soient sÃ»res pour les objets.</p>
<!--
Other duplication includes the similar implementations of the `request_review`
and `approve` methods on `Post`. Both methods delegate to the implementation of
the same method on the value in the `state` field of `Option` and set the new
value of the `state` field to the result. If we had a lot of methods on `Post`
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the [â€œMacrosâ€][macros]<!-- ignore -- > section in Chapter 19).
-->
<p>Nous avons aussi des doublons dans le code des mÃ©thodes <code>demander_relecture</code>
et <code>approuver</code> sur <code>Billet</code>. Ces deux mÃ©thodes dÃ©lÃ¨guent leur travail aux mÃªmes
mÃ©thodes respectives sur la valeur du champ <code>etat</code> de type <code>Option</code> et assignent
la valeur au mÃªme champ <code>etat</code> Ã  la fin. Si nous avions beaucoup de mÃ©thodes sur
<code>Billet</code> qui suivent cette logique, nous devrions considÃ©rer la crÃ©ation et
l'utilisation d'une macro pour Ã©viter cette rÃ©pÃ©tition (voir la
<a href="ch19-06-macros.html#macros">section dÃ©diÃ©e</a><!-- ignore --> dans le chapitre 19).</p>
<!--
By implementing the state pattern exactly as itâ€™s defined for object-oriented
languages, weâ€™re not taking as full advantage of Rustâ€™s strengths as we could.
Letâ€™s look at some changes we can make to the `blog` crate that can make
invalid states and transitions into compile time errors.
-->
<p>En implÃ©mentant le patron Ã©tat exactement comme il l'est dÃ©fini pour les
langages orientÃ©s-objet, nous ne profitons pas pleinement des avantages de
Rust. Voyons voir si nous pouvons faire quelques changements pour que la crate
<code>blog</code> puisse lever des erreurs Ã  la compilation lorsqu'elle aura dÃ©tectÃ© des
Ã©tats ou des transitions invalides.</p>
<!--
#### Encoding States and Behavior as Types
-->
<h4><a class="header" href="#implÃ©menter-les-Ã©tats-et-les-comportements-avec-des-types" id="implÃ©menter-les-Ã©tats-et-les-comportements-avec-des-types">ImplÃ©menter les Ã©tats et les comportements avec des types</a></h4>
<!--
Weâ€™ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, weâ€™ll encode the states into different
types. Consequently, Rustâ€™s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.
-->
<p>Nous allons vous montrer comment repenser le patron Ã©tat pour qu'il offre des
compromis diffÃ©rents. PlutÃ´t que d'intÃ©grer les Ã©tats et les transitions
complÃ¨tement de maniÃ¨re Ã  ce que le code externe ne puissent pas les connaÃ®tre,
nous allons transformer les Ã©tats dans diffÃ©rents types. En consÃ©quence, le
systÃ¨me de vÃ©rification de type de Rust va Ã©viter d'utiliser des brouillons de
billets en provoquant une erreur du compilateur dans les endroits oÃ¹ ils seront
utilisÃ©s alors que seuls les billets publiÃ©s seront autorisÃ©s.</p>
<!--
Letâ€™s consider the first part of `main` in Listing 17-11:
-->
<p>ConsidÃ©rons la premiÃ¨re partie du <code>main</code> de l'encart 17-11Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use blog::Post;
# 
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
# 
#     post.request_review();
#     assert_eq!("", post.content());
# 
#     post.approve();
#     assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use blog::Billet;
</span><span class="boring">
</span>fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());
<span class="boring">
</span><span class="boring">    billet.demander_relecture();
</span><span class="boring">    assert_eq!(&quot;&quot;, billet.contenu());
</span><span class="boring">
</span><span class="boring">    billet.approuver();
</span><span class="boring">    assert_eq!(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;, billet.contenu());
</span>}
</code></pre>
<!--
We still enable the creation of new posts in the draft state using `Post::new`
and the ability to add text to the postâ€™s content. But instead of having a
`content` method on a draft post that returns an empty string, weâ€™ll make it so
draft posts donâ€™t have the `content` method at all. That way, if we try to get
a draft postâ€™s content, weâ€™ll get a compiler error telling us the method
doesnâ€™t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code wonâ€™t even compile.
Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,
as well as methods on each:
-->
<p>Nous pouvons toujours crÃ©er de nouveaux billets Ã  l'Ã©tat de brouillon en
utilisant <code>Billet::new</code> et ajouter du texte au contenu du billet. Mais au lieu
d'avoir une mÃ©thode <code>contenu</code> sur un brouillon de billet qui retourne une chaÃ®ne
de caractÃ¨res vide, nous faisons en sorte que les brouillons de billets n'aient
mÃªme pas de mÃ©thode <code>contenu</code>. Ainsi, si nous essayons de rÃ©cupÃ©rer le contenu
d'un brouillon de billet, nous obtenons une erreur de compilation qui nous
informera que la mÃ©thode n'existe pas. Finalement, il nous sera impossible de
publier le contenu d'un brouillon de billet en production, car ce code ne se
compilera mÃªme pas. L'encart 17-19 nous propose les dÃ©finitions d'une structure
<code>Billet</code> et d'une structure <code>BrouillonDeBillet</code> ainsi que leurs mÃ©thodesÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Billet {
    contenu: String,
}

pub struct BrouillonDeBillet {
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; BrouillonDeBillet {
        BrouillonDeBillet {
            contenu: String::new(),
        }
    }

    pub fn contenu(&amp;self) -&gt; &amp;str {
        &amp;self.contenu
    }
}

impl BrouillonDeBillet {
    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-19: A `Post` with a `content` method and a
`DraftPost` without a `content` method</span>
-->
<p><span class="caption">Encart 17-19Â : un <code>Billet</code> avec une mÃ©thode <code>contenu</code> et
un <code>BrouillonDeBillet</code> sans mÃ©thode <code>contenu</code></span></p>
<!--
Both the `Post` and `DraftPost` structs have a private `content` field that
stores the blog post text. The structs no longer have the `state` field because
weâ€™re moving the encoding of the state to the types of the structs. The `Post`
struct will represent a published post, and it has a `content` method that
returns the `content`.
-->
<p>Les deux structures <code>Billet</code> et <code>BrouillonDeBillet</code> ont un champ privÃ© <code>contenu</code>
qui stocke le texte du billet de blog. Les structures n'ont plus le champ <code>etat</code>
car nous avons dÃ©placÃ© la signification de l'Ã©tat directement dans le nom de ces
types de structures. La structure <code>Billet</code> reprÃ©sente un billet publiÃ©, et a une
mÃ©thode <code>contenu</code> qui retourne le <code>contenu</code>.</p>
<!--
We still have a `Post::new` function, but instead of returning an instance of
`Post`, it returns an instance of `DraftPost`. Because `content` is private
and there arenâ€™t any functions that return `Post`, itâ€™s not possible to create
an instance of `Post` right now.
-->
<p>Nous avons toujours la fonction <code>Billet::new</code>, mais au lieu de retourner une
instance de <code>Billet</code>, elle va retourner une instance de <code>BrouillonDeBillet</code>.
Comme <code>contenu</code> est privÃ© et qu'il n'y a pas de fonction qui retourne <code>Billet</code>,
il ne sera pas possible pour le moment de crÃ©er une instance de <code>Billet</code>.</p>
<!--
The `DraftPost` struct has an `add_text` method, so we can add text to
`content` as before, but note that `DraftPost` does not have a `content` method
defined! So now the program ensures all posts start as draft posts, and draft
posts donâ€™t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.
-->
<p>La structure <code>BrouillonDeBillet</code> a une mÃ©thode <code>ajouter_texte</code>, donc nous
pouvons ajouter du texte Ã  <code>contenu</code> comme nous le faisions avant, mais
remarquez toutefois que <code>BrouillonDeBillet</code> n'a pas de mÃ©thode <code>contenu</code> de
dÃ©finiÂ ! Donc pour l'instant le programme s'assure que tous les billets
dÃ©marrent Ã  l'Ã©tat de brouillon, et que les brouillons ne proposent pas de
contenu Ã  publier. Toute tentative d'outre-passer ces contraintes vont
dÃ©clencher des erreurs de compilation.</p>
<!--
#### Implementing Transitions as Transformations into Different Types
-->
<h4><a class="header" href="#implÃ©menter-les-changements-dÃ©tat-en-tant-que-changement-de-type" id="implÃ©menter-les-changements-dÃ©tat-en-tant-que-changement-de-type">ImplÃ©menter les changements d'Ã©tat en tant que changement de type</a></h4>
<!--
So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Letâ€™s implement
these constraints by adding another struct, `PendingReviewPost`, defining the
`request_review` method on `DraftPost` to return a `PendingReviewPost`, and
defining an `approve` method on `PendingReviewPost` to return a `Post`, as
shown in Listing 17-20:
-->
<p>Donc, comment publier un billetÂ ? Nous voulons renforcer la rÃ¨gle qui dit qu'un
brouillon de billet doit Ãªtre relu et approuvÃ© avant de pouvoir Ãªtre publiÃ©. Un
billet Ã  l'Ã©tat de relecture doit continuer Ã  ne pas montrer son contenu.
ImplÃ©mentons ces contraintes en introduisant une nouvelle structure,
<code>BilletEnRelecture</code>, en dÃ©finissant la mÃ©thode <code>demander_relecture</code> sur
<code>BrouillonDeBillet</code> pour retourner un <code>BilletEnRelecture</code>, et en dÃ©finissant une
mÃ©thode <code>approuver</code> sur <code>BilletEnRelecture</code> pour qu'elle retourne un <code>Billet</code>,
comme le propose l'encart 17-20Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     content: String,
# }
# 
# pub struct DraftPost {
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> DraftPost {
#         DraftPost {
#             content: String::new(),
#         }
#     }
# 
#     pub fn content(&self) -> &str {
#         &self.content
#     }
# }
# 
impl DraftPost {
    // --snip--
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct BrouillonDeBillet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; BrouillonDeBillet {
</span><span class="boring">        BrouillonDeBillet {
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.contenu
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl BrouillonDeBillet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(self) -&gt; BilletEnRelecture {
        BilletEnRelecture {
            contenu: self.contenu,
        }
    }
}

pub struct BilletEnRelecture {
    contenu: String,
}

impl BilletEnRelecture {
    pub fn approuver(self) -&gt; Billet {
        Billet {
            contenu: self.contenu,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by
calling `request_review` on `DraftPost` and an `approve` method that turns a
`PendingReviewPost` into a published `Post`</span>
-->
<p><span class="caption">Encart 17-20Â : ajout d'un <code>BilletEnRelecture</code> qui est crÃ©Ã©
par l'appel Ã  <code>demander_relecture</code> sur <code>BrouillonDeBillet</code>, ainsi qu'une mÃ©thode
<code>approuver</code> qui transforme un <code>BilletEnRelecture</code> en <code>Billet</code> publiÃ©</span></p>
<!--
The `request_review` and `approve` methods take ownership of `self`, thus
consuming the `DraftPost` and `PendingReviewPost` instances and transforming
them into a `PendingReviewPost` and a published `Post`, respectively. This way,
we wonâ€™t have any lingering `DraftPost` instances after weâ€™ve called
`request_review` on them, and so forth. The `PendingReviewPost` struct doesnâ€™t
have a `content` method defined on it, so attempting to read its content
results in a compiler error, as with `DraftPost`. Because the only way to get a
published `Post` instance that does have a `content` method defined is to call
the `approve` method on a `PendingReviewPost`, and the only way to get a
`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,
weâ€™ve now encoded the blog post workflow into the type system.
-->
<p>Les mÃ©thodes <code>demander_relecture</code> et <code>approuver</code> prennent possession de <code>self</code>,
ce qui consomme les instances de <code>BrouillonDeBillet</code> et de <code>BilletEnRelecture</code>
pour les transformer respectivement en <code>BilletEnRelecture</code> et en <code>Billet</code>.
Ainsi, il ne restera plus d'instances de <code>BrouillonDeBillet</code> aprÃ¨s avoir appelÃ©
<code>approuver</code> sur elles, et ainsi de suite. La structure <code>BilletEnRelecture</code> n'a
pas de mÃ©thode <code>contenu</code> qui lui est dÃ©finie, donc si on essaye de lire son
contenu, on obtient une erreur de compilation, comme avec <code>BrouillonDeBillet</code>.
Comme la seule maniÃ¨re d'obtenir une instance de <code>Billet</code> qui a une mÃ©thode
<code>contenu</code> de dÃ©finie est d'appeler la mÃ©thode<code>approuver</code> sur un
<code>BilletEnRelecture</code>, et que la seule maniÃ¨re d'obtenir un <code>BilletEnRelecture</code>
est d'appeler la mÃ©thode <code>demander_relecture</code> sur un <code>BrouillonDeBillet</code>, nous
avons dÃ©sormais intÃ©grÃ© le processus de publication des billets de blog avec le
systÃ¨me de type.</p>
<!--
But we also have to make some small changes to `main`. The `request_review` and
`approve` methods return new instances rather than modifying the struct theyâ€™re
called on, so we need to add more `let post =` shadowing assignments to save
the returned instances. We also canâ€™t have the assertions about the draft and
pending review postâ€™s contents be empty strings, nor do we need them: we canâ€™t
compile code that tries to use the content of posts in those states any longer.
The updated code in `main` is shown in Listing 17-21:
-->
<p>Mais nous devons aussi faire quelques petits changements dans le <code>main</code>. Les
mÃ©thodes <code>demander_relecture</code> et <code>approuver</code> retournent des nouvelles instances
au lieu de modifier la structure sur laquelle elles ont Ã©tÃ© appelÃ©es, donc nous
devons ajouter des assignations de masquage <code>let billet =</code> pour stocker les
nouvelles instances retournÃ©es. Nous ne pouvons pas non plus vÃ©rifier que le
contenu des brouillons de billets et ceux en cours de relecture soient bien
vides, donc nous n'en avons plus besoinÂ : nous ne pouvons plus compiler du code
qui essaye d'utiliser le contenu d'un billet dans cet Ã©tat. Le code du <code>main</code>
mis Ã  jour est prÃ©sentÃ© dans l'encart 17-21Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;);

    let billet = billet.demander_relecture();

    let billet = billet.approuver();

    assert_eq!(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-21: Modifications to `main` to use the new
implementation of the blog post workflow</span>
-->
<p><span class="caption">Encart 17-21Â : modification de <code>main</code> pour utiliser la
nouvelle implÃ©mentation du processus de publication de billet de blog</span></p>
<!--
The changes we needed to make to `main` to reassign `post` mean that this
implementation doesnâ€™t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the `Post` implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.
-->
<p>Les modifications dont nous avons besoin de faire au <code>main</code> pour rÃ©assigner
<code>billet</code> impliquent que cette implÃ©mentation ne suit plus exactement le patron
Ã©tat orientÃ©-objetÂ : les changements d'Ã©tats ne sont plus totalement intÃ©grÃ©s
dans l'implÃ©mentation de <code>Billet</code>. Cependant, nous faisons en sorte que les
Ã©tats invalides soient impossibles grÃ¢ce au systÃ¨me de types et que la
vÃ©rification de type s'effectue Ã  la compilationÂ ! Cela garantit que certains
bogues, comme l'affichage du contenu d'un billet non publiÃ©, sera dÃ©tectÃ© avant
avant d'arriver en production.</p>
<!--
Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the `blog` crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.
-->
<p>Essayez d'accomplir <a href="ch17-03-oo-design-patterns.html#suggestions-implementations">les suggestions proposÃ©es pour les conditions
supplÃ©mentaires que nous avons listÃ©s au dÃ©but de cette
section</a>, sur la crate <code>blog</code> telle qu'elle est
aprÃ¨s l'encart 17-20, pour vous faire une idÃ©e sur cette conception du code.
Notez aussi que certaines suggestions sont dÃ©jÃ  accomplies implicitement grÃ¢ce Ã 
cette conception.</p>
<!--
Weâ€™ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rustâ€™s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns wonâ€™t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages donâ€™t have.
-->
<p>Nous avons vu que mÃªme si Rust est capable d'implÃ©menter des patrons de
conception orientÃ©s-objet, les autres patrons, comme intÃ©grer l'Ã©tat dans le
systÃ¨me de type, est aussi possible en Rust. Ces patrons ont diffÃ©rents
avantages et dÃ©savantages. Bien que vous soyez familier avec les patrons
orientÃ©s-objet, vous gagnerez Ã  repenser les choses pour tirer avantage des
fonctionnalitÃ©s de Rust, comme la dÃ©tection de certains bogues Ã  la compilation.
Les patrons orientÃ©s-objet ne sont pas toujours la meilleure solution en Rust Ã 
cause de certaines de ses fonctionnalitÃ©s, comme la possession, que les langages
orientÃ©s-objet n'ont pas.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-16" id="rÃ©sumÃ©-16">RÃ©sumÃ©</a></h2>
<!--
No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your codeâ€™s
maintainability. Rust also has other features, like ownership, that
object-oriented languages donâ€™t have. An object-oriented pattern wonâ€™t always
be the best way to take advantage of Rustâ€™s strengths, but is an available
option.
-->
<p>Que vous pensiez ou non que Rust est un langage orientÃ©-objet aprÃ¨s avoir lu ce
chapitre, vous savez maintenant que vous pouvez utiliser les objets trait pour
pouvoir obtenir certaines fonctionnalitÃ©s orientÃ©-objet en Rust. La rÃ©partition
dynamique peut offrir de la flexibilitÃ© Ã  votre code en Ã©change d'une perte de
performances Ã  l'exÃ©cution. Vous pouvez utiliser cette flexibilitÃ© pour
implÃ©menter des patrons orientÃ©s-objet qui puissent aider la maintenance de
votre code. Rust offre d'autres fonctionnalitÃ©s, comme la possession, que les
langages orientÃ©s-objet n'ont pas. L'utilisation d'un patron orientÃ©-objet n'est
pas toujours la meilleure maniÃ¨re de tirer parti des avantages de Rust, mais
cela reste une option disponible.</p>
<!--
Next, weâ€™ll look at patterns, which are another of Rustâ€™s features that enable
lots of flexibility. Weâ€™ve looked at them briefly throughout the book but
havenâ€™t seen their full capability yet. Letâ€™s go!
-->
<p>Dans le chapitre suivant, nous allons Ã©tudier les motifs, qui est une autre des
fonctionnalitÃ©s de Rust qui offre beaucoup de flexibilitÃ©. Nous les avons
rencontrÃ©s briÃ¨vement dans le livre, mais nous n'avons pas encore vu tout leur
potentiel. C'est partiÂ !</p>
<!-- markdownlint-disable -->
<!--
[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--40" id="-attention-peinture-fraÃ®che--40">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/203">Pull Request</a>.</p>
</blockquote>
<!--
# Patterns and Matching
-->
<h1><a class="header" href="#les-motifs-et-le-filtrage-par-motif" id="les-motifs-et-le-filtrage-par-motif">Les motifs et le filtrage par motif</a></h1>
<!--
Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with `match`
expressions and other constructs gives you more control over a programâ€™s
control flow. A pattern consists of some combination of the following:
-->
<p>Les motifs ont une syntaxe spÃ©ciale en Rust pour pouvoir les filtrer sur la
structure des types, qu'elle soit simple ou complexe. L'utilisation de motifs
en collaboration avec l'expression <code>match</code> et d'autres constructions vous donne
plus contrÃ´le sur le flux de contrÃ´le de votre programme. Un motif concerneÂ :</p>
<!--
* Literals
* Destructured arrays, enums, structs, or tuples
* Variables
* Wildcards
* Placeholders
-->
<ul>
<li>les littÃ©raux</li>
<li>les tableaux dÃ©structurÃ©s, les Ã©numÃ©rations, les structures, ou les tuples</li>
<li>les variables</li>
<li>les jokers</li>
<li>les espaces rÃ©servÃ©s</li>
</ul>
<!--
These components describe the shape of the data weâ€™re working with, which we
then match against values to determine whether our program has the correct data
to continue running a particular piece of code.
-->
<p>Les composants dÃ©crivent la forme d'une donnÃ©e avec laquelle nous travaillons,
que nous filtrons avec motifs de valeurs pour savoir si notre programme a la
donnÃ©e correcte pour continuer Ã  exÃ©cuter un code qui en a besoin.</p>
<!--
To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the `match` expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesnâ€™t, the code associated with the pattern wonâ€™t run.
-->
<p>Pour utiliser un motif, nous le comparons Ã  quelques valeurs. Si le motif
correspond Ã  la valeur, nous utilisons les Ã©lÃ©ments prÃ©sents dans la valeur
pour notre code. Rappelez-vous que les expressions <code>match</code> du chapitre 6
utilisaient les motifs, comme pour la machine Ã  trier la monnaie par exemple.
Si la valeur correspond Ã  la forme d'un motif, nous pouvions utiliser le nom de
la piÃ¨ce. Sinon, le code liÃ© au motif n'Ã©tait pas exÃ©cutÃ©.</p>
<!--
This chapter is a reference on all things related to patterns. Weâ€™ll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, youâ€™ll know how to use patterns to express many concepts in
a clear way.
-->
<p>Ce chapitre sert de rÃ©fÃ©rence sur ce qui concerne les motifs. Nous allons voir
les moments appropriÃ©s pour utiliser les motifs, les diffÃ©rences entre les
motifs rÃ©futables et irrÃ©futables, et les diffÃ©rentes syntaxes de motifs que
vous pouvez rencontrer. A la fin de ce chapitre, vous saurez comment utiliser
les motifs pour exprimer clairement de nombreux concepts.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--41" id="-attention-peinture-fraÃ®che--41">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/205">Pull Request</a>.</p>
</blockquote>
<!--
## All the Places Patterns Can Be Used
-->
<h2><a class="header" href="#tous-les-endroits-oÃ¹-les-motifs-peuvent-Ãªtre-utilisÃ©s" id="tous-les-endroits-oÃ¹-les-motifs-peuvent-Ãªtre-utilisÃ©s">Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></h2>
<!--
Patterns pop up in a number of places in Rust, and youâ€™ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.
-->
<p>Les motifs apparaissent dans de nombreux endroits en Rust, et vous en avez
utilisÃ© beaucoup sans vous en rendre compteÂ ! Cette section va prÃ©senter les
diffÃ©rentes situations oÃ¹ l'utilisation des motifs est appropriÃ©e.</p>
<!--
### `match` Arms
-->
<h3><a class="header" href="#les-branches-des-match" id="les-branches-des-match">Les branches des <code>match</code></a></h3>
<!--
As discussed in Chapter 6, we use patterns in the arms of `match` expressions.
Formally, `match` expressions are defined as the keyword `match`, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that armâ€™s pattern, like this:
-->
<p>Comme nous l'avons vu au chapitre 6, nous utilisons les motifs dans les
branches des expressions <code>match</code>. Techniquement, les expressions <code>match</code> sont
dÃ©finies avec le mot-clÃ© <code>match</code>, une valeur sur laquelle procÃ©der, et une ou
plusieurs branches qui constituent un motif, ainsi qu'une expression Ã  exÃ©cuter
si la valeur correspond au motif de cette branche, comme ceciÂ :</p>
<!--
```text
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```
-->
<pre><code class="language-text">match VALEUR {
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
}
</code></pre>
<!--
One requirement for `match` expressions is that they need to be *exhaustive* in
the sense that all possibilities for the value in the `match` expression must
be accounted for. One way to ensure youâ€™ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.
-->
<p>L'une des conditions Ã  respecter pour les expressions <code>match</code> est qu'elle doit
Ãªtre <em>exhaustive</em> dans le sens oÃ¹ toutes les possibilitÃ©s pour la valeur dans
l'expression <code>match</code> doivent Ãªtre prises en compte. Une faÃ§on de s'assurer que
vous avez couvert toutes les possibilitÃ©s est d'avoir un motif passe-partout
pour la derniÃ¨re brancheÂ : par exemple, une valeur quelconque ne pourra jamais
Ã©chouer car la derniÃ¨re branche permet de couvrir tous les autres cas
possibles.</p>
<!--
A particular pattern `_` will match anything, but it never binds to a variable,
so itâ€™s often used in the last match arm. The `_` pattern can be useful when
you want to ignore any value not specified, for example. Weâ€™ll cover the `_`
pattern in more detail in the [â€œIgnoring Values in a
Patternâ€][ignoring-values-in-a-pattern]<!-- ignore -- > section later in this
chapter.
-->
<p>Le motif spÃ©cifique <code>_</code> va correspondre Ã  tout, mais il ne fournira jamais de
variable, donc il est souvent utilisÃ© dans la derniÃ¨re branche. Le motif <code>_</code>
peut Ãªtre utile lorsque vous souhaitez ignorer toutes les autres valeurs qui
n'ont pas Ã©tÃ© listÃ©es, par exemple. Nous allons voir plus en dÃ©tail le motif
<code>_</code> dans une section
<a href="ch18-03-pattern-syntax.html">plus tard dans ce chapitre</a><!-- ignore -->.</p>
<!--
### Conditional `if let` Expressions
-->
<h3><a class="header" href="#les-expressions-conditionnelles-if-let" id="les-expressions-conditionnelles-if-let">Les expressions conditionnelles <code>if let</code></a></h3>
<!--
In Chapter 6 we discussed how to use `if let` expressions mainly as a shorter
way to write the equivalent of a `match` that only matches one case.
Optionally, `if let` can have a corresponding `else` containing code to run if
the pattern in the `if let` doesnâ€™t match.
-->
<p>Au chapitre 6, nous avons vu comment utiliser les expressions <code>if let</code>,
principalement pour pouvoir Ã©crire l'Ã©quivalent d'un <code>match</code> qui ne correspond
qu'Ã  un seul cas.
Accessoirement, <code>if let</code> peut avoir un <code>else</code> correspondant au code Ã  exÃ©cuter
si le motif du <code>if let</code> ne correspond pas au premier critÃ¨re.</p>
<!--
Listing 18-1 shows that itâ€™s also possible to mix and match `if let`, `else
if`, and `else if let` expressions. Doing so gives us more flexibility than a
`match` expression in which we can express only one value to compare with the
patterns. Also, the conditions in a series of `if let`, `else if`, `else if
let` arms arenâ€™t required to relate to each other.
-->
<p>L'encart 18-1 montre qu'il est aussi possible de conjuguer les expressions
<code>if let</code>, <code>else if</code>, et <code>else if let</code>. Faire ceci nous donne plus de
flexibilitÃ© qu'une expression <code>match</code> dans laquelle nous ne pouvons que
vÃ©rifier une seule valeur Ã  comparer avec les motifs. De plus, dans une sÃ©rie
de branches <code>if let</code>, <code>else if</code>, et <code>else if let</code>, les conditions n'ont pas
besoin d'avoir les mÃªmes conditions et contextes.</p>
<!--
The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, weâ€™ve created
variables with hardcoded values that a real program might receive from user
input.
-->
<p>Le code de l'encart 18-1 montre une sÃ©rie de vÃ©rifications pour quelques
conditions qui dÃ©cident quelle devrait Ãªtre la couleur de fond. Pour cet
exemple, nous avons crÃ©Ã© les variables avec des valeurs codÃ©es en dur qu'un
vrai programme devrait recevoir d'une saisie d'un utilisateur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let couleur_favorite: Option&lt;&amp;str&gt; = None;
    let on_est_mardi = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(couleur) = couleur_favorite {
        println!(&quot;Utilisation de votre couleur favorite, {}, comme couleur de fond&quot;, couleur);
    } else if on_est_mardi {
        println!(&quot;Mardi, c'est le jour du vertÂ !&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Utilisation du violet comme couleur de fond&quot;);
        } else {
            println!(&quot;Utilisation de l'orange comme couleur de fond&quot;);
        }
    } else {
        println!(&quot;Utilisation du bleu comme couleur de fond&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-1: Mixing `if let`, `else if`, `else if let`,
and `else`</span>
-->
<p><span class="caption">Encart 18-1Â : mÃ©lange de <code>if let</code>, <code>else if</code>,
<code>else if let</code>, et <code>else</code></span></p>
<!--
If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue.
-->
<p>Si l'utilisateur renseigne une couleur favorite, c'est cette couleur qui
devient la couleur de fond. Sinon, si nous sommes mardi, la couleur de fond
sera vert. Sinon, si l'utilisateur a renseignÃ© son age dans une chaÃ®ne de
caractÃ¨res et que nous pouvons l'interprÃ©ter comme un nombre avec succÃ¨s, la
couleur de fond sera soit violet, soit orange en fonction de la valeur de ce
nombre. Si aucune de ces conditions s'applique, la couleur de fond sera bleu.</p>
<!--
This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print `Using purple as the
background color`.
-->
<p>Cette structure conditionnelle nous permet de rÃ©pondre Ã  des conditions
complexes. Avec les valeurs codÃ©es en dur que nous avons ici, cet exemple
devrait afficher <code>Utilisation du violet comme couleur de fond</code>.</p>
<!--
You can see that `if let` can also introduce shadowed variables in the same way
that `match` arms can: the line `if let Ok(age) = age` introduces a new
shadowed `age` variable that contains the value inside the `Ok` variant. This
means we need to place the `if age > 30` condition within that block: we canâ€™t
combine these two conditions into `if let Ok(age) = age && age > 30`. The
shadowed `age` we want to compare to 30 isnâ€™t valid until the new scope starts
with the curly bracket.
-->
<p>Vous pouvez constater que le <code>if let</code> nous permet d'utiliser les variables
masquÃ©es de la mÃªme maniÃ¨re que le fait le font les branches <code>match</code>Â : la ligne
<code>if let Ok(age) = age</code> crÃ©e une nouvelle variable masquÃ©e <code>age</code> qui contient la
valeur prÃ©sente dans la variante <code>Ok</code>. Cela signifie que nous devons placer la
condition <code>if age &gt; 30</code> Ã  l'intÃ©rieur de ce blocÂ : nous ne pouvons pas combiner
ces deux conditions dans une seule <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. La
variable masquÃ©e <code>age</code> que nous souhaitons comparer Ã  30 n'est pas encore en
vigueur tant que la nouvelle portÃ©e entre les accolades n'a pas commencÃ©e.</p>
<!--
The downside of using `if let` expressions is that the compiler doesnâ€™t check
exhaustiveness, whereas with `match` expressions it does. If we omitted the
last `else` block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.
-->
<p>Le dÃ©savantage de l'utilisation des expressions <code>if let</code> est que le compilateur
ne vÃ©rifie pas l'exhaustivitÃ©, ce que fait l'expression <code>match</code>. Si nous avions
enlevÃ© le dernier bloc <code>else</code> et ainsi que nous oublions de gÃ©rer certains cas,
le compilateur ne pourrait pas nous prÃ©venir d'un possible bogue de logique.</p>
<!--
### `while let` Conditional Loops
-->
<h3><a class="header" href="#les-boucles-conditionelles-while-let" id="les-boucles-conditionelles-while-let">les boucles conditionelles <code>while let</code></a></h3>
<!--
Similar in construction to `if let`, the `while let` conditional loop allows a
`while` loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a `while let` loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed.
-->
<p>Comme les constructions <code>if let</code>, les boucles conditionnelles <code>while let</code>
permettent Ã  une boucle <code>while</code> de s'exÃ©cuter aussi longtemps qu'un motif
continue Ã  correspondre. L'exemple dans l'encart 18-2 montre une boucle
<code>while let</code> qui utilise un vecteur comme une pile et affiche les valeurs du
vecteur dans l'ordre opposÃ© Ã  celui dans lequel elles ont Ã©tÃ© insÃ©rÃ©es.</p>
<!--
```rust
# fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut pile = Vec::new();

    pile.push(1);
    pile.push(2);
    pile.push(3);

    while let Some(donnee_du_haut) = pile.pop() {
        println!(&quot;{}&quot;, donnee_du_haut);
    }
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pile = Vec::new();

pile.push(1);
pile.push(2);
pile.push(3);

while let Some(donnee_du_haut) = pile.pop() {
    println!(&quot;{}&quot;, donnee_du_haut);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-2: Using a `while let` loop to print values
for as long as `stack.pop()` returns `Some`</span>
-->
<p><span class="caption">Encart 18-2Â : utilisation d'une boucle <code>while let</code> pour
afficher les valeurs aussi longtemps que <code>pile.pop()</code> retourne une <code>Some</code></span></p>
<!--
This example prints 3, 2, and then 1. The `pop` method takes the last element
out of the vector and returns `Some(value)`. If the vector is empty, `pop`
returns `None`. The `while` loop continues running the code in its block as
long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can
use `while let` to pop every element off our stack.
-->
<p>Cet exemple affiche 3, 2 puis ensuite 1. La mÃ©thode <code>pop</code> sort le dernier
Ã©lÃ©ment du vecteur et retourne <code>Some(valeur)</code>. Si le vecteur est vide, <code>pop</code>
retourne alors <code>None</code>. La boucle <code>while</code> continue Ã  exÃ©cuter le code de son bloc
aussi longtemps que <code>pop</code> retourne un <code>Some</code>. Lorsque <code>pop</code> retournera <code>None</code>,
la boucle s'arrÃªtera. Nous pouvons utiliser <code>while let</code> pour extraire tous les
Ã©lÃ©ments de la pile.</p>
<!--
### `for` Loops
-->
<h3><a class="header" href="#les-boucles-for" id="les-boucles-for">Les boucles <code>for</code></a></h3>
<!--
In Chapter 3, we mentioned that the `for` loop is the most common loop
construction in Rust code, but we havenâ€™t yet discussed the pattern that `for`
takes. In a `for` loop, the pattern is the value that directly follows the
keyword `for`, so in `for x in y` the `x` is the pattern.
-->
<p>Au chapitre 3, nous avions mentionnÃ© que la boucle <code>for</code> Ã©tait la construction
de boucle la plus utilisÃ© dans du code Rust, mais nous n'avons pas encore abordÃ©
le motif que prend <code>for</code>. Dans une boucle <code>for</code>, le motif est la valeur qui suit
directement le mot-clÃ© <code>for</code>, de sorte que <code>x</code> est le motif dans <code>for x in y</code>.</p>
<!--
Listing 18-3 demonstrates how to use a pattern in a `for` loop to destructure,
or break apart, a tuple as part of the `for` loop.
-->
<p>L'encart 18-3 montre comment utiliser un motif dans une boucle <code>for</code> pour
dÃ©structurer, ou dÃ©composer, un tuple comme Ã©tant une partie de la boucle <code>for</code>.</p>
<!--
```rust
# fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (indice, valeur) in v.iter().enumerate() {
        println!(&quot;{} est Ã  l'indice {}&quot;, valeur, indice);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-3: Using a pattern in a `for` loop to
destructure a tuple</span>
-->
<p><span class="caption">Encart 18-3Â : utilisation d'un motif dans une boucle <code>for</code>
pour dÃ©structurer un tuple</span></p>
<!--
The code in Listing 18-3 will print the following:
-->
<p>Le code de l'encart 18-3 va afficher ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a est Ã  l'indice 0
b est Ã  l'indice 1
c est Ã  l'indice 2
</code></pre>
<!--
We use the `enumerate` method to adapt an iterator to produce a value and that
valueâ€™s index in the iterator, placed into a tuple. The first call to
`enumerate` produces the tuple `(0, 'a')`. When this value is matched to the
pattern `(index, value)`, `index` will be `0` and `value` will be `'a'`,
printing the first line of the output.
-->
<p>Nous avons utilisÃ© la mÃ©thode <code>enumerate</code> pour produire une valeur et son indice
Ã  partir d'un itÃ©rateur, que nous avons placÃ© dans un tuple. Le premier appel Ã 
<code>enumerate</code> va produire le tuple <code>(0, 'a')</code>. Lorsque cette valeur est adaptÃ©e au
motif <code>(indice, valeur)</code>, <code>indice</code> vaudra <code>0</code> et <code>valeur</code> vaudra <code>'a'</code>, et
affichera la premiÃ¨re ligne sur la sortie.</p>
<!--
### `let` Statements
-->
<h3><a class="header" href="#les-instructions-let" id="les-instructions-let">Les instructions <code>let</code></a></h3>
<!--
Prior to this chapter, we had only explicitly discussed using patterns with
`match` and `if let`, but in fact, weâ€™ve used patterns in other places as well,
including in `let` statements. For example, consider this straightforward
variable assignment with `let`:
-->
<p>Avant d'arriver Ã  ce chapitre, nous n'avions abordÃ© explicitement l'utilisation
des motifs uniquement avec <code>match</code> et <code>if let</code>, mais en rÃ©alitÃ©, nous avons
utilisÃ© les motifs dans d'autres endroits, y compris les instructions <code>let</code>. Par
exemple, considÃ©rons l'assignation Ã  la variable suivante avec <code>let</code>Â :</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Throughout this book, weâ€™ve used `let` like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a `let` statement looks like this:
-->
<p>Tout au long de ce livre, nous avons utilisÃ© <code>let</code> de cette maniÃ¨re des
centaines de fois, et malgrÃ© tout vous ne vous Ãªtes probablement pas rendu
compte que vous utilisiez les motifsÂ ! Plus formellement, une instruction <code>let</code>
ressemble Ã  ceciÂ :</p>
<!--
```text
let PATTERN = EXPRESSION;
```
-->
<pre><code class="language-text">let MOTIF = EXPRESSION;
</code></pre>
<!--
In statements like `let x = 5;` with a variable name in the `PATTERN` slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
`let x = 5;` example, `x` is a pattern that means â€œbind what matches here to
the variable `x`.â€ Because the name `x` is the whole pattern, this pattern
effectively means â€œbind everything to the variable `x`, whatever the value is.â€
-->
<p>Dans des instructions comme <code>let x = 5;</code> avec un nom de variable dans
l'emplacement <code>MOTIF</code>, le nom de la variable est juste une forme simple de
motif. Rust compare l'expression avec le motif et assigne tous les noms qu'il
rencontre. Dans l'exemple <code>let x = 5;</code>, <code>x</code> est un motif qui signifie
â€œrelie ce qui suit Ã  la variable <code>x</code>â€.  Comme le nom <code>x</code> est un motif en entier,
ce motif demande exactement dans ce cas â€œrelie tout ce qui suit Ã  la variable
<code>x</code>, peu importe quelle valeur c'estâ€.</p>
<!--
To see the pattern matching aspect of `let` more clearly, consider Listing
18-4, which uses a pattern with `let` to destructure a tuple.
-->
<p>Pour comprendre plus clairement l'aspect filtrage par motif de <code>let</code>, admettons
l'encart 18-4, qui utilise un motif avec <code>let</code> pour destructurer un tuple.</p>
<!--
```rust
# fn main() {
    let (x, y, z) = (1, 2, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span>
-->
<p><span class="caption">Encart 18-4Â : utilisation d'un motif pour destructurer un
tuple et crÃ©er trois variables Ã  la fois</span></p>
<!--
Here, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)`
to the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust
binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple
pattern as nesting three individual variable patterns inside it.
-->
<p>Ici, nous avons fait correspondre un tuple Ã  un motif. Rust compare la valeur
<code>(1, 2, 3)</code> au motif <code>(x, y, z)</code> et constate que la valeur correspond au motif,
donc Rust relie <code>1</code> Ã  <code>x</code>, <code>2</code> Ã  <code>y</code>, et <code>3</code> Ã  <code>z</code>. Vous pouvez ainsi considÃ©rer
que ce motif de tuple contient trois variables individuelles en son sein.</p>
<!--
If the number of elements in the pattern doesnâ€™t match the number of elements
in the tuple, the overall type wonâ€™t match and weâ€™ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which wonâ€™t work.
-->
<p>Si le nombre d'Ã©lÃ©ments dans le motif ne correspondent pas au nombre d'Ã©lÃ©ments
dans le tuple, le type au complet ne va pas correspondre et nous allons obtenir
une erreur de compilation. Par exemple, l'encart 18-5 montre une tentative de
dÃ©structurer un tuple avec trois Ã©lÃ©ments dans deux variables, ce qui ne va pas
fonctionner.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let (x, y) = (1, 2, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables donâ€™t match the number of elements in the tuple</span>
-->
<p><span class="caption">Encart 18-5Â : construction incorrecte d'un motif dont les
variables ne vont pas correspondre au nombre d'Ã©lÃ©ments prÃ©sents dans le tuple
</span></p>
<!--
Attempting to compile this code results in this type error:
-->
<p>Si vous essayez de compiler ce code, vous obtiendrez cette erreur de typeÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 -- > src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
If we wanted to ignore one or more of the values in the tuple, we could use `_`
or `..`, as youâ€™ll see in the [â€œIgnoring Values in a
Patternâ€][ignoring-values-in-a-pattern]<!-- ignore -- > section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.
-->
<p>Si nous souhaitons ignorer une ou plusieurs valeurs dans un tuple, nous pouvons
utiliser <code>_</code> ou <code>..</code>, comme vous allez le voir Ã  la derniÃ¨re section de ce
chapitre. Si le problÃ¨me est que nous avons trop de variables dans le motif, la
solution faire correspondre les types en enlevant les variables afin que le
nombre de variables corresponde au nombre d'Ã©lÃ©ments prÃ©sents dans le tuple.</p>
<!--
### Function Parameters
-->
<h3><a class="header" href="#les-paramÃ¨tres-de-fonctions-1" id="les-paramÃ¨tres-de-fonctions-1">Les paramÃ¨tres de fonctions</a></h3>
<!--
Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named `foo` that takes one parameter named `x` of type
`i32`, should by now look familiar.
-->
<p>Les paramÃ¨tres de fonctions peuvent aussi Ãªtre des motifs. Le code de l'encart
18-6 dÃ©clare une fonction <code>foo</code> qui prend un paramÃ¨tre <code>x</code> de type <code>i32</code>.</p>
<!--
```rust
fn foo(x: i32) {
    // code goes here
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(x: i32) {
    // le code se place ici
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span>
-->
<p><span class="caption">Encart 18-6Â : une signature de fonction qui utilise des
motifs dans ses paramÃ¨tres</span></p>
<!--
The `x` part is a pattern! As we did with `let`, we could match a tuple in a
functionâ€™s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.
-->
<p>La partie <code>x</code> est un motifÂ ! Comme nous l'avons dit pour <code>let</code>, nous pouvons
faire correspondre le motif avec un tuple dans les arguments de la fonction.
L'encart 18-7 dÃ©structure les valeurs d'un tuple que nous passons en argument
d'une fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn afficher_coordonnees(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;CoordonnÃ©es actuellesÂ : ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    afficher_coordonnees(&amp;point);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span>
-->
<p><span class="caption">Encart 18-7Â : une fonction avec des paramÃ¨tres qui
dÃ©structurent un tuple</span></p>
<!--
This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the
pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`.
-->
<p>Ce code affiche <code>CoordonÃ©es actuellesÂ : (3, 5)</code>. Les valeurs <code>&amp;(3, 5)</code>
correspondent au motif <code>&amp;(x, y)</code>, donc <code>x</code> a la valeur <code>3</code> et <code>y</code> a la valeur
<code>5</code>.</p>
<!--
We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.
-->
<p>Nous pouvons aussi utiliser les motifs dans la liste des paramÃ¨tres d'une
fermeture de la mÃªme maniÃ¨re que la liste des paramÃ¨tres d'une fonction, car les
fermetures sont similaires aux fonctions, comme nous l'avons dit au chapitre 13.</p>
<!--
At this point, youâ€™ve seen several ways of using patterns, but patterns donâ€™t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. Weâ€™ll discuss
these two concepts next.
-->
<p>A prÃ©sent, vous avez vu plusieurs faÃ§ons d'utiliser les motifs, mais les motifs
ne fonctionnent pas de la mÃªme maniÃ¨re dans toutes les situations oÃ¹ nous les
utilisons. Des fois, le motif sera irrÃ©futableÂ ; d'autres fois, il sera
rÃ©futable. C'est ce que nous allons voir tout de suite.</p>
<!--
[ignoring-values-in-a-pattern]:
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--42" id="-attention-peinture-fraÃ®che--42">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/206">Pull Request</a>.</p>
</blockquote>
<!--
## Refutability: Whether a Pattern Might Fail to Match
-->
<h2><a class="header" href="#la-rÃ©futabilitÃ©--lorsquun-motif-peut-Ã©chouer-Ã -correspondre" id="la-rÃ©futabilitÃ©--lorsquun-motif-peut-Ã©chouer-Ã -correspondre">La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></h2>
<!--
Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are *irrefutable*. An example would be `x` in the
statement `let x = 5;` because `x` matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
*refutable*. An example would be `Some(x)` in the expression `if let Some(x) =
a_value` because if the value in the `a_value` variable is `None` rather than
`Some`, the `Some(x)` pattern will not match.
-->
<p>Les motifs se divisent en deux catÃ©goriesÂ : rÃ©futables et irrÃ©futables. Les
motifs qui vont correspondre Ã  n'importe quelle valeur qu'on lui passe sont
<em>irrÃ©futables</em>. Un exemple serait le <code>x</code> dans l'instruction <code>let x = 5;</code> car
<code>x</code> correspond Ã  tout ce qui est possible et ainsi ne peut pas Ã©chouer Ã  la
correspondance. Les motifs qui peuvent Ã©chouer Ã  correspondre Ã  quelques valeurs
sont <em>rÃ©futables</em>. Un exemple serait <code>Some(x)</code> dans l'expression
<code>if let Some(x) = une_valeur</code> car si la valeur dans la variable <code>une_valeur</code> est
<code>None</code> au lieu de <code>Some</code>, le motif <code>Some(x)</code> ne correspondra pas.</p>
<!--
Function parameters, `let` statements, and `for` loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values donâ€™t match. The `if let` and `while let` expressions accept
refutable and irrefutable patterns, but the compiler warns against
irrefutable patterns because by definition theyâ€™re intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.
-->
<p>Les paramÃ¨tres de fonctions, les instructions <code>let</code>, et les boucles <code>for</code>
peuvent seulement accepter des motifs irrÃ©futables, car le programme ne peut
rien faire d'autre lorsque les valeurs ne correspondent pas. Les expressions
<code>if let</code> et <code>while let</code> acceptent les motifs rÃ©futables et irrÃ©futables, mais le
compilateur met en garde contre l'utilisation des motifs irrÃ©futables dans ce
cas car par dÃ©finition ces expressions sont prÃ©vues pour gÃ©rer un problÃ¨me
Ã©ventuelÂ : le but des conditions est de se comporter diffÃ©remment en fonction de
la rÃ©ussite ou de l'Ã©chec.</p>
<!--
In general, you shouldnâ€™t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, youâ€™ll need to change either the pattern or the construct youâ€™re
using the pattern with, depending on the intended behavior of the code.
-->
<p>De maniÃ¨re gÃ©nÃ©rale, vous ne devriez pas avoir Ã  vous soucier des diffÃ©rences
entre les motifs rÃ©futables et irrÃ©futablesÂ ; en revanche, vous devez vous
familiariser avec le concept de rÃ©futabilitÃ© afin que vous puissiez comprendre
lorsque vous le verrez dans un message d'erreur. Dans ce cas, vous allez avoir
besoin de changer soit le motif, soit la construction avec laquelle vous
utilisez, en fonction du comportement prÃ©vu du code.</p>
<!--
Letâ€™s look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
`let` statement, but for the pattern weâ€™ve specified `Some(x)`, a refutable
pattern. As you might expect, this code will not compile.
-->
<p>Examinons un exemple de ce qu'il se passe lorsque nous essayons d'utiliser un
motif rÃ©futable lorsque Rust prÃ©voit d'utiliser un motif irrÃ©futable, et
vice-versa. L'encart 18-8 montre une instruction <code>let</code>, mais pour le motif nous
avons renseignÃ© <code>Some(x)</code>, un motif rÃ©futable. Comme vous pouvez vous en douter,
ce code ne va pas se compiler.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let some_option_value: Option<i32> = None;
    let Some(x) = some_option_value;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let une_option_quelconque: Option&lt;i32&gt; = None;
</span>    let Some(x) = une_option_quelconque;
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-8: Attempting to use a refutable pattern with
`let`</span>
-->
<p><span class="caption">Encart 18-8Â : tentative d'utilisation d'un motif
rÃ©futable avec <code>let</code></span></p>
<!--
If `some_option_value` was a `None` value, it would fail to match the pattern
`Some(x)`, meaning the pattern is refutable. However, the `let` statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a `None` value. At compile time, Rust will complain that weâ€™ve tried to
use a refutable pattern where an irrefutable pattern is required:
-->
<p>Si <code>une_option_quelconque</code> Ã©tait une valeur <code>None</code>, cela ferait Ã©chouer le motif
<code>Some(x)</code>, ce qui signifie que le motif est rÃ©futable. Cependant, l'instruction
<code>let</code> ne peut accepter qu'un motif irrÃ©futable car il n'y a pas d'instructions Ã 
suivre dans le cas d'une valeur <code>None</code>. A la compilation, Rust s'y opposera en
expliquant que nous avons essayÃ© d'utiliser un motif rÃ©futable lÃ  oÃ¹ un motif
irrÃ©futable est nÃ©cessaireÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 -- > src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     if let Some(x) = some_option_value { /* */ }
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = une_option_quelconque;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     if let Some(x) = une_option_quelconque { /* */ }
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Because we didnâ€™t cover (and couldnâ€™t cover!) every valid value with the
pattern `Some(x)`, Rust rightfully produces a compiler error.
-->
<p>Comme nous n'avons pas couvert (et nous ne pouvons pas le faireÂ !) chaque
valeur possible avec le motif <code>Some(x)</code>, Rust gÃ©nÃ¨re une erreur de compilation,
Ã  juste titre.</p>
<!--
To fix the problem where we have a refutable pattern where an irrefutable
pattern is needed, we can change the code that uses the pattern: instead of
using `let`, we can use `if let`. Then if the pattern doesnâ€™t match, the code
will just skip the code in the curly brackets, giving it a way to continue
validly. Listing 18-9 shows how to fix the code in Listing 18-8.
-->
<p>Pour corriger le problÃ¨me lorsque nous avons un motif rÃ©futable oÃ¹ un motif
irrÃ©futable est nÃ©cessaire, nous pouvons changer le code qui utilise ce motifÂ :
au lieu d'utiliser <code>let</code>, nous pouvons utiliser <code>if let</code>. Ensuite, si le motif
ne correspond pas, le code va simplement sauter le code entre les accolades,
nous offrant la possibilitÃ© de continuer correctement. L'encart 18-9 montre
comment corriger le code de l'encart 18-8.</p>
<!--
```rust
# fn main() {
#     let some_option_value: Option<i32> = None;
    if let Some(x) = some_option_value {
        println!("{}", x);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let une_option_quelconque: Option&lt;i32&gt; = None;
</span>    if let Some(x) = une_option_quelconque {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-9: Using `if let` and a block with refutable
patterns instead of `let`</span>
-->
<p><span class="caption">Encart 18-9Â : utilisation de <code>if let</code> et d'un bloc avec
un motif rÃ©futable plutÃ´t qu'un <code>let</code></span></p>
<!--
Weâ€™ve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give `if
let` a pattern that will always match, such as `x`, as shown in Listing 18-10,
the compiler will give a warning.
-->
<p>Ce code est parfaitement valide, bien que cela signifie que nous ne pouvons pas
utiliser un motif irrÃ©futable sans avoir d'erreur. Si nous donnons au <code>if let</code>
un motif qui correspond toujours, comme pour <code>x</code> montrÃ© dans l'encart 18-10, le
compilateur va lever un avertissement.</p>
<!--
```rust
# fn main() {
    if let x = 5 {
        println!("{}", x);
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with `if let`</span>
-->
<p><span class="caption">Encart 18-10Â : tentative d'utiliser un motif irrÃ©futable
avec <code>if let</code></span></p>
<!--
Rust complains that it doesnâ€™t make sense to use `if let` with an irrefutable
pattern:
-->
<p>Rust explique que cela ne fait aucun sens d'utiliser <code>if let</code> avec un motif
irrÃ©futableÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable if-let pattern
 -- > src/main.rs:2:5
  |
2 | /     if let x = 5 {
3 | |         println!("{}", x);
4 | |     };
  | |_____^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable if-let pattern
 --&gt; src/main.rs:2:5
  |
2 | /     if let x = 5 {
3 | |         println!(&quot;{}&quot;, x);
4 | |     };
  | |_____^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<!--
For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a `match` with only one arm, but
this syntax isnâ€™t particularly useful and could be replaced with a simpler
`let` statement.
-->
<p>C'est pourquoi les branches de <code>match</code> doivent utiliser des motifs rÃ©futables,
sauf pour la derniÃ¨re branche, qui devrait correspondre Ã  n'importe quelle
valeur grÃ¢ce Ã  son motif irrÃ©futable. Rust nous permet d'utiliser un motif
irrÃ©futable dans un <code>match</code> avec une seule branche, mais cette syntaxe n'est
pas particuliÃ¨rement utile et devrait Ãªtre remplacÃ©e par une instruction <code>let</code>
plus simple.</p>
<!--
Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, letâ€™s cover all the syntax we can use to create
patterns.
-->
<p>Maintenant que vous savez oÃ¹ utiliser les motifs et les diffÃ©rences entre les
motifs rÃ©futables et irrÃ©futables, voyons les syntaxes que nous pouvons
utiliser pour crÃ©er des motifs.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--43" id="-attention-peinture-fraÃ®che--43">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/207">Pull Request</a>.</p>
</blockquote>
<!--
## Pattern Syntax
-->
<h2><a class="header" href="#la-syntaxe-des-motifs" id="la-syntaxe-des-motifs">La syntaxe des motifs</a></h2>
<!--
Throughout the book, youâ€™ve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each one.
-->
<p>A travers le livre, vous avez rencontrÃ© de nombreux types de motifs. Dans cette
section, nous allons rassembler toutes les syntaxes valides des motifs et
examiner les raisons pour lesquelles vous devriez utiliser chacune d'entre
elles.</p>
<!--
### Matching Literals
-->
<h3><a class="header" href="#correspondre-aux-littÃ©raux" id="correspondre-aux-littÃ©raux">Correspondre aux littÃ©raux</a></h3>
<!--
As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:
-->
<p>Comme vous l'avez vu chapitre 6, vous pouvez faire directement correspondre des
motifs sur des littÃ©raux. Le code suivant vous donne quelques exemplesÂ :</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;un&quot;),
        2 =&gt; println!(&quot;deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;n'importe quoi&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one` because the value in `x` is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.
-->
<p>Ce code affiche <code>un</code> car la valeur dans <code>x</code> est <code>1</code>. Cette syntaxe est trÃ¨s
utile lorsque vous souhaitez que votre code fasse quelque chose s'il obtient une
valeur prÃ©cise.</p>
<!--
### Matching Named Variables
-->
<h3><a class="header" href="#correspondre-Ã -des-variables-nommÃ©es" id="correspondre-Ã -des-variables-nommÃ©es">Correspondre Ã  des variables nommÃ©es</a></h3>
<!--
Named variables are irrefutable patterns that match any value, and weâ€™ve used
them many times in the book. However, there is a complication when you use
named variables in `match` expressions. Because `match` starts a new scope,
variables declared as part of a pattern inside the `match` expression will
shadow those with the same name outside the `match` construct, as is the case
with all variables. In Listing 18-11, we declare a variable named `x` with the
value `Some(5)` and a variable `y` with the value `10`. We then create a
`match` expression on the value `x`. Look at the patterns in the match arms and
`println!` at the end, and try to figure out what the code will print before
running this code or reading further.
-->
<p>Les variables nommÃ©es sont des motifs irrÃ©futables qui correspondent Ã 
n'importe quelle valeur, et nous les avons utilisÃ©s de nombreuses foix dans le
livre. Cependant, il subsiste un problÃ¨me lorsque vous utilisez les variables
nommÃ©es dans les expressions <code>match</code>. Comme <code>match</code> dÃ©bute une nouvelle portÃ©e,
les variables utilisÃ©es comme Ã©tant une partie du motif de la construction
<code>match</code> vont masquer celles avec le mÃªme nom provenant de l'extÃ©rieur de la
construction <code>match</code>, comme c'est le cas avec toutes les variables. Dans
l'encart 18-11, nous dÃ©clarons une variable <code>x</code> avec la valeur <code>Some(5)</code> et une
variable <code>y</code> avec la valeur <code>10</code>. Nous crÃ©ons alors une expression <code>match</code> sur
la valeur <code>x</code>. Observez les motifs sur les branches du <code>match</code> et du <code>println!</code>
Ã  la fin, et essayez de deviner ce qui sera Ã©crit avant d'exÃ©cuter ce code ou
de lire la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;On a 50&quot;),
        Some(y) =&gt; println!(&quot;Correspondance, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Cas par dÃ©faut, x = {:?}&quot;, x),
    }

    println!(&quot;A la finÂ : x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-11: A `match` expression with an arm that
introduces a shadowed variable `y`</span>
-->
<p><span class="caption">Encart 18-11Â : une expression <code>match</code> avec une branche
qui crÃ©e une variable masquÃ©e <code>y</code></span></p>
<!--
Letâ€™s walk through what happens when the `match` expression runs. The pattern
in the first match arm doesnâ€™t match the defined value of `x`, so the code
continues.
-->
<p>Voyons ce qui se passe lorsque l'expression <code>match</code> est utilisÃ©e. Le motif
prÃ©sent dans la premiÃ¨re branche du <code>match</code> ne correspond pas Ã  la valeur
actuelle de <code>x</code>, donc le code continue.</p>
<!--
The pattern in the second match arm introduces a new variable named `y` that
will match any value inside a `Some` value. Because weâ€™re in a new scope inside
the `match` expression, this is a new `y` variable, not the `y` we declared at
the beginning with the value 10. This new `y` binding will match any value
inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to
the inner value of the `Some` in `x`. That value is `5`, so the expression for
that arm executes and prints `Matched, y = 5`.
-->
<p>Le motif dans la seconde branche du <code>match</code> ajoute une nouvelle variable <code>y</code>
qui va correspondre Ã  n'importe quelle valeur logÃ©e dans une valeur <code>Some</code>.
Comme nous sommes dans une nouvelle portÃ©e Ã  l'intÃ©rieur de l'expression
<code>match</code>, c'est une nouvelle variable <code>y</code>, et non pas le <code>y</code> que nous avons
dÃ©clarÃ© au dÃ©but avec la valeur 10. Cette nouvelle correspondance <code>y</code> va
correspondre Ã  n'importe quelle valeur Ã  l'intÃ©rieur d'un <code>Some</code>, ce qui est
la situation prÃ©sente actuellement dans <code>x</code>. Ainsi, ce nouveau <code>y</code> correspondra
Ã  la valeur interne du <code>Some</code> prÃ©sent dans <code>x</code>. Cette valeur est <code>5</code>, donc
l'expression de cette branche s'exÃ©cute et affiche <code>Correspondance, y = 5</code>.</p>
<!--
If `x` had been a `None` value instead of `Some(5)`, the patterns in the first
two arms wouldnâ€™t have matched, so the value would have matched to the
underscore. We didnâ€™t introduce the `x` variable in the pattern of the
underscore arm, so the `x` in the expression is still the outer `x` that hasnâ€™t
been shadowed. In this hypothetical case, the `match` would print `Default
case, x = None`.
-->
<p>Si <code>x</code> aurait Ã©tÃ© une valeur <code>None</code> plutÃ´t que <code>Some(5)</code>, les motifs prÃ©sents
dans les deux premiÃ¨res branches n'auraient pas correspondu, donc la valeur qui
aurait correspondu serait celui avec le tiret du bas. Nous n'avons pas
introduit de nouvelle variable <code>x</code> qui est prÃ©sente dans la branche du motif,
donc le <code>x</code> dans l'expression dÃ©signe toujours la variable <code>x</code> en dehors, qui
n'a pas Ã©tÃ© masquÃ©e. Dans ce cas, le <code>match</code> devrait afficher
<code>Cas par dÃ©faut, x = None</code>.</p>
<!--
When the `match` expression is done, its scope ends, and so does the scope of
the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.
-->
<p>Lorsque l'expression <code>match</code> est terminÃ©e, sa portÃ©e se termine, et avec elle
la portÃ©e de la variable interne <code>y</code>. Le dernier <code>println!</code> affiche
<code>A la finÂ : x = Some(5), y = 10</code>.</p>
<!--
To create a `match` expression that compares the values of the outer `x` and
`y`, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. Weâ€™ll talk about match guards later in the [â€œExtra
Conditionals with Match Guardsâ€](#extra-conditionals-with-match-guards)<!--
ignore -- > section.
-->
<p>Pour crÃ©er une expression <code>match</code> qui compare les valeurs d'une variable
externe <code>x</code> et <code>y</code>, plutÃ´t que d'utiliser une variable masquÃ©e, nous aurons
besoin d'utiliser Ã  la place un contrÃ´le de correspondance. Nous verrons les
contrÃ´les de correspondance plus loin dans une des sections.</p>
<!--
### Multiple Patterns
-->
<h3><a class="header" href="#plusieurs-motifs" id="plusieurs-motifs">Plusieurs motifs</a></h3>
<!--
In `match` expressions, you can match multiple patterns using the `|` syntax,
which means *or*. For example, the following code matches the value of `x`
against the match arms, the first of which has an *or* option, meaning if the
value of `x` matches either of the values in that arm, that armâ€™s code will
run:
-->
<p>Dans les expressions <code>match</code>, vous pouvez faire correspondre plusieurs motifs
en utilisant la syntaxe <code>|</code>, qui signifie <em>ou</em>. Par exemple, le code suivant
applique un <code>match</code> sur la valeur de <code>x</code>, la premiÃ¨re des branches a une option
<em>ou</em>, ce qui signifie que si la valeur de <code>x</code> correspond Ã  un de ces motifs de
cette branche, le code de cette branche sera exÃ©cutÃ©Â :</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;un ou deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one or two`.
-->
<p>Ce code va afficher <code>un ou deux</code>.</p>
<!--
### Matching Ranges of Values with `..=`
-->
<h3><a class="header" href="#faire-correspondre-un-intervalle-de-valeurs-avec-" id="faire-correspondre-un-intervalle-de-valeurs-avec-">Faire correspondre un intervalle de valeurs avec <code>..=</code></a></h3>
<!--
The `..=` syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:
-->
<p>La syntaxe <code>..=</code> nous permet de faire correspondre un intervalle inclusif de
valeurs. Dans le code suivant, lorsqu'un motif correspond Ã  une des valeurs
prÃ©sentes dans l'intervalle, cette branche va s'exÃ©cuterÂ :</p>
<!--
```rust
# fn main() {
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;de un Ã  cinq&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the `|` operator to express the same idea; instead of
`1..=5`, we would have to specify `1 | 2 | 3 | 4 | 5` if we used `|`.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!
-->
<p>Si <code>x</code> vaut 1, 2, 3, 4 ou 5, la premiÃ¨re branche va correspondre. Cette syntaxe
est plus pratique Ã  utiliser que d'avoir Ã  utiliser l'opÃ©rateur <code>|</code> pour
exprimer la mÃªme idÃ©eÂ ; Ã  la place de <code>1..=5</code> nous aurions dÃ» prÃ©ciser
<code>1 | 2 | 3 | 4 | 5</code> si nous avions dÃ» utiliser <code>|</code>. Renseigner un intervalle
est bien plus court, en particulier si nous souhaitons correspondre aux valeurs
entre 1 et 1000 par exempleÂ !</p>
<!--
Ranges are only allowed with numeric values or `char` values, because the
compiler checks that the range isnâ€™t empty at compile time. The only types for
which Rust can tell if a range is empty or not are `char` and numeric values.
-->
<p>Les intervalles peuvent Ãªtre des nombres ou des <code>char</code> (caractÃ¨res), car le
compilateur vÃ©rifie que l'intervalle n'est pas vide au moment de la
compilation. Les seuls types pour lesquels Rust peut dire si un intervalle est
vide ou non sont pour les nombres et les <code>char</code>.</p>
<!--
Here is an example using ranges of `char` values:
-->
<p>Voici un exemple d'utilisation d'intervalles de <code>char</code>Â :</p>
<!--
```rust
# fn main() {
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;lettre ASCII du dÃ©but&quot;),
        'k'..='z' =&gt; println!(&quot;lettre ASCII de la fin&quot;),
        _ =&gt; println!(&quot;autre chose&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Rust can tell that `c` is within the first patternâ€™s range and prints `early
ASCII letter`.
-->
<p>Rust peut nous dire que <code>c</code> est dans le premier intervalle du premier motif et
afficher <code>lettre ASCII du dÃ©but</code>.</p>
<!--
### Destructuring to Break Apart Values
-->
<h3><a class="header" href="#destructurer-pour-sÃ©parer-les-valeurs" id="destructurer-pour-sÃ©parer-les-valeurs">Destructurer pour sÃ©parer les valeurs</a></h3>
<!--
We can also use patterns to destructure structs, enums, tuples, and references
to use different parts of these values. Letâ€™s walk through each value.
-->
<p>Nous pouvons aussi utiliser les motifs pour destructurer les structures, les
Ã©numÃ©rations, les tuples et les rÃ©fÃ©rences pour utiliser diffÃ©rentes parties de
ces valeurs. Passons en revue chacun des cas.</p>
<!--
#### Destructuring Structs
-->
<h4><a class="header" href="#destructurer-les-structures" id="destructurer-les-structures">Destructurer les structures</a></h4>
<!--
Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can
break apart using a pattern with a `let` statement.
-->
<p>L'encart 18-12 montre une structure <code>Point</code> avec deux champs, <code>x</code> et <code>y</code>, que
nous pouvons sÃ©parer en utilisant un motif avec une instruction <code>let</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-12: Destructuring a structâ€™s fields into
separate variables</span>
-->
<p><span class="caption">Encart 18-12Â : dÃ©structuration des champs d'une structure
dans des variables sÃ©parÃ©es</span></p>
<!--
This code creates the variables `a` and `b` that match the values of the `x`
and `y` fields of the `p` struct. This example shows that the names of the
variables in the pattern donâ€™t have to match the field names of the struct. But
itâ€™s common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.
-->
<p>Ce code crÃ©Ã© les variables <code>a</code> et <code>b</code> qui correspondent aux valeurs des champs
<code>x</code> et <code>y</code> de la structure <code>p</code>. Cet exemple montre que les noms des variables
du motif n'ont pas Ã  correspondre aux noms des champs de la structure. Mais il
est courant de vouloir que les noms des variables correspondent aux noms des
champs pour se rappeler plus facilement quelle variable provient de quel champ.</p>
<!--
Because having variable names match the fields is common and because writing
`let Point { x: x, y: y } = p;` contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the `let` pattern are `x` and
`y` instead of `a` and `b`.
-->
<p>Comme avoir des noms de variables qui correspondent aux champs est courant et
comme Ã©crire <code>let Point { x: x, y: y } = p;</code> est assez rÃ©pÃ©titif, il existe un
raccourci pour les motifs qui correspondent aux champs des structuresÂ : vous
avez simplement besoin de lister le nom des champs de la structure, et les
variables crÃ©Ã©es Ã  partir du motif auront les mÃªmes noms. L'encart 18-12 montre
du code qui se comporte de la mÃªme maniÃ¨re que le code de l'encart 18-12, mais
les variables crÃ©Ã©es dans le motif du <code>let</code> sont <code>x</code> et <code>y</code> au lieu de <code>a</code> et
<code>b</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span>
-->
<p><span class="caption">Encart 18-13Â : dÃ©structuration des champs d'une structure
en utilisant le raccourci pour les champs des structures</span></p>
<!--
This code creates the variables `x` and `y` that match the `x` and `y` fields
of the `p` variable. The outcome is that the variables `x` and `y` contain the
values from the `p` struct.
-->
<p>Ce code crÃ©Ã© les variables <code>x</code> et <code>y</code> qui correspondent aux champs <code>x</code> et <code>y</code>
de la variable <code>p</code>. Il en rÃ©sulte que les variables <code>x</code> et <code>y</code> contiennent les
valeurs correspondantes Ã  la structure <code>p</code>.</p>
<!--
We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.
-->
<p>Nous pouvons aussi destructurer avec des valeurs littÃ©rales comme faisant partie
du motif de la structure plutÃ´t que d'avoir Ã  crÃ©er les variables pour tous les
champs. Ceci nous permet de tester certains champs pour des valeurs
particuliÃ¨res tout en crÃ©ant les variables pour destructurer les autres champs.</p>
<!--
Listing 18-14 shows a `match` expression that separates `Point` values into
three cases: points that lie directly on the `x` axis (which is true when `y =
0`), on the `y` axis (`x = 0`), or neither.
-->
<p>L'encart 18-14 montre une expression <code>match</code> qui sÃ©pare les valeurs <code>Point</code>
en trois catÃ©goriesÂ : les points qui sont directement sur l'axe <code>x</code> (ce qui est
vrai lorsque <code>y = 0</code>), ceux directement sur l'axe <code>y</code> (<code>x = 0</code>), ou sur aucun
de ces deux axes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;Sur l'axe x Ã  la position {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;Sur l'axe y Ã  la position {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Sur aucun des axesÂ : ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span>
-->
<p><span class="caption">Encart 18-14Â : dÃ©structurer et faire correspondre des
valeurs littÃ©rales grÃ¢ce Ã  un seul motif</span></p>
<!--
The first arm will match any point that lies on the `x` axis by specifying that
the `y` field matches if its value matches the literal `0`. The pattern still
creates an `x` variable that we can use in the code for this arm.
-->
<p>La premiÃ¨re branche va correspondre avec n'importe quel point qui se trouve sur
l'axe <code>x</code> en prÃ©cisant que le champ <code>y</code> correspond au littÃ©ral <code>0</code>. Le motif va
toujours crÃ©er une variable <code>x</code> que nous pouvons utiliser dans le code de cette
branche.</p>
<!--
Similarly, the second arm matches any point on the `y` axis by specifying that
the `x` field matches if its value is `0` and creates a variable `y` for the
value of the `y` field. The third arm doesnâ€™t specify any literals, so it
matches any other `Point` and creates variables for both the `x` and `y` fields.
-->
<p>De la mÃªme maniÃ¨re, la seconde branche correspondra avec tous les points sur
l'axe <code>y</code> en prÃ©cisant que le champ <code>x</code> correspondra uniquement si sa valeur
est <code>0</code> et crÃ©era une variable <code>y</code> pour la valeur du champ <code>y</code>. La troisiÃ¨me
branche n'a pas besoin d'un littÃ©ral en particulier, donc elle correspondra Ã 
n'importe quel autre <code>Point</code> et crÃ©era les variables pour les champs <code>x</code> et
<code>y</code>.</p>
<!--
In this example, the value `p` matches the second arm by virtue of `x`
containing a 0, so this code will print `On the y axis at 7`.
-->
<p>Dans cet exemple, la valeur <code>p</code> correspond avec la seconde branche car son <code>x</code>
vaut <code>0</code>, donc ce code va afficher <code>Sur l'axe y Ã  la position 7</code>.</p>
<!--
#### Destructuring Enums
-->
<h4><a class="header" href="#destructurer-une-Ã©numÃ©ration" id="destructurer-une-Ã©numÃ©ration">Destructurer une Ã©numÃ©ration</a></h4>
<!--
Weâ€™ve destructured enums earlier in this book, for example, when we
destructured `Option<i32>` in Listing 6-5 in Chapter 6. One detail we havenâ€™t
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write
a `match` with patterns that will destructure each inner value.
-->
<p>Nous avons destructurÃ© les Ã©numÃ©rations prÃ©cÃ©demment dans ce livre, par exemple
lorsque nous avions destructurÃ© <code>Option&lt;i32&gt;</code> dans l'encart 6-5 du chapitre 6.
Un dÃ©tail que nous n'avons pas prÃ©cisÃ© explicitement Ã©tait que le motif pour
destructurer une Ã©numÃ©ration devait correspondre Ã  la faÃ§on dont est dÃ©fini les
donnÃ©es dans l'Ã©numÃ©ration. Par exemple, dans l'encart 18-15 nous utilisons
l'Ã©numÃ©ration <code>Message</code> de l'encart 6-2 et nous rajoutons un <code>match</code> avec des
motifs qui devraient destructurer chaque valeur interne.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x, y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangerCouleur(0, 160, 255);

    match msg {
        Message::Quitter =&gt; {
            println!(&quot;La variante Quitter n'a pas de donnÃ©es Ã  dÃ©structurer.&quot;)
        }
        Message::Deplacer { x, y } =&gt; {
            println!(
                &quot;DÃ©placement de {} sur l'axe x et de {} sur l'axe y&quot;,
                x, y
            );
        }
        Message::Ecrire(text) =&gt; println!(&quot;Message textuelÂ : {}&quot;, text),
        Message::ChangerCouleur(r, g, b) =&gt; println!(
            &quot;Changement des taux de rouge Ã  {}, de vert Ã  {}, et de bleu Ã  {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span>
-->
<p><span class="caption">Encart 18-15Â : dÃ©structuration des variantes d'une
Ã©numÃ©ration qui stocke diffÃ©rents types de valeurs</span></p>
<!--
This code will print `Change the color to red 0, green 160, and blue 255`. Try
changing the value of `msg` to see the code from the other arms run.
-->
<p>Ce code va afficher
<code>Changement des taux de rouge Ã  0, de vert Ã  160, et de bleu Ã  255</code>. Essayez de
changer la valeur de <code>message</code> pour voir le code qu'exÃ©cute les autres
branches.</p>
<!--
For enum variants without any data, like `Message::Quit`, we canâ€™t destructure
the value any further. We can only match on the literal `Message::Quit` value,
and no variables are in that pattern.
-->
<p>Pour les variantes d'Ã©numÃ©ration sans aucune donnÃ©e, comme <code>Message::Quitter</code>,
nous ne pouvons pas destructurer de valeurs. Nous pouvons uniquement
correspondre Ã  la valeur littÃ©rale <code>Message::Quitter</code>, et il n'y a pas de
variable dans ce motif.</p>
<!--
For struct-like enum variants, such as `Message::Move`, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.
-->
<p>Pour les variantes d'Ã©numÃ©ration qui ressemblent aux structures, comme
<code>Message::Deplacer</code>, nous pouvons utiliser un motif similaire aux motifs que
nous utilisons pour correspondre aux structures. AprÃ¨s le nom de la variante,
nous utilisons des accolades et ensuite nous listons les champs avec des
variables afin de diviser les Ã©lÃ©ments Ã  utiliser dans le code de cette
branche. Ici nous utilisons la forme raccourcie comme nous l'avons fait Ã 
l'encart 18-13.</p>
<!--
For tuple-like enum variants, like `Message::Write` that holds a tuple with one
element and `Message::ChangeColor` that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant weâ€™re
matching.
-->
<p>Pour les variantes d'Ã©numÃ©rations qui ressemblent Ã  des tuples, comme
<code>Message::Ecrire</code> qui stocke un tuple avec un Ã©lÃ©ment, et
<code>Message::ChangerCouleur</code> qui stocke un tuple avec trois Ã©lÃ©ments, le motif
ressemble au motif que nous renseignons pour correspondre aux tuples. Le nombre
de variables dans le motif doit correspondre aux nombre d'Ã©lÃ©ments dans la
variante qui correspond.</p>
<!--
#### Destructuring Nested Structs and Enums
-->
<h4><a class="header" href="#destructurer-des-structures-imbriquÃ©es-et-des-Ã©numÃ©rations" id="destructurer-des-structures-imbriquÃ©es-et-des-Ã©numÃ©rations">Destructurer des structures imbriquÃ©es et des Ã©numÃ©rations</a></h4>
<!--
Until now, all our examples have been matching structs or enums that were one
level deep. Matching can work on nested items too!
-->
<p>Jusqu'Ã  prÃ©sent, tous nos exemples avaient des correspondances avec structures
ou des Ã©numÃ©rations qui avaient un seul niveau de profondeur. Les
correspondances fonctionnent aussi sur les Ã©lÃ©ments imbriquÃ©sÂ !</p>
<!--
For example, we can refactor the code in Listing 18-15 to support RGB and HSV
colors in the `ChangeColor` message, as shown in Listing 18-16.
-->
<p>Par exemple, nous pouvons remanier le code de l'encart 18-15 pour pouvoir
utiliser des couleurs RVB et TSV dans le message <code>ChangerCouleur</code>, comme dans
l'encart 18-16.</p>
<!--
```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) => println!(
            "Change the color to hue {}, saturation {}, and value {}",
            h, s, v
        ),
        _ => (),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Couleur {
    Rvb(i32, i32, i32),
    Tsv(i32, i32, i32),
}

enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(Couleur),
}

fn main() {
    let msg = Message::ChangerCouleur(Couleur::Tsv(0, 160, 255));

    match msg {
        Message::ChangerCouleur(Couleur::Rvb(r, v, b)) =&gt; println!(
            &quot;Changement des taux de rouge Ã  {}, de vert Ã  {}, et de bleu Ã  {}&quot;,
            r, v, b
        ),
        Message::ChangerCouleur(Couleur::Tsv(t, s, v)) =&gt; println!(
            &quot;Changement des taux de teinte Ã  {}, de saturation Ã  {}, et de valeur Ã  {}&quot;,
            t, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-16: Matching on nested enums</span>
-->
<p><span class="caption">Encart 18-16Â : correspondance avec des Ã©numÃ©rations
imbriquÃ©es</span></p>
<!--
The pattern of the first arm in the `match` expression matches a
`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; then
the pattern binds to the three inner `i32` values. The pattern of the second
arm also matches a `Message::ChangeColor` enum variant, but the inner enum
matches the `Color::Hsv` variant instead. We can specify these complex
conditions in one `match` expression, even though two enums are involved.
-->
<p>Le motif de la premiÃ¨re branche dans l'expression <code>match</code> correspond Ã  la
variante d'Ã©numÃ©ration <code>Message::ChangerCouleur</code> qui contient une variante
<code>Couleur::Rvb</code>Â ; ensuite le motif fait correspondre des variables aux trois
valeurs <code>i32</code> Ã  l'intÃ©rieur. Le motif de la seconde branche correspond aussi
Ã  une variante de l'Ã©numÃ©ration de <code>Message::ChangerCouleur</code>, mais la valeur
interne correspond plutÃ´t Ã  la variante <code>Couleur::Tsv</code>. Nous pouvons renseigner
ces conditions complexes dans une seule expression <code>match</code>, mÃªme si nous la
faisons sur deux Ã©numÃ©rations.</p>
<!--
#### Destructuring Structs and Tuples
-->
<h4><a class="header" href="#destructurer-des-structures-et-des-tuples" id="destructurer-des-structures-et-des-tuples">Destructurer des structures et des tuples</a></h4>
<!--
We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:
-->
<p>Nous pouvons mÃ©langer les correspondances et les motifs pour dÃ©structurer des
Ã©lÃ©ments imbriquÃ©s de maniÃ¨re bien plus complexe. L'exemple suivant montre une
dÃ©structuration complexe dans laquelle nous imbriquons des structures et des
tuples Ã  l'intÃ©rieur d'un tuple et nous y destructurons toutes les valeurs
primitivesÂ :</p>
<!--
```rust
# fn main() {
#     struct Point {
#         x: i32,
#         y: i32,
#     }
# 
    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((pieds, pouces), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<!--
This code lets us break complex types into their component parts so we can use
the values weâ€™re interested in separately.
-->
<p>Ce code nous permet de dÃ©composer les parties qui composent des types complexes
pour pouvoir utiliser sÃ©parÃ©ment les valeurs qui nous intÃ©ressent.</p>
<!--
Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.
-->
<p>La dÃ©structuration avec les motifs est un moyen efficace d'utiliser des parties
de valeurs, comme par exemple la valeur de chaque champ d'une structure,
indÃ©pendamment les unes des autres.</p>
<!--
### Ignoring Values in a Pattern
-->
<h3><a class="header" href="#ignorer-des-valeurs-dans-un-motif" id="ignorer-des-valeurs-dans-un-motif">Ignorer des valeurs dans un motif</a></h3>
<!--
Youâ€™ve seen that itâ€™s sometimes useful to ignore values in a pattern, such as
in the last arm of a `match`, to get a catchall that doesnâ€™t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the `_`
pattern (which youâ€™ve seen), using the `_` pattern within another pattern,
using a name that starts with an underscore, or using `..` to ignore remaining
parts of a value. Letâ€™s explore how and why to use each of these patterns.
-->
<p>Vous avez pu constater qu'il est parfois utile d'ignorer des valeurs dans un
motif, comme celle dans la derniÃ¨re branche d'un <code>match</code>, pour obtenir un joker
qui ne fait rien mis Ã  part qu'il reprÃ©sente toutes les autres valeurs
possibles. Il existe plusieurs faÃ§ons d'ignorer des valeurs entiÃ¨res ou des
parties de valeurs dans un motifÂ : l'utilisation du motif <code>_</code> (que vous avez
dÃ©jÃ  vu), l'utilisation du motif <code>_</code> Ã  l'intÃ©rieur d'un autre motif, utiliser
un nom qui commence avec un tiret bas, ou utiliser <code>..</code> pour ignorer les
parties restantes d'une valeur. Voyons comment et pourquoi utiliser ces motifs.</p>
<!--
#### Ignoring an Entire Value with `_`
-->
<h4><a class="header" href="#ignorer-une-valeur-entiÃ¨re-avec-_" id="ignorer-une-valeur-entiÃ¨re-avec-_">Ignorer une valeur entiÃ¨re avec <code>_</code></a></h4>
<!--
Weâ€™ve used the underscore (`_`) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore `_` pattern is especially
useful as the last arm in a `match` expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.
-->
<p>Nous avons utilisÃ© le tiret bas (<code>_</code>) comme un motif de joker qui devait
correspondre avec n'importe quelle valeur mais ne pouvait pas Ãªtre assignÃ© Ã 
une valeur. Bien que le motif du tiret bas <code>_</code> est particuliÃ¨rement utile dans
la derniÃ¨re branche d'une expression <code>match</code>, nous pouvons l'utiliser dans
n'importe quel motif, y compris les paramÃ¨tres de fonctions, comme montrÃ© dans
l'encart 18-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(_: i32, y: i32) {
    println!(&quot;Ce code utilise uniquement le paramÃ¨tre yÂ : {}&quot;, y);
}

fn main() {
    fonction(3, 4);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-17: Using `_` in a function signature</span>
-->
<p><span class="caption">Encart 18-17Â : utilisation d'un <code>_</code> dans la signature
d'une fonction</span></p>
<!--
This code will completely ignore the value passed as the first argument, `3`,
and will print `This code only uses the y parameter: 4`.
-->
<p>Ce code va complÃ¨tement ignorer la valeur envoyÃ©e en premier argument, <code>3</code>, et
va afficher <code>Ce code utilise uniquement le paramÃ¨tre yÂ : 4</code>.</p>
<!--
In most cases when you no longer need a particular function parameter, you
would change the signature so it doesnâ€™t include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesnâ€™t need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.
-->
<p>Dans la plupart des cas lorsque vous n'avez pas besoin d'un paramÃ¨tre d'une
fonction, vous pouvez changer la signature pour qu'elle n'inclue pas le
paramÃ¨tre non utilisÃ©. Ignorer un paramÃ¨tre de fonction peut Ãªtre
particuliÃ¨rement utile dans certains cas, comme par exemple, lors de
l'implÃ©mentation d'un trait lorsque vous avez besoin d'un certain type de
signature mais que le corps de la fonction dans votre implÃ©mentation n'a pas
besoin d'un des paramÃ¨tres. Le compilateur ne vous avertira plus que ces
paramÃ¨tres de fonction ne sont pas utilisÃ©s, ce qui serait le cas si vous
utilisiez un nom Ã  la place.</p>
<!--
#### Ignoring Parts of a Value with a Nested `_`
-->
<h4><a class="header" href="#ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriquÃ©" id="ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriquÃ©">Ignorer des parties d'une valeur en utilisant un <code>_</code> imbriquÃ©</a></h4>
<!--
We can also use `_` inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a settingâ€™s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.
-->
<p>Nous pouvons aussi utiliser <code>_</code> au sein d'un autre motif pour ignorer
uniquement une partie d'une valeur, par exemple, si nous souhaitons tester
qu'une seule partie d'une valeur mais que nous n'utilisons pas les autres
parties dans le code que nous souhaitons exÃ©cuter. L'encart 18-18 montre du
code qui s'occupe de gÃ©rer une valeur d'un rÃ©glage. Les rÃ¨gles mÃ©tier sont que
l'utilisateur ne doit pas pouvoir rÃ©Ã©crire un rÃ©glage personnalisÃ© mais peut
annuler le rÃ©glage et lui donner une valeur s'il est bien inexistant.</p>
<!--
```rust
# fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut valeur_du_reglage = Some(5);
    let nouvelle_valeur_du_reglage = Some(10);

    match (valeur_du_reglage, nouvelle_valeur_du_reglage) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Vous ne pouvez pas Ã©craser une valeur dÃ©jÃ  existante&quot;);
        }
        _ =&gt; {
            valeur_du_reglage = nouvelle_valeur_du_reglage;
        }
    }

    println!(&quot;Le rÃ©glage vaut {:?}&quot;, valeur_du_reglage);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-18: Using an underscore within patterns that
match `Some` variants when we donâ€™t need to use the value inside the
`Some`</span>
-->
<p><span class="caption">Encart 18-18Â : utilisation d'un tiret bas dans des motifs
qui correspondent avec des variantes <code>Some</code> lorsque nous n'avons pas besoin
d'utiliser la valeur Ã  l'intÃ©rieur du <code>Some</code></span></p>
<!--
This code will print `Can't overwrite an existing customized value` and then
`setting is Some(5)`. In the first match arm, we donâ€™t need to match on or use
the values inside either `Some` variant, but we do need to test for the case
when `setting_value` and `new_setting_value` are the `Some` variant. In that
case, we print why weâ€™re not changing `setting_value`, and it doesnâ€™t get
changed.
-->
<p>Ce code va afficher <code>Vous ne pouvez pas Ã©craser une valeur dÃ©jÃ  existante</code> et
ensuite <code>Le rÃ©glage vaut Some(5)</code>. Dans la premiÃ¨re branche, nous n'avons pas
besoin de rÃ©cupÃ©rer ou d'utiliser les valeurs Ã  l'intÃ©rieur de chacune des
variantes <code>Some</code>, mais nous avons besoin de tester les cas lorsque
<code>valeur_du_reglage</code> et <code>nouvelle_valeur_du_reglage</code> vaudront la variante
<code>Some</code>. Dans ce cas, nous Ã©crivons que nous n'allons pas changer
<code>valeur_du_reglage</code>, et il ne changera pas.</p>
<!--
In all other cases (if either `setting_value` or `new_setting_value` are
`None`) expressed by the `_` pattern in the second arm, we want to allow
`new_setting_value` to become `setting_value`.
-->
<p>Dans tous les autres cas (lorsque soit <code>valeur_du_reglage</code>, soit
<code>nouvelle_valeur_du_reglage</code> vaut <code>None</code>) qui correspondront avec le motif
<code>_</code> de la seconde branche, nous voulons permettre Ã  la valeur de
<code>nouvelle_valeur_du_reglage</code> de remplacer celle de <code>valeur_du_reglage</code>.</p>
<!--
We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.
-->
<p>Nous pouvons aussi utiliser les tirets bas Ã  plusieurs endroits dans un mÃªme
motif pour ignorer des valeurs prÃ©cises. L'encart 18-19 montre un exemple qui
ignore la seconde et quatriÃ¨me valeur dans un tuple de cinq Ã©lÃ©ments.</p>
<!--
```rust
# fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        }
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, _, troisieme, _, cinquieme) =&gt; {
            println!(&quot;Voici quelques nombresÂ : {}, {}, {}&quot;, premier, troisieme, cinquieme)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span>
-->
<p><span class="caption">Encart 18-19Â : on ignore plusieurs Ã©lÃ©ments d'un tuple
</span></p>
<!--
This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be
ignored.
-->
<p>Ce code va afficher <code>Voici quelques nombresÂ : 2, 8, 32</code>, et les valeurs 4 et 16
seront ignorÃ©es.</p>
<!--
#### Ignoring an Unused Variable by Starting Its Name with `_`
-->
<h4><a class="header" href="#ignorer-une-variable-non-utilisÃ©e-en-dÃ©marrant-son-nom-avec-un-_" id="ignorer-une-variable-non-utilisÃ©e-en-dÃ©marrant-son-nom-avec-un-_">Ignorer une variable non utilisÃ©e en dÃ©marrant son nom avec un <code>_</code></a></h4>
<!--
If you create a variable but donâ€™t use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes itâ€™s useful to create a
variable you wonâ€™t use yet, such as when youâ€™re prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we run this code, we should
only get a warning about one of them.
-->
<p>Si vous crÃ©ez une variable mais que vous ne l'utilisez nulle part, Rust va
lancer un avertissement car cela est peut-Ãªtre un bogue. Mais parfois il est
utile de crÃ©er une variable que vous n'utilisez pas encore, ce qui peut arriver
lorsque vous crÃ©ez un prototype ou crÃ©ez un projet. Dans ce genre de situation,
vous pouvez demander Ã  Rust de ne pas vous avertir de la variable non utilisÃ©e
en dÃ©butant le nom de la variable avec un tiret bas. Dans l'encart 18-20, nous
crÃ©ons deux variables non utilisÃ©es, mais lorsque nous compilerons ce code,
nous n'aurons qu'un seul avertissement sur une seule d'entre elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span>
-->
<p><span class="caption">Encart 18-20Â : dÃ©marrer le nom d'une variable avec un
tiret bas pour Ã©viter d'avoir des avertissements Ã  propos de variables non
utilisÃ©es</span></p>
<!--
Here we get a warning about not using the variable `y`, but we donâ€™t get a
warning about not using the variable preceded by the underscore.
-->
<p>Ici nous avons un avertissement qui nous prÃ©vient que nous n'utilisons pas la
variable <code>y</code>, mais nous n'avons pas d'avertissement Ã  propos de la variable qui
a le nom qui commence par un tiret bas.</p>
<!--
Note that there is a subtle difference between using only `_` and using a name
that starts with an underscore. The syntax `_x` still binds the value to the
variable, whereas `_` doesnâ€™t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.
-->
<p>Remarquez comme la diffÃ©rence est subtile entre l'utilisation d'uniquement <code>_</code>
et un nom qui commence par un tiret bas. La syntaxe <code>_x</code> continue Ã  associer la
valeur Ã  une variable, alors que <code>_</code> ne le fait pas du tout. Pour montrer un
cas oÃ¹ cette diffÃ©rence est importante, l'encart 18-21 va nous donner une
erreur.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;SalutationsÂ !&quot;));

    if let Some(_s) = s {
        println!(&quot;j'ai trouvÃ© une chaine de caractÃ¨res&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span>
-->
<p><span class="caption">Encart 18-21Â : une variable non utilisÃ©e qui commence par
un tiret bas continue Ã  assigner la valeur, qui pourrait prendre possession de
la valeur</span></p>
<!--
Weâ€™ll receive an error because the `s` value will still be moved into `_s`,
which prevents us from using `s` again. However, using the underscore by itself
doesnâ€™t ever bind to the value. Listing 18-22 will compile without any errors
because `s` doesnâ€™t get moved into `_`.
-->
<p>Nous allons obtenir une erreur car la valeur <code>s</code> est toujours dÃ©placÃ©e dans
<code>_s</code>, ce qui nous empÃªche d'utiliser <code>s</code> ensuite. Cependant, l'utilisation du
tiret bas tout seul n'assigne jamais la valeur Ã  quelque chose. L'encart 18-22
va se compiler sans aucune erreur car <code>s</code> n'est pas dÃ©placÃ© dans <code>_</code>.</p>
<!--
```rust
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;SalutationsÂ !&quot;));

    if let Some(_) = s {
        println!(&quot;j'ai trouvÃ© une chaine de caractÃ¨res&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-22: Using an underscore does not bind the
value</span>
-->
<p><span class="caption">Encart 18-22Â : l'utilisation d'un tiret bas n'assigne pas
la valeur</span></p>
<!--
This code works just fine because we never bind `s` to anything; it isnâ€™t moved.
-->
<p>Ce code fonctionne correctement car nous n'assignons jamais <code>s</code> Ã  quelque
choseÂ ; elle n'est jamais dÃ©placÃ©e.</p>
<!--
#### Ignoring Remaining Parts of a Value with `..`
-->
<h4><a class="header" href="#ignorer-les-Ã©lÃ©ments-restants-dune-valeur-avec-" id="ignorer-les-Ã©lÃ©ments-restants-dune-valeur-avec-">Ignorer les Ã©lÃ©ments restants d'une valeur avec <code>..</code></a></h4>
<!--
With values that have many parts, we can use the `..` syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The `..` pattern ignores any parts of a value that we havenâ€™t
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
`Point` struct that holds a coordinate in three-dimensional space. In the
`match` expression, we want to operate only on the `x` coordinate and ignore
the values in the `y` and `z` fields.
-->
<p>Avec les valeurs qui ont de nombreux Ã©lÃ©ments, nous pouvons utiliser la syntaxe
<code>..</code> pour utiliser uniquement quelques Ã©lÃ©ments et ignorer les autres, ce qui
Ã©vite d'avoir Ã  faire une liste de tirets bas pour chacune des valeurs
ignorÃ©es. Le motif <code>..</code> ignore tous les Ã©lÃ©ments d'une valeur qui ne
correspondent pas explicitement au reste du motif. Dans l'encart 18-23, nous
avons une structure <code>Point</code> qui stocke des coordonnÃ©es dans un espace
tridimensionnel. Dans l'expression <code>match</code>, nous souhaitons utiliser uniquement
la coordonnÃ©e <code>x</code> et ignorer les valeurs des champs <code>y</code> et <code>z</code>.</p>
<!--
```rust
# fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origine = Point { x: 0, y: 0, z: 0 };

    match origine {
        Point { x, .. } =&gt; println!(&quot;x vaut {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-23: Ignoring all fields of a `Point` except
for `x` by using `..`</span>
-->
<p><span class="caption">Encart 18-23Â : on ignore tous les champs d'un <code>Point</code>, Ã 
l'exception de <code>x</code>, en utilisant <code>..</code></span></p>
<!--
We list the `x` value and then just include the `..` pattern. This is quicker
than having to list `y: _` and `z: _`, particularly when weâ€™re working with
structs that have lots of fields in situations where only one or two fields are
relevant.
-->
<p>Nous ajoutons la valeur <code>x</code> et juste ensuite nous insÃ©rons le motif <code>..</code>. C'est
plus rapide que d'avoir Ã  rajouter <code>y: _</code> et <code>z: _</code>, en particulier lorsque
nous travaillons avec des structures qui ont beaucoup de champs alors qu'un
seul champ ou deux nous intÃ©ressent.</p>
<!--
The syntax `..` will expand to as many values as it needs to be. Listing 18-24
shows how to use `..` with a tuple.
-->
<p>La syntaxe <code>..</code> va s'Ã©tendre Ã  toutes les valeurs qu'elle devra couvrir.
L'encart 18-24 montre comment utiliser <code>..</code> avec un tuple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, .., dernier) =&gt; {
            println!(&quot;Voici quelques nombresÂ : {}, {}&quot;, premier, dernier);
        }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span>
-->
<p><span class="caption">Encart 18-24Â : on correspond uniquement avec la premiÃ¨re
et la derniÃ¨re valeur d'un tuple et nous ignorons toutes les autres valeurs
</span></p>
<!--
In this code, the first and last value are matched with `first` and `last`. The
`..` will match and ignore everything in the middle.
-->
<p>Dans ce code, la premiÃ¨re et la derniÃ¨re valeur correspondent Ã  <code>premier</code> et
<code>dernier</code>. Le <code>..</code> va correspondre et ignorer tout ce qui se trouve entre les
deux.</p>
<!--
However, using `..` must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using `..` ambiguously, so it will not
compile.
-->
<p>Cependant, l'utilisation de <code>..</code> peut Ãªtre ambigu. S'il n'est pas clair de
savoir quelles sont les valeurs qui doivent correspondre et celles qui doivent
Ãªtre ignorÃ©es, Rust va nous donner une erreur. L'encart 18-25 nous montre un
exemple d'utilisation ambigu de <code>..</code>, donc il ne se compilera pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (.., second, ..) =&gt; {
            println!(&quot;Voici quelques nombresÂ : {}&quot;, second)
        },
    }
}
</code></pre>
<!--
<span class="caption">Listing 18-25: An attempt to use `..` in an ambiguous
way</span>
-->
<p><span class="caption">Encart 18-25Â : une tentative d'utilisation de <code>..</code> de
maniÃ¨re ambigu</span></p>
<!--
When we compile this example, we get this error:
-->
<p>Lorsque nous compilons cet  exemple, nous obtenons l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 -- > src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Itâ€™s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with `second` and then how many further values to
ignore thereafter. This code could mean that we want to ignore `2`, bind
`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore
`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth.
The variable name `second` doesnâ€™t mean anything special to Rust, so we get a
compiler error because using `..` in two places like this is ambiguous.
-->
<p>Il n'est pas possible pour Rust de dÃ©terminer combien de valeurs sont Ã  ignorer
dans le tuple avant de faire correspondre une valeur avec <code>second</code> et ensuite
combien d'autres Ã  ignorer aprÃ¨s cela. Ce code pourrait signifier que nous
voulons ignorer <code>2</code>, faire correspondre <code>second</code> avec <code>4</code>, en ensuite ignorer
<code>8</code>, <code>16</code>, et <code>32</code>Â ; ou que nous souhaitons ignorer <code>2</code> et <code>4</code>, et faire
correspondre <code>second</code> Ã  <code>8</code>, et ignorer ensuite <code>16</code> et <code>32</code>Â ; et ainsi de
suite. Le nom de la variable <code>second</code> ne signifie pas grand-chose pour Rust,
donc nous obtenons une erreur de compilation Ã  cause de l'utilisation de <code>..</code>
Ã  deux endroits qui rendent la situation ambigu.</p>
<!--
### Extra Conditionals with Match Guards
-->
<h3><a class="header" href="#plus-de-conditions-avec-les-contrÃ´les-de-correspondance" id="plus-de-conditions-avec-les-contrÃ´les-de-correspondance">Plus de conditions avec les contrÃ´les de correspondance</a></h3>
<!--
A *match guard* is an additional `if` condition specified after the pattern in
a `match` arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.
-->
<p>Un <em>contrÃ´le de correspondance</em> est une condition <code>if</code> supplÃ©mentaire renseignÃ©e
aprÃ¨s le motif d'une branche d'un <code>match</code> qui doit elle aussi correspondre, de
mÃªme que le filtrage par motif, pour que cette branche soit choisie. Les
contrÃ´les de correspondance sont utiles pour exprimer des idÃ©es plus complexes
que celles permises par les motifs tout seuls.</p>
<!--
The condition can use variables created in the pattern. Listing 18-26 shows a
`match` where the first arm has the pattern `Some(x)` and also has a match
guard of `if x < 5`.
-->
<p>La condition peut utiliser des variables crÃ©Ã©es dans le motif. L'encart 18-26
montre un <code>match</code> dans lequel la premiÃ¨re branche a le motif <code>Some(x)</code> et
procÃ¨de aussi au contrÃ´le de correspondance <code>if x &lt; 5</code>.</p>
<!--
```rust
# fn main() {
    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombre = Some(4);

    match nombre {
        Some(x) if x &lt; 5 =&gt; println!(&quot;moins que cinqÂ : {}&quot;, x),
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-26: Adding a match guard to a pattern</span>
-->
<p><span class="caption">Encart 18-26Â : ajout d'un contrÃ´le de correspondance Ã  un
motif</span></p>
<!--
This example will print `less than five: 4`. When `num` is compared to the
pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then
the match guard checks whether the value in `x` is less than `5`, and because
it is, the first arm is selected.
-->
<p>Cet exemple va afficher <code>moins que cinqÂ : 4</code>. Lorsque <code>nombre</code> est comparÃ© au
motif de la premiÃ¨re branche, il va correspondre, car <code>Some(4)</code> correspond Ã 
<code>Some(x)</code>. Ensuite, le contrÃ´le de correspondance vÃ©rifie si la valeur dans <code>x</code>
est infÃ©rieure Ã  <code>5</code>, et comme c'est le cas, la premiÃ¨re branche est choisie.</p>
<!--
If `num` had been `Some(10)` instead, the match guard in the first arm would
have been false because 10 is not less than 5. Rust would then go to the second
arm, which would match because the second arm doesnâ€™t have a match guard and
therefore matches any `Some` variant.
-->
<p>Si <code>nombre</code> aurait Ã©tÃ© plutÃ´t <code>Some(10)</code>, le contrÃ´le de correspondance de la
premiÃ¨re branche aurait Ã©tÃ© faux car 10 n'est pas infÃ©rieur Ã  5. Rust serait
donc allÃ© Ã  la seconde branche, qui devrait correspondre car la seconde branche
n'a pas de contrÃ´le de correspondance et correspond parfois Ã  la variante
<code>Some</code>.</p>
<!--
There is no way to express the `if x < 5` condition within a pattern, so the
match guard gives us the ability to express this logic.
-->
<p>Il n'y a pas d'autre moyen d'exprimer la condition <code>if x &lt; 5</code> dans un motif,
donc le contrÃ´le de correspondance nous donne la possibilitÃ© d'exprimer cette
logique.</p>
<!--
In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the `match` expression instead of using the variable outside the
`match`. That new variable meant we couldnâ€™t test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.
-->
<p>Dans l'encart 18-11, nous avions mentionnÃ© le fait que nous pouvions utiliser
des contrÃ´les de correspondance pour rÃ©soudre notre problÃ¨me de masquage dans
le motif. Souvenez-vous qu'une nouvelle variable avait Ã©tÃ© crÃ©Ã©e Ã  l'intÃ©rieur
du motif dans l'expression <code>match</code> au lieu d'utiliser la variable situÃ©e Ã 
l'extÃ©rieur du <code>match</code>. Cette nouvelle variable implique que nous ne pouvons
pas comparer avec la variable qui se situe Ã  l'extÃ©rieur. L'encart 18-27 nous
montre comment nous pouvons utiliser un contrÃ´le de correspondance pour
rÃ©pondre Ã  ce besoin.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Nous obtenons 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Nous avons une correspondance, n = {}&quot;, n),
        _ =&gt; println!(&quot;Cas par dÃ©faut, x = {:?}&quot;, x),
    }

    println!(&quot;Au finalÂ : x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span>
-->
<p><span class="caption">Encart 18-27Â : utilisation d'un contrÃ´le de
correspondance pour vÃ©rifier l'Ã©galitÃ© avec une variable externe au bloc</span></p>
<!--
This code will now print `Default case, x = Some(5)`. The pattern in the second
match arm doesnâ€™t introduce a new variable `y` that would shadow the outer `y`,
meaning we can use the outer `y` in the match guard. Instead of specifying the
pattern as `Some(y)`, which would have shadowed the outer `y`, we specify
`Some(n)`. This creates a new variable `n` that doesnâ€™t shadow anything because
there is no `n` variable outside the `match`.
-->
<p>Ce code va maintenant afficher <code>Cas par dÃ©faut, x = Some(5)</code>. Le motif de la
seconde branche du <code>match</code> ne crÃ©e pas de nouvelle variable <code>y</code> qui masquerait
le <code>y</code> externe, ce qui signifie que nous pouvons utiliser le <code>y</code> externe dans
le contrÃ´le de correspondance. Au lieu de renseigner le motif comme Ã©tant
<code>Some(y)</code>, ce qui aurait masquÃ© le <code>y</code> externe, nous renseignons <code>Some(n)</code>.
Cela va crÃ©er une nouvelle variable <code>n</code> qui ne masque rien car il n'y a pas de
variable <code>n</code> Ã  l'extÃ©rieur du <code>match</code>.</p>
<!--
The match guard `if n == y` is not a pattern and therefore doesnâ€™t introduce
new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and
we can look for a value that has the same value as the outer `y` by comparing
`n` to `y`.
-->
<p>Le contrÃ´le de correspondance <code>if n == y</code> n'est pas un motif et donc il
n'introduit pas de nouvelle variable. Ce <code>y</code> <em>est</em> la variable externe <code>y</code> au
lieu d'Ãªtre une nouvelle variable masquÃ©e <code>y</code>, et nous pouvons comparer une
valeur qui a la mÃªme valeur que le <code>y</code> externe en comparant <code>n</code> Ã  <code>y</code>.</p>
<!--
You can also use the *or* operator `|` in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence of combining a match guard with a pattern that uses
`|`. The important part of this example is that the `if y` match guard applies
to `4`, `5`, *and* `6`, even though it might look like `if y` only applies to
`6`.
-->
<p>Vous pouvez aussi utiliser l'opÃ©rateur <em>ou</em> <code>|</code> dans un contrÃ´le de
correspondance pour y renseigner plusieurs motifsÂ ; la condition du contrÃ´le de
correspondance s'effectuera alors sur tous les motifs. L'encart 18-28 montre la
prioritÃ© de combinaison d'un contrÃ´le de correspondance sur un motif qui
utilise <code>|</code>. La partie importante de cet exemple est que le contrÃ´le de
correspondance <code>if y</code> s'applique sur <code>4</code>, <code>5</code>, <em>et</em> <code>6</code>, mÃªme si <code>if y</code> semble
s'appliquer uniquement Ã  <code>6</code>.</p>
<!--
```rust
# fn main() {
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span>
-->
<p><span class="caption">Encart 18-28Â : combinaison de plusieurs motifs avec un
contrÃ´le de correspondance</span></p>
<!--
The match condition states that the arm only matches if the value of `x` is
equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the
pattern of the first arm matches because `x` is `4`, but the match guard `if y`
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints `no`. The reason is that the `if`
condition applies to the whole pattern `4 | 5 | 6`, not only to the last value
`6`. In other words, the precedence of a match guard in relation to a pattern
behaves like this:
-->
<p>La condition de correspondance signifie que la branche correspond uniquement si
la valeur de <code>x</code> vaut <code>4</code>, <code>5</code>, ou <code>6</code> <em>et</em> que <code>y</code> vaut <code>true</code>. Lorsque ce
code s'exÃ©cute, le motif de la premiÃ¨re branche correspond car <code>x</code> vaut 4, mais
le contrÃ´le de correspondance <code>if y</code> est faux, donc ce programme affiche <code>no</code>.
La raison est que la condition <code>if</code> s'applique Ã  tout le motif <code>4 | 5 | 6</code>, et
pas seulement Ã  la derniÃ¨re valeur <code>6</code>. Autrement dit, la prioritÃ© d'un
contrÃ´le de correspondance avec un motif se comporte comme ceciÂ :</p>
<!--
```text
(4 | 5 | 6) if y => ...
```
-->
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<!--
rather than this:
-->
<p>plutÃ´t que comme ceciÂ :</p>
<!--
```text
4 | 5 | (6 if y) => ...
```
-->
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<!--
After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
`|` operator, the arm would have matched and the program would have printed
`yes`.
-->
<p>AprÃ¨s avoir exÃ©cutÃ© le code, le fonctionnement des prioritÃ©s devient Ã©videntÂ :
si le contrÃ´le de correspondance Ã©tait seulement appliquÃ© Ã  la derniÃ¨re valeur
renseignÃ©e avec l'opÃ©rateur <code>|</code>, la branche correspondrait et le programme
aurait affichÃ© <code>yes</code>.</p>
<!--
### `@` Bindings
-->
<h3><a class="header" href="#capturer-des-valeurs-avec-" id="capturer-des-valeurs-avec-">Capturer des valeurs avec <code>@</code></a></h3>
<!--
The *at* operator (`@`) lets us create a variable that holds a value at the
same time weâ€™re testing that value to see whether it matches a pattern. Listing
18-29 shows an example where we want to test that a `Message::Hello` `id` field
is within the range `3..=7`. But we also want to bind the value to the variable
`id_variable` so we can use it in the code associated with the arm. We could
name this variable `id`, the same as the field, but for this example weâ€™ll use
a different name.
-->
<p>L'opÃ©rateur <code>@</code> nous permet de crÃ©er une variable qui stocke une valeur en mÃªme
temps que nous testons cette valeur pour vÃ©rifier si elle correspond Ã  un
motif. L'encart 18-29 montre un exemple dans lequel nous souhaitons tester
qu'un champ <code>id</code> d'un <code>Message::Hello</code> est dans un intervalle <code>3..=7</code>. Mais
nous voulons aussi associer la valeur Ã  la variable <code>id_variable</code> pour que nous
puissions l'utiliser dans le code associÃ© Ã  la branche. Nous aurions pu nommer
cette variable avec le mÃªme nom que le champ <code>id</code>, mais pour cet exemple nous
allons utiliser un nom diffÃ©rent.</p>
<!--
```rust
# fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Nous avons trouvÃ© un id dans l'intervalleÂ : {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Nous avons trouvÃ© un id dans un autre intervalle&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Nous avons trouvÃ© un autre idÂ : {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-29: Using `@` to bind to a value in a pattern
while also testing it</span>
-->
<p><span class="caption">Encart 18-29Â : utilisation de <code>@</code> pour lier une valeur
d'un motif Ã  une variable pendant qu'on la teste</span></p>
<!--
This example will print `Found an id in range: 5`. By specifying `id_variable
@` before the range `3..=7`, weâ€™re capturing whatever value matched the range
while also testing that the value matched the range pattern.
-->
<p>Cet exemple va afficher <code>Nous avons trouvÃ© un id dans l'intervalleÂ : 5</code>. En
renseignant <code>id_variable @</code> avant l'intervalle <code>3..=7</code>, nous capturons la
valeur qui correspond Ã  l'intervalle pendant que nous vÃ©rifions que la valeur
correspond au motif de l'intervalle.</p>
<!--
In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesnâ€™t have a variable that contains the actual value
of the `id` field. The `id` fieldâ€™s value could have been 10, 11, or 12, but
the code that goes with that pattern doesnâ€™t know which it is. The pattern code
isnâ€™t able to use the value from the `id` field, because we havenâ€™t saved the
`id` value in a variable.
-->
<p>Dans la seconde branche, oÃ¹ nous avons uniquement un intervalle renseignÃ© dans
le motif, le code associÃ© Ã  la branche n'a pas besoin d'une variable qui
contient la valeur actuelle du champ <code>id</code>. La valeur du champ <code>id</code> aurait pu
Ãªtre 10, 11, ou 12, mais le code associÃ© Ã  ce motif ne saura pas quelle est sa
valeur. Le code du motif n'est pas capable d'utiliser la valeur du champ <code>id</code>,
car nous n'avons pas enregistrÃ© <code>id</code> dans une variable.</p>
<!--
In the last arm, where weâ€™ve specified a variable without a range, we do have
the value available to use in the armâ€™s code in a variable named `id`. The
reason is that weâ€™ve used the struct field shorthand syntax. But we havenâ€™t
applied any test to the value in the `id` field in this arm, as we did with the
first two arms: any value would match this pattern.
-->
<p>Dans la derniÃ¨re branche, nous avons renseignÃ© une variable sans intervalle,
nous avons la valeur qui peut Ãªtre utilisÃ©e dans le code de la branche, dans la
variable <code>id</code>. La raison Ã  cela est que nous avons utilisÃ© la syntaxe
raccourcie pour les champs des structures. Mais nous n'avons pas appliquÃ© de
tests Ã  la valeur sur le champ <code>id</code> de cette branche, comme nous l'avions fait
avec les deux premiÃ¨res branchesÂ : n'importe quelle valeur correspondra Ã  ce
motif.</p>
<!--
Using `@` lets us test a value and save it in a variable within one pattern.
-->
<p>L'utilisation de <code>@</code> nous permet de tester une valeur et de l'enregistrer dans
une variable au sein d'un seul et mÃªme motif.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-17" id="rÃ©sumÃ©-17">RÃ©sumÃ©</a></h2>
<!--
Rustâ€™s patterns are very useful in that they help distinguish between different
kinds of data. When used in `match` expressions, Rust ensures your patterns
cover every possible value, or your program wonâ€™t compile. Patterns in `let`
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.
-->
<p>Les motifs de Rust sont trÃ¨s utiles lorsque nous devons distinguer diffÃ©rents
types de donnÃ©es. Lorsque nous les avions utilisÃ©s dans les expressions
<code>match</code>, Rust s'est assurÃ© que vos motifs couvent l'intÃ©gralitÃ© de toutes
valeurs possibles, ou alors votre programme ne se compilait pas. Les motifs
dans les instructions <code>let</code> et les paramÃ¨tres de fonction rendre ces
constructions encore plus utiles, permettant de dÃ©structurer les valeurs en
parties plus petites tout en les assignant Ã  des variables. Nous pouvons crÃ©er
des motifs trÃ¨s simples ou alors plus complexes pour rÃ©pondre Ã  nos besoins.</p>
<!--
Next, for the penultimate chapter of the book, weâ€™ll look at some advanced
aspects of a variety of Rustâ€™s features.
-->
<p>Dans le chapitre suivant, qui sera l'avant-dernier du livre, nous allons
dÃ©couvrir quelques aspects avancÃ©s de l'Ã©ventail de fonctionnalitÃ©s de Rust.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--44" id="-attention-peinture-fraÃ®che--44">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/208">Pull Request</a>.</p>
</blockquote>
<!--
# Advanced Features
-->
<h1><a class="header" href="#les-fonctionnalitÃ©s-avancÃ©es" id="les-fonctionnalitÃ©s-avancÃ©es">Les fonctionnalitÃ©s avancÃ©es</a></h1>
<!--
By now, youâ€™ve learned the most commonly used parts of the Rust programming
language. Before we do one more project in Chapter 20, weâ€™ll look at a few
aspects of the language you might run into every once in a while. You can use
this chapter as a reference for when you encounter any unknowns when using
Rust. The features youâ€™ll learn to use in this chapter are useful in very
specific situations. Although you might not reach for them often, we want to
make sure you have a grasp of all the features Rust has to offer.
-->
<p>Jusqu'ici, vous avez appris les fonctionnalitÃ©s les plus utilisÃ©es du langage
de programmation Rust. Avant de commencer le nouveau projet du chapitre 20, nous
allons regarder quelques aspects du langage que vous pourriez rencontrer de
temps Ã  autre. Vous pouvez utiliser ce chapitre comme Ã©tant une rÃ©fÃ©rence
lorsque vous rencontrerez des Ã©lÃ©ments inconnus lorsque vous utiliserez Rust.
Les fonctionnalitÃ©s que vous allez dÃ©couvrir dans ce chapitre sont utiles dans
de nombreuses situations spÃ©cifiques. MÃªme si vous n'allez pas les rencontrer
trÃ¨s souvent, nous voulons nous assurer que vous comprenez bien toutes les
fonctionnalitÃ©s qu'offrent Rust.</p>
<!--
In this chapter, weâ€™ll cover:
-->
<p>Dans ce chapitre, nous allons voirÂ :</p>
<!--
* Unsafe Rust: how to opt out of some of Rustâ€™s guarantees and take
  responsibility for manually upholding those guarantees
* Advanced traits: associated types, default type parameters, fully qualified
  syntax, supertraits, and the newtype pattern in relation to traits
* Advanced types: more about the newtype pattern, type aliases, the never type,
  and dynamically sized types
* Advanced functions and closures: function pointers and returning closures
* Macros: ways to define code that defines more code at compile time
-->
<ul>
<li>Le <em>unsafe</em> de RustÂ : comment dÃ©sactiver certaines garanties de Rust et
prendre la responsabilitÃ© de veiller manuellement Ã  ces garanties</li>
<li>Les traits avancÃ©sÂ : les types associÃ©s, les types de paramÃ¨tres par dÃ©faut,
la syntaxe entiÃ¨rement dÃ©taillÃ©e, les supertraits, et le motif newtype en lien
avec les traits</li>
<li>Les types avancÃ©sÂ : en savoir plus sur le motif newtype, les alias de type, le
type never, et les types Ã  taille dynamique</li>
<li>Les fonctions et fermetures avancÃ©esÂ : les pointeurs de fonctions et retourner
des fermetures</li>
<li>Les macrosÂ : une maniÃ¨re de dÃ©finir du code qui Ã©crit encore plus de code au
moment de la compilation</li>
</ul>
<!--
Itâ€™s a panoply of Rust features with something for everyone! Letâ€™s dive in!
-->
<p>VoilÃ  une plÃ©thore de fonctionnalitÃ©s de Rust dans lesquelles chacun y trouvera
son compteÂ ! CommenÃ§ons tout de suiteÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--45" id="-attention-peinture-fraÃ®che--45">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/210">Pull Request</a>.</p>
</blockquote>
<!--
## Unsafe Rust
-->
<h2><a class="header" href="#le-rust-non-sÃ©curisÃ©-unsafe" id="le-rust-non-sÃ©curisÃ©-unsafe">Le Rust non sÃ©curisÃ© (<code>unsafe</code>)</a></h2>
<!--
All the code weâ€™ve discussed so far has had Rustâ€™s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesnâ€™t enforce these memory safety guarantees: itâ€™s called *unsafe Rust*
and works just like regular Rust, but gives us extra superpowers.
-->
<p>Tout le code Rust dont nous avons abordÃ© jusqu'Ã  prÃ©sent a bÃ©nÃ©ficiÃ© des
garanties de sÃ©curitÃ© de la mÃ©moire, vÃ©rifiÃ©es Ã  la compilation. Cependant, Rust
a un second langage cachÃ© en son sein qui n'appliquent pas ces vÃ©rifications
pour la sÃ©curitÃ© de la mÃ©moireÂ : il s'appelle le <em>Rust non sÃ©curisÃ©</em> et
fonctionne comme le Rust habituel, mais fournit quelques super-pouvoirs
supplÃ©mentaires.</p>
<!--
Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
itâ€™s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, itâ€™s not! In these cases, you can use unsafe code to tell the compiler,
â€œTrust me, I know what Iâ€™m doing.â€ The downside is that you use it at your own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.
-->
<p>Le Rust non sÃ©curisÃ© existe car, par nature, l'analyse statique est conservatif.
Lorsque le compilateur essaye de dÃ©terminer si le code respecte ou non les
garanties, il vaut mieux rejeter quelques programmes valides plutÃ´t que
d'accepter quelques programmes invalides. Bien que le code puisse Ãªtre correct,
dÃ¨s que Rust n'est pas capable de le comprendre, il ne l'est plusÂ ! Dans ce cas,
vous pouvez utiliser du code non sÃ©curisÃ© pour dire au compilateur â€œfais-moi
confiance, je sais ce que je faitâ€. La contrepartie pour cela est que vous
l'utilisez Ã  vos risques et pÃ©rilsÂ : si vous Ã©crivez du code non sÃ©curisÃ© de
maniÃ¨re incorrecte, des problÃ¨mes liÃ©s Ã  la sÃ©curitÃ© de la mÃ©moire peuvent se
produire, comme le dÃ©rÃ©fÃ©rencement d'un pointeur vide par exemple.</p>
<!--
Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didnâ€™t let you do unsafe operations, you
couldnâ€™t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Letâ€™s explore what we can do with unsafe
Rust and how to do it.
-->
<p>Une autre raison pour laquelle Rust embarque son alter-ego non sÃ©curisÃ© est que
le matÃ©riel des ordinateurs sur lequel il repose n'est pas sÃ©curisÃ© par essence.
Si Rust ne vous laisse pas procÃ©der Ã  des opÃ©rations non sÃ©curisÃ©es, vous ne
pourrez pas faire certaines choses. Rust doit pouvoir vous permettre de
dÃ©velopper du code bas-niveau, comme pouvoir interagir directement avec le
systÃ¨me d'exploitation ou mÃªme Ã©crire votre propre systÃ¨me d'exploitation.
Pouvoir travailler avec des systÃ¨mes bas-niveau est un des objectifs du langage.
Voyons ce que nous pouvons faire avec le Rust non sÃ©curisÃ© et comment le faire.</p>
<!--
### Unsafe Superpowers
-->
<h3><a class="header" href="#les-super-pouvoirs-du-code-non-sÃ©curisÃ©" id="les-super-pouvoirs-du-code-non-sÃ©curisÃ©">Les super-pouvoirs du code non sÃ©curisÃ©</a></h3>
<!--
To switch to unsafe Rust, use the `unsafe` keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust, called
*unsafe superpowers*, that you canâ€™t in safe Rust. Those superpowers include
the ability to:
-->
<p>Pour pouvoir utiliser le Rust non sÃ©curisÃ©, il faut utiliser le mot-clÃ© <code>unsafe</code>
et ensuite crÃ©er un nouveau bloc qui contient le code non sÃ©curisÃ©. Vous pouvez
faire cinq actions en Rust non sÃ©curisÃ©, qui s'appellent <em>les super-pouvoirs du
non sÃ©curisÃ©</em>, que vous ne pouvez pas faire en Rust sÃ©curisÃ©. Ces super-pouvoirs
permettent deÂ :</p>
<!--
* Dereference a raw pointer
* Call an unsafe function or method
* Access or modify a mutable static variable
* Implement an unsafe trait
* Access fields of `union`s
-->
<ul>
<li>DÃ©rÃ©fÃ©rencer un pointeur brut</li>
<li>Faire appel Ã  une fonction ou une mÃ©thode non sÃ©curisÃ©e</li>
<li>Lire ou modifier une variable statique mutable</li>
<li>ImplÃ©menter un trait non sÃ©curisÃ©</li>
<li>AccÃ©der aux champs des <code>union</code></li>
</ul>
<!--
Itâ€™s important to understand that `unsafe` doesnâ€™t turn off the borrow checker
or disable any other of Rustâ€™s safety checks: if you use a reference in unsafe
code, it will still be checked. The `unsafe` keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. Youâ€™ll still get some degree of safety inside of an unsafe block.
-->
<p>Il est important de comprendre que <code>unsafe</code> ne dÃ©sactive pas le vÃ©rificateur
d'emprunt et ne dÃ©sactive pas les autres vÃ©rifications de sÃ©curitÃ© de RustÂ : si
vous utilisez une rÃ©fÃ©rence dans du code non sÃ©curisÃ©, elle sera toujours
vÃ©rifiÃ©e. Le mot-clÃ© <code>unsafe</code> vous donne seulement accÃ¨s Ã  ces cinq
fonctionnalitÃ©s qui ne sont alors pas vÃ©rifiÃ©es par le compilateur pour veiller
Ã  la sÃ©curitÃ© de la mÃ©moire. Vous conservez un certain niveau de sÃ©curitÃ© Ã 
l'intÃ©rieur d'un bloc <code>unsafe</code>.</p>
<!--
In addition, `unsafe` does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, youâ€™ll ensure the code inside an `unsafe` block will
access memory in a valid way.
-->
<p>De plus, <code>unsafe</code> ne signifie pas que le code Ã  l'intÃ©rieur du bloc est
obligatoirement dangereux ou qu'il va forcÃ©ment avoir des problÃ¨mes de sÃ©curitÃ©
mÃ©moireÂ : le but Ã©tant qu'en tant que dÃ©veloppeur, vous vous assurez que le code
Ã  l'intÃ©rieur d'un bloc <code>unsafe</code> va accÃ©der correctement Ã  la mÃ©moire.</p>
<!--
People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with `unsafe` youâ€™ll know that
any errors related to memory safety must be within an `unsafe` block. Keep
`unsafe` blocks small; youâ€™ll be thankful later when you investigate memory
bugs.
-->
<p>Personne n'est parfait, les erreurs arrivent, et en nÃ©cessitant que ces cinq
opÃ©rations non sÃ©curisÃ©s se trouvent dans des blocs marquÃ©s d'un <code>unsafe</code>, vous
saurez que des erreurs liÃ©es Ã  la sÃ©curitÃ© de la mÃ©moire se trouveront dans un
bloc <code>unsafe</code>. Essayez de minimiser la taille des blocs <code>unsafe</code>Â ; vous ne le
regretterez pas lorsque vous diagnostiquerez des bogues de mÃ©moire.</p>
<!--
To isolate unsafe code as much as possible, itâ€™s best to enclose unsafe code
within a safe abstraction and provide a safe API, which weâ€™ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`
from leaking out into all the places that you or your users might want to use
the functionality implemented with `unsafe` code, because using a safe
abstraction is safe.
-->
<p>Pour isoler autant que possible le code non sÃ©curisÃ©, il vaut mieux intÃ©grer du
code non sÃ©curisÃ© dans une abstraction et fournir ainsi une API sÃ©curisÃ©e, ce
que nous verrons plus tard dans ce chapitre lorsque nous examinerons les
fonctions et mÃ©thodes non sÃ©curisÃ©es. Certaines parties de la bibliothÃ¨que
standard sont implÃ©mentÃ©s comme Ã©tant des abstractions sÃ©curisÃ©es et basÃ©es sur
du code non sÃ©curisÃ© qui a Ã©tÃ© auditÃ©. Envelopper du code non sÃ©curisÃ© dans une
abstraction sÃ©curisÃ©e Ã©vite l'utilisation de <code>unsafe</code> de se propager dans des
endroits oÃ¹ vous ou vos utilisateurs souhaiteraient Ã©viter d'utiliser les
fonctionnalitÃ©s du code <code>unsafe</code>, car utiliser une abstraction sÃ©curisÃ©e doit
Ãªtre sÃ»re.</p>
<!--
Letâ€™s look at each of the five unsafe superpowers in turn. Weâ€™ll also look at
some abstractions that provide a safe interface to unsafe code.
-->
<p>Analysons chacun Ã  leur tour les cinq super-pouvoirs. Nous allons aussi
dÃ©couvrir quelques abstractions qui fournissent une interface sÃ©curisÃ©e pour
faire fonctionner du code non sÃ©curisÃ©.</p>
<!--
### Dereferencing a Raw Pointer
-->
<h3><a class="header" href="#dÃ©rÃ©fÃ©rencer-un-pointeur-brut" id="dÃ©rÃ©fÃ©rencer-un-pointeur-brut">DÃ©rÃ©fÃ©rencer un pointeur brut</a></h3>
<!--
In Chapter 4, in the [â€œDangling Referencesâ€][dangling-references]<!-- ignore
-- > section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called *raw pointers* that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as `*const T` and `*mut T`, respectively. The asterisk isnâ€™t the
dereference operator; itâ€™s part of the type name. In the context of raw
pointers, *immutable* means that the pointer canâ€™t be directly assigned to
after being dereferenced.
-->
<p>Au chapitre 4, dans la section
<a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-pendouillantes">â€œLes rÃ©fÃ©rences pendouillantesâ€</a><!-- ignore -->, nous
avions mentionnÃ© que le compilateur s'assure que les rÃ©fÃ©rences sont toujours
valides. Le Rust non sÃ©curisÃ© a deux nouveaux types qui s'appellent les
<em>pointeurs brut</em> qui ressemblent aux rÃ©fÃ©rences. Comme les rÃ©fÃ©rences, les
pointeurs bruts peuvent Ãªtre immuables ou mutables et s'Ã©crivent respectivement
<code>*const T</code> et <code>*mut T</code>. L'astÃ©risque n'est pas l'opÃ©rateur de dÃ©rÃ©fÃ©rencementÂ ;
il fait partie du nom du type. Dans un contexte de pointeur brut, <em>immuable</em>
signifie que le pointeur ne peut pas Ãªtre affectÃ© directement aprÃ¨s avoir Ã©tÃ©
dÃ©rÃ©fÃ©rencÃ©.</p>
<!--
Different from references and smart pointers, raw pointers:
-->
<p>Par rapport aux rÃ©fÃ©rences et les pointeurs intelligents, les pointeurs
bruts peuventÂ :</p>
<!--
* Are allowed to ignore the borrowing rules by having both immutable and
  mutable pointers or multiple mutable pointers to the same location
* Arenâ€™t guaranteed to point to valid memory
* Are allowed to be null
* Donâ€™t implement any automatic cleanup
-->
<ul>
<li>ignorer les rÃ¨gles d'emprunt en ayant plusieurs pointeurs tant immuables que
mutables ou en ayant plusieurs pointeurs mutables qui pointent vers le mÃªme
endroit.</li>
<li>ne pas Ãªtre obligÃ© de pointer sur un emplacement mÃ©moire valide</li>
<li>Ãªtre autorisÃ© Ã  avoir la valeur nulle</li>
<li>ne pas implÃ©menter de fonctionnalitÃ© de nettoyage automatique</li>
</ul>
<!--
By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rustâ€™s guarantees donâ€™t apply.
-->
<p>En renonÃ§ant Ã  ce que Rust fasse respecter ces garanties, vous pouvez sacrifier
la sÃ©curitÃ© garantie pour obtenir de meilleures performances ou avoir la
possibilitÃ© de vous interfacer avec un autre langage ou matÃ©riel pour lesquels
les garanties de Rust ne s'appliquent pas.</p>
<!--
Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.
-->
<p>L'encart 19-1 montre comment crÃ©er un pointeur brut immuable et mutable Ã  partir
de rÃ©fÃ©rences.</p>
<!--
```rust
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-1: Creating raw pointers from references</span>
-->
<p><span class="caption">Encart 19-1Â : crÃ©ation de pointeurs bruts Ã  partir de
rÃ©fÃ©rences</span></p>
<!--
Notice that we donâ€™t include the `unsafe` keyword in this code. We can create
raw pointers in safe code; we just canâ€™t dereference raw pointers outside an
unsafe block, as youâ€™ll see in a bit.
-->
<p>Remarquez que nous n'incorporons pas le mot-clÃ© <code>unsafe</code> dans ce code. Nous
pouvons crÃ©er des pointeurs bruts dans du code sÃ©curisÃ©Â ; nous ne pouvons
simplement pas dÃ©rÃ©fÃ©rencer les pointeurs bruts Ã  l'extÃ©rieur d'un bloc non
sÃ©curisÃ©, comme vous allez le constater d'ici peu.</p>
<!--
Weâ€™ve created raw pointers by using `as` to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we canâ€™t make that assumption about just any raw
pointer.
-->
<p>Nous avons crÃ©Ã© des pointeurs bruts en utilisant <code>as</code> pour transformer les
rÃ©fÃ©rences immuables et mutables en leur type de pointeur brut correspondant.
Comme nous les avons crÃ©Ã©s directement Ã  partir de rÃ©fÃ©rences qui sont garanties
d'Ãªtre valides, nous savons que ces pointeurs bruts seront valides, mais nous ne
pouvons pas faire cette dÃ©duction sur tous les pointeurs bruts.</p>
<!--
Next, weâ€™ll create a raw pointer whose validity we canâ€™t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.
-->
<p>Ensuite, nous allons crÃ©er un pointeur brut dont la validitÃ© n'est pas
certaine. L'encart 19-2 montre comment crÃ©er un pointeur brut vers un
emplacement arbitraire de la mÃ©moire. Essayer d'utiliser de la mÃ©moire
arbitraire est incertainÂ : il peut y avoir des donnÃ©es Ã  cette adresse, ou il
peut ne pas y en avoir, le programme peut dÃ©boucher sur une erreur de
segmentation. Habituellement, il n'y a pas de bonne raison d'Ã©crire du code
comme celui-ci, mais c'est possible.</p>
<!--
```rust
# fn main() {
    let address = 0x012345usize;
    let r = address as *const i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let addresse = 0x012345usize;
    let r = addresse as *const i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span>
-->
<p><span class="caption">Encart 19-2Â : crÃ©ation d'un pointeur brut vers une
adresse mÃ©moire arbitraire</span></p>
<!--
Recall that we can create raw pointers in safe code, but we canâ€™t *dereference*
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator `*` on a raw pointer that requires an `unsafe` block.
-->
<p>Souvenez-vous que nous pouvons crÃ©er des pointeurs bruts dans du code sÃ©curisÃ©,
mais que nous ne pouvons pas y <em>dÃ©rÃ©fÃ©rencer</em> les pointeurs bruts et lire les
donnÃ©es sur lesquelles ils pointent. Dans l'encart 19-3, nous utilisons
l'opÃ©rateur de dÃ©rÃ©fÃ©rencement <code>*</code> sur un pointeur brut qui nÃ©cessite un bloc
<code>unsafe</code>.</p>
<!--
```rust,unsafe
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;

    unsafe {
        println!(&quot;r1 vautÂ : {}&quot;, *r1);
        println!(&quot;r2 vautÂ : {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-3: Dereferencing raw pointers within an
`unsafe` block</span>
-->
<p><span class="caption">Encart 19-3Â : dÃ©rÃ©fÃ©rencement d'un pointeur brut Ã 
l'intÃ©rieur d'un bloc <code>unsafe</code></span></p>
<!--
Creating a pointer does no harm; itâ€™s only when we try to access the value that
it points at that we might end up dealing with an invalid value.
-->
<p>La crÃ©ation de pointeur ne pose pas de problÃ¨mesÂ ; c'est seulement lorsque nous
essayons d'accÃ©der aux valeurs sur lesquelles elles pointent qu'on risque
d'obtenir une valeur invalide.</p>
<!--
Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`
raw pointers that both pointed to the same memory location, where `num` is
stored. If we instead tried to create an immutable and a mutable reference to
`num`, the code would not have compiled because Rustâ€™s ownership rules donâ€™t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!
-->
<p>Remarquez aussi que dans les encarts 19-1 et 19-3, nous avons crÃ©Ã© les
pointeurs bruts <code>*const i32</code> et <code>*mut i32</code> qui pointent tous les deux au mÃªme
endroit de la mÃ©moire, oÃ¹ <code>nombre</code> est stockÃ©. Si nous avions plutÃ´t tentÃ© de
crÃ©er une rÃ©fÃ©rence immuable et une mutable vers <code>nombre</code>, le code n'aurait pas
compilÃ© Ã  cause des rÃ¨gles de possession de Rust qui ne permettent pas d'avoir
une rÃ©fÃ©rence mutable en mÃªme temps qu'une ou plusieurs rÃ©fÃ©rences immuables.
Avec les pointeurs bruts, nous pouvons crÃ©er un pointeur mutable et un pointeur
immuable vers le mÃªme endroit et changer la donnÃ©e via le pointeur mutable, en
risquant un accÃ¨s concurrent. Soyez vigilantÂ !</p>
<!--
With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as youâ€™ll see in the next section,
[â€œCalling an Unsafe Function or
Method.â€](#calling-an-unsafe-function-or-method)<!-- ignore -- > Another case is
when building up safe abstractions that the borrow checker doesnâ€™t understand.
Weâ€™ll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.
-->
<p>Avec tous ces dangers, pourquoi vous risquer Ã  utiliser les pointeurs brutsÂ ?
Une des utilisations majeures et lorsque nous nous interfacons avec du code
C, comme vous allez le dÃ©couvrir dans la section suivante. Une autre
utilisation est lorsque nous crÃ©ons une abstraction sÃ©curisÃ©e qui le
vÃ©rificateur d'emprunt ne comprends pas. Nous allons dÃ©couvrir les fonctions
non sÃ©curisÃ©es et ensuite voir un exemple d'une abstraction sÃ©curisÃ©e qui
utilise du code non sÃ©curisÃ©.</p>
<!--
### Calling an Unsafe Function or Method
-->
<h3><a class="header" href="#faire-appel-Ã -une-fonction-ou-une-mÃ©thode-non-sÃ©curisÃ©e" id="faire-appel-Ã -une-fonction-ou-une-mÃ©thode-non-sÃ©curisÃ©e">Faire appel Ã  une fonction ou une mÃ©thode non sÃ©curisÃ©e</a></h3>
<!--
The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra `unsafe` before the rest of the definition. The
`unsafe` keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust canâ€™t guarantee weâ€™ve
met these requirements. By calling an unsafe function within an `unsafe` block,
weâ€™re saying that weâ€™ve read this functionâ€™s documentation and take
responsibility for upholding the functionâ€™s contracts.
-->
<p>Le second type d'opÃ©ration qui nÃ©cessite un bloc <code>unsafe</code> est l'appel Ã  des
fonctions non sÃ©curisÃ©es. Les fonctions et mÃ©thodes non sÃ©curisÃ©es ressemblent
exactement pareil que les mÃ©thodes et fonctions habituelles, mais ont un
<code>unsafe</code> en plus devant le reste de leur dÃ©finition. Le mot-clÃ© <code>unsafe</code> dans
ce cas signifie que la fonction a des exigences Ã  respecter pour pouvoir y
faire appel, car Rust ne peut pas garantir que nous avons rempli ces exigences.
En faisant appel Ã  une fonction non sÃ©curisÃ©e dans un bloc <code>unsafe</code>, nous
signalons que nous avons lu la documentation de cette fonction et pris la
responsabilitÃ© de respecter les conditions d'utilisation de la fonction.</p>
<!--
Here is an unsafe function named `dangerous` that doesnâ€™t do anything in its
body:
-->
<p>Voici une fonction non sÃ©curisÃ©e <code>dangereux</code>, qui ne fait rien dans son corpsÂ :</p>
<!--
```rust,unsafe
# fn main() {
    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    unsafe fn dangereux() {}

    unsafe {
        dangereux();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
We must call the `dangerous` function within a separate `unsafe` block. If we
try to call `dangerous` without the `unsafe` block, weâ€™ll get an error:
-->
<p>Nous devons faire appel Ã  la fonction <code>dangereux</code> dans un bloc <code>unsafe</code> sÃ©parÃ©.
Si nous essayons d'appeler <code>dangereux</code> sans le bloc <code>unsafe</code>, nous obtenons une
erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 -- > src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangereux();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
By inserting the `unsafe` block around our call to `dangerous`, weâ€™re asserting
to Rust that weâ€™ve read the functionâ€™s documentation, we understand how to use
it properly, and weâ€™ve verified that weâ€™re fulfilling the contract of the
function.
-->
<p>En ajoutant le bloc <code>unsafe</code> autour de notre appel Ã  <code>dangereux</code>, nous
signalons Ã  Rust que nous avons lu la documentation de la fonction, que nous
comprenons comment l'utiliser correctement, et que nous avons vÃ©rifiÃ© que nous
rÃ©pondons bien aux exigences de la fonction.</p>
<!--
Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other
unsafe operations within an unsafe function, we donâ€™t need to add another
`unsafe` block.
-->
<p>Les corps des fonctions non sÃ©curisÃ©es sont bien des blocs <code>unsafe</code>, donc pour
pouvoir procÃ©der Ã  d'autres opÃ©rations non sÃ©curisÃ©es dans une fonction non
sÃ©curisÃ©e, nous n'avons pas besoin d'ajouter un autre bloc <code>unsafe</code>.</p>
<!--
#### Creating a Safe Abstraction over Unsafe Code
-->
<h4><a class="header" href="#crÃ©er-une-abstraction-sÃ©curisÃ©e-sur-du-code-non-sÃ©curisÃ©" id="crÃ©er-une-abstraction-sÃ©curisÃ©e-sur-du-code-non-sÃ©curisÃ©">CrÃ©er une abstraction sÃ©curisÃ©e sur du code non sÃ©curisÃ©</a></h4>
<!--
Just because a function contains unsafe code doesnâ€™t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, letâ€™s study a function from the standard
library, `split_at_mut`, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use `split_at_mut`.
-->
<p>Ce n'est pas parce qu'une fonction contient du code non sÃ©curisÃ© que nous devons
forcÃ©ment marquer l'intÃ©gralitÃ© de cette fonction comme non sÃ©curisÃ©e. En fait,
envelopper du code non sÃ©curisÃ© dans une fonction sÃ©curisÃ©e est une abstraction
courante. Par exemple, Ã©tudions une fonction de la bibliothÃ¨que standard,
<code>split_at_mut</code>, qui nÃ©cessite du code non sÃ©curisÃ©, et Ã©tudions comment nous
devrions l'implÃ©menter. Cette mÃ©thode sÃ©curisÃ©e est dÃ©finie sur des slices
mutablesÂ : elle prend une slice en paramÃ¨tre et en crÃ©Ã©e deux autres en divisant
la slice Ã  l'indice donnÃ© en argument. L'encart 19-4 montre comment utiliser
<code>split_at_mut</code>.</p>
<!--
```rust
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-4: Using the safe `split_at_mut`
function</span>
-->
<p><span class="caption">Encart 19-4Â : utilisation de la fonction sÃ©curisÃ©e
<code>split_at_mut</code></span></p>
<!--
We canâ€™t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which wonâ€™t compile. For simplicity, weâ€™ll
implement `split_at_mut` as a function rather than a method and only for slices
of `i32` values rather than for a generic type `T`.
-->
<p>Nous ne pouvons pas implÃ©menter cette fonction en utilisant uniquement du Rust
sÃ©curisÃ©. Une tentative en ce sens ressemblerait Ã  l'encart 19-5, qui ne se
compilera pas. Par simplicitÃ©, nous allons implÃ©menter <code>split_at_mut</code> comme une
fonction plutÃ´t qu'une mÃ©thode et seulement pour des slices de valeurs <code>i32</code> au
lieu d'un type gÃ©nÃ©rique <code>T</code>.</p>
<!--
```rust,ignore,does_not_compile
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid], &mut slice[mid..])
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid], &amp;mut slice[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-5: An attempted implementation of
`split_at_mut` using only safe Rust</span>
-->
<p><span class="caption">Encart 19-5Â : une tentative d'implÃ©mentation de
<code>split_at_mut</code> en utilisant uniquement du Rust sÃ©curisÃ©</span></p>
<!--
This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether itâ€™s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.
-->
<p>Cette fonction commence par obtenir la longueur totale de la slice. Elle
vÃ©rifie ensuite que l'indice donnÃ© en paramÃ¨tre est bien Ã  l'intÃ©rieur de la
slice en vÃ©rifiant s'il est infÃ©rieur ou Ã©gal Ã  la longueur. La vÃ©rification
implique que si nous envoyons un indice qui est plus grand que la longueur de
la slice Ã  dÃ©couper, la fonction va paniquer avant d'essayer d'utiliser cet
indice.</p>
<!--
Then we return two mutable slices in a tuple: one from the start of the
original slice to the `mid` index and another from `mid` to the end of the
slice.
-->
<p>Ensuite, nous retournons deux slices mutables dans un tupleÂ : une Ã  partir du
dÃ©but de la slice initiale jusqu'Ã  l'indice <code>mod</code> et une autre Ã  partir de
l'indice jusqu'Ã  la fin de la slice.</p>
<!--
When we try to compile the code in Listing 19-5, weâ€™ll get an error.
-->
<p>Lorsque nous essayons de compiler le code de l'encart 19-5, nous allons obtenir
une erreur.</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 -- > src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&mut slice[..mid], &mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut slice[..mid], &amp;mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rustâ€™s borrow checker canâ€™t understand that weâ€™re borrowing different parts of
the slice; it only knows that weâ€™re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices arenâ€™t overlapping, but Rust isnâ€™t smart enough to know this. When we
know code is okay, but Rust doesnâ€™t, itâ€™s time to reach for unsafe code.
-->
<p>Le vÃ©rificateur d'emprunt de Rust ne comprend pas que nous empruntons
diffÃ©rentes parties de la sliceÂ ; il comprend seulement que nous empruntons la
mÃªme slice Ã  deux reprises. L'emprunt de diffÃ©rentes parties d'une slice ne
pose fondamentalement pas de problÃ¨mes car les deux slices ne se chevauchent
pas, mais Rust n'est pas suffisamment intelligent pour comprendre ceci. Lorsque
nous savons que ce code est correct, mais que Rust ne le sait pas, il est
appropriÃ© d'utiliser du code non sÃ©curisÃ©.</p>
<!--
Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls
to unsafe functions to make the implementation of `split_at_mut` work.
-->
<p>L'encart 19-6 montre comment utiliser un bloc <code>unsafe</code>, un pointeur brut, et
quelques appels Ã  des fonctions non sÃ©curisÃ©es pour construire une
implÃ©mentation de <code>split_at_mut</code> qui fonctionne.</p>
<!--
```rust,unsafe
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-6: Using unsafe code in the implementation of
the `split_at_mut` function</span>
-->
<p><span class="caption">Encart 19-6Â : utilisation de code non sÃ©curisÃ© dans
l'implÃ©mentation de la fonction <code>split_at_mut</code></span></p>
<!--
Recall from [â€œThe Slice Typeâ€][the-slice-type]<!-- ignore -- > section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the `len` method to get the length of a slice and the `as_mut_ptr`
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the type
`*mut i32`, which weâ€™ve stored in the variable `ptr`.
-->
<p>Souvenez-vous de la section <a href="ch04-03-slices.html#le-type-slice">â€œLe type sliceâ€</a><!-- ignore --> du
chapitre 4 dans laquelle nous avions dit qu'un slice est dÃ©fini par un pointeur
vers une donnÃ©e ainsi qu'une longueur de la slice. Nous avons utilisÃ© la mÃ©thode
<code>len</code> pour obtenir la longueur d'une slice ainsi que la mÃ©thode <code>as_mut_ptr</code>
pour accÃ©der au pointeur brut d'une slice. Dans ce cas, comme nous avons une
slice mutable de valeurs <code>i32</code>, <code>as_mut_ptr</code> retourne un pointeur brut avec le
type <code>*mut i32</code>, que nous avons stockÃ© dans la variable <code>ptr</code>.</p>
<!--
We keep the assertion that the `mid` index is within the slice. Then we get to
the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from `ptr` and is `mid` items long. Then we call the `add`
method on `ptr` with `mid` as an argument to get a raw pointer that starts at
`mid`, and we create a slice using that pointer and the remaining number of
items after `mid` as the length.
-->
<p>Nous avons conservÃ© la vÃ©rification que l'indice <code>mid</code> soit dans la slice.
Ensuite, nous utilisons le code non sÃ©curisÃ©Â : la fonction
<code>slice::from_raw_parts_mut</code> prend en paramÃ¨tre un pointeur brut et une longueur,
et elle crÃ©Ã©e une slice. Nous utilisons cette fonction pour crÃ©er une slice qui
dÃ©bute Ã  <code>ptr</code> et qui est long de <code>mid</code> Ã©lÃ©ments. Ensuite nous faisons appel Ã 
la mÃ©thode <code>add</code> sur <code>ptr</code> avec <code>mid</code> en argument pour obtenir un pointeur
brut qui dÃ©marre Ã  <code>mid</code>, et nous crÃ©ons une slice qui utilise ce pointeur et
le nombre restant d'Ã©lÃ©ments aprÃ¨s <code>mid</code> pour la longueur.</p>
<!--
The function `slice::from_raw_parts_mut` is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The `add` method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an `unsafe` block around our calls to
`slice::from_raw_parts_mut` and `add` so we could call them. By looking at
the code and by adding the assertion that `mid` must be less than or equal to
`len`, we can tell that all the raw pointers used within the `unsafe` block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of `unsafe`.
-->
<p>La fonction <code>slice::from_raw_parts_mut</code> est non sÃ©curisÃ© car elle prend en
argument un pointeur brut et doit avoir confiance en la validitÃ© de ce pointeur.
La mÃ©thode <code>add</code> sur les pointeurs bruts est aussi non sÃ©curisÃ©e, car elle
doit croire que l'emplacement dÃ©calÃ© est aussi un pointeur valide. VoilÃ 
pourquoi nous avons placÃ© un bloc <code>unsafe</code> autour de nos appels Ã 
<code>slice::from_raw_parts_mut</code> et <code>add</code> afin que nous puissions les appeler. En
analysant le code et en ayant ajoutÃ© la vÃ©rification que <code>mid</code> doit Ãªtre
infÃ©rieur ou Ã©gal Ã  <code>len</code>, nous pouvons affirmer que tous les pointeurs bruts
utilisÃ©s dans le bloc <code>unsafe</code> sont des pointeurs valides vers les donnÃ©es de la
slice. C'est une utilisation acceptable et appropriÃ©e de <code>unsafe</code>.</p>
<!--
Note that we donâ€™t need to mark the resulting `split_at_mut` function as
`unsafe`, and we can call this function from safe Rust. Weâ€™ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
`unsafe` code in a safe way, because it creates only valid pointers from the
data this function has access to.
-->
<p>Remarquez que nous n'avons pas eu besoin de marquer la fonction rÃ©sultante
<code>split_at_mut</code> comme Ã©tant <code>unsafe</code>, et que nous pouvons faire appel Ã  cette
fonction dans du code Rust sÃ©curisÃ©. Nous avons crÃ©Ã© une abstraction sÃ©curisÃ©e
du code non sÃ©curisÃ© avec une implÃ©mentation de la fonction qui utilise de
maniÃ¨re sÃ©curisÃ©e du code non sÃ©curisÃ©, car elle crÃ©Ã©e uniquement des pointeurs
valides Ã  partir des donnÃ©es dont cette fonction a accÃ¨s.</p>
<!--
In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.
-->
<p>En contre-partie, l'utilisation de <code>slice::from_raw_parts_mut</code> dans l'encart
19-7 peut planter lorsque la slice sera utilisÃ©e. Ce code prend un emplacement
arbitraire dans la mÃ©moire et crÃ©e un slice de 10 000 Ã©lÃ©ments.</p>
<!--
```rust,unsafe
# fn main() {
    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let slice: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    use std::slice;

    let addresse = 0x01234usize;
    let r = addresse as *mut i32;

    let slice: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span>
-->
<p><span class="caption">Encart 19-7Â : crÃ©ation d'une slice Ã  partir d'un
emplacement mÃ©moire arbitraire</span></p>
<!--
We donâ€™t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid `i32` values. Attempting to use
`slice` as though itâ€™s a valid slice results in undefined behavior.
-->
<p>Nous ne possÃ©dons par la mÃ©moire Ã  cet emplacement arbitraire, et il n'y a
aucune garantie que la slice crÃ©Ã©e par ce code contient des valeurs <code>i32</code>
valides. La tentative d'utilisation <code>slice</code> sera soumis Ã  un comportement
imprÃ©visible mÃªme si elle est une slice valide.</p>
<!--
#### Using `extern` Functions to Call External Code
-->
<h4><a class="header" href="#utiliser-des-fonctions-extern-pour-faire-appel-Ã -du-code-externe" id="utiliser-des-fonctions-extern-pour-faire-appel-Ã -du-code-externe">Utiliser des fonctions <code>extern</code> pour faire appel Ã  du code externe</a></h4>
<!--
Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, `extern`, that facilitates the creation
and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.
-->
<p>Parfois, votre code Rust peut avoir besoin d'interagir avec du code Ã©crit dans
d'autres langages. Dans ce cas, Rust propose un mot-clÃ©, <code>extern</code>, qui facilite
la crÃ©ation et l'utilisation du <em>Foreign Function Interface (FFI)</em>. Le FFI est
un outil permettant Ã  un langage de programmation de dÃ©finir des fonctions et
permettre Ã  diffÃ©rents langages de programmation de faire appel Ã  ces
fonctions.</p>
<!--
Listing 19-8 demonstrates how to set up an integration with the `abs` function
from the C standard library. Functions declared within `extern` blocks are
always unsafe to call from Rust code. The reason is that other languages donâ€™t
enforce Rustâ€™s rules and guarantees, and Rust canâ€™t check them, so
responsibility falls on the programmer to ensure safety.
-->
<p>L'encart 19-8 montre comment rÃ©gler l'intÃ©gration avec la fonction <code>abs</code> de la
bibliothÃ¨que standard du C. Les fonctions dÃ©clarÃ©es dans les blocs <code>extern</code>
sont toujours non sÃ©curisÃ©s lorsqu'on les utilise dans du code Rust. La raison
Ã  cela est que les autres langages n'appliquent pas les rÃ¨gles et garanties de
Rust, et Rust ne peut pas les vÃ©rifier, donc la responsabilitÃ© de les utiliser
en toute sÃ©curitÃ© revient au dÃ©veloppeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,unsafe
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage CÂ : {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage CÂ : {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-8: Declaring and calling an `extern` function
defined in another language</span>
-->
<p><span class="caption">Encart 19-8Â : dÃ©claration et appel Ã  une fonction externe
qui est dÃ©finie dans un autre langage</span></p>
<!--
Within the `extern "C"` block, we list the names and signatures of external
functions from another language we want to call. The `"C"` part defines which
*application binary interface (ABI)* the external function uses: the ABI
defines how to call the function at the assembly level. The `"C"` ABI is the
most common and follows the C programming languageâ€™s ABI.
-->
<p>Au sein du bloc <code>extern &quot;C&quot;</code>, nous listons les noms et les signatures des
fonctions externes de l'autre langage que nous souhaitons solliciter. La partie
&quot;C&quot; dÃ©finit quelle est l'<em>application binary interface (ABI)</em> que la fonction
doit utiliserÂ : l'ABI dÃ©finit comment faire appel Ã  la fonction au niveau
assembleur. L'ABI <code>&quot;C&quot;</code> est la plus courante et respecte l'ABI du langage de
programmation C.</p>
<!--
> #### Calling Rust Functions from Other Languages
>
> We can also use `extern` to create an interface that allows other languages
> to call Rust functions. Instead of an `extern` block, we add the `extern`
> keyword and specify the ABI to use just before the `fn` keyword. We also need
> to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle
> the name of this function. *Mangling* is when a compiler changes the name
> weâ€™ve given a function to a different name that contains more information for
> other parts of the compilation process to consume but is less human readable.
> Every programming language compiler mangles names slightly differently, so
> for a Rust function to be nameable by other languages, we must disable the
> Rust compilerâ€™s name mangling.
>
> In the following example, we make the `call_from_c` function accessible from
> C code, after itâ€™s compiled to a shared library and linked from C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> This usage of `extern` does not require `unsafe`.
-->
<blockquote>
<h4><a class="header" href="#faire-appel-Ã -des-fonctions-rust-dans-dautres-langages" id="faire-appel-Ã -des-fonctions-rust-dans-dautres-langages">Faire appel Ã  des fonctions Rust dans d'autres langages</a></h4>
<p>Nous pouvons aussi utiliser <code>extern</code> pour crÃ©er une interface qui permet Ã 
d'autres langages de faire appel Ã  des fonctions Rust. Au lieu d'avoir un
bloc <code>extern</code>, nous ajoutons le mot-clÃ© <code>extern</code> et nous renseignons l'ABI
Ã  utiliser juste avant le mot-clÃ© <code>fn</code>. Nous avons aussi besoin d'ajouter
l'annotation <code>#[no_mangle]</code> pour dire au compilateur Rust de ne pas dÃ©former
le nom de cette fonction. La <em>dÃ©formation</em> s'effectue lorsqu'un compilateur
change le nom que nous avons donnÃ© Ã  une fonction pour un nom qui contient
plus d'informations pour d'autres Ã©tapes du processus de compilation, mais
qui est moins lisible par l'humain. Tous les compilateurs de langages de
programmation dÃ©forment les noms de faÃ§on lÃ©gÃ¨rement diffÃ©rente, donc pour
que le nom d'une fonction Rust soit utilisable par d'autres langages, nous
devons dÃ©sactiver la dÃ©formation du nom par le compilateur de Rust.</p>
</blockquote>
<!--
### Accessing or Modifying a Mutable Static Variable
-->
<h3><a class="header" href="#lire-ou-modifier-une-variable-statique-mutable" id="lire-ou-modifier-une-variable-statique-mutable">Lire ou modifier une variable statique mutable</a></h3>
<!--
Until now, weâ€™ve not talked about *global variables*, which Rust does support
but can be problematic with Rustâ€™s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.
-->
<p>Jusqu'Ã  prÃ©sent, nous n'avons pas parlÃ© des <em>variables globales</em>, que Rust
accepte mais qui peuvent poser des problÃ¨mes avec les rÃ¨gles de possession de
Rust. Si deux tÃ¢ches accÃ¨dent en mÃªme temps Ã  la mÃªme variable globale, cela
peut causer un accÃ¨s concurrent.</p>
<!--
In Rust, global variables are called *static* variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.
-->
<p>En Rust, les variables globales s'appellent des variables <em>statiques</em>. L'encart
19-9 montre un exemple de dÃ©claration et d'utilisation d'une variable statique
avec une slice de chaÃ®ne de caractÃ¨res comme valeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```
-->
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;Cela vautÂ : {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-9: Defining and using an immutable static
variable</span>
-->
<p><span class="caption">Encart 19-9Â : dÃ©finition et utilisation d'une variable
statique immuable</span></p>
<!--
Static variables are similar to constants, which we discussed in the
[â€œDifferences Between Variables and
Constantsâ€][differences-between-variables-and-constants]<!-- ignore -- >
section in Chapter 3. The names of static variables are in
`SCREAMING_SNAKE_CASE` by convention, and we *must* annotate the variableâ€™s
type, which is `&'static str` in this example. Static variables can only store
references with the `'static` lifetime, which means the Rust compiler can
figure out the lifetime; we donâ€™t need to annotate it explicitly. Accessing an
immutable static variable is safe.
-->
<p>Les variables statiques ressemblent aux constantes, que nous avons vu dans la
section
<a href="ch03-01-variables-and-mutability.html#diff%C3%A9rences-entre-les-variables-et-les-constantes">â€œDiffÃ©rences entre les variables et les constantesâ€</a><!-- ignore -->
du chapitre 3. Les noms des variables statiques sont par convention en
<code>SCREAMING_SNAKE_CASE</code>, et nous <em>devons</em> obligatoirement renseigner le type de
la variable, qui est <code>&amp;'static str</code> dans cet exemple. Les variables statiques
peuvent uniquement stocker des rÃ©fÃ©rences avec la durÃ©e de vie <code>'static</code>, ce
qui signifie que le compilateur Rust peut comprendre sa durÃ©e de vieÂ ; nous
n'avons pas besoin de la renseigner explicitement. L'accÃ¨s Ã  une variable
statique immuable est sÃ©curisÃ©.</p>
<!--
Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever theyâ€™re used.
-->
<p>Les constantes et les variables statiques immuables se ressemblent, mais leur
diffÃ©rence subtile est que les valeurs dans les variables statiques sont une
adresse fixe en mÃ©moire. L'utilisation de sa valeur va toujours accÃ©der Ã  la
mÃªme donnÃ©e. Les constantes en revanche, peuvent reproduire leurs donnÃ©es Ã 
chaque fois qu'elles sont utilisÃ©es.</p>
<!--
Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named `COUNTER`.
-->
<p>Une autre diffÃ©rence entre les constantes et les variables statiques est que
les variables statiques peuvent Ãªtre mutables. Lire et modifier des variables
statiques mutables est <em>non sÃ©curisÃ©</em>. L'encart 19-10 montre comment dÃ©clarer,
lire et modifier la variable statique mutable <code>COMPTEUR</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,unsafe
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">static mut COMPTEUR: u32 = 0;

fn ajouter_au_compteur(valeur: u32) {
    unsafe {
        COMPTEUR += valeur;
    }
}

fn main() {
    ajouter_au_compteur(3);

    unsafe {
        println!(&quot;COMPTEURÂ : {}&quot;, COMPTEUR);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span>
-->
<p><span class="caption">Encart 19-10Â : la lecture et l'Ã©criture d'une variable
statique mutable est non sÃ©curisÃ©</span></p>
<!--
As with regular variables, we specify mutability using the `mut` keyword. Any
code that reads or writes from `COUNTER` must be within an `unsafe` block. This
code compiles and prints `COUNTER: 3` as we would expect because itâ€™s single
threaded. Having multiple threads access `COUNTER` would likely result in data
races.
-->
<p>Comme avec les variables classiques, nous renseignons la mutabilitÃ© en
utilisant le mot-clÃ© <code>mut</code>. Tout code qui lit ou modifie <code>COMPTEUR</code> doit se
trouver dans un bloc <code>unsafe</code>. Ce code se compile et affiche <code>COMPTEURÂ : 3</code>
comme nous l'espÃ©rions car nous n'avons qu'une seule tÃ¢che. Si nous avions
plusieurs tÃ¢ches qui accÃ¨dent Ã  <code>COMPTEUR</code> nous pourrions avoir un accÃ¨s
concurrent.</p>
<!--
With mutable data that is globally accessible, itâ€™s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, itâ€™s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.
-->
<p>Avec les donnÃ©es mutables qui sont globalement accessibles, il devient
difficile de s'assurer qu'il n'y a pas d'accÃ¨s concurrent, c'est pourquoi Rust
considÃ¨re les variables statiques mutables comme Ã©tant non sÃ©curisÃ©es. Lorsque
c'est possible, il vaut mieux utiliser les techniques de concurrence et les
pointeurs intelligents adaptÃ©s au multitÃ¢che que nous avons vu au chapitre 16,
afin que le compilateur puisse vÃ©rifier que les donnÃ©es qu'utilisent les
diffÃ©rentes tÃ¢ches sont sÃ©curisÃ©es.</p>
<!--
### Implementing an Unsafe Trait
-->
<h3><a class="header" href="#implÃ©menter-un-trait-non-sÃ©curisÃ©" id="implÃ©menter-un-trait-non-sÃ©curisÃ©">ImplÃ©menter un trait non sÃ©curisÃ©</a></h3>
<!--
The final action that works only with `unsafe` is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler canâ€™t verify. We can declare that a trait is `unsafe` by adding the
`unsafe` keyword before `trait` and marking the implementation of the trait as
`unsafe` too, as shown in Listing 19-11.
-->
<p>La derniÃ¨re action qui fonctionne uniquement avec <code>unsafe</code> est l'implÃ©mentation
d'un trait non sÃ©curisÃ©. Un trait n'est pas sÃ©curisÃ© lorsque au moins une de ses
mÃ©thodes contient une invariante que le compilateur ne peut pas vÃ©rifier. Nous
pouvons dÃ©clarer un trait qui n'est pas sÃ©curisÃ© en ajoutant le mot-clÃ© <code>unsafe</code>
devant <code>trait</code> et en marquant aussi l'implÃ©mentation du trait comme <code>unsafe</code>,
comme dans l'encart 19-11.</p>
<!--
```rust,unsafe
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">unsafe trait Foo {
    // les mÃ©thodes vont ici
}

unsafe impl Foo for i32 {
    // les implÃ©mentations des mÃ©thodes vont ici
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span>
-->
<p><span class="caption">Encart 19-11Â : dÃ©finition et implÃ©mentation d'un trait non
sÃ©curisÃ©</span></p>
<!--
By using `unsafe impl`, weâ€™re promising that weâ€™ll uphold the invariants that
the compiler canâ€™t verify.
-->
<p>En utilisant <code>unsafe impl</code>, nous promettons que nous veillons aux invariantes
que le compilateur ne peut pas vÃ©rifier.</p>
<!--
As an example, recall the `Sync` and `Send` marker traits we discussed in the
[â€œExtensible Concurrency with the `Sync` and `Send`
Traitsâ€][extensible-concurrency-with-the-sync-and-send-traits]<!-- ignore -- >
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of `Send` and `Sync` types. If we implement a
type that contains a type that is not `Send` or `Sync`, such as raw pointers,
and we want to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust
canâ€™t verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with `unsafe`.
-->
<p>Par exemple, souvenez-vous des traits <code>Sync</code> et <code>Send</code> que nous avions dÃ©couvert
dans une section du
<a href="ch16-04-extensible-concurrency-sync-and-send.html">chapitre 16</a><!-- ignore -->Â :
le compilateur implÃ©mente automatiquement ces traits si nos types sont
entiÃ¨rement composÃ©s des types <code>Send</code> et <code>Sync</code>. Si nous implÃ©mentions un type
qui contenait un type qui n'Ã©tait pas <code>Send</code> ou <code>Sync</code>, comme des pointeurs
bruts, et nous souhaitions marquer ce type comme Ã©tant <code>Send</code> ou <code>Sync</code>, nous
aurions dÃ» utiliser <code>unsafe</code>. Rust ne peut pas vÃ©rifier que notre type respecte
les garanties pour que ce type puisse Ãªtre envoyÃ© en toute sÃ©curitÃ© entre des
tÃ¢ches ou qu'il puisse Ãªtre utilisÃ© par plusieurs tÃ¢chesÂ ; toutefois, nous avons
besoin de faire ces vÃ©rifications manuellement et les signaler avec <code>unsafe</code>.</p>
<!--
### Accessing Fields of a Union
-->
<h3><a class="header" href="#utiliser-des-champs-dun-union" id="utiliser-des-champs-dun-union">Utiliser des champs d'un Union</a></h3>
<!--
A `union` is similar to a `struct`, but only one declared field is used in a
particular instance at one time. Unions are primarily used to interface with
unions in C code. Accessing union fields is unsafe because Rust canâ€™t guarantee
the type of the data currently being stored in the union instance. You can
learn more about unions in [the reference][reference].
-->
<p>Un <code>union</code> ressemble Ã  une <code>struct</code>, mais un seul champ de ceux dÃ©clarÃ©s est
utilisÃ© dans une instance prÃ©cise au mÃªme moment. Les unions sont principalement
utilisÃ©s pour s'interfacer avec les unions du code C. L'accÃ¨s aux champs des
unions n'est pas sÃ©curisÃ© car Rust ne peut pas garantir le type de donnÃ©es qui
est actuellement stockÃ©e dans l'instance de l'union. Vous pouvez en apprendre
plus sur les unions dans <a href="https://doc.rust-lang.org/reference/items/unions.html">the reference</a>.</p>
<!--
### When to Use Unsafe Code
-->
<h3><a class="header" href="#quand-utiliser-du-code-non-sÃ©curisÃ©" id="quand-utiliser-du-code-non-sÃ©curisÃ©">Quand utiliser du code non sÃ©curisÃ©</a></h3>
<!--
Using `unsafe` to take one of the five actions (superpowers) just discussed
isnâ€™t wrong or even frowned upon. But it is trickier to get `unsafe` code
correct because the compiler canâ€™t help uphold memory safety. When you have a
reason to use `unsafe` code, you can do so, and having the explicit `unsafe`
annotation makes it easier to track down the source of problems when they occur.
-->
<p>L'utilisation de <code>unsafe</code> pour s'approprier une des cinq actions (ou
super-pouvoirs) que nous venons d'aborder n'est pas une mauvaise chose et ne doit
pas Ãªtre mal vu. Mais il est plus difficile de sÃ©curiser du code <code>unsafe</code> car le
compilateur ne peut pas aider Ã  garantir la sÃ©curitÃ© de la mÃ©moire. Lorsque vous
avez une bonne raison d'utiliser du code non sÃ©curisÃ©, vous pouvez le faire, et
vous aurez l'annotation explicite <code>unsafe</code> pour faciliter la recherche de la
source de problÃ¨mes lorsqu'ils surviennent.</p>
<!--
[dangling-references]:
ch04-02-references-and-borrowing.html#dangling-references
[differences-between-variables-and-constants]:
ch03-01-variables-and-mutability.html#differences-between-variables-and-constants
[extensible-concurrency-with-the-sync-and-send-traits]:
ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits
[the-slice-type]: ch04-03-slices.html#the-slice-type
[reference]: ../reference/items/unions.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--46" id="-attention-peinture-fraÃ®che--46">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/211">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Traits
-->
<h2><a class="header" href="#les-traits-avancÃ©s" id="les-traits-avancÃ©s">Les traits avancÃ©s</a></h2>
<!--
We first covered traits in the [â€œTraits: Defining Shared
Behaviorâ€][traits-defining-shared-behavior]<!-- ignore -- > section of Chapter
10, but as with lifetimes, we didnâ€™t discuss the more advanced details. Now
that you know more about Rust, we can get into the nitty-gritty.
-->
<p>Nous avons vu les traits dans une section du chapitre 10, mais comme les durÃ©es
de vie, nous n'avons pas abordÃ© certains dÃ©tails. Maintenant que vous en savez
plus sur Rust, nous pouvons entrer dans le vif du sujet.</p>
<!--
### Specifying Placeholder Types in Trait Definitions with Associated Types
-->
<h3><a class="header" href="#placer-des-types-Ã -remplacer-dans-les-dÃ©finitions-des-traits-grÃ¢ce-aux-types-associÃ©s" id="placer-des-types-Ã -remplacer-dans-les-dÃ©finitions-des-traits-grÃ¢ce-aux-types-associÃ©s">Placer des types Ã  remplacer dans les dÃ©finitions des traits grÃ¢ce aux types associÃ©s</a></h3>
<!--
*Associated types* connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used in this typeâ€™s
place for the particular implementation. That way, we can define a trait that
uses some types without needing to know exactly what those types are until the
trait is implemented.
-->
<p>Les <em>types associÃ©s</em> connectent un type Ã  remplacer avec un trait afin que la
dÃ©finition des mÃ©thodes puisse utiliser ces types Ã  remplacer dans leur
signature. Celui qui implÃ©mente un trait doit renseigner un type concret pour
Ãªtre utilisÃ© Ã  la place du type Ã  remplacer pour cette implÃ©mentation prÃ©cise.
Ainsi, nous pouvons dÃ©finir un trait qui utilise certains types sans avoir
besoin de savoir exactement quels sont ces types jusqu'Ã  ce que ce trait soit
implÃ©mentÃ©.</p>
<!--
Weâ€™ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: theyâ€™re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.
-->
<p>Nous avions dit que vous aurez rarement besoin de la plupart des
fonctionnalitÃ©s avancÃ©es de ce chapitre. Les types associÃ©s sont un entre-deuxÂ :
ils sont utilisÃ©s plus rarement que les fonctionnalitÃ©s expliquÃ©es dans le reste
de ce livre, mais on les rencontre plus frÃ©quemment que de nombreuses
fonctionnalitÃ©s de ce chapitre.</p>
<!--
One example of a trait with an associated type is the `Iterator` trait that the
standard library provides. The associated type is named `Item` and stands in
for the type of the values the type implementing the `Iterator` trait is
iterating over. In [â€œThe `Iterator` Trait and the `next`
Methodâ€][the-iterator-trait-and-the-next-method]<!-- ignore -- > section of
Chapter 13, we mentioned that the definition of the `Iterator` trait is as
shown in Listing 19-12.
-->
<p>Un exemple de trait avec un type associÃ© est le trait <code>Iterator</code> que fournit la
bibliothÃ¨que standard. Le type associÃ© <code>Item</code> permet de renseigner le type des
valeurs que le type qui implÃ©mente le trait <code>Iterator</code> parcours. Dans une
section du chapitre 13, nous avons mentionnÃ© que la dÃ©finition du trait
<code>Iterator</code> ressemblait Ã  cet encart 19-12.</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-12: The definition of the `Iterator` trait
that has an associated type `Item`</span>
-->
<p><span class="caption">Encart 19-12Â : la dÃ©finition du trait <code>Iterator</code> qui a un
type <code>Item</code> associÃ©</span></p>
<!--
The type `Item` is a placeholder type, and the `next` methodâ€™s definition shows
that it will return values of type `Option<Self::Item>`. Implementors of the
`Iterator` trait will specify the concrete type for `Item`, and the `next`
method will return an `Option` containing a value of that concrete type.
-->
<p>Le type <code>Item</code> est un type Ã  remplacer, et la dÃ©finition de la mÃ©thode <code>next</code>
informe qu'elle va retourner des valeurs du type <code>Option&lt;Self::Item&gt;</code>. Ceux qui
implÃ©menterons le trait <code>Iterator</code> devront renseigner un type concret pour
<code>Item</code>, et la mÃ©thode <code>next</code> va retourner une <code>Option</code> qui contiendra une
valeur de ce type concret.</p>
<!--
Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. So why use associated types?
-->
<p>Les types associÃ©s ressemblent au mÃªme concept que les gÃ©nÃ©riques, car ces
derniers nous permettent de dÃ©finir une fonction sans avoir Ã  renseigner les
types avec lesquels elle travaille. Donc pourquoi utiliser les types associÃ©sÂ ?</p>
<!--
Letâ€™s examine the difference between the two concepts with an example from
Chapter 13 that implements the `Iterator` trait on the `Counter` struct. In
Listing 13-21, we specified that the `Item` type was `u32`:
-->
<p>Examinons les diffÃ©rences entre les deux concepts grÃ¢ce Ã  un exemple du
chapitre 13 qui implÃ©mente le trait <code>Iterator</code> sur la structure <code>Compteur</code>.
Dans l'encart 13-21, nous avions renseignÃ© que le type <code>Item</code> Ã©tait <code>u32</code>Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
This syntax seems comparable to that of generics. So why not just define the
`Iterator` trait with generics, as shown in Listing 19-13?
-->
<p>Cette syntaxe ressemble aux gÃ©nÃ©riques. Donc pourquoi uniquement dÃ©finir le
trait <code>Iterator</code> avec les gÃ©nÃ©riques, comme dans l'encart 19-13Â ?</p>
<!--
```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-13: A hypothetical definition of the
`Iterator` trait using generics</span>
-->
<p><span class="caption">Encart 19-13Â : une dÃ©finition hypothÃ©tique du trait
<code>Iterator</code> en utilisant des gÃ©nÃ©riques</span></p>
<!--
The difference is that when using generics, as in Listing 19-13, we must
annotate the types in each implementation; because we can also implement
`Iterator<String> for Counter` or any other type, we could have multiple
implementations of `Iterator` for `Counter`. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
`next` method on `Counter`, we would have to provide type annotations to
indicate which implementation of `Iterator` we want to use.
-->
<p>La diffÃ©rence est que lorsque vous utilisez les gÃ©nÃ©riques, comme dans l'encart
19-13, nous devons annoter les types dans chaque implÃ©mentationÂ ; et comme nous
pouvons aussi implÃ©menter <code>Iterator&lt;String&gt; for Compteur</code> sur d'autres types,
nous pourrions alors avoir plusieurs implÃ©mentations de <code>Iterator</code> pour
<code>Compteur</code>. Autrement dit, lorsqu'un trait a un paramÃ¨tre gÃ©nÃ©rique, il peut
Ãªtre implÃ©mentÃ© sur un type plusieurs fois, en changeant Ã  chaque fois le type
concret du paramÃ¨tre de type gÃ©nÃ©rique. Lorsque nous utilisons la mÃ©thode <code>next</code>
sur <code>Compteur</code>, nous devons appliquer une annotation de type pour indiquer
quelle implÃ©mentation de <code>Iterator</code> nous souhaitons utiliser.</p>
<!--
With associated types, we donâ€™t need to annotate types because we canâ€™t
implement a trait on a type multiple times. In Listing 19-12 with the
definition that uses associated types, we can only choose what the type of
`Item` will be once, because there can only be one `impl Iterator for Counter`.
We donâ€™t have to specify that we want an iterator of `u32` values everywhere
that we call `next` on `Counter`.
-->
<p>Avec les types associÃ©s, nous n'avons pas besoin d'annoter les types car nous
n'implÃ©mentons pas un trait plusieurs fois sur un mÃªme type. Dans l'encart
19-12 qui contient la dÃ©finition qui utilise les types associÃ©s, nous pouvons
uniquement choisir une seule fois quel sera le type de <code>Item</code>, car il ne peut
y avoir qu'un seul <code>impl Iterator for Compteur</code>. Nous n'avons pas eu Ã  prÃ©ciser
que nous souhaitions avoir un itÃ©rateur de valeurs <code>u32</code> Ã  chaque fois que nous
faisons appel Ã  <code>next</code> sur <code>Compteur</code>.</p>
<!--
### Default Generic Type Parameters and Operator Overloading
-->
<h3><a class="header" href="#les-paramÃ¨tres-de-types-gÃ©nÃ©riques-par-dÃ©faut-et-la-surcharge-dopÃ©rateur" id="les-paramÃ¨tres-de-types-gÃ©nÃ©riques-par-dÃ©faut-et-la-surcharge-dopÃ©rateur">Les paramÃ¨tres de types gÃ©nÃ©riques par dÃ©faut et la surcharge d'opÃ©rateur</a></h3>
<!--
When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is `<PlaceholderType=ConcreteType>` when
declaring the generic type.
-->
<p>Lorsque nous utilisons les paramÃ¨tres de types gÃ©nÃ©riques, nous pouvons
renseigner un type concret par dÃ©faut pour le type gÃ©nÃ©rique. Cela Ã©vite de
contraindre ceux qui implÃ©mentent ce trait d'avoir Ã  renseigner un type concret
si celui par dÃ©faut fonctionne bien. La syntaxe pour renseigner un type par
dÃ©faut pour un type gÃ©nÃ©rique est <code>&lt;TypeARemplacer=TypeConcret&gt;</code> lorsque nous
dÃ©clarons le type gÃ©nÃ©rique.</p>
<!--
A great example of a situation where this technique is useful is with operator
overloading. *Operator overloading* is customizing the behavior of an operator
(such as `+`) in particular situations.
-->
<p>Un bon exemple d'une situation pour laquelle cette technique est utile est avec
la surcharge d'opÃ©rateurs. <em>La surcharge d'opÃ©rateur</em> permet de personnaliser
le comportement d'un opÃ©rateur (comme <code>+</code>) dans des cas particuliers.</p>
<!--
Rust doesnâ€™t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in `std::ops` by implementing the traits associated with the operator. For
example, in Listing 19-14 we overload the `+` operator to add two `Point`
instances together. We do this by implementing the `Add` trait on a `Point`
struct:
-->
<p>Rust ne vous permet pas de crÃ©er vos propres opÃ©rateurs ou de surcharger des
opÃ©rateurs. Mais vous pouvez surcharger les opÃ©rations et les traits listÃ©s
dans <code>std::ops</code> en implÃ©mentant les traits associÃ©s Ã  l'opÃ©rateur. Par exemple,
dans l'encart 19-14 nous surchargeons l'opÃ©rateur <code>+</code> pour additionner ensemble
deux instances de <code>Point</code>. Nous pouvons faire cela en implÃ©mentant le trait
<code>Add</code> sur une structure <code>Point</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-14: Implementing the `Add` trait to overload
the `+` operator for `Point` instances</span>
-->
<p><span class="caption">Encart 19-14Â : implÃ©mentation du trait <code>Add</code> pour
surcharger l'opÃ©rateur <code>+</code> pour les instances de <code>Point</code></span></p>
<!--
The `add` method adds the `x` values of two `Point` instances and the `y`
values of two `Point` instances to create a new `Point`. The `Add` trait has an
associated type named `Output` that determines the type returned from the `add`
method.
-->
<p>La mÃ©thode <code>add</code> ajoute les valeurs <code>x</code> de deux instances de <code>Point</code> ainsi que
les valeurs <code>y</code> de deux instances de <code>Point</code> pour crÃ©er un nouveau <code>Point</code>. Le
trait <code>Add</code> a un type associÃ© <code>Output</code> qui dÃ©termine le type retournÃ© pour la
mÃ©thode <code>add</code>.</p>
<!--
The default generic type in this code is within the `Add` trait. Here is its
definition:
-->
<p>Le type gÃ©nÃ©rique par dÃ©faut dans ce code est dans le trait <code>Add</code>. Voici sa
dÃ©finitionÂ :</p>
<!--
```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code should look generally familiar: a trait with one method and an
associated type. The new part is `Rhs=Self`: this syntax is called *default
type parameters*. The `Rhs` generic type parameter (short for â€œright hand
sideâ€) defines the type of the `rhs` parameter in the `add` method. If we donâ€™t
specify a concrete type for `Rhs` when we implement the `Add` trait, the type
of `Rhs` will default to `Self`, which will be the type weâ€™re implementing
`Add` on.
-->
<p>Ce code devrait vous Ãªtre familierÂ : un trait avec une mÃ©thode et un type
associÃ©. La nouvelle partie concerne <code>Rhs=Self</code>Â : cette syntaxe s'appelle les
<em>paramÃ¨tres de types par dÃ©faut</em>. Le paramÃ¨tre de type gÃ©nÃ©rique <code>Rhs</code>
(c'est le raccourci de â€œRight Hand Sideâ€) qui dÃ©finit le type du paramÃ¨tre
<code>rhs</code> dans la mÃ©thode <code>add</code>. Si nous ne renseignons pas de type concret pour
<code>Rhs</code> lorsque nous implÃ©mentons le trait <code>Add</code>, le type de <code>Rhs</code> sera par
dÃ©faut <code>Self</code>, qui sera le type sur lequel nous implÃ©mentons <code>Add</code>.</p>
<!--
When we implemented `Add` for `Point`, we used the default for `Rhs` because we
wanted to add two `Point` instances. Letâ€™s look at an example of implementing
the `Add` trait where we want to customize the `Rhs` type rather than using the
default.
-->
<p>Lorsque nous avons implÃ©mentÃ© <code>Add</code> sur <code>Point</code>, nous avons utilisÃ© la valeur
par dÃ©faut de <code>Rhs</code> car nous voulions additionner deux instances de <code>Point</code>.
Voyons un exemple d'implÃ©mentation du trait <code>Add</code> dans lequel nous souhaitons
personnaliser le type <code>Rhs</code> plutÃ´t que d'utiliser celui par dÃ©faut.</p>
<!--
We have two structs, `Millimeters` and `Meters`, holding values in different
units. We want to add values in millimeters to values in meters and have the
implementation of `Add` do the conversion correctly. We can implement `Add` for
`Millimeters` with `Meters` as the `Rhs`, as shown in Listing 19-15.
-->
<p>Nous avons deux structures, <code>Millimetres</code> et <code>Metres</code>, qui stockent des valeurs
dans diffÃ©rentes unitÃ©s. Nous voulons pouvoir additionner les valeurs en
millimÃ¨tres avec les valeurs en mÃ¨tres et appliquer l'implÃ©mentation de <code>Add</code>
pour pouvoir faire la conversion correctement. Nous pouvons implÃ©menter <code>Add</code>
sur <code>Millimetres</code> avec <code>Metres</code> comme Ã©tant le <code>Rhs</code>, comme dans l'encart 19-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Milimetres(u32);
struct Metres(u32);

impl Add&lt;Metres&gt; for Milimetres {
    type Output = Milimetres;

    fn add(self, other: Metres) -&gt; Milimetres {
        Milimetres(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-15: Implementing the `Add` trait on
`Millimeters` to add `Millimeters` to `Meters`</span>
-->
<p><span class="caption">Encart 19-15Â : implÃ©mentation du trait <code>Add</code> sur
<code>Milimetres</code> pour pouvoir addition <code>Milimetres</code> Ã  <code>Metres</code></span></p>
<!--
To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the
value of the `Rhs` type parameter instead of using the default of `Self`.
-->
<p>Pour additionner <code>Milimetres</code> et <code>Metres</code>, nous renseignons
<code>impl Add&lt;Metres&gt;</code> pour rÃ©gler la valeur du paramÃ¨tre de type <code>Rhs</code> au lieu
d'utiliser la valeur par dÃ©faut <code>Self</code>.</p>
<!--
Youâ€™ll use default type parameters in two main ways:
-->
<p>Vous utiliserez les paramÃ¨tres de types par dÃ©faut dans deux principaux casÂ :</p>
<!--
* To extend a type without breaking existing code
* To allow customization in specific cases most users wonâ€™t need
-->
<ul>
<li>Pour Ã©tendre un type sans casser le code existant</li>
<li>Pour permettre la personnalisation dans des cas spÃ©cifiques que la plupart
des utilisateurs n'auront pas</li>
</ul>
<!--
The standard libraryâ€™s `Add` trait is an example of the second purpose:
usually, youâ€™ll add two like types, but the `Add` trait provides the ability to
customize beyond that. Using a default type parameter in the `Add` trait
definition means you donâ€™t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isnâ€™t needed, making
it easier to use the trait.
-->
<p>Le trait <code>Add</code> de la bibliothÃ¨que standard est un exemple du second casÂ :
gÃ©nÃ©ralement, vous additionnez deux types similaires, mais le trait <code>Add</code> offre
la possibilitÃ© de personnaliser cela. L'utilisation d'un paramÃ¨tre de type par
dÃ©faut dans la dÃ©finition du trait <code>Add</code> signifie que vous n'aurez pas Ã 
renseigner de paramÃ¨tre en plus la plupart du temps. Autrement dit, il n'est
pas nÃ©cessaire d'avoir recours Ã  des assemblages de code, ce qui facilite
l'utilisation du trait.</p>
<!--
The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.
-->
<p>Le premier cas est similaire au second mais dans le cas inverseÂ : si vous
souhaitez ajouter un paramÃ¨tre de type Ã  un trait existant, vous pouvez lui en
donner un par dÃ©faut pour permettre l'ajout des fonctionnalitÃ©s du trait sans
casser l'implÃ©mentation actuelle du code.</p>
<!--
### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name
-->
<h3><a class="header" href="#la-syntaxe-totalement-dÃ©finie-pour-clarifier-les-appels-Ã -des-mÃ©thodes-qui-ont-le-mÃªme-nom" id="la-syntaxe-totalement-dÃ©finie-pour-clarifier-les-appels-Ã -des-mÃ©thodes-qui-ont-le-mÃªme-nom">La syntaxe totalement dÃ©finie pour clarifier les appels Ã  des mÃ©thodes qui ont le mÃªme nom</a></h3>
<!--
Nothing in Rust prevents a trait from having a method with the same name as
another traitâ€™s method, nor does Rust prevent you from implementing both traits
on one type. Itâ€™s also possible to implement a method directly on the type with
the same name as methods from traits.
-->
<p>Il n'y a rien en Rust qui Ã©vite qu'un trait d'avoir une mÃ©thode avec le mÃªme
nom qu'une autre mÃ©thode d'un autre trait, ni de vous empÃªcher d'implÃ©menter
d'implÃ©menter ces deux traits sur un mÃªme type. Il est aussi possible
d'implÃ©menter directement une mÃ©thode avec le mÃªme nom que celle prÃ©sente dans
les traits sur ce type.</p>
<!--
When calling methods with the same name, youâ€™ll need to tell Rust which one you
want to use. Consider the code in Listing 19-16 where weâ€™ve defined two traits,
`Pilot` and `Wizard`, that both have a method called `fly`. We then implement
both traits on a type `Human` that already has a method named `fly` implemented
on it. Each `fly` method does something different.
-->
<p>Lorsque nous faisons appel Ã  des mÃ©thodes qui ont un conflit de nom, vous devez
prÃ©ciser Ã  Rust prÃ©cisÃ©ment celui que vous souhaitez utiliser. Imaginons le
code dans l'encart 19-16 dans lequel nous avons dÃ©fini deux traits, <code>Pilote</code> et
<code>Magicien</code>, qui ont tous les deux une mÃ©thode <code>voler</code>. Lorsque nous
implÃ©mentons les deux traits sur un type <code>Humain</code> qui a dÃ©jÃ  une mÃ©thode
<code>voler</code> qui lui a Ã©tÃ© implÃ©mentÃ©. Chaque mÃ©thode <code>voler</code> fait quelque chose de
diffÃ©rent.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">trait Pilote {
    fn voler(&amp;self);
}

trait Magicien {
    fn voler(&amp;self);
}

struct Humain;

impl Pilote for Humain {
    fn voler(&amp;self) {
        println!(&quot;Ici le capitaine qui vous parle.&quot;);
    }
}

impl Magicien for Humain {
    fn voler(&amp;self) {
        println!(&quot;DÃ©colage !&quot;);
    }
}

impl Humain {
    fn voler(&amp;self) {
        println!(&quot;*agite frÃ©nÃ©tiquement ses bras*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-16: Two traits are defined to have a `fly`
method and are implemented on the `Human` type, and a `fly` method is
implemented on `Human` directly</span>
-->
<p><span class="caption">Encart 19-16Â : deux traits qui ont une mÃ©thode <code>voler</code>
et qui sont implÃ©mentÃ©s sur le type <code>Humain</code>, et une mÃ©thode <code>voler</code> est aussi
implÃ©mentÃ©e directement sur <code>Humain</code></span></p>
<!--
When we call `fly` on an instance of `Human`, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-17.
-->
<p>Lorsque nous utilisons <code>voler</code> sur une instance de <code>Humain</code>, le compilateur
fait appel par dÃ©faut Ã  la mÃ©thode qui est directement implÃ©mentÃ©e sur le type,
comme le montre l'encart 19-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# trait Pilot {
#     fn fly(&self);
# }
# 
# trait Wizard {
#     fn fly(&self);
# }
# 
# struct Human;
# 
# impl Pilot for Human {
#     fn fly(&self) {
#         println!("This is your captain speaking.");
#     }
# }
# 
# impl Wizard for Human {
#     fn fly(&self) {
#         println!("Up!");
#     }
# }
# 
# impl Human {
#     fn fly(&self) {
#         println!("*waving arms furiously*");
#     }
# }
# 
fn main() {
    let person = Human;
    person.fly();
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilote {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Magicien {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Humain;
</span><span class="boring">
</span><span class="boring">impl Pilote for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Ici le capitaine qui vous parle.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Magicien for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;DÃ©colage !&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;*agite frÃ©nÃ©tiquement ses bras*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let une_personne = Humain;
    une_personne.voler();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-17: Calling `fly` on an instance of
`Human`</span>
-->
<p><span class="caption">Encart 19-17Â : utilisation de <code>voler</code> sur une instance de
<code>Humain</code></span></p>
<!--
Running this code will print `*waving arms furiously*`, showing that Rust
called the `fly` method implemented on `Human` directly.
-->
<p>L'exÃ©cution de ce code va afficher <code>*agite frÃ©nÃ©tiquement ses bras*</code>, ce qui
dÃ©montre que Rust a appelÃ© la mÃ©thode <code>voler</code> implÃ©mentÃ©e directement sur
<code>Humain</code>.</p>
<!--
To call the `fly` methods from either the `Pilot` trait or the `Wizard` trait,
we need to use more explicit syntax to specify which `fly` method we mean.
Listing 19-18 demonstrates this syntax.
-->
<p>Pour faire appel aux mÃ©thodes <code>voler</code> des traits <code>Pilote</code> ou <code>Magicien</code>, nous
devons utiliser une syntaxe plus explicite pour prÃ©ciser quelle mÃ©thode <code>voler</code>
nous souhaitons utiliser. L'encart 19-18 montre cette syntaxe.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# trait Pilot {
#     fn fly(&self);
# }
# 
# trait Wizard {
#     fn fly(&self);
# }
# 
# struct Human;
# 
# impl Pilot for Human {
#     fn fly(&self) {
#         println!("This is your captain speaking.");
#     }
# }
# 
# impl Wizard for Human {
#     fn fly(&self) {
#         println!("Up!");
#     }
# }
# 
# impl Human {
#     fn fly(&self) {
#         println!("*waving arms furiously*");
#     }
# }
# 
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilote {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Magicien {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Humain;
</span><span class="boring">
</span><span class="boring">impl Pilote for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Ici le capitaine qui vous parle.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Magicien for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;DÃ©colage !&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;*agite frÃ©nÃ©tiquement ses bras*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let une_personne = Humain;
    Pilote::voler(&amp;une_personne);
    Magicien::voler(&amp;une_personne);
    une_personne.voler();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-18: Specifying which traitâ€™s `fly` method we
want to call</span>
-->
<p><span class="caption">Encart 19-18Â : prÃ©ciser quelle mÃ©thode <code>voler</code> de quel
trait nous souhaitons utiliser</span></p>
<!--
Specifying the trait name before the method name clarifies to Rust which
implementation of `fly` we want to call. We could also write
`Human::fly(&person)`, which is equivalent to the `person.fly()` that we used
in Listing 19-18, but this is a bit longer to write if we donâ€™t need to
disambiguate.
-->
<p>Si on renseigne le nom du trait avant le nom de la mÃ©thode, cela indique Ã  Rust
quelle implÃ©mentation de <code>voler</code> nous souhaitons utiliser. Nous pouvons aussi
Ã©crire <code>Humain::voler(&amp;une_personne)</code>, qui est Ã©quivalent Ã 
<code>une_personne.voler()</code> que nous avons utilisÃ© dans l'encart 19-18, mais c'est
un peu plus long Ã  Ã©crire si nous n'avons pas besoin de prÃ©ciser les choses.</p>
<!--
Running this code prints the following:
-->
<p>L'exÃ©cution de ce code affiche ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Ici le capitaine qui vous parle.
DÃ©colage !
*agite frÃ©nÃ©tiquement ses bras*
</code></pre>
<!--
Because the `fly` method takes a `self` parameter, if we had two *types* that
both implement one *trait*, Rust could figure out which implementation of a
trait to use based on the type of `self`.
-->
<p>Comme la mÃ©thode <code>voler</code> prends un paramÃ¨tre <code>self</code>, si nous avions deux
<em>types</em> qui implÃ©mentaient chacun un des deux <em>traits</em>, Rust pourrait en
dÃ©duire quelle implÃ©mentation de quel trait Ã  utiliser en fonction du type
de <code>self</code>.</p>
<!--
However, associated functions that are part of traits donâ€™t have a `self`
parameter. When two types in the same scope implement that trait, Rust canâ€™t
figure out which type you mean unless you use *fully qualified syntax*. For
example, the `Animal` trait in Listing 19-19 has the associated function
`baby_name`, the implementation of `Animal` for the struct `Dog`, and the
associated function `baby_name` defined on `Dog` directly.
-->
<p>Cependant, les fonctions associÃ©es qui font partie des traits n'ont pas de
paramÃ¨tre <code>self</code>. Lorsque deux types de la mÃªme portÃ©e implÃ©mentent ce trait,
Rust ne peut pas en dÃ©duire quel type vous sous-entendez jusqu'Ã  ce que vous
utilisiez la <em>syntaxe totalement dÃ©finie</em>. Par exemple, le trait <code>Animal</code> de
l'encart 19-19 a une fonction associÃ©e <code>nom_bebe</code>, l'implÃ©mentation de
<code>Animal</code> sur la structure <code>Chien</code>, et la fonction associÃ©e <code>nom_bebe</code> dÃ©finie
directement sur <code>Chien</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```
-->
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn nom_bebe() -&gt; String;
}

struct Chien;

impl Chien {
    fn nom_bebe() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Chien {
    fn nom_bebe() -&gt; String {
        String::from(&quot;chiot&quot;)
    }
}

fn main() {
    println!(&quot;Un bÃ©bÃ© chien s'appelle un {}&quot;, Chien::nom_bebe());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-19: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span>
-->
<p><span class="caption">Encart 19-19Â : un trait avec une fonction associÃ©e et un
type avec une autre fonction associÃ©e qui porte le mÃªme nom et qui implÃ©mente
aussi ce trait</span></p>
<!--
This code is for an animal shelter that wants to name all puppies Spot, which
is implemented in the `baby_name` associated function that is defined on `Dog`.
The `Dog` type also implements the trait `Animal`, which describes
characteristics that all animals have. Baby dogs are called puppies, and that
is expressed in the implementation of the `Animal` trait on `Dog` in the
`baby_name` function associated with the `Animal` trait.
-->
<p>Ce code a Ã©tÃ© conÃ§u pour un refuge Ã  animaux qui souhaite que tous leurs chiots
soient nommÃ©s Spot, ce qui est implÃ©mentÃ© dans la fonction associÃ©e <code>nom_bebe</code>
de <code>Chien</code>. Le type <code>Chien</code> implÃ©mente lui aussi le trait <code>Animal</code>, qui dÃ©crit
les caractÃ©ristiques que tous les animaux doivent avoir. Les bÃ©bÃ©s chiens
doivent s'appeler des chiots, et ceci est exprimÃ© dans l'implÃ©mentation du
trait <code>Animal</code> sur <code>Chien</code> dans la fonction <code>nom_bebe</code> associÃ©e au trait
<code>Animal</code>.</p>
<!--
In `main`, we call the `Dog::baby_name` function, which calls the associated
function defined on `Dog` directly. This code prints the following:
-->
<p>Dans le <code>main</code>, nous faisons appel Ã  la fonction <code>Chien::nom_bebe</code>, qui fait
appel Ã  la fonction associÃ©e directement dÃ©finie sur <code>Chien</code>. Ce code affiche
ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<!--
This output isnâ€™t what we wanted. We want to call the `baby_name` function that
is part of the `Animal` trait that we implemented on `Dog` so the code prints
`A baby dog is called a puppy`. The technique of specifying the trait name that
we used in Listing 19-18 doesnâ€™t help here; if we change `main` to the code in
Listing 19-20, weâ€™ll get a compilation error.
-->
<p>Ce rÃ©sultat n'est pas celui que nous souhaitons. Nous voulons appeler la
fonction <code>nom_bebe</code> qui fait partie du trait <code>Animal</code> que nous avons implÃ©mentÃ©
sur <code>Chien</code> afin que le code affiche <code>Un bÃ©bÃ© chien s'appelle un chiot</code>. La
technique pour prÃ©ciser le nom du trait que nous avons utilisÃ© ne va pas nous
aider iciÂ ; si nous changeons le <code>main</code> par le code de l'encart 19-20, nous
allons avoir une erreur de compilation.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# trait Animal {
#     fn baby_name() -> String;
# }
# 
# struct Dog;
# 
# impl Dog {
#     fn baby_name() -> String {
#         String::from("Spot")
#     }
# }
# 
# impl Animal for Dog {
#     fn baby_name() -> String {
#         String::from("puppy")
#     }
# }
# 
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn nom_bebe() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Chien;
</span><span class="boring">
</span><span class="boring">impl Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;chiot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Un bÃ©bÃ© chien s'appelle un {}&quot;, Animal::nom_bebe());
}
</code></pre>
<!--
<span class="caption">Listing 19-20: Attempting to call the `baby_name`
function from the `Animal` trait, but Rust doesnâ€™t know which implementation to
use</span>
-->
<p><span class="caption">Encart 19-20Â : tentative d'appel Ã  la fonction <code>nom_bebe</code>
du trait <code>Animal</code>, mais Rust ne sait pas quelle implÃ©mentation utiliser</span></p>
<!--
Because `Animal::baby_name` is an associated function rather than a method, and
thus doesnâ€™t have a `self` parameter, Rust canâ€™t figure out which
implementation of `Animal::baby_name` we want. Weâ€™ll get this compiler error:
-->
<p>Comme <code>Animal::nom_bebe</code> est une fonction associÃ©e plutÃ´t qu'une mÃ©thode, et
qu'elle n'a pas de paramÃ¨tre <code>self</code>, Rust ne peut pas savoir quelle
implÃ©mentation de <code>Animal::nom_bebe</code> nous souhaitons utiliser. Nous obtenons
alors cette erreur de compilationÂ :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  -- > src/main.rs:20:43
   |
2  |     fn baby_name() -> String;
   |     ------------------------- required by `Animal::baby_name`
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot resolve `_: Animal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
2  |     fn nom_bebe() -&gt; String;
   |     ------------------------ required by `Animal::nom_bebe`
...
20 |     println!(&quot;Un bÃ©bÃ© chien s'appelle un {}&quot;, Animal::nom_bebe());
   |                                               ^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot resolve `_: Animal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
To disambiguate and tell Rust that we want to use the implementation of
`Animal` for `Dog`, we need to use fully qualified syntax. Listing 19-21
demonstrates how to use fully qualified syntax.
-->
<p>Pour expliquer Ã  Rust que nous souhaitons utiliser l'implÃ©mentation de <code>Animal</code>
pour <code>Chien</code>, nous devons utiliser la syntaxe totalement dÃ©finie. L'encart
19-21 montre comment utiliser la syntaxe totalement dÃ©finie.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# trait Animal {
#     fn baby_name() -> String;
# }
# 
# struct Dog;
# 
# impl Dog {
#     fn baby_name() -> String {
#         String::from("Spot")
#     }
# }
# 
# impl Animal for Dog {
#     fn baby_name() -> String {
#         String::from("puppy")
#     }
# }
# 
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn nom_bebe() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Chien;
</span><span class="boring">
</span><span class="boring">impl Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;chiot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Un bÃ©bÃ© chien s'appelle un {}&quot;, &lt;Chien as Animal&gt;::nom_bebe());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-21: Using fully qualified syntax to specify
that we want to call the `baby_name` function from the `Animal` trait as
implemented on `Dog`</span>
-->
<p><span class="caption">Encart 19-21Â : utilisation de la syntaxe totalement
dÃ©finie pour prÃ©ciser que nous souhaitons appeler la fonction <code>nom_bebe</code> du
trait <code>Animal</code> comme il est implÃ©mentÃ© sur <code>Chien</code></span></p>
<!--
Weâ€™re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the `baby_name` method from the `Animal` trait as
implemented on `Dog` by saying that we want to treat the `Dog` type as an
`Animal` for this function call. This code will now print what we want:
-->
<p>Nous avons donnÃ© Ã  Rust une annotation de type entre des chevrons, ce qui
indique que nous souhaitons appeler la mÃ©thode <code>nom_bebe</code> du trait <code>Animal</code>
comme elle est implÃ©mentÃ©e sur <code>Chien</code> en indiquant que nous souhaitons traiter
le type <code>Chien</code> comme Ã©tant un <code>Animal</code> pour cet appel de fonction. Ce code va
dÃ©sormais afficher ce que nous souhaitonsÂ :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Un bÃ©bÃ© chien s'appelle un chiot
</code></pre>
<!--
In general, fully qualified syntax is defined as follows:
-->
<p>De maniÃ¨re gÃ©nÃ©rale, une syntaxe totalement dÃ©finie est dÃ©finie comme ceciÂ :</p>
<!--
```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```
-->
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(destinataire_si_methode, argument_suivant, ...);
</code></pre>
<!--
For associated functions, there would not be a `receiver`: there would only be
the list of other arguments. You could use fully qualified syntax everywhere
that you call functions or methods. However, youâ€™re allowed to omit any part of
this syntax that Rust can figure out from other information in the program. You
only need to use this more verbose syntax in cases where there are multiple
implementations that use the same name and Rust needs help to identify which
implementation you want to call.
-->
<p>Pour les fonctions associÃ©es, il n'y a pas de <code>destinataire</code>Â : il n'y a qu'une
liste d'arguments. Vous pouvez utiliser la syntaxe totalement dÃ©finie n'importe
oÃ¹ vous faites appel Ã  des fonctions ou des mÃ©thodes. Cependant, vous pouvez
Ã©viter de renseigner n'importe quelle partie de cette syntaxe que Rust peut en
dÃ©duire Ã  partir d'autres informations prÃ©sentes dans le code. Vous avez
seulement besoin d'utiliser cette syntaxe plus verbeuse dans les cas oÃ¹ il y a
plusieurs implÃ©mentations qui utilisent le mÃªme nom et que Rust doit Ãªtre aidÃ©
pour identifier quelle implÃ©mentation vous souhaitez appeler.</p>
<!--
### Using Supertraits to Require One Traitâ€™s Functionality Within Another Trait
-->
<h3><a class="header" href="#utiliser-les-supertraits-pour-utiliser-la-fonctionnalitÃ©-dun-trait-dans-un-autre-trait" id="utiliser-les-supertraits-pour-utiliser-la-fonctionnalitÃ©-dun-trait-dans-un-autre-trait">Utiliser les supertraits pour utiliser la fonctionnalitÃ© d'un trait dans un autre trait</a></h3>
<!--
Sometimes, you might need one trait to use another traitâ€™s functionality. In
this case, you need to rely on the dependent trait also being implemented.
The trait you rely on is a *supertrait* of the trait youâ€™re implementing.
-->
<p>Des fois, vous pourriez avoir besoin d'un trait pour utiliser une autre
fonctionnalitÃ© d'un trait. Dans ce cas, vous devez pouvoir compter sur le fait
que le trait dÃ©pendant soit bien implÃ©mentÃ©. Le trait sur lequel vous comptez
est alors un <em>supertrait</em> du trait que vous implÃ©mentez.</p>
<!--
For example, letâ€™s say we want to make an `OutlinePrint` trait with an
`outline_print` method that will print a value framed in asterisks. That is,
given a `Point` struct that implements `Display` to result in `(x, y)`, when we
call `outline_print` on a `Point` instance that has `1` for `x` and `3` for
`y`, it should print the following:
-->
<p>Par exemple, imaginons que nous souhaitons crÃ©er un trait <code>OutlinePrint</code> qui
offre une mÃ©thode <code>outline_print</code> affiche une valeur entourÃ©e d'astÃ©risques.
Pour une structure <code>Point</code> qui implÃ©mente <code>Display</code> pour afficher <code>(x, y)</code>,
lorsque nous faisons appel Ã  <code>outline_print</code> sur une instance de <code>Point</code> qui a
<code>1</code> pour valeur de <code>x</code> et <code>3</code> pour <code>y</code>, cela devrait afficher ceciÂ :</p>
<!--
```text
**********
*        *
* (1, 3) *
*        *
**********
```
-->
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<!--
In the implementation of `outline_print`, we want to use the `Display` traitâ€™s
functionality. Therefore, we need to specify that the `OutlinePrint` trait will
work only for types that also implement `Display` and provide the functionality
that `OutlinePrint` needs. We can do that in the trait definition by specifying
`OutlinePrint: Display`. This technique is similar to adding a trait bound to
the trait. Listing 19-22 shows an implementation of the `OutlinePrint` trait.
-->
<p>Dans l'implÃ©mentation de <code>outline_print</code>, nous souhaitons utiliser la
fonctionnalitÃ© du trait <code>Display</code>. Toutefois, nous devons renseigner que le
trait <code>OutlinePrint</code> fonctionnera uniquement pour les types qui auront aussi
implÃ©mentÃ© <code>Display</code> et qui fourniront la fonctionnalitÃ© dont a besoin
<code>OutlinePrint</code>. Nous pouvons faire ceci dans la dÃ©finition du trait en
renseignant <code>OutlinePrint: Display</code>. Cette technique ressemble Ã  l'ajout d'un
trait liÃ© au trait. L'encart 19-22 montre une implÃ©mentation du trait
<code>OutlinePrint</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let valeur = self.to_string();
        let largeur = valeur.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
        println!(&quot;* {} *&quot;, valeur);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-22: Implementing the `OutlinePrint` trait that
requires the functionality from `Display`</span>
-->
<p><span class="caption">Encart 19-22Â : implÃ©mentation du trait <code>OutlinePrint</code> qui
nÃ©cessite la fonctionnalitÃ© offerte par <code>Display</code></span></p>
<!--
Because weâ€™ve specified that `OutlinePrint` requires the `Display` trait, we
can use the `to_string` function that is automatically implemented for any type
that implements `Display`. If we tried to use `to_string` without adding a
colon and specifying the `Display` trait after the trait name, weâ€™d get an
error saying that no method named `to_string` was found for the type `&Self` in
the current scope.
-->
<p>Comme nous avons prÃ©cisÃ© que <code>OutlinePrint</code> nÃ©cessite le trait <code>Display</code>, nous
pouvons utiliser la fonction <code>to_string</code> qui est automatiquement implÃ©mentÃ©e
pour n'importe quel type qui implÃ©mente <code>Display</code>. Si nous avions essayÃ©
d'utiliser <code>to_string</code> sans ajouter un double-point et en renseignant le trait
<code>Display</code> aprÃ¨s le nom du trait, nous obtiendrons alors une erreur qui nous
informerait qu'il n'y a pas de mÃ©thode <code>to_string</code> pour le type <code>&amp;Self</code> dans la
portÃ©e courante.</p>
<!--
Letâ€™s see what happens when we try to implement `OutlinePrint` on a type that
doesnâ€™t implement `Display`, such as the `Point` struct:
-->
<p>Voyons ce qui ce passe lorsque nous essayons d'implÃ©menter <code>OutlinePrint</code> sur
un type qui n'implÃ©mente pas <code>Display</code>, comme la structure <code>Point</code>Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::fmt;
# 
# trait OutlinePrint: fmt::Display {
#     fn outline_print(&self) {
#         let output = self.to_string();
#         let len = output.len();
#         println!("{}", "*".repeat(len + 4));
#         println!("*{}*", " ".repeat(len + 2));
#         println!("* {} *", output);
#         println!("*{}*", " ".repeat(len + 2));
#         println!("{}", "*".repeat(len + 4));
#     }
# }
# 
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
# 
# fn main() {
#     let p = Point { x: 1, y: 3 };
#     p.outline_print();
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let valeur = self.to_string();
</span><span class="boring">        let largeur = valeur.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, valeur);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<!--
We get an error saying that `Display` is required but not implemented:
-->
<p>Nous obtenons une erreur qui dit que <code>Display</code> est nÃ©cessaire mais n'est pas
implÃ©mentÃ©Â :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  -- > src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
To fix this, we implement `Display` on `Point` and satisfy the constraint that
`OutlinePrint` requires, like so:
-->
<p>Pour rÃ©gler cela, nous implÃ©mentons <code>Display</code> sur <code>Point</code> afin de rÃ©pondre aux
besoins de <code>OutlinePrint</code>, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# trait OutlinePrint: fmt::Display {
#     fn outline_print(&self) {
#         let output = self.to_string();
#         let len = output.len();
#         println!("{}", "*".repeat(len + 4));
#         println!("*{}*", " ".repeat(len + 2));
#         println!("* {} *", output);
#         println!("*{}*", " ".repeat(len + 2));
#         println!("{}", "*".repeat(len + 4));
#     }
# }
# 
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
# impl OutlinePrint for Point {}
# 
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
# 
# fn main() {
#     let p = Point { x: 1, y: 3 };
#     p.outline_print();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let valeur = self.to_string();
</span><span class="boring">        let largeur = valeur.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, valeur);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<!--
Then implementing the `OutlinePrint` trait on `Point` will compile
successfully, and we can call `outline_print` on a `Point` instance to display
it within an outline of asterisks.
-->
<p>Suite Ã  cela, l'implÃ©mentation du trait <code>OutlinePrint</code> sur <code>Point</code> va se
compiler avec succÃ¨s, et nous pourrons appeler <code>outline_print</code> sur une instance
de <code>Point</code> pour l'afficher dans le cadre constituÃ© d'astÃ©risques.</p>
<!--
### Using the Newtype Pattern to Implement External Traits on External Types
-->
<h3><a class="header" href="#utiliser-le-motif-newtype-pour-implÃ©menter-des-traits-externes-sur-des-types-externes" id="utiliser-le-motif-newtype-pour-implÃ©menter-des-traits-externes-sur-des-types-externes">Utiliser le motif newtype pour implÃ©menter des traits externes sur des types externes</a></h3>
<!--
In Chapter 10 in the [â€œImplementing a Trait on a
Typeâ€][implementing-a-trait-on-a-type]<!-- ignore -- > section, we mentioned
the orphan rule that states weâ€™re allowed to implement a trait on a type as
long as either the trait or the type are local to our crate. Itâ€™s possible to
get around this restriction using the *newtype pattern*, which involves
creating a new type in a tuple struct. (We covered tuple structs in the
[â€œUsing Tuple Structs without Named Fields to Create Different
Typesâ€][tuple-structs]<!-- ignore -- > section of Chapter 5.) The tuple struct
will have one field and be a thin wrapper around the type we want to implement
a trait for. Then the wrapper type is local to our crate, and we can implement
the trait on the wrapper. *Newtype* is a term that originates from the Haskell
programming language. There is no runtime performance penalty for using this
pattern, and the wrapper type is elided at compile time.
-->
<p>Dans <a href="ch10-02-traits.html">une section</a><!-- ignore --> du chapitre
10, nous avions mentionnÃ© la rÃ¨gle de l'orphelin qui Ã©nonÃ§ait que nous pouvions
implÃ©menter un trait sur un type Ã  condition tant que le trait ou le type soit
local Ã  notre crate. Il est possible de contourner cette restriction en
utilisant le <em>motif newtype</em>, ce qui implique de crÃ©er un nouveau type dans une
structure tuple (nous avons vu les structures tuple dans la section
<a href="ch05-01-defining-structs.html#utilisation-de-structures-tuples-sans-champ-nomm%C3%A9-pour-cr%C3%A9er-des-types-diff%C3%A9rents">â€œUtilisation de structures tuples sans champ nommÃ© pour crÃ©er des types diffÃ©rentsâ€</a><!-- ignore -->
du chapitre 5). La structure tuple aura un champ et sera une petite enveloppe
pour le type sur lequel nous souhaitons implÃ©menter le trait. Ensuite, le type
enveloppant est local Ã  notre crate, et nous pouvons lui implÃ©menter un trait.
<em>Newtype</em> est un terme qui provient du langage de programmation Haskell. Il n'y
a pas de consÃ©quence sur les performance Ã  l'exÃ©cution pour l'utilisation de ce
motif, et le type enveloppant est rÃ©solu Ã  la compilation.</p>
<!--
As an example, letâ€™s say we want to implement `Display` on `Vec<T>`, which the
orphan rule prevents us from doing directly because the `Display` trait and the
`Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct
that holds an instance of `Vec<T>`; then we can implement `Display` on
`Wrapper` and use the `Vec<T>` value, as shown in Listing 19-23.
-->
<p>Comme exemple, disons que nous souhaitons implÃ©menter <code>Display</code> sur <code>Vec&lt;T&gt;</code>, ce
que la rÃ¨gle de l'orphelin nous empÃªche directement de faire car le trait
<code>Display</code> et le type <code>Vec&lt;T&gt;</code> sont dÃ©finis en dehors de notre crate. Nous
pouvons construire une structure <code>Enveloppe</code> qui possÃ¨de une instance de
<code>Vec&lt;T&gt;</code>Â ; et ensuite nous pouvons implÃ©menter <code>Display</code> sur <code>Enveloppe</code> et
utiliser la valeur <code>Vec&lt;T&gt;</code>, comme dans l'encart 19-23.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Enveloppe(Vec&lt;String&gt;);

impl fmt::Display for Enveloppe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Enveloppe(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-23: Creating a `Wrapper` type around
`Vec<String>` to implement `Display`</span>
-->
<p><span class="caption">Encart 19-23Â : crÃ©ation d'un type <code>Enveloppe</code> autour de
<code>Vec&lt;String&gt;</code> pour implÃ©menter <code>Display</code></span></p>
<!--
The implementation of `Display` uses `self.0` to access the inner `Vec<T>`,
because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the
tuple. Then we can use the functionality of the `Display` type on `Wrapper`.
-->
<p>L'implÃ©mentation de <code>Display</code> utilise <code>self.0</code> pour accÃ©der Ã  la valeur de
<code>Vec&lt;T&gt;</code>, car <code>Enveloppe</code> est une structure tuple et <code>Vec&lt;T&gt;</code> est l'Ã©lÃ©ment Ã 
l'indice 0 du tuple. Ensuite, nous pouvons utiliser la fonctionnalitÃ© du type
<code>Display</code> sur <code>Enveloppe</code>.</p>
<!--
The downside of using this technique is that `Wrapper` is a new type, so it
doesnâ€™t have the methods of the value itâ€™s holding. We would have to implement
all the methods of `Vec<T>` directly on `Wrapper` such that the methods
delegate to `self.0`, which would allow us to treat `Wrapper` exactly like a
`Vec<T>`. If we wanted the new type to have every method the inner type has,
implementing the `Deref` trait (discussed in Chapter 15 in the [â€œTreating Smart
Pointers Like Regular References with the `Deref`
Traitâ€][smart-pointer-deref]<!-- ignore -- > section) on the `Wrapper` to return
the inner type would be a solution. If we donâ€™t want the `Wrapper` type to have
all the methods of the inner typeâ€”for example, to restrict the `Wrapper` typeâ€™s
behaviorâ€”we would have to implement just the methods we do want manually.
-->
<p>Le dÃ©savantage d'utiliser cette technique est que <code>Enveloppe</code> est un nouveau
type, dont il n'implÃ©mente pas toutes les mÃ©thodes de la valeur qu'il possÃ¨de.
Il faudrait implÃ©menter toutes les mÃ©thodes de <code>Vec&lt;T&gt;</code> directement sur
<code>Enveloppe</code> afin que les mÃ©thodes dÃ©lÃ¨guent Ã  <code>self.0</code>, ce qui nous permettrait
d'utiliser <code>Enveloppe</code> exactement comme un <code>Vec&lt;T&gt;</code>. Si nous voulions que le
nouveau type ait toutes les mÃ©thodes du type qu'il possÃ¨de, l'implÃ©mentation du
trait <code>Deref</code> (que nous avons vu dans
<a href="ch15-02-deref.html">une section du chapitre 15</a><!-- ignore -->) sur
<code>Enveloppe</code> pour retourner le type interne pourrait Ãªtre une solution. Si nous
ne souhaitons pas que le type <code>Enveloppe</code> ait toutes les mÃ©thodes du type qu'il
possÃ¨de (par exemple, pour limiter les fonctionnalitÃ©s du type <code>Enveloppe</code>),
nous devrions implÃ©menter manuellement que les mÃ©thodes que nous souhaitons.</p>
<!--
Now you know how the newtype pattern is used in relation to traits; itâ€™s also a
useful pattern even when traits are not involved. Letâ€™s switch focus and look
at some advanced ways to interact with Rustâ€™s type system.
-->
<p>Maintenant vous savez comment le motif newtype est utilisÃ© en lien avec les
traitsÂ ; c'est aussi un motif trÃ¨s utile mÃªme lorsque les traits ne sont pas
concernÃ©s. Changeons de sujet et dÃ©couvrons d'autres techniques avancÃ©es pour
interagir avec le systÃ¨me de type de Rust.</p>
<!-- markdownlint-disable -->
<!--
[implementing-a-trait-on-a-type]:
ch10-02-traits.html#implementing-a-trait-on-a-type
[the-iterator-trait-and-the-next-method]:
ch13-02-iterators.html#the-iterator-trait-and-the-next-method
[traits-defining-shared-behavior]:
ch10-02-traits.html#traits-defining-shared-behavior
[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
-->
<!-- markdownlint-restore -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--47" id="-attention-peinture-fraÃ®che--47">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/218">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Types
-->
<h2><a class="header" href="#les-types-avancÃ©s" id="les-types-avancÃ©s">Les types avancÃ©s</a></h2>
<!--
The Rust type system has some features that weâ€™ve mentioned in this book but
havenâ€™t yet discussed. Weâ€™ll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then weâ€™ll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. Weâ€™ll also
discuss the `!` type and dynamically sized types.
-->
<p>Le systÃ¨me de type de Rust offre quelques fonctionnalitÃ©s que nous avons
mentionnÃ© dans ce livre mais que nous n'avons pas encore Ã©tudiÃ©. Nous allons
commencer par voir les newtypes en gÃ©nÃ©ral lorsque nous examinerons pourquoi
les newtypes sont des types utiles. Ensuite nous nous pencherons sur les alias
de type, une fonctionnalitÃ© qui ressemble aux newtypes mais avec quelques
diffÃ©rences sÃ©mantiques. Nous allons aussi voir le type <code>!</code> et les types Ã 
taille dynamique.</p>
<!--
> Note: The next section assumes youâ€™ve read the earlier section [â€œUsing the
> Newtype Pattern to Implement External Traits on External
> Types.â€][using-the-newtype-pattern]<!-- ignore -- >
-->
<blockquote>
<p>RemarqueÂ : cette section suppose que vous avez lu la
<a href="ch19-03-advanced-traits.html">section prÃ©cÃ©dente</a><!-- ignore --></p>
</blockquote>
<!--
### Using the Newtype Pattern for Type Safety and Abstraction
-->
<h3><a class="header" href="#utiliser-le-motif-newtype-pour-la-sÃ©curitÃ©-et-labstraction-des-types" id="utiliser-le-motif-newtype-pour-la-sÃ©curitÃ©-et-labstraction-des-types">Utiliser le motif newtype pour la sÃ©curitÃ© et l'abstraction des types</a></h3>
<!--
The newtype pattern is useful for tasks beyond those weâ€™ve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-15: recall that the `Millimeters` and `Meters` structs wrapped `u32`
values in a newtype. If we wrote a function with a parameter of type
`Millimeters`, we couldnâ€™t compile a program that accidentally tried to call
that function with a value of type `Meters` or a plain `u32`.
-->
<p>Le motif newtype est utile pour des tÃ¢ches qui se prolongent en dehors de ce
que nous avons vu jusqu'Ã  prÃ©sent, notamment pour faire en sorte statiquement
que les valeurs ne soient jamais confondues et pour indiquer les unitÃ©s d'une
valeur. Vous avez vu un exemple d'utilisation des newtypes pour indiquer des
unitÃ©s dans l'encart 19-15Â : souvenez-vous des structures <code>Milimetres</code> et
<code>Metres</code> qui englobaient des valeurs <code>u32</code> dans ces newtypes. Si nous avions
Ã©crit une fonction avec un paramÃ¨tre de type <code>Milimetres</code>, nous ne pourrions
pas compiler un programme qui fait accidentellement appel Ã  cette fonction avec
une valeur du type <code>Metres</code> ou un <code>u32</code> pur.</p>
<!--
Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type if we used the new type directly to restrict
the available functionality, for example.
-->
<p>Une autre utilisation du motif newtype est de rendre abstrait certains dÃ©tails
d'implÃ©mentation d'un typeÂ : le newtype peut exposer une API publique qui est
diffÃ©rente de l'API du type interne privÃ© si nous avons utilisÃ© directement le
newtype pour restreindre les fonctionnalitÃ©s disponibles, par exemple.</p>
<!--
Newtypes can also hide internal implementation. For example, we could provide a
`People` type to wrap a `HashMap<i32, String>` that stores a personâ€™s ID
associated with their name. Code using `People` would only interact with the
public API we provide, such as a method to add a name string to the `People`
collection; that code wouldnâ€™t need to know that we assign an `i32` ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the [â€œEncapsulation that
Hides Implementation
Detailsâ€][encapsulation-that-hides-implementation-details]<!-- ignore -- >
section of Chapter 17.
-->
<p>Les newtypes peuvent aussi masquer des implÃ©mentations internes. Par exemple,
nous pouvons fournir un type <code>Personnes</code> pour embarquer un
<code>HashMap&lt;i32, String&gt;</code> qui stocke un identifiant d'une personne associÃ© Ã  son
nom. Le code qui utilisera <code>Personnes</code> ne pourra utiliser que l'API publique
que nous fournissons, comme une mÃ©thode pour ajouter une chaÃ®ne de caractÃ¨res
de caractÃ¨re qui est un nom Ã  la collection <code>Personnes</code>Â ; ce code n'aura pas
besoin de savoir que nous assignons en interne un identifiant <code>i32</code> aux noms.
Le motif newtype est une faÃ§on allÃ©gÃ©e de procÃ©der Ã  de l'encapsulation pour
masquer des dÃ©tails d'implÃ©mentation, comme nous l'avons vu dans <a href="ch17-01-what-is-oo.html">une partie du
chapitre 17</a><!-- ignore -->.</p>
<!--
### Creating Type Synonyms with Type Aliases
-->
<h3><a class="header" href="#crÃ©er-des-synonymes-de-noms-avec-les-alias-de-type" id="crÃ©er-des-synonymes-de-noms-avec-les-alias-de-type">CrÃ©er des synonymes de noms avec les alias de type</a></h3>
<!--
Along with the newtype pattern, Rust provides the ability to declare a *type
alias* to give an existing type another name. For this we use the `type`
keyword. For example, we can create the alias `Kilometers` to `i32` like so:
-->
<p>En plus du motif newtype, Rust fournit la possibilitÃ© de dÃ©clarer un <em>alias de
type</em> pour donner un autre nom Ã  un type dÃ©jÃ  existant. Pour faire cela, nous
utilisons le mot-clÃ© <code>type</code>. Par exemple, nous pouvons crÃ©er l'alias
<code>Kilometres</code> pour un <code>i32</code>, comme ceciÂ :</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;
# 
#     let x: i32 = 5;
#     let y: Kilometers = 5;
# 
#     println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometres = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters`
and `Meters` types we created in Listing 19-15, `Kilometers` is not a separate,
new type. Values that have the type `Kilometers` will be treated the same as
values of type `i32`:
-->
<p>DÃ©sormais, l'alias <code>Kilometres</code> est un <em>synonyme</em> de <code>i32</code>Â ; contrairement aux
types <code>Milimetres</code> et <code>Metres</code> que nous avons crÃ©Ã© dans l'encart 19-15,
<code>Kilometres</code> n'est pas un newtype sÃ©parÃ©. Les valeurs qui ont le type
<code>Kilometre</code> seront traitÃ©s comme si elles Ã©taient du type <code>i32</code>Â :</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;

    let x: i32 = 5;
    let y: Kilometres = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometres = i32;

let x: i32 = 5;
let y: Kilometres = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<!--
Because `Kilometers` and `i32` are the same type, we can add values of both
types and we can pass `Kilometers` values to functions that take `i32`
parameters. However, using this method, we donâ€™t get the type checking benefits
that we get from the newtype pattern discussed earlier.
-->
<p>Comme <code>Kilometres</code> et <code>i32</code> sont du mÃªme type, nous pouvons additionner les
valeurs des deux types et nous pouvons envoyer des valeurs <code>Kilometres</code> aux
fonctions qui prennent des paramÃ¨tres <code>i32</code>. Cependant, en utilisant cette
mÃ©thode, nous ne bÃ©nÃ©ficions pas des bienfaits de la vÃ©rification du type que
nous avions avec le motif newtype que nous avons vu prÃ©cÃ©demment.</p>
<!--
The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:
-->
<p>L'utilisation principale pour les synonymes de types est de rÃ©duire la
rÃ©pÃ©tition. Par exemple, nous pourrions avoir un type un peu long comme
celui-ciÂ :</p>
<!--
```rust,ignore
Box<dyn Fn() + Send + 'static>
```
-->
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<!--
Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.
-->
<p>L'Ã©criture de ce type un peu long dans des signatures de fonctions et comme
annotations de types tout au long du code peut Ãªtre fatigante et faciliter les
erreurs. Imaginez avoir un projet avec plein de code comme celui dans l'encart
19-24.</p>
<!--
```rust
# fn main() {
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
        // --snip--
    }

    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // -- partie masquÃ©e ici --
    }

    fn retourne_un_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // -- partie masquÃ©e ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-24: Using a long type in many places</span>
-->
<p><span class="caption">Encart 19-24Â : utilisation d'un long type dans de nombreux
endroits</span></p>
<!--
A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, weâ€™ve introduced an alias named `Thunk` for the verbose type and
can replace all uses of the type with the shorter alias `Thunk`.
-->
<p>Un alias de type simplifie ce code en rÃ©duisant la rÃ©pÃ©tition. Dans l'encart
19-25, nous avons ajoutÃ© un alias <code>Thunk</code> pour ce type verbeux et qui peut
remplacer tous ses cas d'emploi du type avec l'alias <code>Thunk</code>, plus court.</p>
<!--
```rust
# fn main() {
    type Thunk = Box<dyn Fn() + Send + 'static>;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -> Thunk {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Thunk) {
        // -- partie masquÃ©e ici --
    }

    fn retourne_un_long_type() -&gt; Thunk {
        // -- partie masquÃ©e ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-25: Introducing a type alias `Thunk` to reduce
repetition</span>
-->
<p><span class="caption">Encart 19-25Â : ajout et utilisation d'un alias <code>Thunk</code>
pour rÃ©duire les rÃ©pÃ©titions</span></p>
<!--
This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (*thunk* is a word for code
to be evaluated at a later time, so itâ€™s an appropriate name for a closure that
gets stored).
-->
<p>Ce code est plus facile Ã  lire et Ã©crireÂ ! Choisir un nom plus explicite pour
un alias peut aussi vous aider Ã  communiquer ce que vous voulez faire (<em>thunk</em>
est un terme dÃ©signant du code qui peut Ãªtre Ã©valuÃ© plus tard, donc c'est un nom
appropriÃ© pour une fermeture qui est stockÃ©e).</p>
<!--
Type aliases are also commonly used with the `Result<T, E>` type for reducing
repetition. Consider the `std::io` module in the standard library. I/O
operations often return a `Result<T, E>` to handle situations when operations
fail to work. This library has a `std::io::Error` struct that represents all
possible I/O errors. Many of the functions in `std::io` will be returning
`Result<T, E>` where the `E` is `std::io::Error`, such as these functions in
the `Write` trait:
-->
<p>Les alias de type sont couramment utilisÃ©s avec le type <code>Result&lt;T, E&gt;</code> pour
rÃ©duire la rÃ©pÃ©tition. Regardez le module <code>std::io</code> de la bibliothÃ¨que standard.
Les opÃ©rations d'entrÃ©e/sortie retournent parfois un <code>Result&lt;T, E&gt;</code> pour gÃ©rer
les situations lorsque les opÃ©rations Ã©chouent. Cette bibliothÃ¨que a une
structure <code>std::io::Error</code> qui reprÃ©sente toutes les erreurs possibles
d'entrÃ©e/sortie. De nombreuses fonctions dans <code>std::io</code> vont retourner un
<code>Result&lt;T, E&gt;</code> avec <code>E</code> qui est <code>std::io::Error</code>, ces fonctions sont dans le
trait <code>Write</code>Â :</p>
<!--
```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type of
alias declaration:
-->
<p>Le <code>Result&lt;..., Error&gt;</code> est rÃ©pÃ©tÃ© plein de fois. Ainsi, <code>std::io</code> a ce type de
dÃ©claration d'aliasÂ :</p>
<!--
```rust
# use std::fmt;
# 
type Result<T> = std::result::Result<T, std::io::Error>;
# 
# pub trait Write {
#     fn write(&mut self, buf: &[u8]) -> Result<usize>;
#     fn flush(&mut self) -> Result<()>;
# 
#     fn write_all(&mut self, buf: &[u8]) -> Result<()>;
#     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Because this declaration is in the `std::io` module, we can use the fully
qualified alias `std::io::Result<T>`â€”that is, a `Result<T, E>` with the `E`
filled in as `std::io::Error`. The `Write` trait function signatures end up
looking like this:
-->
<p>Comme cette dÃ©claration est dans le module <code>std::io</code>, nous pouvons utiliser
l'alias <code>std::io::Result&lt;T&gt;</code> â€” qui est un <code>Result&lt;T, E&gt;</code> avec le <code>E</code> qui est
dÃ©jÃ  renseignÃ© comme Ã©tant un <code>std::io::Error</code>. Les fonctions du trait <code>Write</code>
ressemblent finalement Ã  ceciÂ :</p>
<!--
```rust
# use std::fmt;
# 
# type Result<T> = std::result::Result<T, std::io::Error>;
# 
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
The type alias helps in two ways: it makes code easier to write *and* it gives
us a consistent interface across all of `std::io`. Because itâ€™s an alias, itâ€™s
just another `Result<T, E>`, which means we can use any methods that work on
`Result<T, E>` with it, as well as special syntax like the `?` operator.
-->
<p>L'alias de type nous aide sur deux domainesÂ : il permet de faciliter l'Ã©criture
du code <em>et</em> il nous donne une interface uniforme pour tout <code>std::io</code>. Comme
c'est un alias, c'est simplement un autre <code>Result&lt;T, E&gt;</code>, ce qui signifie que
nous pouvons utiliser n'importe quelle mÃ©thode qui fonctionne avec
<code>Result&lt;T, E&gt;</code>, ainsi que les syntaxes spÃ©ciales comme l'opÃ©rateur <code>?</code>.</p>
<!--
### The Never Type that Never Returns
-->
<h3><a class="header" href="#le-type-jamais-qui-ne-retourna-pas-de-valeur" id="le-type-jamais-qui-ne-retourna-pas-de-valeur">Le type &quot;jamais&quot;, qui ne retourna pas de valeur</a></h3>
<!--
Rust has a special type named `!` thatâ€™s known in type theory lingo as the
*empty type* because it has no values. We prefer to call it the *never type*
because it stands in the place of the return type when a function will never
return. Here is an example:
-->
<p>Rust a un type spÃ©cial qui s'appelle <code>!</code> qui est connu dans le vocabulaire de
la thÃ©orie des types comme Ã©tant le <em>type vide</em> car il n'a pas de valeur. Nous
prÃ©fÃ©rons appeler cela le <em>type jamais</em> car il remplace le type de retour
lorsqu'une fonction ne va jamais retourner quelque chose. Voici un exempleÂ :</p>
<!--
```rust
fn bar() -> ! {
    // --snip--
#     panic!();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn bar() -&gt; ! {
    // -- partie masquÃ©e ici --
<span class="boring">    panic!();
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
This code is read as â€œthe function `bar` returns never.â€ Functions that return
never are called *diverging functions*. We canâ€™t create values of the type `!`
so `bar` can never possibly return.
-->
<p>Ce code peut Ãªtre interprÃ©tÃ© comme â€œla fonction <code>bar</code> qui ne retourne pas de
valeurâ€. Les fonctions qui ne retournent pas de valeur s'appellent des
<em>fonctions divergentes</em>. Nous ne pouvons pas crÃ©er de valeurs de type <code>!</code> donc
<code>bar</code> afin que <code>bar</code> ne puisse jamais retourner de valeur.</p>
<!--
But what use is a type you can never create values for? Recall the code from
Listing 2-5; weâ€™ve reproduced part of it here in Listing 19-26.
-->
<p>Mais Ã  quoi sert un type dont on ne peut jamais crÃ©er de valeurs ?
Souvenez-vous du code de l'encart 2-5Â ; nous avons reproduit une partie de
celui-ci dans l'encart 19-26.</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         // --snip--
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
# 
#         println!("You guessed: {}", guess);
# 
#         // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        // -- partie masquÃ©e ici --
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span>        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">        // -- partie masquÃ©e ici --
</span><span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagnÃ©Â !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-26: A `match` with an arm that ends in
`continue`</span>
-->
<p><span class="caption">Encart 19-26Â : un <code>match</code> avec une branche qui finit par
un <code>continue</code></span></p>
<!--
At the time, we skipped over some details in this code. In Chapter 6 in [â€œThe
`match` Control Flow Operatorâ€][the-match-control-flow-operator]<!-- ignore
-- > section, we discussed that `match` arms must all return the same type. So,
for example, the following code doesnâ€™t work:
-->
<p>A l'Ã©poque, nous avions sautÃ© quelques dÃ©tails dans ce code. Dans la section
<a href="ch06-02-match.html#la-structure-de-contr%C3%B4le-match">â€œLa structure de contrÃ´le
<code>match</code>â€</a><!-- ignore --> du chapitre 6, nous
avons vu que les branches d'un <code>match</code> doivent toutes retourner le mÃªme type.
Donc, par exemple, le code suivant ne fonctionne pasÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let guess = "3";
    let guess = match guess.trim().parse() {
        Ok(_) => 5,
        Err(_) => "hello",
    };
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let supposition = &quot;3&quot;;
</span>    let supposition = match supposition.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;salut&quot;,
    };
<span class="boring">}
</span></code></pre>
<pre><code class="language-rust ignore does_not_compile">let supposition = match supposition.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;salut&quot;,
}
</code></pre>
<!--
The type of `guess` in this code would have to be an integer *and* a string,
and Rust requires that `guess` have only one type. So what does `continue`
return? How were we allowed to return a `u32` from one arm and have another arm
that ends with `continue` in Listing 19-26?
-->
<p>Le type de <code>supposition</code> dans ce code devrait Ãªtre un entier <em>et</em> une chaÃ®ne de
caractÃ¨res, et Rust nÃ©cessite que <code>supposition</code> n'ait qu'un seul type possible.
Donc que retourne <code>continue</code>Â ? Pourquoi pouvons-nous retourner un <code>u32</code> dans
une branche et avoir une autre branche qui finit avec un <code>continue</code> dans
l'encart 19-26Â ?</p>
<!--
As you might have guessed, `continue` has a `!` value. That is, when Rust
computes the type of `guess`, it looks at both match arms, the former with a
value of `u32` and the latter with a `!` value. Because `!` can never have a
value, Rust decides that the type of `guess` is `u32`.
-->
<p>Comme vous l'avez devinÃ©, <code>continue</code> a une valeur <code>!</code>. Ainsi, lorsque Rust
calcule le type de <code>supposition</code>, il regarde les deux branches, la premiÃ¨re
avec une valeur <code>u32</code> et la seconde avec une valeur <code>!</code>. Comme <code>!</code> ne peut
jamais retourner de valeur, Rust dÃ©cide alors que le type de <code>supposition</code> est
<code>u32</code>.</p>
<!--
The formal way of describing this behavior is that expressions of type `!` can
be coerced into any other type. Weâ€™re allowed to end this `match` arm with
`continue` because `continue` doesnâ€™t return a value; instead, it moves control
back to the top of the loop, so in the `Err` case, we never assign a value to
`guess`.
-->
<p>Une faÃ§on classique de dÃ©crire ce comportement est de dire que les expressions
du type <code>!</code> peuvent Ãªtre transformÃ©es dans n'importe quel type. Nous pouvons
finir cette branche de <code>match</code> avec <code>continue</code> car <code>continue</code> ne retourne pas
de valeurÂ ; Ã  la place, il retourne le contrÃ´le en haut de la boucle, donc dans
le cas d'un <code>Err</code>, nous n'assignons jamais de valeur Ã  <code>supposition</code>.</p>
<!--
The never type is useful with the `panic!` macro as well. Remember the `unwrap`
function that we call on `Option<T>` values to produce a value or panic? Here
is its definition:
-->
<p>Ce type &quot;jamais&quot; est aussi utile avec la macro <code>panic!</code>. Vous souvenez-vous que
la fonction <code>unwrap</code> que nous appelons sur les valeurs <code>Option&lt;T&gt;</code> fournissent
une valeur, ou paniquentÂ ? Voici sa dÃ©finitionÂ :</p>
<!--
```rust,ignore
# enum Option<T> {
#     Some(T),
#     None,
# }
# 
# use crate::Option::*;
# 
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<!--
In this code, the same thing happens as in the `match` in Listing 19-26: Rust
sees that `val` has the type `T` and `panic!` has the type `!`, so the result
of the overall `match` expression is `T`. This code works because `panic!`
doesnâ€™t produce a value; it ends the program. In the `None` case, we wonâ€™t be
returning a value from `unwrap`, so this code is valid.
-->
<p>Dans ce code, il se passe la mÃªme chose que l'encart 19-26Â : Rust constate que
<code>val</code> est du type <code>T</code> et que <code>panic!</code> est du type <code>!</code>, donc le rÃ©sultat de
l'ensemble de l'expression <code>match</code> est <code>T</code>. Ce code fonctionne car <code>panic!</code> ne
produit pas de valeurÂ ; il termine le programme. Dans le cas d'un <code>None</code>, nous
ne retournons pas une valeur de <code>unwrap</code>, donc ce code est valide.</p>
<!--
One final expression that has the type `!` is a `loop`:
-->
<p>Une des expressions qui sont du type <code>!</code> est le <code>loop</code>Â :</p>
<!--
```rust,ignore
# fn main() {
    print!("forever ");

    loop {
        print!("and ever ");
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;pour toujours &quot;);

    loop {
        print!(&quot;et toujours &quot;);
    }
<span class="boring">}
</span></code></pre>
<!--
Here, the loop never ends, so `!` is the value of the expression. However, this
wouldnâ€™t be true if we included a `break`, because the loop would terminate
when it got to the `break`.
-->
<p>Ici, la boucle ne se termine jamais, donc <code>!</code> est la valeur de cette
expression. En revanche, cela ne sera pas vrai si nous utilisons un <code>break</code>,
car la boucle va s'arrÃªter lorsqu'elle rencontrera le <code>break</code>.</p>
<!--
### Dynamically Sized Types and the `Sized` Trait
-->
<h3><a class="header" href="#les-types-Ã -taille-dynamique-et-le-trait-sized" id="les-types-Ã -taille-dynamique-et-le-trait-sized">Les types Ã  taille dynamique et le trait <code>Sized</code></a></h3>
<!--
Due to Rustâ€™s need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of *dynamically sized types*. Sometimes referred to
as *DSTs* or *unsized types*, these types let us write code using values whose
size we can know only at runtime.
-->
<p>Vu qu'il est nÃ©cessaire pour Rust de connaÃ®tre certains dÃ©tails, comme la
quantitÃ© d'espace Ã  allouer Ã  une valeur d'un type donnÃ©, il y a un aspect de
ce systÃ¨me de type qui peut Ãªtre dÃ©routantÂ : le concept des <em>types Ã  taille
dynamique</em>. Parfois appelÃ©s <em>DST</em> (Dynamically Sized Types) ou <em>types sans
taille</em>, ces types nous permettent d'Ã©crire du code qui utilisent des valeurs
qui ne peuvent Ãªtre connues uniquement Ã  l'exÃ©cution.</p>
<!--
Letâ€™s dig into the details of a dynamically sized type called `str`, which
weâ€™ve been using throughout the book. Thatâ€™s right, not `&str`, but `str` on
its own, is a DST. We canâ€™t know how long the string is until runtime, meaning
we canâ€™t create a variable of type `str`, nor can we take an argument of type
`str`. Consider the following code, which does not work:
-->
<p>Voyons les dÃ©tails d'un type Ã  taille dynamique qui s'appelle <code>str</code>, que nous
avons utilisÃ© dans ce livre. Plus prÃ©cisÃ©ment <code>&amp;str</code>, car <code>str</code> en lui-mÃªme est
un DST. Nous ne connaÃ®tre la longueur de la chaÃ®ne de caractÃ¨re qu'Ã 
l'exÃ©cution, ce qui signifie que nous ne pouvons pas ni crÃ©er une variable de
type <code>str</code>, ni prendre prendre en argument un type <code>str</code>. Imaginons le code
suivant, qui ne devrait pas fonctionnerÂ :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Salut tout le mondeÂ !&quot;;
    let s2: str = &quot;Comment Ã§a vaÂ ?&quot;;
<span class="boring">}
</span></code></pre>
<!--
Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two `str` values would need to take up the
same amount of space. But they have different lengths: `s1` needs 12 bytes of
storage and `s2` needs 15. This is why itâ€™s not possible to create a variable
holding a dynamically sized type.
-->
<p>Rust a besoin de savoir combien de mÃ©moire allouer pour chaque valeur d'un type
donnÃ©, et toutes les valeurs de ce type doivent utiliser la mÃªme quantitÃ© de
mÃ©moire. Si Rust nous aurait autorisÃ© Ã  Ã©crire ce code, ces deux valeurs <code>str</code>
devraient occuper la mÃªme quantitÃ© de mÃ©moire. Mais elles ont deux longueurs
diffÃ©rentesÂ : <code>s1</code> prend 21 octets en mÃ©moire alors que <code>s2</code> en a besoin de 15.
C'est pourquoi il est impossible de crÃ©er une variable qui stocke un type Ã 
taille dynamique.</p>
<!--
So what do we do? In this case, you already know the answer: we make the types
of `s1` and `s2` a `&str` rather than a `str`. Recall that in the [â€œString
Slicesâ€][string-slices]<!-- ignore -- > section of Chapter 4, we said the slice
data structure stores the starting position and the length of the slice.
-->
<p>Donc qu'est-ce qu'on peut faireÂ ? Dans ce cas, vous connaissez dÃ©jÃ  la rÃ©ponseÂ :
nous faisons en sorte que le type de <code>s1</code> et <code>s2</code> soit <code>&amp;str</code> plutÃ´t que <code>str</code>.
Souvenez-vous que dans la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res">â€œLes slices de chaÃ®nes de caractÃ¨resâ€</a><!-- ignore -->
du chapitre 4, nous avions dit que la structure de donnÃ©es slice stockait
l'emplacement de dÃ©part et la longueur de la slice.</p>
<!--
So although a `&T` is a single value that stores the memory address of where
the `T` is located, a `&str` is *two* values: the address of the `str` and its
length. As such, we can know the size of a `&str` value at compile time: itâ€™s
twice the length of a `usize`. That is, we always know the size of a `&str`, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.
-->
<p>Aussi, bien qu'un <code>&amp;T</code> soit une seule valeur qui stocke l'adresse mÃ©moire d'oÃ¹
se trouve le <code>T</code>, un <code>&amp;str</code> reprÃ©sente <em>deux</em> valeursÂ : l'adresse du <code>str</code> et sa
longueur. Ainsi, nous pouvons connaÃ®tre la taille d'une valeur <code>&amp;str</code> Ã  la
compilationÂ : elle vaut deux fois la taille d'un <code>usize</code>. Ce faisant, nous
connaissons toujours la taille d'un <code>&amp;str</code>, peu importe la longueur de la chaÃ®ne
de caractÃ¨res sur laquelle cela pointe. GÃ©nÃ©ralement, c'est comme cela que les
types Ã  taille dynamique sont utilisÃ©s en RustÂ : ils ont des mÃ©tadonnÃ©es
supplÃ©mentaires qui stockent la taille des informations dynamiques. La rÃ¨gle
d'or des types Ã  taille dynamique est que nous devons toujours placer les
valeurs Ã  types Ã  taille dynamique dans une sorte de pointeur.</p>
<!--
We can combine `str` with all kinds of pointers: for example, `Box<str>` or
`Rc<str>`. In fact, youâ€™ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the [â€œUsing Trait Objects That
Allow for Values of Different
Typesâ€][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` (`Rc<dyn
Trait>` would work too).
-->
<p>Nous pouvons combiner <code>str</code> avec n'importe quel type de pointeurÂ : par exemple,
<code>Box&lt;str&gt;</code> ou <code>Rc&lt;str&gt;</code>. En fait, vous avez vu cela dÃ©jÃ  auparavant mais avec un
type Ã  taille dynamiqueÂ : les traits. Chaque trait est un type Ã  taille
dynamique auquel nous pouvons nous rÃ©fÃ©rer en utilisant le nom du trait. Dans
<a href="ch17-02-trait-objects.html">une section</a><!--
ignore --> du chapitre 17, nous avions mentionnÃ© que pour utiliser les traits
comme des objets traits, nous devions les utiliser avec un pointeur, comme le
<code>&amp;dyn Trait</code> ou <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> devrait aussi fonctionner).</p>
<!--
To work with DSTs, Rust has a particular trait called the `Sized` trait to
determine whether or not a typeâ€™s size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on `Sized` to every generic function.
That is, a generic function definition like this:
-->
<p>Pour pouvoir travailler avec les DST, Rust a un trait particulier <code>Sized</code> pour
dÃ©terminer si oui ou non la taille d'un type est connue Ã  la compilation. Ce
trait est automatiquement implÃ©mentÃ© sur tout ce qui a une taille connue Ã  la
compilation. De plus, Rust ajoute implicitement le trait liÃ© <code>Sized</code> sur chaque
fonction gÃ©nÃ©rique. Ainsi, la dÃ©finition d'une fonction gÃ©nÃ©rique comme
celle-ciÂ :</p>
<!--
```rust,ignore
fn generic<T>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T&gt;(t: T) {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
is actually treated as though we had written this:
-->
<p>... est en rÃ©alitÃ© traitÃ©e comme si nous avions Ã©cris ceciÂ :</p>
<!--
```rust,ignore
fn generic<T: Sized>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: Sized&gt;(t: T) {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:
-->
<p>Par dÃ©faut, les fonctions gÃ©nÃ©riques vont fonctionner uniquement sur les types
qui ont une taille connue Ã  la compilation. Cependant, vous pouvez utiliser la
syntaxe spÃ©ciale suivante pour Ã©viter cette restrictionÂ :</p>
<!--
```rust,ignore
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: ?Sized&gt;(t: &amp;T) {
    // -- partie masquÃ©e ici --
}
</code></pre>
<!--
A trait bound on `?Sized` is the opposite of a trait bound on `Sized`: we would
read this as â€œ`T` may or may not be `Sized`.â€ This syntax is only available for
`Sized`, not any other traits.
-->
<p>Le trait liÃ© <code>?Sized</code> est l'opposÃ© du trait liÃ© <code>Sized</code>Â : nous pourrions lire
ceci comme Ã©tant â€œ<code>T</code> peut Ãªtre ou non un <code>Sized</code>â€. Cette syntaxe est disponible
uniquement pour <code>Sized</code>, et non pas pour les autres traits.</p>
<!--
Also note that we switched the type of the `t` parameter from `T` to `&T`.
Because the type might not be `Sized`, we need to use it behind some kind of
pointer. In this case, weâ€™ve chosen a reference.
-->
<p>Remarquez aussi que nous avons changÃ© le type du paramÃ¨tre <code>t</code> de <code>T</code> en <code>&amp;T</code>.
Comme ce type pourrait ne pas Ãªtre un <code>Sized</code>, nous devons l'utiliser avec
quelque chose qui sert de pointeur. Dans ce cas, nous avons choisi une
rÃ©fÃ©rence.</p>
<!--
Next, weâ€™ll talk about functions and closures!
-->
<p>Dans la partie suivante, nous allons parler des fonctions et des fermeturesÂ !</p>
<!--
[encapsulation-that-hides-implementation-details]:
ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details
[string-slices]: ch04-03-slices.html#string-slices
[the-match-control-flow-operator]:
ch06-02-match.html#the-match-control-flow-operator
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[using-the-newtype-pattern]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--48" id="-attention-peinture-fraÃ®che--48">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/219">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Functions and Closures
-->
<h2><a class="header" href="#les-fonctions-et-fermetures-avancÃ©es" id="les-fonctions-et-fermetures-avancÃ©es">Les fonctions et fermetures avancÃ©es</a></h2>
<!--
Next, weâ€™ll explore some advanced features related to functions and
closures, which include function pointers and returning closures.
-->
<p>Maintenant, nous allons explorer quelques fonctionnalitÃ©s avancÃ©es liÃ©es aux
fonctions et aux fermetures, comme les pointeurs de fonctions et retourner des
fermetures.</p>
<!--
### Function Pointers
-->
<h3><a class="header" href="#pointeurs-de-fonctions" id="pointeurs-de-fonctions">Pointeurs de fonctions</a></h3>
<!--
Weâ€™ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function youâ€™ve already defined rather than defining a new closure. Doing this
with function pointers will allow you to use functions as arguments to other
functions. Functions coerce to the type `fn` (with a lowercase f), not to be
confused with the `Fn` closure trait. The `fn` type is called a *function
pointer*. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-27.
-->
<p>Nous avons dÃ©jÃ  vu comment envoyer des fermetures dans des fonctionsÂ ; mais vous
pouvez aussi envoyer des fonctions classiques dans d'autres fonctionsÂ ! Cette
technique est utile lorsque vous souhaitez envoyer une fonction que vous avez
dÃ©jÃ  dÃ©finie plutÃ´t que de dÃ©finir une nouvelle fermeture. Vous pouvez faire
ceci avec des pointeurs de fonctions, qui vous permettent d'utiliser des
fonctions en argument d'autres fonctions. Les fonctions nÃ©cessitent le type <code>fn</code>
(avec un f minuscule), Ã  ne pas confondre avec le trait de fermeture <code>Fn</code>. Le
type <code>fn</code> s'appelle un <em>pointeur de fonction</em>. La syntaxe pour renseigner qu'un
paramÃ¨tre est un pointeur de fonction ressemble Ã  celle des fermetures, comme
vous pouvez le voir dans l'encart 19-27.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}

fn le_faire_deux_fois(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let reponse = le_faire_deux_fois(ajouter_un, 5);

    println!(&quot;La rÃ©ponse estÂ : {}&quot;, reponse);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-27: Using the `fn` type to accept a function
pointer as an argument</span>
-->
<p><span class="caption">Encart 19-27Â : utiliser le type <code>fn</code> pour accepter un
pointeur de fonction en argument</span></p>
<!--
This code prints `The answer is: 12`. We specify that the parameter `f` in
`do_twice` is an `fn` that takes one parameter of type `i32` and returns an
`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can pass
the function name `add_one` as the first argument to `do_twice`.
-->
<p>Ce code affiche <code>La rÃ©ponse estÂ : 12</code>. Nous avons prÃ©cisÃ© que le paramÃ¨tre <code>f</code>
dans <code>le_faire_deux_fois</code> est une <code>fn</code> qui prend en argument un paramÃ¨tre du
type <code>i32</code> et retourne un <code>i32</code>. Nous pouvons ensuite appeler <code>f</code> dans le corps
de <code>le_faire_deux_fois</code>. Dans <code>main</code>, nous pouvons envoyer le nom de la fonction
<code>add_one</code> dans le premier argument de <code>le_faire_deux_fois</code>.</p>
<!--
Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as the
parameter type directly rather than declaring a generic type parameter with one
of the `Fn` traits as a trait bound.
-->
<p>Contrairement aux fermetures, <code>fn</code> est un type plutÃ´t qu'un trait, donc nous
renseignons <code>fn</code> directement comme type de paramÃ¨tre plutÃ´t que de dÃ©clarer un
paramÃ¨tre de type gÃ©nÃ©rique avec un des traits <code>Fn</code> liÃ©s.</p>
<!--
Function pointers implement all three of the closure traits (`Fn`, `FnMut`, and
`FnOnce`), so you can always pass a function pointer as an argument for a
function that expects a closure. Itâ€™s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.
-->
<p>Les pointeurs de fonctions implÃ©mentent tous les trois traits de fermeture
(<code>Fn</code>, <code>FnMut</code>, et <code>FnOnce</code>), afin que vous puissiez toujours envoyer un
pointeur de fonction en argument d'une fonction qui attendait une fermeture. Il
vaut mieux Ã©crire des fonctions qui utilisent un type gÃ©nÃ©rique et un des traits
de fermetures afin que vos fonctions puissent accepter soit des fonctions, soit
des fermetures.</p>
<!--
An example of where you would want to only accept `fn` and not closures is when
interfacing with external code that doesnâ€™t have closures: C functions can
accept functions as arguments, but C doesnâ€™t have closures.
-->
<p>Un exemple dans lequel vous voudriez accepter uniquement des <code>fn</code>, et non pas
des fermetures, est lorsque vous vous interfacez avec du code externe qui n'a
pas de fermeturesÂ : les fonctions C peuvent accepter des fonctions en argument,
mais le C n'a pas fermetures.</p>
<!--
As an example of where you could use either a closure defined inline or a named
function, letâ€™s look at a use of `map`. To use the `map` function to turn a
vector of numbers into a vector of strings, we could use a closure, like this:
-->
<p>Un autre exemple dans lequel vous pouvez utiliser soit une fermeture dÃ©finie en
une seule ligne ou le nom d'une fonction, est lorsque vous utilisez <code>map</code>. Pour
utiliser la fonction <code>map</code> pour transformer un vecteur de nombres en vecteur de
chaÃ®nes de caractÃ¨res, nous pouvons utiliser une fermeture, comme ceciÂ :</p>
<!--
```rust
# fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let liste_de_nombres = vec![1, 2, 3];
    let liste_de_chaines: Vec&lt;String&gt; =
        liste_de_nombres.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could name a function as the argument to `map` instead of the closure,
like this:
-->
<p>Ou alors nous pouvons utiliser le nom d'une fonction en argument de <code>map</code> plutÃ´t
qu'une fermeture, comme ceciÂ :</p>
<!--
```rust
# fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(ToString::to_string).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let liste_de_nombres = vec![1, 2, 3];
    let liste_de_chaines: Vec&lt;String&gt; =
        liste_de_nombres.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Note that we must use the fully qualified syntax that we talked about earlier
in the [â€œAdvanced Traitsâ€][advanced-traits]<!-- ignore -- > section because
there are multiple functions available named `to_string`. Here, weâ€™re using the
`to_string` function defined in the `ToString` trait, which the standard
library has implemented for any type that implements `Display`.
-->
<p>Notez que nous devons utiliser la syntaxe complÃ¨te que nous avons vu
prÃ©cÃ©demment dans <a href="ch19-03-advanced-traits.html">la section prÃ©cÃ©dente</a><!-- ignore --> car il
y a plusieurs fonctions de disponibles qui s'appellent <code>to_string</code>. Ici, nous
utilisons la fonction <code>to_string</code> dÃ©finie dans le trait <code>ToString</code>, que la
bibliothÃ¨que standard a implÃ©mentÃ© sur chaque type qui implÃ©mente <code>Display</code>.</p>
<!--
We have another useful pattern that exploits an implementation detail of tuple
structs and tuple-struct enum variants. These types use `()` as initializer
syntax, which looks like a function call. The initializers are actually
implemented as functions returning an instance thatâ€™s constructed from their
arguments. We can use these initializer functions as function pointers that
implement the closure traits, which means we can specify the initializer
functions as arguments for methods that take closures, like so:
-->
<p>Nous avons un autre motif utile qui exploite un dÃ©tail de l'implÃ©mentation des
structures tuple et des variantes d'Ã©numÃ©rations de structures de tuples. Ces
types utilisent <code>()</code> comme syntaxe d'initialisation, qui ressemble Ã  un appel de
fonction. Les initialisateurs sont actuellement implÃ©mentÃ©s comme Ã©tant des
fonctions qui retournent une instance qui est construite avec leurs propres
arguments. Nous pouvons utiliser ces fonctions d'initialisation comme Ã©tant des
pointeurs de fonctions qui implÃ©mentent les traits de fermetures, ce qui
signifie que nous pouvons renseigner les fonctions d'initialisation en argument
de mÃ©thodes qui prennent en argument des fermetures, comme ceciÂ :</p>
<!--
```rust
# fn main() {
    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Statut {
        Valeur(u32),
        Stop,
    }

    let liste_de_statuts: Vec&lt;Statut&gt; = (0u32..20).map(Statut::Valeur).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Here we create `Status::Value` instances using each `u32` value in the range
that `map` is called on by using the initializer function of `Status::Value`.
Some people prefer this style, and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.
-->
<p>Nous avons ici crÃ©Ã© des instances de <code>Statut::Valeur</code> en utilisant chacune des
valeurs <code>u32</code> prÃ©sentes dans l'intervalle sur laquelle nous appelons <code>map</code> en
utilisant la fonction d'initialisation de <code>Statut::Valeur</code>. Certaines personnes
prÃ©fÃ¨rent ce style, et d'autres prÃ©fÃ¨rent utiliser des fermetures. Ces deux cas
se compilent pour faire la mÃªme chose, donc vous pouvez utiliser le style qui
vous conviens le plus.</p>
<!--
### Returning Closures
-->
<h3><a class="header" href="#retourner-des-fermetures" id="retourner-des-fermetures">Retourner des fermetures</a></h3>
<!--
Closures are represented by traits, which means you canâ€™t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. But you canâ€™t do that with closures because they donâ€™t have a
concrete type that is returnable; youâ€™re not allowed to use the function
pointer `fn` as a return type, for example.
-->
<p>Les fermetures sont reprÃ©sentÃ©es par des traits, ce qui signifie que vous ne
pouvez pas retourner directement des fermetures. Dans la plupart des cas oÃ¹ vous
voudrez retourner un trait, vous pouvez utiliser Ã  la place le type concret qui
implÃ©mente le trait comme valeur de retour de la fonction. Mais vous ne pouvez
pas faire ceci avec les fermetures car elles n'ont pas de type concret qu'elles
peuvent retournerÂ ; vous n'Ãªtes pas autorisÃ© Ã  utiliser le pointeur de fonction
<code>fn</code> comme type de retour, par exemple.</p>
<!--
The following code tries to return a closure directly, but it wonâ€™t compile:
-->
<p>Le code suivant essaye de retourner directement une fermeture, mais ne peut pas
se compilerÂ :</p>
<!--
```rust,ignore,does_not_compile
fn returns_closure() -> dyn Fn(i32) -> i32 {
    |x| x + 1
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<!--
The compiler error is as follows:
-->
<p>Voici l'erreur de compilationÂ :</p>
<!--
```console
$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0277]: the size for values of type `(dyn std::ops::Fn(i32) -> i32 + 'static)` cannot be known at compilation time
 -- > src/lib.rs:1:25
  |
1 | fn returns_closure() -> dyn Fn(i32) -> i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -> i32 + 'static)`
  = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>
  = note: the return type of a function must have a statically known size

error[E0308]: mismatched types
 -- > src/lib.rs:2:5
  |
1 | fn returns_closure() -> dyn Fn(i32) -> i32 {
  |                         ------------------ expected `(dyn std::ops::Fn(i32) -> i32 + 'static)` because of return type
2 |     |x| x + 1
  |     ^^^^^^^^^ expected trait `std::ops::Fn`, found closure
  |
  = note: expected trait object `(dyn std::ops::Fn(i32) -> i32 + 'static)`
                  found closure `[closure@src/lib.rs:2:5: 2:14]`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `functions-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0277]: the size for values of type `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` cannot be known at compilation time
 --&gt; src/lib.rs:1:25
  |
1 | fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
  |                                ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: the return type of a function must have a statically known size

error[E0308]: mismatched types
 --&gt; src/lib.rs:2:5
  |
1 | fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
  |                                ------------------ expected `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` because of return type
2 |     |x| x + 1
  |     ^^^^^^^^^ expected trait `std::ops::Fn`, found closure
  |
  = note: expected trait object `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
                  found closure `[closure@src/lib.rs:2:5: 2:14]`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `functions-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error references the `Sized` trait again! Rust doesnâ€™t know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:
-->
<p>Encore l'erreur du trait <code>Sized</code>Â ! Rust ne sait pas combien de mÃ©moire sera
nÃ©cessaire pour stocker la fermeture. Nous avons vu une solution Ã  ce problÃ¨me
prÃ©cÃ©demment. Nous pouvons utiliser un objet traitÂ :</p>
<!--
```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn retourne_une_fermeture() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will compile just fine. For more about trait objects, refer to the
section [â€œUsing Trait Objects That Allow for Values of Different
Typesâ€][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > in Chapter 17.
-->
<p>Ce code va se compiler Ã  merveille. Pour en savoir plus sur les objets trait,
rendez-vous
<a href="ch17-02-trait-objects.html">Ã  la section</a><!--
ignore --> du chapitre 17.</p>
<!--
Next, letâ€™s look at macros!
-->
<p>Maintenant, penchons-nous sur les macrosÂ !</p>
<!--
[advanced-traits]:
ch19-03-advanced-traits.html#advanced-traits
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--49" id="-attention-peinture-fraÃ®che--49">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/212">Pull Request</a>.</p>
</blockquote>
<!--
## Macros
-->
<h2><a class="header" href="#les-macros" id="les-macros">Les macros</a></h2>
<!--
Weâ€™ve used macros like `println!` throughout this book, but we havenâ€™t fully
explored what a macro is and how it works. The term *macro* refers to a family
of features in Rust: *declarative* macros with `macro_rules!` and three kinds
of *procedural* macros:
-->
<p>Nous avons dÃ©jÃ  utilisÃ© des macros tout au long de ce livre, comme <code>println!</code>,
mais nous n'avons pas explorÃ© en profondeur ce qu'est une macro et comment
elles fonctionnent. Le terme <em>macro</em> revoit Ã  une famille de fonctionnalitÃ©s de
RustÂ : les macros <em>dÃ©claratives</em> avec <code>macro_rules!</code> et trois types de macros
<em>procÃ©durales</em>Â :</p>
<!--
* Custom `#[derive]` macros that specify code added with the `derive` attribute
  used on structs and enums
* Attribute-like macros that define custom attributes usable on any item
* Function-like macros that look like function calls but operate on the tokens
  specified as their argument
-->
<ul>
<li>Des macros <code>#[derive]</code> personnalisÃ©es qui renseigne du code ajoutÃ© grÃ¢ce Ã 
l'attribut <code>derive</code> utilisÃ© sur les structures et les Ã©numÃ©rations</li>
<li>Les macros qui ressemblent Ã  des attributs qui dÃ©finissent des attributs
personnalisÃ©s qui sont utilisables sur n'importe quel Ã©lÃ©ment</li>
<li>Les macros qui ressemblent Ã  des fonctions mais qui opÃ¨rent sur les Ã©lÃ©ments
renseignÃ©s en argument</li>
</ul>
<!--
Weâ€™ll talk about each of these in turn, but first, letâ€™s look at why we even
need macros when we already have functions.
-->
<p>Nous allons voir chacune d'entre elles Ã  leur tour, mais avant, posons-nous la
question de pourquoi nous avons besoin de macros alors que nous avons dÃ©jÃ  les
fonctions.</p>
<!--
### The Difference Between Macros and Functions
-->
<h3><a class="header" href="#la-diffÃ©rence-entre-les-macros-et-les-fonctions" id="la-diffÃ©rence-entre-les-macros-et-les-fonctions">La diffÃ©rence entre les macros et les fonctions</a></h3>
<!--
Fundamentally, macros are a way of writing code that writes other code, which
is known as *metaprogramming*. In Appendix C, we discuss the `derive`
attribute, which generates an implementation of various traits for you. Weâ€™ve
also used the `println!` and `vec!` macros throughout the book. All of these
macros *expand* to produce more code than the code youâ€™ve written manually.
-->
<p>Essentiellement, les macros sont une faÃ§on d'Ã©crire du code qui Ã©crit un autre
code, ce qui s'appelle la <em>mÃ©taprogrammation</em>. Dans l'annexe C, nous verrons
l'attribut <code>derive</code>, qui gÃ©nÃ¨re une implÃ©mentation de diffÃ©rents traits pour
vous. Nous avons aussi utilisÃ© les macros <code>println!</code> et <code>vec!</code> dans ce livre.
Toutes ces macros <em>se dÃ©ploient</em> pour produire plus de code que celui que vous
avez Ã©crit manuellement.</p>
<!--
Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions donâ€™t.
-->
<p>La mÃ©taprogrammation est utile pour rÃ©duire la quantitÃ© de code que vous avez Ã 
Ã©crire et Ã  maintenir, ce qui est aussi un des rÃ´les des fonctions. Cependant,
les macros ont quelques pouvoirs en plus que les fonctions n'ont pas.</p>
<!--
A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call `println!("hello")` with one argument or
`println!("hello {}", name)` with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function canâ€™t, because it gets
called at runtime and a trait needs to be implemented at compile time.
-->
<p>La signature d'une fonction doit dÃ©clarer le nombre et le type de paramÃ¨tres
qu'Ã  cette fonction. Les macros, d'un autre cÃ´tÃ©, peuvent prendre un nombre
variable de paramÃ¨tresÂ : nous pouvons faire appel Ã  <code>println!(&quot;salut&quot;)</code> avec un
seul argument, ou <code>println!(&quot;salut {}&quot;, nom)</code> avec deux arguments. Aussi, les
macros se dÃ©ploient avant que le compilateur interprÃ¨te la signification du
code, donc une macro peut, par exemple, implÃ©menter un trait sur un type donnÃ©.
Une fonction ne peut pas le faire, car elle est exÃ©cutÃ©e Ã  l'exÃ©cution et un
trait doit Ãªtre implÃ©mentÃ© Ã  la compilation.</p>
<!--
The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because youâ€™re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.
-->
<p>Le dÃ©savantage d'implÃ©menter une macro par rapport Ã  une fonction est que les
dÃ©finitions de macros sont plus complexes que les dÃ©finitions de fonction car
vous Ã©crivez du code Rust qui Ã©crit lui-mÃªme du code Rust. A cause de cette
approche, les dÃ©finitions de macro sont gÃ©nÃ©ralement plus difficiles Ã  lire,
comprendre et maintenir que les dÃ©finitions de fonctions.</p>
<!--
Another important difference between macros and functions is that you must
define macros or bring them into scope *before* you call them in a file, as
opposed to functions you can define anywhere and call anywhere.
-->
<p>Une autre diffÃ©rence importante entre les macros et les fonctions est que vous
devez dÃ©finir les macros ou les importer dans la portÃ©e <em>avant</em> de les utiliser
dans le fichier, contrairement aux fonctions que vous pouvez dÃ©finir n'importe
oÃ¹ et y faire appel n'importe oÃ¹.</p>
<!--
### Declarative Macros with `macro_rules!` for General Metaprogramming
-->
<h3><a class="header" href="#les-macros-dÃ©claratives-avec-macro_rules-pour-la-mÃ©taprogrammation-gÃ©nÃ©rale" id="les-macros-dÃ©claratives-avec-macro_rules-pour-la-mÃ©taprogrammation-gÃ©nÃ©rale">Les macros dÃ©claratives avec <code>macro_rules!</code> pour la mÃ©taprogrammation gÃ©nÃ©rale</a></h3>
<!--
The most widely used form of macros in Rust is *declarative macros*. These are
also sometimes referred to as â€œmacros by example,â€ â€œ`macro_rules!` macros,â€ or
just plain â€œmacros.â€ At their core, declarative macros allow you to write
something similar to a Rust `match` expression. As discussed in Chapter 6,
`match` expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.
-->
<p>La forme la plus utilisÃ©e de macro en Rust est la <em>macro dÃ©clarative</em>. Elles
sont parfois appelÃ©es â€œmacros dÃ©finies par un exempleâ€,
â€œmacros <code>macro_rules!</code>â€, ou simplement â€œmacrosâ€. Au fond, les macros
dÃ©claratives vous permettent d'Ã©crire quelque chose de similaire Ã  une
expression <code>match</code> de Rust. Comme nous l'avons vu au chapitre 6, les
expressions <code>match</code> sont des structures de contrÃ´le qui prennent en argument
une expression, compare la valeur qui en rÃ©sulte avec les motifs, et ensuite
exÃ©cute le code associÃ© au motif qui correspond. Les macros comparent elles
aussi une valeur avec des motifs qui sont associÃ©s Ã  code particulierÂ : dans
cette situation, la valeur est littÃ©ralement le code source Rust envoyÃ© Ã  la
macroÂ ; les motifs sont comparÃ©s avec la structure de ce code sourceÂ ; et le
code associÃ© Ã  chaque motif vient remplacer le code passÃ© Ã  la macro, lorsqu'il
correspond. Tout ceci se passe lors de la compilation.</p>
<!--
To define a macro, you use the `macro_rules!` construct. Letâ€™s explore how to
use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8
covered how we can use the `vec!` macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:
-->
<p>Pour dÃ©finir une macro, il faut utiliser la construction <code>macro_rules!</code>.
Explorons l'utilisation de <code>macro_rules!</code> en observant comment la macro <code>vec!</code>
est dÃ©finie. Le chapitre 8 nous a permis de comprendre comment utiliser la
macro <code>vec!</code> pour crÃ©er un nouveau vecteur avec des valeurs prÃ©cises. Par
exemple, la macro suivante crÃ©e un nouveau vecteur qui contient trois entiersÂ :</p>
<!--
```rust
let v: Vec<u32> = vec![1, 2, 3];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
We could also use the `vec!` macro to make a vector of two integers or a vector
of five string slices. We wouldnâ€™t be able to use a function to do the same
because we wouldnâ€™t know the number or type of values up front.
-->
<p>Nous aurions pu aussi utiliser la macro <code>vec!</code> pour crÃ©er un vecteur de deux
entiers ou un vecteur de cinq slices de chaÃ®nes de caractÃ¨res. Nous n'aurions
pas pu utiliser une fonction pour faire la mÃªme chose car nous n'aurions pas pu
connaÃ®tre le nombre ou le type de valeurs au dÃ©part.</p>
<!--
Listing 19-28 shows a slightly simplified definition of the `vec!` macro.
-->
<p>L'encart 19-28 montre une dÃ©finition lÃ©gÃ¨rement simplifiÃ©e de la macro <code>vec!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-28: A simplified version of the `vec!` macro
definition</span>
-->
<p><span class="caption">Encart 19-28Â : une version simplifiÃ©e de la dÃ©finition de
la macro <code>vec!</code></span></p>
<!--
> Note: The actual definition of the `vec!` macro in the standard library
> includes code to preallocate the correct amount of memory up front. That code
> is an optimization that we donâ€™t include here to make the example simpler.
-->
<blockquote>
<p>RemarqueÂ : la dÃ©finition actuelle de la macro <code>vec!</code> de la bibliothÃ¨que
standard embarque du code pour prÃ©-allouer la bonne quantitÃ© de mÃ©moire en
amont. Ce code est une optimisation que nous n'allons pas intÃ©grer ici pour
simplifier l'exemple.</p>
</blockquote>
<!--
The `#[macro_export]` annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro canâ€™t be brought into scope.
-->
<p>L'annotation <code>#[macro_export]</code> indique que cette macro doit Ãªtre disponible Ã 
chaque fois que la crate dans laquelle la macro est dÃ©finie est importÃ©e dans
la portÃ©e. Sans cette annotation, la macro ne pourrait pas Ãªtre importÃ©e dans
la portÃ©e.</p>
<!--
We then start the macro definition with `macro_rules!` and the name of the
macro weâ€™re defining *without* the exclamation mark. The name, in this case
`vec`, is followed by curly brackets denoting the body of the macro definition.
-->
<p>Ensuite, nous commenÃ§ons la dÃ©finition de la macro avec <code>macro_rules!</code> suivi du
nom de la macro que nous dÃ©finissons <em>sans</em> le point d'exclamation. Le nom, qui
dans ce cas est <code>vec</code>, est suivi par des accolades indiquant le corps de la
dÃ©finition de la macro.</p>
<!--
The structure in the `vec!` body is similar to the structure of a `match`
expression. Here we have one arm with the pattern `( $( $x:expr ),* )`,
followed by `=>` and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.
-->
<p>La structure dans le corps de <code>vec!</code> ressemble Ã  la structure d'une expression
<code>match</code>. Ici nous avons une branche avec le motif <code>( $( $x:expr ), * )</code>, suivi
par <code>=&gt;</code> et le code du bloc associÃ© Ã  ce motif. Si le motif correspond, le bloc
de code associÃ© sera dÃ©ployÃ©. Etant donnÃ© que c'est le seul motif dans cette
macro, il n'y a qu'une seule bonne faÃ§on d'y correspondreÂ ; tout autre motif va
dÃ©boucher sur une erreur. Des macros plus complexes auront plus qu'une seule
branche.</p>
<!--
Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Letâ€™s walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see [the reference].
-->
<p>La syntaxe correcte pour un motif dans les dÃ©finitions de macros est diffÃ©rente
de la syntaxe de motif que nous avons vu au chapitre 18 car les motifs de
macros sont comparÃ©s Ã  des structures de code Rust plutÃ´t qu'Ã  des valeurs.
Examinons la signification des Ã©lÃ©ments du motif de l'encart 19-28Â ; pour voir
l'intÃ©gralitÃ© de la syntaxe du motif de la macro, rendez-vous
<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Ã  la documentation</a>.</p>
<!--
[the reference]: ../reference/macros-by-example.html
-->
<!--
First, a set of parentheses encompasses the whole pattern. A dollar sign (`$`)
is next, followed by a set of parentheses that captures values that match the
pattern within the parentheses for use in the replacement code. Within `$()` is
`$x:expr`, which matches any Rust expression and gives the expression the name
`$x`.
-->
<p>PremiÃ¨rement, un jeu de parenthÃ¨ses englobent l'intÃ©gralitÃ© du motif. Ensuite
vient le symbole dollar (<code>$</code>), suivi par un jeu de parenthÃ¨ses qui capturent les
valeurs qui correspondent au motif entre les parenthÃ¨ses pour les utiliser dans
le code de remplacement. A l'intÃ©rieur du <code>$()</code> nous avons <code>$x:expr</code>, qui
correspond Ã  n'importe quelle expression Rust et donne le nom <code>$x</code> Ã 
l'expression.</p>
<!--
The comma following `$()` indicates that a literal comma separator character
could optionally appear after the code that matches the code in `$()`. The `*`
specifies that the pattern matches zero or more of whatever precedes the `*`.
-->
<p>La virgule qui suit le <code>$()</code> signifie que cette virgule littÃ©rale comme
caractÃ¨re littÃ©ral de sÃ©paration peut optionnellement apparaÃ®tre aprÃ¨s le code
qui correspond au code du <code>$()</code>. Le <code>*</code> informe que ce motif correspond Ã  zÃ©ro
ou plus Ã©lÃ©ments rÃ©pÃ©tÃ©s correspondant Ã  ce qui prÃ©cÃ¨de ce <code>*</code>.</p>
<!--
When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three
times with the three expressions `1`, `2`, and `3`.
-->
<p>Lorsque nous faisons appel Ã  cette macro avec <code>vec![1, 2, 3];</code>, le motif <code>$x</code>
correspond Ã  trois reprises avec les trois expressions <code>1</code>, <code>2</code>, et <code>3</code>.</p>
<!--
Now letâ€™s look at the pattern in the body of the code associated with this arm:
`temp_vec.push()` within `$()*` is generated for each part that matches `$()`
in the pattern zero or more times depending on how many times the pattern
matches. The `$x` is replaced with each expression matched. When we call this
macro with `vec![1, 2, 3];`, the code generated that replaces this macro call
will be the following:
-->
<p>Maintenant, penchons-nous sur le motif dans le corps du code associÃ© Ã  cette
brancheÂ : <code>temp_vec.push()</code> dans le <code>$()*</code> est gÃ©nÃ©rÃ© pour chacune des parties
qui correspondent au <code>$()</code> dans le motif pour zÃ©ro ou plus de fois, en fonction
de combien de fois le motif correspond. Le <code>$x</code> est remplacÃ© par chaque
expression qui correspond. Lorsque nous faisons appel Ã  cette macro avec
<code>vec![1, 2, 3];</code>, le code gÃ©nÃ©rÃ© qui remplace cet appel de macro ressemblera Ã 
ceciÂ :</p>
<!--
```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```
-->
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<!--
Weâ€™ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.
-->
<p>Nous avons dÃ©fini une macro qui peut prendre n'importe quel nombre d'arguments
de n'importe quel type et qui peut gÃ©nÃ©rer du code pour crÃ©er un vecteur qui
contient les Ã©lÃ©ments renseignÃ©s.</p>
<!--
There are some strange edge cases with `macro_rules!`. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, `macro_rules!` will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will *use* macros more than *write* macros, we wonâ€™t discuss
`macro_rules!` any further. To learn more about how to write macros, consult
the online documentation or other resources, such as [â€œThe Little Book of Rust
Macrosâ€][tlborm].
-->
<p>Il subsiste quelques cas marginaux Ã©tranges avec <code>macro_rules!</code>. BientÃ´t, Rust
rajoutera un second type de macro dÃ©clarative qui fonctionnera de la mÃªme
maniÃ¨re mais qui corrigera ces cas marginaux. AprÃ¨s cette mise Ã  jour,
<code>macro_rules!</code> sera dÃ©prÃ©ciÃ©e. En sachant cela, ainsi que le fait que la
plupart des dÃ©veloppeurs Rust vont plus <em>utiliser</em> les macros <em>qu'Ã©crire</em> des
macros, nous ne verrons plus Ã  nouveau <code>macro_rules!</code> Ã  l'avenir. Pour en
savoir plus sur l'Ã©criture des macros, consultez la documentation en ligne, ou
d'autres ressources comme <a href="https://danielkeep.github.io/tlborm/book/index.html">â€œThe Little Book of Rust Macrosâ€</a>.</p>
<!--
[tlborm]: https://danielkeep.github.io/tlborm/book/index.html
-->
<!--
### Procedural Macros for Generating Code from Attributes
-->
<h3><a class="header" href="#les-macros-procÃ©durales-pour-gÃ©nÃ©rer-du-code-Ã -partir-des-attributs" id="les-macros-procÃ©durales-pour-gÃ©nÃ©rer-du-code-Ã -partir-des-attributs">Les macros procÃ©durales pour gÃ©nÃ©rer du code Ã  partir des attributs</a></h3>
<!--
The second form of macros is *procedural macros*, which act more like functions
(and are a type of procedure). Procedural macros accept some code as an input,
operate on that code, and produce some code as an output rather than matching
against patterns and replacing the code with other code as declarative macros
do.
-->
<p>La seconde forme de macro est la <em>macro procÃ©durale</em>, qui se comporte plus
comme des fonctions (et sont un type de procÃ©dure). Les macros procÃ©durales
prennent du code en entrÃ©e, travaille sur ce code, et produit du code en sortie
plutÃ´t que de faire des correspondances sur des motifs et remplacer du code
avec un autre code, comme le font les macros dÃ©claratives.</p>
<!--
The three kinds of procedural macros (custom derive, attribute-like, and
function-like) all work in a similar fashion.
-->
<p>Les trois types de macros procÃ©durales (les dÃ©rivÃ©es personnalisÃ©es, celles qui
ressemblent aux attributs, et celles qui ressemblent Ã  des fonctions)
fonctionnent toutes de la mÃªme maniÃ¨re.</p>
<!--
When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. Using procedural macros looks like the code in
Listing 19-29, where `some_attribute` is a placeholder for using a specific
macro.
-->
<p>Lorsque vous crÃ©ez une macro procÃ©durale, les dÃ©finitions doivent Ãªtre rangÃ©es
dans leur propre crate avec un type spÃ©cial de crate. Ceci pour des raisons
techniques complexes que nous espÃ©rons supprimer dans l'avenir. L'utilisation
des macros procÃ©durales ressemble au code de l'encart 19-29, dans lequel
<code>un_attribut_quelconque</code> est un emplacement pour l'utilisation d'une macro
spÃ©cifique.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```
-->
<pre><code class="language-rust ignore">use proc_macro;

#[un_attribut_quelconque]
pub fn un_nom_quelconque(entree: TokenStream) -&gt; TokenStream {
}
</code></pre>
<!--
<span class="caption">Listing 19-29: An example of using a procedural
macro</span>
-->
<p><span class="caption">Encart 19-29Â : un exemple d'utilisation d'une macro
procÃ©durale</span></p>
<!--
The function that defines a procedural macro takes a `TokenStream` as an input
and produces a `TokenStream` as an output. The `TokenStream` type is defined by
the `proc_macro` crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input `TokenStream`, and the code the macro produces
is the output `TokenStream`. The function also has an attribute attached to it
that specifies which kind of procedural macro weâ€™re creating. We can have
multiple kinds of procedural macros in the same crate.
-->
<p>La fonction qui dÃ©finit une macro procÃ©durale prend un <code>TokenStream</code> en entrÃ©e
et produit un <code>TokenStream</code> en sortie. Le type <code>TokenStream</code> est dÃ©fini par la
crate <code>proc_macro</code> qui est fournie par Rust et reprÃ©sente une sÃ©quence de
jetons. C'est le cÅ“ur de la macroÂ : le code source sur lequel la macro opÃ¨re
compose l'entrÃ©e <code>TokenStream</code>, et le code que la macro produit est une sortie
<code>TokenStream</code>. La fonction a aussi un attribut qui lui est rattachÃ© qui
renseigne quel genre de macro procÃ©durale nous crÃ©ons. Nous pouvons avoir
diffÃ©rents types de macros procÃ©durales dans la mÃªme crate.</p>
<!--
Letâ€™s look at the different kinds of procedural macros. Weâ€™ll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.
-->
<p>Voyons maintenant les diffÃ©rents types de macros procÃ©durales. Nous allons
commencer par une macro dÃ©rivÃ©e personnalisÃ©e et nous expliquerons ensuite les
petites diffÃ©rences avec les autres types.</p>
<!--
### How to Write a Custom `derive` Macro
-->
<h3><a class="header" href="#comment-Ã©crire-une-macro-dÃ©rivÃ©e-personnalisÃ©e" id="comment-Ã©crire-une-macro-dÃ©rivÃ©e-personnalisÃ©e">Comment Ã©crire une macro dÃ©rivÃ©e personnalisÃ©e</a></h3>
<!--
Letâ€™s create a crate named `hello_macro` that defines a trait named
`HelloMacro` with one associated function named `hello_macro`. Rather than
making our crate users implement the `HelloMacro` trait for each of their
types, weâ€™ll provide a procedural macro so users can annotate their type with
`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro`
function. The default implementation will print `Hello, Macro! My name is
TypeName!` where `TypeName` is the name of the type on which this trait has
been defined. In other words, weâ€™ll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.
-->
<p>CrÃ©ons une crate <code>hello_macro</code> qui dÃ©finit un trait qui s'appelle <code>HelloMacro</code>
avec une fonction associÃ©e <code>hello_macro</code>. PlutÃ´t que de contraindre les
utilisateurs de notre crate Ã  implÃ©menter le trait <code>HelloMacro</code> sur chacun de
leurs types, nous allons fournir une macro procÃ©durale qui permettra aux
utilisateurs de pouvoir annoter leur type avec <code>#[derive(HelloMacro)]</code> afin
d'obtenir une implÃ©mentation par dÃ©faut de la fonction <code>hello_macro</code>.
L'implÃ©mentation par dÃ©faut affichera <code>Hello, MacroÂ ! Mon nom est TypeNameÂ !</code>,
dans lequel <code>TypeName</code> est le nom du type sur lequel ce trait a Ã©tÃ© dÃ©fini.
Autrement dit, nous allons Ã©crire une crate qui permet Ã  un autre dÃ©veloppeur
d'Ã©crire du code comme l'encart 19-30 en utilisant notre crate.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
<span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span>
-->
<p><span class="caption">Encart 19-30Â : le code qu'un utilisateur de notre crate
pourra Ã©crire lorsqu'il utilisera notre macro procÃ©durale</span></p>
<!--
This code will print `Hello, Macro! My name is Pancakes!` when weâ€™re done. The
first step is to make a new library crate, like this:
-->
<p>Ce code va afficher <code>Hello, MacroÂ ! Mon nom est PancakesÂ !</code> lorsque vous en
aurez fini. La premiÃ¨re Ã©tape est de crÃ©er une nouvelle crate de bibliothÃ¨que,
comme ceciÂ :</p>
<!--
```console
$ cargo new hello_macro --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<!--
Next, weâ€™ll define the `HelloMacro` trait and its associated function:
-->
<p>Ensuite, nous allons dÃ©finir le trait <code>HelloMacro</code> et sa fonction associÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub trait HelloMacro {
    fn hello_macro();
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<!--
We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:
-->
<p>Nous avons maintenant un trait et sa fonction. A partir de lÃ , notre
utilisateur de la crate peut implÃ©menter le trait pour accomplir la
fonctionnalitÃ© souhaitÃ©e, comme ceciÂ :</p>
<!--
```rust,ignore
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, MacroÂ ! Mon nom est PancakesÂ !&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
However, they would need to write the implementation block for each type they
wanted to use with `hello_macro`; we want to spare them from having to do this
work.
-->
<p>Cependant, l'utilisateur doit Ã©crire le bloc d'implÃ©mentation pour chacun des
types qu'il souhaite utiliser avec <code>hello_macro</code>Â ; nous souhaitons leur
Ã©pargner de faire ce travail.</p>
<!--
Additionally, we canâ€™t yet provide the `hello_macro` function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesnâ€™t have reflection capabilities, so it canâ€™t look up the typeâ€™s
name at runtime. We need a macro to generate code at compile time.
-->
<p>De plus, nous ne pouvons pas encore fournir la fonction <code>hello_macro</code> avec
l'implÃ©mentation par dÃ©faut qui va afficher le nom du type du trait sur lequel
nous l'implÃ©mentonsÂ : Rust n'est pas rÃ©flexif, donc il ne peut pas connaÃ®tre le
nom du type Ã  l'exÃ©cution. Nous avons besoin d'une macro pour gÃ©nÃ©rer le code Ã 
la compilation.</p>
<!--
The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named `foo`, a custom derive procedural macro crate is
called `foo_derive`. Letâ€™s start a new crate called `hello_macro_derive` inside
our `hello_macro` project:
-->
<p>La prochaine Ã©tape est de dÃ©finir la macro procÃ©durale. A l'heure de l'Ã©criture
de ces lignes, les macros procÃ©durales au besoin d'Ãªtre placÃ©es dans leur
propre crate. Cette restriction pourra Ã©ventuellement Ãªtre levÃ©e. La convention
pour structurer les crates et les crates de macros est la suivanteÂ : pour
une crate <code>foo</code>, une crate de macro procÃ©durale personnalisÃ©e de dÃ©rivÃ©e doit
s'appeler <code>foo_derive</code>. CrÃ©ons une nouvelle crate <code>hello_macro_derive</code> au sein
de notre projet <code>hello_macro</code>Â :</p>
<!--
```console
$ cargo new hello_macro_derive --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<!--
Our two crates are tightly related, so we create the procedural macro crate
within the directory of our `hello_macro` crate. If we change the trait
definition in `hello_macro`, weâ€™ll have to change the implementation of the
procedural macro in `hello_macro_derive` as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
`hello_macro` crate use `hello_macro_derive` as a dependency and re-export the
procedural macro code. However, the way weâ€™ve structured the project makes it
possible for programmers to use `hello_macro` even if they donâ€™t want the
`derive` functionality.
-->
<p>Nos deux crates sont Ã©troitement liÃ©es, donc nous crÃ©ons la crate de macro
procÃ©durale Ã  l'intÃ©rieur du dossier de notre crate <code>hello_macro</code>. Si nous
changeons la dÃ©finition du trait dans <code>hello_macro</code>, nous aurons aussi Ã 
changer l'implÃ©mentation de la macro procÃ©durale dans <code>hello_macro_derive</code>. Les
deux crates vont devoir Ãªtre publiÃ©es sÃ©parÃ©ment, et les dÃ©veloppeurs qui vont
utiliser ces crates vont avoir besoin d'ajouter les deux dÃ©pendances et les
importer dans la portÃ©e. Nous pouvons plutÃ´t faire en sorte que la crate
<code>hello_macro</code> utilise <code>hello_macro_derive</code> comme dÃ©pendance et rÃ©-exporter le
code de la macro procÃ©durale. Cependant, la faÃ§on dont nous avons structurÃ© le
projet donne la possibilitÃ© aux dÃ©veloppeurs d'utiliser <code>hello_macro</code> mÃªme s'ils
ne veulent pas la fonctionnalitÃ© <code>derive</code>.</p>
<!--
We need to declare the `hello_macro_derive` crate as a procedural macro crate.
Weâ€™ll also need functionality from the `syn` and `quote` crates, as youâ€™ll see
in a moment, so we need to add them as dependencies. Add the following to the
*Cargo.toml* file for `hello_macro_derive`:
-->
<p>Nous devons dÃ©clarer la crate <code>hello_macro_derive</code> comme Ã©tant une crate de
macro procÃ©durale. Nous allons aussi avoir besoin des fonctionnalitÃ©s des
crates <code>syn</code> et <code>quote</code>, comme vous allez de constater bientÃ´t, donc nous
allons les ajouter comme dÃ©pendances. Ajoutez ceci dans le fichier <em>Cargo.toml</em>
de <code>hello_macro_derive</code>Â :</p>
<!--
<span class="filename">Filename: hello_macro_derive/Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : hello_macro_derive/Cargo.toml</span></p>
<!--
```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```
-->
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<!--
To start defining the procedural macro, place the code in Listing 19-31 into
your *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code
wonâ€™t compile until we add a definition for the `impl_hello_macro` function.
-->
<p>Pour commencer Ã  dÃ©finir la macro procÃ©durale, placez le code de l'encart 19-31
dans votre fichier <em>src/lib.rs</em> de la crate <code>hello_macro_derive</code>. Notez que ce
code ne se compilera pas tant que nous n'ajouterons pas une dÃ©finition pour la
fonction <code>impl_hello_macro</code>.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construit une reprÃ©sentation du code Rust en arborescence
    // syntaxique que nous pouvons manipuler
    let ast = syn::parse(input).unwrap();

    // Construit l'implÃ©mentation du trait
    impl_hello_macro(&amp;ast)
}
</code></pre>
<!--
<span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span>
-->
<p><span class="caption">Encart 19-31Â : du code que la plupart des macros
procÃ©durales auront besoin pour travailler avec du code Rust</span></p>
<!--
Notice that weâ€™ve split the code into the `hello_macro_derive` function, which
is responsible for parsing the `TokenStream`, and the `impl_hello_macro`
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(`hello_macro_derive` in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (`impl_hello_macro` in this case) will be different
depending on your procedural macroâ€™s purpose.
-->
<p>Remarquez que nous avons divisÃ© le code dans la fonction <code>hello_macro_derive</code>,
qui est responsable de parcourir le <code>TokenStream</code>, et la fonction
<code>impl_hello_macro</code>, qui est responsable de transformer l'arborescence
syntaxiqueÂ : cela facilite l'Ã©criture de la macro procÃ©durale. Le code dans la
fonction englobante (qui est <code>hello_macro_derive</code> dans notre cas) sera le mÃªme
pour presque toutes les crates de macro procÃ©durales que vous allez voir ou
crÃ©er. Le code que vous renseignez dans le corps de la fonction (qui est
<code>impl_hello_macro</code> dans notre cas) diffÃ¨rera en fonction de ce que fait votre
macro procÃ©durale.</p>
<!--
Weâ€™ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The
`proc_macro` crate comes with Rust, so we didnâ€™t need to add that to the
dependencies in *Cargo.toml*. The `proc_macro` crate is the compilerâ€™s API that
allows us to read and manipulate Rust code from our code.
-->
<p>Nous avons ajoutÃ© trois nouvelles cratesÂ : <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, et <a href="https://crates.io/crates/quote"><code>quote</code></a>.
La crate <code>proc_macro</code> est fournie par Rust, donc nous n'avons pas besoin de
l'ajouter aux dÃ©pendances dans <em>Cargo.toml</em>. La crate <code>proc_macro</code> fournit une
API du compilateur qui nous permet de lire et manipuler le code Rust Ã  partir de
notre code.</p>
<!--
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
-->
<!--
The `syn` crate parses Rust code from a string into a data structure that we
can perform operations on. The `quote` crate turns `syn` data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.
-->
<p>La crate <code>syn</code> transforme le code Rust d'une chaÃ®ne de caractÃ¨res en une
structure de donnÃ©es sur laquelle nous pouvons procÃ©der Ã  des opÃ©rations. La
crate <code>quote</code> re-transforme les structures de donnÃ©es de <code>syn</code> en code Rust.
Ces crates facilite le parcours de toute sorte de code Rust que nous aurions
besoin de gÃ©rerÂ : l'Ã©criture d'un interprÃ©teur complet de code Rust n'a jamais
Ã©tÃ© aussi facile.</p>
<!--
The `hello_macro_derive` function will be called when a user of our library
specifies `#[derive(HelloMacro)]` on a type. This is possible because weâ€™ve
annotated the `hello_macro_derive` function here with `proc_macro_derive` and
specified the name, `HelloMacro`, which matches our trait name; this is the
convention most procedural macros follow.
-->
<p>La fonction <code>hello_macro_derive</code> va Ãªtre appelÃ©e lorsqu'un utilisateur de notre
bibliothÃ¨que utilisera <code>#[derive(HelloMacro)]</code> sur un type. Cela sera possible
car nous avons annotÃ© notre fonction <code>hello_macro_derive</code> avec
<code>proc_macro_derive</code> et nous avons renseignÃ© le nom, <code>HelloMacro</code>, qui
correspond au nom de notre traitÂ ; c'est la convention que la plupart des
macros procÃ©durales doivent suivre.</p>
<!--
The `hello_macro_derive` function first converts the `input` from a
`TokenStream` to a data structure that we can then interpret and perform
operations on. This is where `syn` comes into play. The `parse` function in
`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput`
struct we get from parsing the `struct Pancakes;` string:
-->
<p>La fonction <code>hello_macro_derive</code> commence par convertir le <code>input</code> qui est un
<code>TokenStream</code> en une structure de donnÃ©es que nous pouvons ensuite interprÃ©ter
et y faire des opÃ©rations dessus. C'est lÃ  que <code>syn</code> rentre en jeu. La fonction
<code>parse</code> de <code>syn</code> prend un <code>TokenStream</code> et retourne une structure <code>DeriveInput</code>
qui reprÃ©sente le code Rust. L'encart 19-32 montre les parties intÃ©ressantes de
la structure <code>DeriveInput</code> que nous obtenons en convertissant la chaÃ®ne de
caractÃ¨res <code>struct Pancakes;</code>Â :</p>
<!--
```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```
-->
<pre><code class="language-rust ignore">DeriveInput {
    // -- partie masquÃ©e ici --

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<!--
<span class="caption">Listing 19-32: The `DeriveInput` instance we get when
parsing the code that has the macroâ€™s attribute in Listing 19-30</span>
-->
<p><span class="caption">Encart 19-32Â : l'instance de <code>DeriveInput</code> que nous
obtenons lorsque nous convertissons le code qui l'attribut de la macro dans
l'encart 19-30</span></p>
<!--
The fields of this struct show that the Rust code weâ€™ve parsed is a unit struct
with the `ident` (identifier, meaning the name) of `Pancakes`. There are more
fields on this struct for describing all sorts of Rust code; check the [`syn`
documentation for `DeriveInput`][syn-docs] for more information.
-->
<p>Les champs de cette structure montrent que ce code Rust que nous avons converti
est une structure unitaire avec l'<code>ident</code> (raccourci de <code>identifier</code>, qui
dÃ©signe le nom) <code>Pancakes</code>. Il y a d'autres champs sur cette structure
dÃ©crivant toutes sortes de codes RustÂ ; regardez la
<a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">documentation de <code>syn</code> pour <code>DeriveInput</code></a> pour en savoir plus.</p>
<!--
[syn-docs]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
-->
<!--
Soon weâ€™ll define the `impl_hello_macro` function, which is where weâ€™ll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a `TokenStream`. The returned `TokenStream` is
added to the code that our crate users write, so when they compile their crate,
theyâ€™ll get the extra functionality that we provide in the modified
`TokenStream`.
-->
<p>BientÃ´t, nous dÃ©finirons la fonction <code>impl_hello_macro</code>, qui nous permettra de
construire de nous code Rust que nous souhaitons injecter. Mais avant de faire
cela, remarquez que la sortie de notre macro derive est aussi un <code>TokenStream</code>.
Le <code>TokenStream</code> retournÃ© est ajoutÃ© au code que les utilisateurs de notre
crate ont Ã©crit, donc lorsqu'ils compilent leur crate, ils rÃ©cupÃ©reront la
fonctionnalitÃ© additionnelle que nous injectons dans le <code>TokenStream</code> modifiÃ©.</p>
<!--
You might have noticed that weâ€™re calling `unwrap` to cause the
`hello_macro_derive` function to panic if the call to the `syn::parse` function
fails here. Itâ€™s necessary for our procedural macro to panic on errors because
`proc_macro_derive` functions must return `TokenStream` rather than `Result` to
conform to the procedural macro API. Weâ€™ve simplified this example by using
`unwrap`; in production code, you should provide more specific error messages
about what went wrong by using `panic!` or `expect`.
-->
<p>Vous avez peut-Ãªtre remarquÃ© que nous faisons appel Ã  <code>unwrap</code> pour faire
paniquer la fonction <code>hello_macro_derive</code> si l'appel Ã  la fonction <code>syn::parse</code>
que nous faisons Ã©choue. Il est nÃ©cessaire de faire paniquer notre macro
procÃ©durale si elle rencontre des erreurs car les fonctions <code>proc_macro_derive</code>
doivent retourner un <code>TokenStream</code> plutÃ´t qu'un <code>Result</code> pour se conformer Ã 
l'API de la macro procÃ©durale. Nous avons simplifiÃ© cet exemple en utilisant
<code>unwrap</code>Â ; dans du code en production, vous devriez renseigner des messages
d'erreur plus prÃ©cis sur ce qui s'est mal passÃ© en utilisant <code>panic!</code> ou
<code>expect</code>.</p>
<!--
Now that we have the code to turn the annotated Rust code from a `TokenStream`
into a `DeriveInput` instance, letâ€™s generate the code that implements the
`HelloMacro` trait on the annotated type, as shown in Listing 19-33.
-->
<p>Maintenant que nous avons le code pour transformer le code Rust annotÃ© d'un
<code>TokenStream</code> en une instance de <code>DeriveInput</code>, crÃ©ons le code qui implÃ©mente le
trait <code>HelloMacro</code> sur le type annotÃ©, comme l'encart 19-33.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore
# extern crate proc_macro;
# 
# use proc_macro::TokenStream;
# use quote::quote;
# use syn;
# 
# #[proc_macro_derive(HelloMacro)]
# pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
#     // Construct a representation of Rust code as a syntax tree
#     // that we can manipulate
#     let ast = syn::parse(input).unwrap();
# 
#     // Build the trait implementation
#     impl_hello_macro(&ast)
# }
# 
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construit une reprÃ©sentation du code Rust en arborescence
</span><span class="boring">    // syntaxique que nous pouvons manipuler
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Construit l'implÃ©mentation du trait
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let nom = &amp;ast.ident;
    let generation = quote! {
        impl HelloMacro for #nom {
            fn hello_macro() {
                println!(&quot;Hello, MacroÂ ! Mon nom estÂ {}&quot;, stringify!(#nom));
            }
        }
    };
    generation.into()
}
</code></pre>
<!--
<span class="caption">Listing 19-33: Implementing the `HelloMacro` trait using
the parsed Rust code</span>
-->
<p><span class="caption">Encart 19-33Â : implÃ©mentation du trait <code>HelloMacro</code> en
utilisant le code Rust interprÃ©tÃ©</span></p>
<!--
We get an `Ident` struct instance containing the name (identifier) of the
annotated type using `ast.ident`. The struct in Listing 19-32 shows that when
we run the `impl_hello_macro` function on the code in Listing 19-30, the
`ident` we get will have the `ident` field with a value of `"Pancakes"`. Thus,
the `name` variable in Listing 19-33 will contain an `Ident` struct instance
that, when printed, will be the string `"Pancakes"`, the name of the struct in
Listing 19-30.
-->
<p>Nous obtenons une instance de structure <code>Ident</code> qui contient le nom
(<code>identifier</code>) du type annotÃ© en utilisant <code>ast.ident</code>. La structure de l'encart
19-32 montre ceci lorsque nous exÃ©cutons la fonction <code>impl_hello_macro</code> sur le
code de l'encart 19-30, le <code>ident</code> que nous obtenons aura le champ <code>ident</code> avec
la valeur <code>&quot;Pancakes&quot;</code>. Ainsi, la variable <code>nom</code> de l'encart 19-33 contiendra
une instance de la structure <code>Ident</code> qui, une fois affichÃ©e, sera la chaÃ®ne de
caractÃ¨res <code>&quot;Pancakes&quot;</code>, le nom de la structure de l'encart 19-30.</p>
<!--
The `quote!` macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the `quote!`
macroâ€™s execution, so we need to convert it to a `TokenStream`. We do this by
calling the `into` method, which consumes this intermediate representation and
returns a value of the required `TokenStream` type.
-->
<p>La macro <code>quote!</code> nous permet de dÃ©finir le code Rust que nous souhaitons
retourner. Le compilateur attend quelque chose de diffÃ©rent en rÃ©sultat que le
ce qui correspond Ã  l'exÃ©cution de <code>quote!</code>, donc nous devons le convertir en
<code>TokenStream</code>. Nous faisons ceci en faisant appel Ã  la mÃ©thode <code>into</code>, qui se
base sur cette reprÃ©sentation intermÃ©diaire et retourne une valeur attendue,
comme ici du type <code>TokenStream</code>.</p>
<!--
The `quote!` macro also provides some very cool templating mechanics: we can
enter `#name`, and `quote!` will replace it with the value in the variable
`name`. You can even do some repetition similar to the way regular macros work.
Check out [the `quote` crateâ€™s docs][quote-docs] for a thorough introduction.
-->
<p>La macro <code>quote!</code> fournit aussi quelques mÃ©caniques de gabarit intÃ©ressantesÂ :
nous pouvons entrer <code>#nom</code>, et <code>quote!</code> va le remplacer avec la valeur dans la
variable <code>nom</code>. Vous pouvez mÃªme procÃ©der Ã  quelques rÃ©pÃ©tions de faÃ§on
similaire au fonctionnement des macros classiques. Regardez dans
<a href="https://docs.rs/quote">la documentation de <code>quote</code></a> pour une prÃ©sentation plus dÃ©taillÃ©e.</p>
<!--
[quote-docs]: https://docs.rs/quote
-->
<!--
We want our procedural macro to generate an implementation of our `HelloMacro`
trait for the type the user annotated, which we can get by using `#name`. The
trait implementation has one function, `hello_macro`, whose body contains the
functionality we want to provide: printing `Hello, Macro! My name is` and then
the name of the annotated type.
-->
<p>Nous souhaitons que notre macro procÃ©durale gÃ©nÃ¨re une implÃ©mentation de notre
trait <code>HelloMacro</code> pour le type que l'utilisateur a annotÃ©, que nous pouvons
obtenir en utilisant <code>#nom</code>. L'implÃ©mentation du trait utilise une fonction,
<code>hello_macro</code>, dont le corps contient la fonctionnalitÃ© que nous souhaitons
fournirÂ : l'affichage de <code>Hello, MacroÂ ! Mon nom est</code> suivi par le nom du type
annotÃ©.</p>
<!--
The `stringify!` macro used here is built into Rust. It takes a Rust
expression, such as `1 + 2`, and at compile time turns the expression into a
string literal, such as `"1 + 2"`. This is different than `format!` or
`println!`, macros which evaluate the expression and then turn the result into
a `String`. There is a possibility that the `#name` input might be an
expression to print literally, so we use `stringify!`. Using `stringify!` also
saves an allocation by converting `#name` to a string literal at compile time.
-->
<p>La macro <code>stringify!</code> utilisÃ©e ici est Ã©crite en Rust. Elle prend en argument
une expression Rust, comme <code>1 + 2</code>, et Ã  la compilation transforme l'expression
en une chaÃ®ne de caractÃ¨res littÃ©rale, comme <code>&quot;1 + 2&quot;</code>. Cela est diffÃ©rent de
<code>format!</code> ou de <code>println!</code>, des macros qui Ã©valuent l'expression et retourne
ensuite le rÃ©sultat dans une <code>String</code>. Il est possible que l'entrÃ©e <code>#nom</code> soit
une expression Ã  Ã©crire littÃ©ralement, donc nous utilisons <code>stringify!</code>.
L'utilisation de <code>stringify!</code> Ã©vite aussi une allocation en convertissant <code>#nom</code>
en une chaine de caractÃ¨res littÃ©rale Ã  la compilation.</p>
<!--
At this point, `cargo build` should complete successfully in both `hello_macro`
and `hello_macro_derive`. Letâ€™s hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your *projects* directory using `cargo new pancakes`. We need to add
`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`
crateâ€™s *Cargo.toml*. If youâ€™re publishing your versions of `hello_macro` and
`hello_macro_derive` to [crates.io](https://crates.io/), they would be regular
dependencies; if not, you can specify them as `path` dependencies as follows:
-->
<p>Maintenant, <code>cargo build</code> devrait fonctionner correctement pour <code>hello_macro</code> et
<code>hello_macro_derive</code>. Relions maintenant ces crates au code de l'encart 19-30
pour voir les macros procÃ©durales Ã  l'oeuvreÂ ! CrÃ©ez un nouveau projet binaire
dans votre dossier <em>projects</em> en utilisant <code>cargo new pancakes</code>. Nous avons
besoin d'ajouter <code>hello_macro</code> et <code>hello_macro_derive</code> comme dÃ©pendances dans le
<em>Cargo.toml</em> de la crate <code>pancakes</code>. Si vous publiez vos versions de
<code>hello_macro</code> et de <code>hello_macro_derive</code> sur <a href="https://crates.io">crates.io</a>,
elles sont des dÃ©pendances classiquesÂ ; sinon, vous pouvez les renseigner comme
dÃ©pendance locale avec <code>path</code> comme ceciÂ :</p>
<!--
```toml
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```
-->
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!--
Put the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it
should print `Hello, Macro! My name is Pancakes!` The implementation of the
`HelloMacro` trait from the procedural macro was included without the
`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the
trait implementation.
-->
<p>Renseignez le code l'encart 19-30 dans <em>src/main.rs</em>, puis lancez <code>cargo run</code>Â :
cela devrait afficher <code>Hello, MacroÂ ! Mon nom est PancakesÂ !</code>. L'implÃ©mentation
du trait <code>HelloMacro</code> Ã  l'aide de la macro procÃ©durale est injectÃ©e sans que la
crate <code>pancakes</code> n'ai besoin de le faire manuellementÂ ; le
<code>#[derive(HelloMacro)]</code> a rajoutÃ© automatiquement l'implÃ©mentation du trait.</p>
<!--
Next, letâ€™s explore how the other kinds of procedural macros differ from custom
derive macros.
-->
<p>Maintenant, dÃ©couvrons comment les autres types de macros procÃ©durales se
distinguent des macros derive personnalisÃ©es.</p>
<!--
### Attribute-like macros
-->
<h3><a class="header" href="#les-macros-qui-ressemblent-Ã -des-attributs" id="les-macros-qui-ressemblent-Ã -des-attributs">Les macros qui ressemblent Ã  des attributs</a></h3>
<!--
Attribute-like macros are similar to custom derive macros, but instead of
generating code for the `derive` attribute, they allow you to create new
attributes. Theyâ€™re also more flexible: `derive` only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Hereâ€™s an example of using an attribute-like macro: say you have an attribute
named `route` that annotates functions when using a web application framework:
-->
<p>Les macros qui ressemblent Ã  des attributs ressemblent aux macros derive
personnalisÃ©es, mais au lieu de gÃ©nÃ©rer du code pour l'attribut <code>derive</code>, elles
vous permettent de crÃ©er des nouveaux attributs. Elles sont aussi plus
flexiblesÂ : <code>derive</code> fonctionne uniquement pour les structures et les
Ã©numÃ©rationsÂ ; les attributs peuvent Ãªtre aussi appliquÃ©s aux autres Ã©lÃ©ments,
comme les fonctions. Voici un exemple d'utilisation d'une macro qui ressemble Ã 
un attributÂ : imaginons que vous avez un attribut <code>chemin</code> qui est une
annotation pour des fonctions lorsque vous utilisez un environnement de
dÃ©veloppement d'application webÂ :</p>
<!--
```rust,ignore
#[route(GET, "/")]
fn index() {
```
-->
<pre><code class="language-rust ignore">#[chemin(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<!--
This `#[route]` attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:
-->
<p>Cet attribut <code>#[chemin]</code> sera dÃ©fini par l'environnement de dÃ©veloppement comme
Ã©tant une macro procÃ©durale. La signature de la fonction de dÃ©finition de la
macro ressemblera Ã  ceciÂ :</p>
<!--
```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn chemin(attribut: TokenStream, element: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
Here, we have two parameters of type `TokenStream`. The first is for the
contents of the attribute: the `GET, "/"` part. The second is the body of the
item the attribute is attached to: in this case, `fn index() {}` and the rest
of the functionâ€™s body.
-->
<p>Maintenant, nous avons deux paramÃ¨tres de type <code>TokenStream</code>. Le premier
correspond au contenu de l'attributÂ : la partie <code>GET, &quot;/&quot;</code>. Le second est le
corps de l'Ã©lÃ©ment sur lequel cet attribut sera appliquÃ©Â : dans notre cas,
<code>fn index() {}</code> et le reste du corps de la fonction.</p>
<!--
Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the `proc-macro` crate type and implement a
function that generates the code you want!
-->
<p>Mis Ã  part cela, les macros qui ressemblent Ã  des attributs fonctionnent de la
mÃªme maniÃ¨re que les macros derive personnalisÃ©esÂ : vous gÃ©nÃ©rez une crate avec
le type de la crate <code>proc-macro</code> et implÃ©mentez une fonction qui gÃ©nÃ¨rera le
code que vous souhaitezÂ !</p>
<!--
### Function-like macros
-->
<h3><a class="header" href="#les-macros-qui-ressemblent-Ã -des-fonctions" id="les-macros-qui-ressemblent-Ã -des-fonctions">Les macros qui ressemblent Ã  des fonctions</a></h3>
<!--
Function-like macros define macros that look like function calls. Similarly to
`macro_rules!` macros, theyâ€™re more flexible than functions; for example, they
can take an unknown number of arguments. However, `macro_rules!` macros can be
defined only using the match-like syntax we discussed in the section
[â€œDeclarative Macros with `macro_rules!` for General Metaprogrammingâ€][decl]
earlier. Function-like macros take a `TokenStream` parameter and their
definition manipulates that `TokenStream` using Rust code as the other two
types of procedural macros do. An example of a function-like macro is an `sql!`
macro that might be called like so:
-->
<p>Les macros qui ressemblent Ã  des fonctions dÃ©finissent des macros qui
ressemblent Ã  des appels de fonction. De la mÃªme maniÃ¨re que les macros
<code>macro_rules!</code>, elles sont plus flexibles que les fonctionsÂ ; par exemple, elles
peuvent prendre une quantitÃ© non finie d'arguments. Cependant, les macros
<code>macro_rules!</code> peuvent Ãªtre dÃ©finies uniquement en utilisant la syntaxe qui
ressemble Ã  <code>match</code> que nous avons vu dans <a href="ch19-06-macros.html#les-macros-d%C3%A9claratives-avec-macro_rules-pour-la-m%C3%A9taprogrammation-g%C3%A9n%C3%A9rale">une section prÃ©cÃ©dente</a>. Les
macros qui ressemblent Ã  des fonctions prennent en paramÃ¨tre un <code>TokenStream</code> et
leurs dÃ©finitions manipulent ce <code>TokenStream</code> en utilisant du code Rust comme le
font les deux autres types de macros procÃ©durales. Voici un exemple d'une macro
qui ressemble Ã  une fonction qui est une macro <code>sql!</code> qui devrait Ãªtre utilisÃ©e
comme ceciÂ :</p>
<!--
[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming
-->
<!--
```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```
-->
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM publications WHERE id=1);
</code></pre>
<!--
This macro would parse the SQL statement inside it and check that itâ€™s
syntactically correct, which is much more complex processing than a
`macro_rules!` macro can do. The `sql!` macro would be defined like this:
-->
<p>Cette macro devrait interprÃ©ter l'instruction SQL qu'on lui envoie et vÃ©rifier
si elle est syntaxiquement correcte, ce qui est un procÃ©dÃ© bien plus complexe
que ce qu'une macro <code>macro_rules!</code> peut faire. La macro <code>sql!</code> sera dÃ©finie
comme ceciÂ :</p>
<!--
```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
This definition is similar to the custom derive macroâ€™s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.
-->
<p>Cette dÃ©finition ressemble Ã  la signature de la macro derive personnalisÃ©eÂ :
nous rÃ©cupÃ©rons les Ã©lÃ©ments entre parenthÃ¨ses et retournons le code que nous
souhaitons gÃ©nÃ©rer.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-18" id="rÃ©sumÃ©-18">RÃ©sumÃ©</a></h2>
<!--
Whew! Now you have some Rust features in your toolbox that you wonâ€™t use often,
but youâ€™ll know theyâ€™re available in very particular circumstances. Weâ€™ve
introduced several complex topics so that when you encounter them in error
message suggestions or in other peoplesâ€™ code, youâ€™ll be able to recognize
these concepts and syntax. Use this chapter as a reference to guide you to
solutions.
-->
<p>OuahÂ ! Maintenant vous avez quelques fonctionnalitÃ©s de Rust supplÃ©mentaires
dans votre boite Ã  outils que vous utiliserez probablement rarement, mais vous
savez maintenant qu'elles vous aideront dans des situations trÃ¨s particuliÃ¨res.
Nous avons abordÃ© plusieurs sujets complexes afin que vous puissiez les
reconnaÃ®tre ainsi que leur syntaxe lorsque vous les rencontrerez dans des
messages de suggestions dans des erreurs ou dans du code de quelqu'un d'autre.
Utilisez ce chapitre comme rÃ©fÃ©rence pour vous guider vers ces solutions.</p>
<!--
Next, weâ€™ll put everything weâ€™ve discussed throughout the book into practice
and do one more project!
-->
<p>Au chapitre suivant, nous allons mettre en pratique tout ce que nous avons
appris dans ce livre en l'appliquant Ã  un nouveau projetÂ !</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--50" id="-attention-peinture-fraÃ®che--50">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/214">Pull Request</a>.</p>
</blockquote>
<!--
# Final Project: Building a Multithreaded Web Server
-->
<h1><a class="header" href="#projet-final--construire-un-serveur-web-multitÃ¢ches" id="projet-final--construire-un-serveur-web-multitÃ¢ches">Projet final : construire un serveur web multitÃ¢ches</a></h1>
<!--
Itâ€™s been a long journey, but weâ€™ve reached the end of the book. In this
chapter, weâ€™ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.
-->
<p>Cela a Ã©tÃ© un long voyage, mais nous avons atteint la fin de ce livre. Dans ce
chapitre, nous allons construire un nouveau projet ensemble pour mettre en
application certains concepts que nous avons vu dans les derniers chapitres, et
aussi pour rÃ©capituler quelques leÃ§ons prÃ©cÃ©dentes.</p>
<!--
For our final project, weâ€™ll make a web server that says â€œhelloâ€ and looks like
Figure 20-1 in a web browser.
-->
<p>Pour notre projet final, nous allons construire un serveur web qui dit
â€œsalutationsâ€ et qui ressemble dans un navigateur web Ã  l'illustration 20-1.</p>
<!--
![hello from rust](img/trpl20-01.png)
-->
<p><img src="img/trpl20-01.png" alt="bonjour de la part de Rust" /></p>
<!--
<span class="caption">Figure 20-1: Our final shared project</span>
-->
<p><span class="caption">Illustration 20-1Â : notre dernier projet en commun</span></p>
<!--
Here is the plan to build the web server:
-->
<p>Voici le plan de construction du serveur webÂ :</p>
<!--
1. Learn a bit about TCP and HTTP.
2. Listen for TCP connections on a socket.
3. Parse a small number of HTTP requests.
4. Create a proper HTTP response.
5. Improve the throughput of our server with a thread pool.
-->
<ol>
<li>En savoir plus sur TCP et HTTP.</li>
<li>Ecouter les connections TCP sur un port.</li>
<li>InterprÃ©ter une petite quantitÃ© de requÃªtes HTTP.</li>
<li>CrÃ©er une rÃ©ponse HTTP adÃ©quate.</li>
<li>Augmenter le dÃ©bit de notre serveur avec un groupe de tÃ¢ches.</li>
</ol>
<!--
But before we get started, we should mention one detail: the method weâ€™ll use
wonâ€™t be the best way to build a web server with Rust. A number of
production-ready crates are available on [crates.io](https://crates.io/) that
provide more complete web server and thread pool implementations than weâ€™ll
build.
-->
<p>Mais avant de commencer, nous devons signaler une choseÂ : les mÃ©thodes que nous
allons utiliser ne sont pas les meilleures pour construire un serveur web avec
Rust. Un certain nombre de crate mÃ¢tures pour la production disponibles sur
<a href="https://crates.io/">crates.io</a> fourniront des serveurs web et des
implÃ©mentations de groupe de tÃ¢ches plus complets que ce que nous allons
construire.</p>
<!--
However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. Weâ€™ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.
-->
<p>Toutefois, notre intention dans ce chapitre est de vous aider Ã  apprendre, et
non pas de se laisser aller Ã  la facilitÃ©. Comme Rust est un langage de
programmation de systÃ¨mes, nous pouvons choisir le niveau d'abstraction sur
lequel nous souhaitons travailler et nous pouvons descendre Ã  un niveau plus bas
que ce qui est possible ou praticable dans d'autres langages. Nous allons Ã©crire
manuellement le serveur HTTP basique et le groupe de tÃ¢ches pour que vous
puissiez apprendre les idÃ©es et techniques gÃ©nÃ©rales derriÃ¨re les crates que
vous serez peut-Ãªtre amenÃ©s Ã  utiliser Ã  l'avenir.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--51" id="-attention-peinture-fraÃ®che--51">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/215">Pull Request</a>.</p>
</blockquote>
<!--
## Building a Single-Threaded Web Server
-->
<h2><a class="header" href="#dÃ©velopper-un-serveur-web-monotÃ¢che" id="dÃ©velopper-un-serveur-web-monotÃ¢che">DÃ©velopper un serveur web monotÃ¢che</a></h2>
<!--
Weâ€™ll start by getting a single-threaded web server working. Before we begin,
letâ€™s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.
-->
<p>Nous allons commencer par faire fonctionner un serveur web avec une seule tÃ¢che.
Avant de commencer, faisons un survol rapide des protocoles utilisÃ©s dans les
serveurs web. Les dÃ©tails de ces protocoles ne sont pas le sujet de ce livre,
mais un rapide aperÃ§u vous donnera les informations dont vous avez besoin.</p>
<!--
The two main protocols involved in web servers are the *Hypertext Transfer
Protocol* *(HTTP)* and the *Transmission Control Protocol* *(TCP)*. Both
protocols are *request-response* protocols, meaning a *client* initiates
requests and a *server* listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.
-->
<p>Les deux principaux protocoles utilisÃ©s dans les serveurs web sont le
<em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> et le <em>Transmission Control Protocol</em>
<em>(TCP)</em>. Ces deux protocoles sont des protocoles de type <em>demande-rÃ©ponse</em>, ce
qui signifie qu'un <em>client</em> dÃ©marre les requÃªtes, et le <em>serveur</em> Ã©coute les
requÃªtes et fournit une rÃ©ponse au client. Le contenu de ces requÃªtes et
rÃ©ponses est dÃ©fini par les protocoles.</p>
<!--
TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesnâ€™t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. Itâ€™s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. Weâ€™ll work with the
raw bytes of TCP and HTTP requests and responses.
-->
<p>TCP est le protocole le plus bas-niveau qui dÃ©crit les dÃ©tails de comment une
information passe d'un serveur Ã  un autre mais ne prÃ©cise pas ce qu'est cette
information. HTTP est construit sur TCP en dÃ©finissant le contenu des requÃªtes et
des rÃ©ponses. Il est techniquement possible d'utiliser HTTP avec d'autres
protocoles, mais dans la grande majoritÃ© des cas, HTTP envoie ses donnÃ©es via
TCP. Nous allons travailler avec les octets bruts des requÃªtes et des rÃ©ponses
de TCP et HTTP.</p>
<!--
### Listening to the TCP Connection
-->
<h3><a class="header" href="#ecouter-les-connexions-tcp" id="ecouter-les-connexions-tcp">Ecouter les connexions TCP</a></h3>
<!--
Our web server needs to listen to a TCP connection, so thatâ€™s the first part
weâ€™ll work on. The standard library offers a `std::net` module that lets us do
this. Letâ€™s make a new project in the usual fashion:
-->
<p>Notre serveur web a besoin d'Ã©couter les connexions TCP, donc cela sera la
premiÃ¨re partie sur laquelle nous travaillerons. La bibliothÃ¨que standard offre
un module <code>std::net</code> qui nous permet de faire ceci. CrÃ©ons un nouveau projet de
maniÃ¨re habituelleÂ :</p>
<!--
```console
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```
-->
<pre><code class="language-console">$ cargo new salutations
     Created binary (application) `salutations` project
$ cd salutations
</code></pre>
<!--
Now enter the code in Listing 20-1 in *src/main.rs* to start. This code will
listen at the address `127.0.0.1:7878` for incoming TCP streams. When it gets
an incoming stream, it will print `Connection established!`.
-->
<p>Maintenant, saisissez le code de l'encart 20-1 dans <em>src/main.rs</em> pour
commencer. Ce code va Ã©couter les flux TCP entrants Ã  l'adresse
<code>127.0.0.1:7878</code>. Lorsqu'il obtiendra un flux entrant, il va afficher
<code>Connexion Ã©tablieÂ !</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        println!(&quot;Connexion Ã©tablieÂ !&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span>
-->
<p><span class="caption">Encart 20-1Â : Ã©coute des flux entrants et affichage d'un
message lorsque nous recevons un flux</span></p>
<!--
Using `TcpListener`, we can listen for TCP connections at the address
`127.0.0.1:7878`. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesnâ€™t
represent the authorsâ€™ computer specifically), and `7878` is the port. Weâ€™ve
chosen this port for two reasons: HTTP is normally accepted on this port, and
7878 is *rust* typed on a telephone.
-->
<p>En utilisant <code>TcpListener</code>, nous pouvons Ã©couter les connexions TCP Ã  l'adresse
<code>127.0.0.1:7878</code>. Dans cette adresse, la partie avant les double-points est une
adresse IP qui reprÃ©sente votre ordinateur (c'est la mÃªme sur chaque ordinateur
et ne reprÃ©sente pas prÃ©cisÃ©ment l'ordinateur de l'auteur), et <code>7878</code> est le
port. Nous avons choisi ce port pour deux raisonsÂ : HTTP est habituellement
acceptÃ© sur ce port, et 7878 correspond aux touches utilisÃ©es sur un clavier de
tÃ©lÃ©phone pour Ã©crire <em>Rust</em>.</p>
<!--
The `bind` function in this scenario works like the `new` function in that it
will return a new `TcpListener` instance. The reason the function is called
`bind` is that in networking, connecting to a port to listen to is known as
â€œbinding to a port.â€
-->
<p>La fonction <code>bind</code> dans ce scÃ©nario fonctionne comme la fonction <code>new</code> dans le
sens oÃ¹ elle retourne une nouvelle instance de <code>TcpListener</code>. La raison pour
laquelle cette fonction s'appelle <code>bind</code> <em>(NdT : signifie &quot;lier&quot;)</em> est que dans
les rÃ©seaux, connecter un port Ã  Ã©couter se dit aussi â€œlier Ã  un portâ€.</p>
<!--
The `bind` function returns a `Result<T, E>`, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1024), so if
we tried to connect to port 80 without being an administrator, binding wouldnâ€™t
work. As another example, binding wouldnâ€™t work if we ran two instances of our
program and so had two programs listening to the same port. Because weâ€™re
writing a basic server just for learning purposes, we wonâ€™t worry about
handling these kinds of errors; instead, we use `unwrap` to stop the program if
errors happen.
-->
<p>La fonction <code>bind</code> retourne un <code>Result&lt;T, E&gt;</code>, ce qui signifie que la crÃ©ation
de lien peut Ã©chouer. Par exemple, la connexion au port 80 nÃ©cessite d'Ãªtre
administrateur (les utilisateurs non-administrateur ne peuvent Ã©couter que sur
les ports supÃ©rieurs Ã  1024), donc si nous essayons de connecter un port 80
sans Ãªtre administrateur, le lien ne va pas fonctionner. Un autre exemple, le
lien ne va pas fonctionner si nous exÃ©cutons deux instances de notre programme
et que nous avons deux programmes qui Ã©coutent sur le mÃªme port. Comme nous
Ã©crivons un serveur basique uniquement Ã  but pÃ©dagogique, nous n'avons pas Ã 
nous soucier de la gestion de ce genre d'erreurÂ ; c'est pourquoi nous utilisons
<code>unwrap</code> pour arrÃªter l'exÃ©cution du programme si des erreurs arrivent.</p>
<!--
The `incoming` method on `TcpListener` returns an iterator that gives us a
sequence of streams (more specifically, streams of type `TcpStream`). A single
*stream* represents an open connection between the client and the server. A
*connection* is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, `TcpStream` will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this `for` loop will process each connection in turn and produce a series of
streams for us to handle.
-->
<p>La mÃ©thode <code>incoming</code> d'un <code>TcpListener</code> retourne l'itÃ©rateur qui nous donne une
sÃ©quence de flux (plus prÃ©cisÃ©ment, des flux de type <code>TcpStream</code>). Un seul
<em>flux</em> reprÃ©sente une connexion entre le client et le serveur. Une <em>connexion</em>
est le nom qui dÃ©signe tout le processus dÃ©signant la requÃªte ainsi que la
rÃ©ponse, durant lequel le client se connecte au serveur, le serveur gÃ©nÃ¨re une
rÃ©ponse, et le serveur ferme la connexion. Ainsi, <code>TcpStream</code> va se lire
lui-mÃªme pour voir ce que le client a envoyÃ© et nous permettre ensuite d'Ã©crire
notre rÃ©ponse dans le flux. De maniÃ¨re gÃ©nÃ©rale, cette boucle <code>for</code> traitera
chaque connexion dans l'ordre et produire nous une sÃ©rie de flux pour que nous
puissions les gÃ©rer.</p>
<!--
For now, our handling of the stream consists of calling `unwrap` to terminate
our program if the stream has any errors; if there arenâ€™t any errors, the
program prints a message. Weâ€™ll add more functionality for the success case in
the next listing. The reason we might receive errors from the `incoming` method
when a client connects to the server is that weâ€™re not actually iterating over
connections. Instead, weâ€™re iterating over *connection attempts*. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.
-->
<p>Pour l'instant, notre gestion des flux consiste Ã  appeler <code>unwrap</code> pour arrÃªter
notre programme si le flux rencontre une erreurÂ ; s'il n'y a pas d'erreurs, le
programme affiche un message. Nous allons ajouter plus de fonctionnalitÃ©s dans
le cas de succÃ¨s dans le prochain encart. La raison pour laquelle nous pourrions
recevoir des erreurs de la mÃ©thode <code>incoming</code> lorsqu'un client se connecte au
serveur est qu'en rÃ©alitÃ© nous n'itÃ©rons pas sur les connexions. En effet, nous
itÃ©rons sur des <em>tentatives de connexion</em>. La connexion peut Ã©chouer pour de
nombreuses raisons, beaucoup d'entre elles sont spÃ©cifiques au systÃ¨me
d'exploitation. Par exemple, de nombreux systÃ¨mes d'exploitation ont une limite
sur le nombre de connexions ouvertes simultanÃ©ment qu'ils peuvent supporterÂ ;
les tentatives de nouvelles connexions une fois ce nombre dÃ©passÃ© produiront une
erreur jusqu'Ã  ce que certaines connexions soient fermÃ©es.</p>
<!--
Letâ€™s try running this code! Invoke `cargo run` in the terminal and then load
*127.0.0.1:7878* in a web browser. The browser should show an error message
like â€œConnection reset,â€ because the server isnâ€™t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!
-->
<p>Essayons d'exÃ©cuter ce codeÂ ! Saisissez <code>cargo run</code> dans le terminal et ensuite
ouvrez <em>127.0.0.1:7878</em> dans un navigateur web. Le navigateur devrait afficher
un message d'erreur comme â€œLa connexion a Ã©tÃ© rÃ©initialisÃ©eâ€, car le serveur ne
renvois pas de donnÃ©es pour le moment. Mais si vous regardez le terminal, vous
devriez voir quelques messages qui se sont affichÃ©s lorsque le navigateur s'est
connectÃ© au serveurÂ !</p>
<!--
```text
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```
-->
<pre><code class="language-text">     Running `target/debug/salutations`
Connexion Ã©tablieÂ !
Connexion Ã©tablieÂ !
Connexion Ã©tablieÂ !
</code></pre>
<!--
Sometimes, youâ€™ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the *favicon.ico* icon that appears in the
browser tab.
-->
<p>Des fois, vous pourriez voir plusieurs messages s'afficher pour une seule
requÃªte de navigateurÂ ; la raison Ã  cela est peut-Ãªtre que le navigateur fait
une requÃªte pour la page ainsi que des requÃªtes pour d'autres ressources, comme
l'icone <em>favicon.ico</em> qui s'affiche dans l'onglet du navigateur.</p>
<!--
It could also be that the browser is trying to connect to the server multiple
times because the server isnâ€™t responding with any data. When `stream` goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the `drop` implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that weâ€™ve successfully gotten a handle to a TCP connection!
-->
<p>Peut-Ãªtre que le navigateur essaye aussi de se connecter plusieurs fois au
serveur car le serveur ne rÃ©pond aucune donnÃ©e. Lorsque <code>flux</code> sort de la portÃ©e
et est nettoyÃ© Ã  la fin de la boucle, la connexion est fermÃ©e car cela est
implÃ©mentÃ© dans le <code>drop</code>. Les navigateurs rÃ©agissent Ã  ces connexions fermÃ©es
en rÃ©-essayant, car le problÃ¨me peut Ãªtre temporaire. La partie importante est
que nous avons obtenu avec succÃ¨s un manipulateur de connexion TCPÂ !</p>
<!--
Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when youâ€™re done running a particular version of the code. Then restart `cargo
run` after youâ€™ve made each set of code changes to make sure youâ€™re running the
newest code.
-->
<p>Souvenez-vous que vous pouvez arrÃªter le programme en appuyant sur
<span class="keystroke">ctrl-c</span> lorsque vous avez fini d'exÃ©cuter une
version du code. Relancez ensuite <code>cargo run</code> aprÃ¨s avoir appliquÃ© un jeu de
modifications pour vous assurer d'exÃ©cuter le nouveau code.</p>
<!--
### Reading the Request
-->
<h3><a class="header" href="#lire-la-requÃªte" id="lire-la-requÃªte">Lire la requÃªte</a></h3>
<!--
Letâ€™s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, weâ€™ll start a new function for processing connections. In
this new `handle_connection` function, weâ€™ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.
-->
<p>CommenÃ§ons Ã  implÃ©menter la fonctionnalitÃ© pour lire la requÃªte du navigateurÂ !
Pour sÃ©parer les parties oÃ¹ nous obtenons une connexion et celle oÃ¹ nous
agissons avec la connexion, nous allons crÃ©er une nouvelle fonction pour traiter
les connexions. Dans cette nouvelle fonction <code>gestion_connexion</code>, nous allons
lire des donnÃ©es provenant du flux TCP et les afficher afin que nous puissions
voir les donnÃ©es envoyÃ©es par le navigateur. Changez le code pour qu'il
ressemble Ã  l'encart 20-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        gestion_connexion(flux);
    }
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    println!(&quot;RequÃªteÂ : {}&quot;, String::from_utf8_lossy(&amp;tampon[..]));
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-2: Reading from the `TcpStream` and printing
the data</span>
-->
<p><span class="caption">Encart 20-2Â : lecture du <code>TcpStream</code> et affichage des
donnÃ©es</span></p>
<!--
We bring `std::io::prelude` into scope to get access to certain traits that let
us read from and write to the stream. In the `for` loop in the `main` function,
instead of printing a message that says we made a connection, we now call the
new `handle_connection` function and pass the `stream` to it.
-->
<p>Nous avons importÃ© <code>std::io::prelude</code> dans la portÃ©e pour accÃ©der Ã  certains
traits qui nous permettent de lire et d'Ã©crire dans le flux. Dans la boucle
<code>for</code> de la fonction <code>main</code>, au lieu d'afficher un message qui dit que nous
avons Ã©tabli une connexion, nous faisons maintenant appel Ã  <code>gestion_connexion</code>
et nous lui passons le <code>flux</code>.</p>
<!--
In the `handle_connection` function, weâ€™ve made the `stream` parameter mutable.
The reason is that the `TcpStream` instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be `mut` because its
internal state might change; usually, we think of â€œreadingâ€ as not needing
mutation, but in this case we need the `mut` keyword.
-->
<p>Dans la fonction <code>gestion_connexion</code>, nous avons fait en sorte que le paramÃ¨tre
<code>flux</code> soit mutable. La raison Ã  cela est que l'instance de <code>TcpStream</code> garde en
mÃ©moire interne quelles donnÃ©es il nous a retournÃ©. Il peut avoir plus de
donnÃ©es que celles que nous avons demandÃ©, et il peut alors conserver ces
donnÃ©es jusqu'Ã  la prochaine fois oÃ¹ nous demanderons des donnÃ©es. Il doit donc
Ãªtre <code>mut</code> car son Ã©tat interne doit pouvoir changerÂ ; d'habitude, nous n'avons
pas besoin que la â€œlectureâ€ nÃ©cessite d'Ãªtre mutable, mais dans ce cas nous
avons besoin du mot-clÃ© <code>mut</code>.</p>
<!--
Next, we need to actually read from the stream. We do this in two steps:
first, we declare a `buffer` on the stack to hold the data that is read in.
Weâ€™ve made the buffer 1024 bytes in size, which is big enough to hold the
data of a basic request and sufficient for our purposes in this chapter. If
we wanted to handle requests of an arbitrary size, buffer management would
need to be more complicated; weâ€™ll keep it simple for now. We pass the buffer
to `stream.read`, which will read bytes from the `TcpStream` and put them in
the buffer.
-->
<p>Ensuite, nous devons lire les donnÃ©es du flux. Nous faisons cela en deux
tempsÂ : d'abord, nous dÃ©clarons un <code>tampon</code> sur la pile pour y stocker les
donnÃ©es qui seront lues. Nous avons fait en sorte que le tampon fasse 1024
octets, ce qui est suffisamment grand pour stocker les donnÃ©es d'un requÃªte
basique, ce qui est suffisant pour nos besoins dans ce chapitre. Si nous
aurions voulu gÃ©rer des requÃªtes de tailles quelconques, la gestion du tampon
aurait Ã©tÃ© plus complexeÂ ; nous allons la garder simplifiÃ©e pour l'instant.
Nous envoyons le tampon dans <code>flux.read</code>, qui va lire les octets provenant du
<code>TcpStream</code> et les ajouter dans le tampon.</p>
<!--
Second, we convert the bytes in the buffer to a string and print that string.
The `String::from_utf8_lossy` function takes a `&[u8]` and produces a `String`
from it. The â€œlossyâ€ part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with `ï¿½`, the `U+FFFD REPLACEMENT CHARACTER`. You might see replacement
characters for characters in the buffer that arenâ€™t filled by request data.
-->
<p>Ensuite, nous convertissons les octets prÃ©sents dans le tampon en chaÃ®nes de
caractÃ¨res et nous affichons cette chaÃ®ne de caractÃ¨res. La fonction
<code>String::from_utf8_lossy</code> prends en paramÃ¨tres un <code>&amp;[u8]</code> le transforme en une
<code>String</code>. La partie â€œlossyâ€ du nom indique le comportement de cette fonction
lorsqu'elle rencontre une sÃ©quence UTF-8 invalideÂ : elle va remplacer la
sÃ©quence invalide par <code>ï¿½</code>, le caractÃ¨re <code>U+FFFD REPLACEMENT CHARACTER</code>. Vous
devriez voir ces caractÃ¨res de remplacement pour les caractÃ¨res dans le
tampon qui ne correspondent pas aux donnÃ©es de la demande.</p>
<!--
Letâ€™s try this code! Start the program and make a request in a web browser
again. Note that weâ€™ll still get an error page in the browser, but our
programâ€™s output in the terminal will now look similar to this:
-->
<p>Essayons ce codeÂ ! DÃ©marrez le programme et faites Ã  nouveau une requÃªte dans
un navigateur web. Notez que nous obtenons toujours une page d'erreur dans le
navigateur web, mais que la sortie de notre programme dans le terminal devrait
ressembler Ã  ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/salutations`
RequÃªteÂ : GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
</code></pre>
<!--
Depending on your browser, you might get slightly different output. Now that
weâ€™re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after `Request: GET`. If the
repeated connections are all requesting */*, we know the browser is trying to
fetch */* repeatedly because itâ€™s not getting a response from our program.
-->
<p>En fonction de votre navigateur, vous pourriez voir une sortie lÃ©gÃ¨rement
diffÃ©rente. Maintenant que nous affichons les donnÃ©es des requÃªtes, nous
pouvons constater pourquoi nous obtenons pourquoi nous obtenons plusieurs
connexions pour un seul chargement de page dans le navigateur web en analysant
le chemin aprÃ¨s le <code>RequÃªteÂ : GET</code>. Si les connexions rÃ©pÃ©tÃ©es sont toutes vers
<em>/</em>, nous pouvons constater que le navigateur essaye d'obtenir <em>/</em> Ã  rÃ©pÃ©tition
car il n'obtient pas de rÃ©ponse de la part de notre programme.</p>
<!--
Letâ€™s break down this request data to understand what the browser is asking of
our program.
-->
<p>DÃ©composons les donnÃ©es de cette requÃªte pour comprendre ce que le navigateur
demande Ã  notre programme.</p>
<!--
### A Closer Look at an HTTP Request
-->
<h3><a class="header" href="#une-analyse-plus-poussÃ©e-dune-requÃªte-http" id="une-analyse-plus-poussÃ©e-dune-requÃªte-http">Une analyse plus poussÃ©e d'une requÃªte HTTP</a></h3>
<!--
HTTP is a text-based protocol, and a request takes this format:
-->
<p>HTTP est un protocole basÃ© sur du texte, et une requÃªte doit suivre cette
formeÂ :</p>
<!--
```text
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">MÃ©thode URI-DemandÃ©e Version-HTTP CRLF
entÃªtes CRLF
corps-du-message
</code></pre>
<!--
The first line is the *request line* that holds information about what the
client is requesting. The first part of the request line indicates the *method*
being used, such as `GET` or `POST`, which describes how the client is making
this request. Our client used a `GET` request.
-->
<p>La premiÃ¨re ligne est la <em>ligne de requÃªte</em> qui contient les informations sur
ce que demande le client. La premiÃ¨re partie de la ligne de requÃªte indique la
<em>mÃ©thode</em> utilisÃ©e, comme <code>GET</code> ou <code>POST</code>, qui dÃ©crit comment le client fait sa
requÃªte. Notre client a utilisÃ© une requÃªte <code>GET</code>.</p>
<!--
The next part of the request line is */*, which indicates the *Uniform Resource
Identifier* *(URI)* the client is requesting: a URI is almost, but not quite,
the same as a *Uniform Resource Locator* *(URL)*. The difference between URIs
and URLs isnâ€™t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.
-->
<p>La prochaine partie de la ligne de requÃªte est <em>/</em>, qui indique <em>l'URI</em>
<em>(Uniform Resource Identifier)</em> que demande le clientÂ : une URI est presque,
mais pas complÃ¨tement, la mÃªme chose qu'une <em>URL</em> <em>(Uniform Resource Locator)</em>.
La diffÃ©rence entre les URI et les URL n'est pas trÃ¨s importante pour nos
besoins dans ce chapitre, mais la spÃ©cification de HTTP utilise le terme URI,
donc nous pouvons simplement remplacer URL par URI dans ce cas-ci.</p>
<!--
The last part is the HTTP version the client uses, and then the request line
ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,
which are terms from the typewriter days!) The CRLF sequence can also be
written as `\r\n`, where `\r` is a carriage return and `\n` is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than `\r\n`.
-->
<p>La derniÃ¨re partie est la version HTTP que le client utilise, et ensuite la
ligne de requÃªte termine avec une <em>sÃ©quence CRLF</em> (CRLF signifie
<em>Carriage Return, retour chariot</em>, et <em>Line Feed, saut de ligne</em> qui sont des
termes qui remontent Ã  l'Ã©poque des machines Ã  Ã©crireÂ !). La sÃ©quence CRLF peut
aussi Ãªtre Ã©crite <code>\r\n</code>, dans laquelle <code>\r</code> est un retour chariot, et <code>\n</code> est
un saut de ligne. La sÃ©quence CRLF sÃ©pare la ligne de requÃªte du reste des
donnÃ©es de la requÃªte. Notez toutefois que lorsqu'un CRLF est affichÃ©, nous
voyons une nouvelle ligne plutÃ´t qu'un <code>\r\n</code>.</p>
<!--
Looking at the request line data we received from running our program so far,
we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the
version.
-->
<p>D'aprÃ¨s la ligne de requÃªte que nous avons reÃ§u aprÃ¨s avoir exÃ©cutÃ© notre
programme prÃ©cÃ©demment, nous constatons que la mÃ©thode est <code>GET</code>, <em>/</em> est l'URI
demandÃ©e, et <code>HTTP/1.1</code> est la version.</p>
<!--
After the request line, the remaining lines starting from `Host:` onward are
headers. `GET` requests have no body.
-->
<p>AprÃ¨s la ligne de requÃªte, les lignes aprÃ¨s celle oÃ¹ nous avons <code>Host:</code> sont
des entÃªtes. Les requÃªtes <code>GET</code> n'ont pas de corps.</p>
<!--
Try making a request from a different browser or asking for a different
address, such as *127.0.0.1:7878/test*, to see how the request data changes.
-->
<p>Essayez de faire une requÃªte dans un navigateur diffÃ©rent ou de demander une
adresse diffÃ©rente, comme <em>127.0.0.1:7878/test</em>, pour observer comment les
donnÃ©es de requÃªte changent.</p>
<!--
Now that we know what the browser is asking for, letâ€™s send back some data!
-->
<p>Maintenant que nous savons ce que demande le navigateur, envoyons-lui quelques
donnÃ©esÂ !</p>
<!--
### Writing a Response
-->
<h3><a class="header" href="#ecrire-une-rÃ©ponse" id="ecrire-une-rÃ©ponse">Ecrire une rÃ©ponse</a></h3>
<!--
Now weâ€™ll implement sending data in response to a client request. Responses
have the following format:
-->
<p>Maintenant, nous allons implÃ©menter l'envoi d'une rÃ©ponse Ã  requÃªte client. Les
rÃ©ponses suivent le format suivantÂ :</p>
<!--
```text
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">Version-HTTP Code-Statut Phrase-De-Raison CRLF
entÃªtes CRLF
corps-message
</code></pre>
<!--
The first line is a *status line* that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.
-->
<p>La premiÃ¨re ligne est une <em>ligne de statut</em> qui contient la version HTTP
utilisÃ©e dans la rÃ©ponse, un code numÃ©rique de statut qui rÃ©sume le rÃ©sultat
de la requÃªte, et une phrase de raison qui fournit une description textuelle du
code de statut. AprÃ¨s la sÃ©quence CRLF viennent tous les entÃªtes, une autre
sÃ©quence CRLF, et enfin le corps de la rÃ©ponse.</p>
<!--
Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:
-->
<p>Voici un exemple de rÃ©ponse qui utilise HTTP version 1.1, qui a un code de
statut de 200, une phrase de raison Ã  OK, pas d'entÃªtes, et pas de corpsÂ :</p>
<!--
```text
HTTP/1.1 200 OK\r\n\r\n
```
-->
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<!--
The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Letâ€™s write this to the stream as our response to a
successful request! From the `handle_connection` function, remove the
`println!` that was printing the request data and replace it with the code in
Listing 20-3.
-->
<p>Le code de statut 200 est la rÃ©ponse standard de succÃ¨s. Le texte est une toute
petite rÃ©ponse HTTP de succÃ¨s. Ecrivons ceci dans le flux de notre rÃ©ponse Ã 
une requÃªte avec succÃ¨sÂ ! Dans la fonction <code>gestion_connexion</code>, enlevez le
<code>println!</code> qui affiche les donnÃ©es de requÃªte et remplacez-la par le code de
l'encart 20-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    let reponse = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span>
-->
<p><span class="caption">Encart 20-3Â : Ã©criture d'une toute petite rÃ©ponse HTTP de
rÃ©ussite dans le flux</span></p>
<!--
The first new line defines the `response` variable that holds the success
messageâ€™s data. Then we call `as_bytes` on our `response` to convert the string
data to bytes. The `write` method on `stream` takes a `&[u8]` and sends those
bytes directly down the connection.
-->
<p>La premiÃ¨re ligne dÃ©finit la variable <code>reponse</code> qui contient les donnÃ©es du
message de rÃ©ussite. Ensuite, nous faisons appel Ã  <code>as_bytes</code> sur notre
<code>reponse</code> pour convertir la chaÃ®ne de caractÃ¨res en octets. La mÃ©thode <code>write</code>
sur le <code>flux</code> prend en argument un <code>&amp;[u8]</code> et envoie ces octets directement
dans la connexion.</p>
<!--
Because the `write` operation could fail, we use `unwrap` on any error result
as before. Again, in a real application you would add error handling here.
Finally, `flush` will wait and prevent the program from continuing until all
the bytes are written to the connection; `TcpStream` contains an internal
buffer to minimize calls to the underlying operating system.
-->
<p>Comme l'opÃ©ration <code>write</code> peut Ã©chouer, nous utilisons <code>unwrap</code> sur toutes les
erreurs, comme prÃ©cÃ©demment. Encore une foisÂ ; dans un vÃ©ritable application,
vous devriez gÃ©rer les cas d'erreur ici. Enfin, <code>flush</code> va attendre et empÃªcher
le programme de continuer Ã  s'exÃ©cuter jusqu'Ã  ce que tous les octets soient
Ã©crits dans la connexionÂ ; <code>TcpStream</code> contient un tampon interne pour rÃ©duire
les appels au systÃ¨me d'exploitation concernÃ©.</p>
<!--
With these changes, letâ€™s run our code and make a request. Weâ€™re no longer
printing any data to the terminal, so we wonâ€™t see any output other than the
output from Cargo. When you load *127.0.0.1:7878* in a web browser, you should
get a blank page instead of an error. Youâ€™ve just hand-coded an HTTP request
and response!
-->
<p>Avec ces modifications, exÃ©cutons Ã  nouveau notre code et lanÃ§ons une requÃªte
dans le navigateur. Nous n'affichons plus les donnÃ©es dans le terminal, donc
nous ne voyons plus aucune sortie autre que celle de Cargo. Lorsque vous
chargez <em>127.0.0.1:7878</em> dans un navigateur web, vous devriez obtenir une page
blanche plutÃ´t qu'une erreur. Vous venez de coder en dur une rÃ©ponse Ã  une
requÃªte HTTPÂ !</p>
<!--
### Returning Real HTML
-->
<h3><a class="header" href="#retourner-du-vrai-html" id="retourner-du-vrai-html">Retourner du vrai HTML</a></h3>
<!--
Letâ€™s implement the functionality for returning more than a blank page. Create
a new file, *hello.html*, in the root of your project directory, not in the
*src* directory. You can input any HTML you want; Listing 20-4 shows one
possibility.
-->
<p>ImplÃ©mentons la fonctionnalitÃ© pour retourner plus qu'une page blanche. CrÃ©ez
un nouveau fichier, <em>hello.html</em>, Ã  la racine de votre dossier de projet, et
non pas dans le dossier <em>src</em>. Vous pouvez ajouter le HTML que vous souhaitezÂ ;
l'encart 20-4 vous montre une possibilitÃ©.</p>
<!--
<span class="filename">Filename: hello.html</span>
-->
<p><span class="filename">FichierÂ : salutation.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1><a class="header" href="#hello" id="hello">Hello!</a></h1>
    <p>Hi from Rust</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;SalutationsÂ !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;SalutÂ !&lt;/h1&gt;
    &lt;p&gt;Bonjour de la part de Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-4: A sample HTML file to return in a
response</span>
-->
<p><span class="caption">Encart 20-4Â : un exemple de fichier HTML Ã  retourner dans
une rÃ©ponse</span></p>
<!--
This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, weâ€™ll modify `handle_connection` as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.
-->
<p>Ceci est un document HTML5 minimal avec des entÃªtes et un peu de texte. Pour
retourner ceci Ã  partir d'un serveur lorsqu'une requÃªte est reÃ§ue, nous allons
modifier <code>gestion_connexion</code> comme proposÃ© dans l'encart 20-5 pour lire le
fichier HTML, l'ajouter dans la rÃ©ponse comme faisant partie de son corps, et
l'envoyer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
use std::fs;
// --snip--

# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let contents = fs::read_to_string("hello.html").unwrap();

    let response = format!(
        "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// -- partie masquÃ©e ici --

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let reponse = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-5: Sending the contents of *hello.html* as the
body of the response</span>
-->
<p><span class="caption">Encart 20-5Â : envoi du contenu de <em>salutation.html</em> dans
le corps de la rÃ©ponse</span></p>
<!--
Weâ€™ve added a line at the top to bring the standard libraryâ€™s filesystem module
into scope. The code for reading the contents of a file to a string should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.
-->
<p>Nous avons ajoutÃ© une ligne en haut pour importer le module de systÃ¨me de
fichiers de la bibliothÃ¨que standard. Le code pour lire le contenu d'un fichier
dans une <code>String</code> devrait vous Ãªtre familierÂ ; nous n'avons utilisÃ© dans le
chapitre 12 lorsque nous lisions le contenu d'un fichier pour notre projet
d'entrÃ©e/sortie, dans l'encart 12-4.</p>
<!--
Next, we use `format!` to add the fileâ€™s contents as the body of the success
response. To ensure a valid HTTP response, we add the `Content-Length` header
which is set to the size of our response body, in this case the size of `hello.html`.
-->
<p>Ensuite, nous avons utilisÃ© <code>format!</code> pour ajouter le contenu du fichier comme
Ã©tant le corps de la rÃ©ponse avec succÃ¨s. Pour garantir que ce soit une rÃ©ponse
HTTP valide, nous avons ajoutÃ© l'entÃªte <code>Content-Length</code> qui dÃ©finit la taille
du corps de notre rÃ©ponse, qui dans ce cas est la taille de <code>hello.html</code>.</p>
<!--
Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; you
should see your HTML rendered!
-->
<p>ExÃ©cutez ce code avec <code>cargo run</code> et ouvrez <em>127.0.0.1:7878</em> dans votre
navigateur webÂ ; vous devriez voir le rÃ©sultat de votre HTMLÂ !</p>
<!--
Currently, weâ€™re ignoring the request data in `buffer` and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
*127.0.0.1:7878/something-else* in your browser, youâ€™ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to */*.
-->
<p>Pour le moment, nous ignorons les donnÃ©es de la requÃªte prÃ©sentes dans
<code>tampon</code> et nous renvoyons sans conditions le contenu du fichier HTML. Cela
signifie que si vous essayez de demander <em>127.0.0.1:7878/autre-chose</em> dans
votre navigateur web, vous obtiendrez la mÃªme rÃ©ponse HTML. Notre serveur est
trÃ¨s limitÃ©, et ne correspond pas Ã  ce que font la plupart des serveurs web.
Nous souhaitons dÃ©sormais personnaliser nos rÃ©ponses en fonction de la requÃªte
et renvoyer seulement le fichier HTML pour la bonne requÃªte faite Ã  <em>/</em>.</p>
<!--
### Validating the Request and Selectively Responding
-->
<h3><a class="header" href="#valider-la-requÃªte-et-rÃ©pondre-de-maniÃ¨re-sÃ©lective" id="valider-la-requÃªte-et-rÃ©pondre-de-maniÃ¨re-sÃ©lective">Valider la requÃªte et rÃ©pondre de maniÃ¨re sÃ©lective</a></h3>
<!--
Right now, our web server will return the HTML in the file no matter what the
client requested. Letâ€™s add functionality to check that the browser is
requesting */* before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify `handle_connection`,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for */* looks like and adds `if` and
`else` blocks to treat requests differently.
-->
<p>Jusqu'Ã  prÃ©sent, notre serveur web devrait retourner le HTML du fichier peu
importe ce que demande le client. Ajoutons une fonctionnalitÃ© pour vÃ©rifier que
le navigateur demande bien <em>/</em> avant de retourner le fichier HTML et retournons
une erreur si le navigateur demande autre chose. Pour cela, nous devons
modifier <code>gestion_connexion</code> comme l'encart 20-6. Ce nouveau code compare le
contenu de la requÃªte que nous recevons Ã  une requÃªte que nous voudrions pour
<em>/</em> en ajoutant des blocs <code>if</code> et <code>else</code> pour traiter diffÃ©remment les requÃªtes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";

    if buffer.starts_with(get) {
        let contents = fs::read_to_string("hello.html").unwrap();

        let response = format!(
            "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if tampon.starts_with(get) {
        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let reponse = format!(
            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
            contenu.len(),
            contenu
        );

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    } else {
        // autres requÃªtes
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-6: Matching the request and handling requests
to */* differently from other requests</span>
-->
<p><span class="caption">Encart 20-6Â : dÃ©tection et gestion des requÃªtes vers <em>/</em>,
qui est diffÃ©rente en fonction des autres requÃªtes</span></p>
<!--
First, we hardcode the data corresponding to the */* request into the `get`
variable. Because weâ€™re reading raw bytes into the buffer, we transform `get`
into a byte string by adding the `b""` byte string syntax at the start of the
content data. Then we check whether `buffer` starts with the bytes in `get`. If
it does, it means weâ€™ve received a well-formed request to */*, which is the
success case weâ€™ll handle in the `if` block that returns the contents of our
HTML file.
-->
<p>D'abord, nous codons en dur les donnÃ©es correspondant Ã  la requÃªte <em>/</em> dans la
variable <code>get</code>. Comme nous lisons des octets bruts provenant du tampon, nous
transformons <code>get</code> en une chaÃ®ne d'octets en ajoutant la syntaxe de chaÃ®ne
d'octets <code>b&quot;&quot;</code> au dÃ©but du contenu des donnÃ©es. Ensuite, nous attendons le
moment oÃ¹ le <code>tampon</code> commence par les mÃªmes octets que ceux dans <code>get</code>.
Lorsque c'est le cas, cela signifie que nous avons reÃ§u une requÃªte
correctement bien formulÃ©e vers <em>/</em>, qui est le cas de rÃ©ussite que nous allons
gÃ©rer dans le bloc <code>if</code> qui retourne le contenu de notre fichier HTML.</p>
<!--
If `buffer` does *not* start with the bytes in `get`, it means weâ€™ve received
some other request. Weâ€™ll add code to the `else` block in a moment to respond
to all other requests.
-->
<p>Si <code>tampon</code> ne <em>commence pas</em> avec les octets prÃ©sents dans <code>get</code>, cela
signifie que nous avons reÃ§u une autre requÃªte. Nous allons bientÃ´t ajouter du
code au bloc <code>else</code> pour rÃ©pondre Ã  toutes les autres requÃªtes.</p>
<!--
Run this code now and request *127.0.0.1:7878*; you should get the HTML in
*hello.html*. If you make any other request, such as
*127.0.0.1:7878/something-else*, youâ€™ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.
-->
<p>ExÃ©cutez ce code maintenant et demandez <em>127.0.0.1:7878</em>Â ; vous devriez obtenir
le HTML de <em>salutation.html</em>. Si vous faites n'importe quelle autre requÃªte,
comme <em>127.0.0.1:7878/autre-chose</em>, vous allez obtenir une erreur de connexion
comme celle que vous avez vu lorsque vous exÃ©cutiez le code l'encart 20-1 et de
l'encart 20-2.</p>
<!--
Now letâ€™s add the code in Listing 20-7 to the `else` block to return a response
with the status code 404, which signals that the content for the request was
not found. Weâ€™ll also return some HTML for a page to render in the browser
indicating the response to the end user.
-->
<p>Maintenant ajoutons le code de l'encart 20-7 au bloc <code>else</code> pour retourner une
rÃ©ponse avec le code de statut 404, qui signale que le contenu demandÃ© par
cette requÃªte n'est pas trouvÃ©. Nous allons aussi retourner du HTML pour qu'une
page s'affiche dans le navigateur, indiquant la rÃ©ponse Ã  l'utilisateur final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
#     if buffer.starts_with(get) {
#         let contents = fs::read_to_string("hello.html").unwrap();
# 
#         let response = format!(
#             "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
#             contents.len(),
#             contents
#         );
# 
#         stream.write(response.as_bytes()).unwrap();
#         stream.flush().unwrap();
    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND\r\n\r\n";
        let contents = fs::read_to_string("404.html").unwrap();

        let response = format!("{}{}", status_line, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    if tampon.starts_with(get) {
</span><span class="boring">        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">        let reponse = format!(
</span><span class="boring">            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">            contenu.len(),
</span><span class="boring">            contenu
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">        flux.flush().unwrap();
</span>    // -- partie masquÃ©e ici --
    } else {
        let ligne_statut = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
        let contenu = fs::read_to_string(&quot;404.html&quot;).unwrap();

        let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than */* was requested</span>
-->
<p><span class="caption">Encart 20-7Â : rÃ©pondre un code de statut 404 et une page
d'erreur s'il y autre chose que <em>/</em> qui est demandÃ©</span></p>
<!--
Here, our response has a status line with status code 404 and the reason
phrase `NOT FOUND`. Weâ€™re still not returning headers, and the body of the
response will be the HTML in the file *404.html*. Youâ€™ll need to create a
*404.html* file next to *hello.html* for the error page; again feel free to use
any HTML you want or use the example HTML in Listing 20-8.
-->
<p>Ici, notre rÃ©ponse a une ligne de statut avec le code de statut 404 et la
phrase de raison <code>NOT FOUND</code>. Nous ne retournons toujours pas d'entÃªtes, et le
corps de la rÃ©ponse sera le HTML prÃ©sent dans le fichier <em>404.html</em>. Nous aurons
besoin de crÃ©er un fichier <code>404.html</code> Ã  cÃ´tÃ© de <em>salutation.html</em> pour la page
d'erreurÂ ; n'hÃ©sitez pas Ã  nouveau Ã  utiliser le HTML que vous souhaitez ou Ã 
dÃ©faut utiliser le HTML d'exemple prÃ©sent dans l'encart 20-8.</p>
<!--
<span class="filename">Filename: 404.html</span>
-->
<p><span class="filename">FichierÂ : 404.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1><a class="header" href="#oops" id="oops">Oops!</a></h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;SalutationsÂ !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;OupsÂ !&lt;/h1&gt;
    &lt;p&gt;DÃ©solÃ©, je ne connaÃ®t pas ce que vous demandez.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span>
-->
<p><span class="caption">Encart 20-8Â : contenu d'exemple pour la page Ã  renvoyer
avec les rÃ©ponses 404</span></p>
<!--
With these changes, run your server again. Requesting *127.0.0.1:7878*
should return the contents of *hello.html*, and any other request, like
*127.0.0.1:7878/foo*, should return the error HTML from *404.html*.
-->
<p>Une fois ces modifications appliquÃ©es, exÃ©cutez Ã  nouveau votre serveur. Les
requÃªtes vers <em>127.0.0.1:7878</em> devraient retourner le contenu de
<em>salutation.html</em>, et toutes les autres requÃªtes, comme
<em>127.0.0.1:7878/autre-chose</em>, devraient retourner le HTML d'erreur prÃ©sent dans
<em>404.html</em>.</p>
<!--
### A Touch of Refactoring
-->
<h3><a class="header" href="#un-peu-de-remaniement" id="un-peu-de-remaniement">Un peu de remaniement</a></h3>
<!--
At the moment the `if` and `else` blocks have a lot of repetition: theyâ€™re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Letâ€™s make the code more
concise by pulling out those differences into separate `if` and `else` lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large `if` and `else` blocks.
-->
<p>Pour l'instant, les blocs <code>if</code> et <code>else</code> contiennent beaucoup de code rÃ©pÃ©tÃ©Â :
ils lisent tous les deux des fichiers et Ã©crivent le contenu de ces fichiers
dans le flux. La seule diffÃ©rence entre eux sont la ligne de statut et le nom
du fichier. Rendons le code plus concis en isolant ces diffÃ©rences dans des
lignes <code>if</code> et <code>else</code> qui vont assigner les valeurs de la ligne de statut et du
nom de fichier Ã  des variablesÂ ; nous pourrons ensuite utiliser ces variables
sans avoir Ã  se prÃ©occuper du contexte dans du code qui va lire le fichier et
Ã©crire la rÃ©ponse. L'encart 20-9 montre le code qui dÃ©coule du remplacement des
gros blocs <code>if</code> et <code>else</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!("{}{}", status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici--

fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masquÃ©e ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span>    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-9: Refactoring the `if` and `else` blocks to
contain only the code that differs between the two cases</span>
-->
<p><span class="caption">Encart 20-9Â : remaniement des blocs <code>if</code> et <code>else</code> pour
qu'ils contiennent uniquement le code qui diffÃ©rencie les deux cas</span></p>
<!--
Now the `if` and `else` blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to `status_line` and `filename` using a pattern in the `let`
statement, as discussed in Chapter 18.
-->
<p>Maintenant que les blocs <code>if</code> et <code>else</code> retournent uniquement les valeurs
correctes pour la ligne de statut et le nom du fichier dans un tupleÂ ; nous
pouvons utiliser la dÃ©structuration pour assigner ces deux valeurs Ã 
<code>ligne_statut</code> et <code>nom_fichier</code> en utilisant un motif dans l'instruction <code>let</code>,
comme nous l'avons vu dans le chapitre 18.</p>
<!--
The previously duplicated code is now outside the `if` and `else` blocks and
uses the `status_line` and `filename` variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.
-->
<p>Le code prÃ©cÃ©dent qui Ã©tait en double se trouve maintenant Ã  l'extÃ©rieur des
blocs <code>if</code> et <code>else</code> et utilise les variables <code>ligne_statut</code> et <code>nom_fichier</code>.
Cela permet de mettre en Ã©vidence plus facilement les diffÃ©rences entre les
deux cas, et cela signifie que nous n'avons qu'un seul endroit du code Ã 
modifier si nous souhaitons changer le fonctionnement de lecture du fichier et
d'Ã©criture de la rÃ©ponse. Le comportement du code de l'encart 20-9 devrait Ãªtre
identique Ã  celui de l'encart 20-8.</p>
<!--
Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.
-->
<p>SuperÂ ! Nous avons maintenant un serveur web simple qui tient dans environ 40
lignes de code, qui rÃ©pond Ã  une requÃªte prÃ©cise par sa page de contenu et
rÃ©pond Ã  toutes les autres avec une rÃ©ponse 404.</p>
<!--
Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Letâ€™s examine how that can be a problem by simulating some
slow requests. Then weâ€™ll fix it so our server can handle multiple requests at
once.
-->
<p>Actuellement, notre serveur fonctionne dans une seule tÃ¢che, ce qui signifie
qu'il ne peut rÃ©pondre qu'Ã  une seule requÃªte Ã  la fois. Examinons maintenant
Ã  quel point cela peut Ãªtre un problÃ¨me en simulant des rÃ©ponses lentes Ã  des
requÃªtes. Ensuite, nous corrigerons notre serveur pour qu'il puisse gÃ©rer
plusieurs requÃªtes Ã  la fois.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--52" id="-attention-peinture-fraÃ®che--52">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/216">Pull Request</a>.</p>
</blockquote>
<!--
## Turning Our Single-Threaded Server into a Multithreaded Server
-->
<h2><a class="header" href="#transformer-notre-serveur-monotÃ¢che-en-serveur-multitÃ¢ches" id="transformer-notre-serveur-monotÃ¢che-en-serveur-multitÃ¢ches">Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></h2>
<!--
Right now, the server will process each request in turn, meaning it wonâ€™t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. Weâ€™ll need to fix
this, but first, weâ€™ll look at the problem in action.
-->
<p>Jusqu'Ã  prÃ©sent, le serveur va traiter chaque requÃªte dans l'ordre, ce qui
signifie qu'il ne va pas traiter une seconde connexion tant que la premiÃ¨re
n'a pas fini d'Ãªtre traitÃ©e. Si le serveur reÃ§oit encore plus de requÃªtes,
cette exÃ©cution Ã  la chaÃ®ne sera de moins en moins optimale. Si le serveur
reÃ§oit une requÃªte qui prend longtemps Ã  traiter, les demandes suivantes
devront attendre que la longue requÃªte Ã  traiter soit terminÃ©e, mÃªme si les
nouvelles requÃªtes peuvent Ãªtre traitÃ©es rapidement. Nous devons corriger cela,
mais d'abord, observons ce problÃ¨me en pratique.</p>
<!--
### Simulating a Slow Request in the Current Server Implementation
-->
<h3><a class="header" href="#simuler-une-longue-requÃªte-Ã -traiter-avec-limplÃ©mentation-actuelle-du-serveur" id="simuler-une-longue-requÃªte-Ã -traiter-avec-limplÃ©mentation-actuelle-du-serveur">Simuler une longue requÃªte Ã  traiter avec l'implÃ©mentation actuelle du serveur</a></h3>
<!--
Weâ€™ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to */sleep* with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.
-->
<p>Nous allons voir comment une requÃªte longue Ã  traiter peut influer sur le
traitement des autres requÃªtes par l'implÃ©mentation actuelle de notre serveur.
L'encart 20-10 rajoute le traitement d'une requÃªte pour <em>/pause</em> qui va simuler
une longue rÃ©ponse qui va faire en sorte que le serveur soit en pause pendant 5
secondes avant de rÃ©pondre Ã  nouveau.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
use std::thread;
use std::time::Duration;
// --snip--
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    // --snip--
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span>use std::thread;
use std::time::Duration;
// -- partie masquÃ©e ici--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masquÃ©e ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span>    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;

    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if tampon.starts_with(pause) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // -- partie masquÃ©e ici--
<span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 20-10: Simulating a slow request by recognizing
*/sleep* and sleeping for 5 seconds</span>
-->
<p><span class="caption">Encart 20-10Â : simulation d'un long traitement de requÃªte
en dÃ©tectant <em>/pause</em> et en faisant une pause de 5 secondes</span></p>
<!--
This code is a bit messy, but itâ€™s good enough for simulation purposes. We
created a second request `sleep`, whose data our server recognizes. We added an
`else if` after the `if` block to check for the request to */sleep*. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.
-->
<p>Ce code est peu brouillon, mais est suffisant pour nos besoins de simulation.
Nous avons crÃ©Ã© une seconde possibilitÃ© de requÃªte <code>pause</code>, avec les donnÃ©es que
notre serveur va dÃ©tecter. Nous avons ajoutÃ© un <code>else if</code> aprÃ¨s le bloc <code>if</code>
pour vÃ©rifier les requÃªtes vers <em>/pause</em>. Lorsque cette requÃªte est reÃ§ue, le
serveur va se mettre en pause pendant 5 secondes avant de gÃ©nÃ©rer la page HTML
de succÃ¨s.</p>
<!--
You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!
-->
<p>Vous pouvez constater Ã  quel point notre serveur est primitifÂ : une
bibliothÃ¨que digne de ce nom devrait gÃ©rer la dÃ©tection de diffÃ©rents types de
requÃªtes de maniÃ¨re bien moins verbeuseÂ !</p>
<!--
Start the server using `cargo run`. Then open two browser windows: one for
*http://127.0.0.1:7878/* and the other for *http://127.0.0.1:7878/sleep*. If
you enter the */* URI a few times, as before, youâ€™ll see it respond quickly.
But if you enter */sleep* and then load */*, youâ€™ll see that */* waits until
`sleep` has slept for its full 5 seconds before loading.
-->
<p>DÃ©marrez le serveur en utilisant <code>cargo run</code>. Ouvrez ensuite deux fenÃªtres de
navigateur webÂ : une pour <em>http://127.0.0.1:7878/</em> et l'autre pour
<em>http://127.0.0.1:7878/pause</em>. Si vous demandez l'URI <em>/</em> plusieurs fois, comme
vous l'avez fait prÃ©cÃ©demment, vous constaterez que le serveur rÃ©pond
rapidement. Mais lorsque vous saisirez <em>/pause</em> et que vous chargerez ensuite
<em>/</em>, vous constaterez que <em>/</em> attend que <code>pause</code> ai fini sa pause des 5
secondes avant de se charger.</p>
<!--
There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one weâ€™ll implement is
a thread pool.
-->
<p>Il y a plusieurs maniÃ¨res de changer le fonctionnement de notre serveur web
pour Ã©viter d'accumuler des requÃªtes aprÃ¨s une requÃªte dont le traitement est
longÂ ; celle que nous allons implÃ©menter est un groupe de tÃ¢ches.</p>
<!--
### Improving Throughput with a Thread Pool
-->
<h3><a class="header" href="#amÃ©liorer-le-dÃ©bit-avec-un-groupe-de-tÃ¢ches" id="amÃ©liorer-le-dÃ©bit-avec-un-groupe-de-tÃ¢ches">AmÃ©liorer le dÃ©bit avec un groupe de tÃ¢ches</a></h3>
<!--
A *thread pool* is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, itâ€™s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.
-->
<p>Un <em>groupe de tÃ¢ches</em> est un groupe constituÃ© de tÃ¢ches qui ont Ã©tÃ© crÃ©es et
qui attendent des missions. Lorsque le programme reÃ§oit une nouvelle mission,
il assigne une des tÃ¢ches du groupe pour cette mission, et cette tÃ¢che va
traiter la mission. Les tÃ¢ches restantes dans le groupe restent disponibles
pour traiter d'autres missions qui peuvent arriver pendant que la premiÃ¨re
tÃ¢che est en cours de traitement. Lorsque la premiÃ¨re tÃ¢che a fini avec sa
mission, elle retourne dans le groupe de tÃ¢ches inactives, prÃªte Ã  gÃ©rer une
nouvelle tÃ¢che. Un groupe de tÃ¢ches vous permet de traiter plusieurs connexions
en simultanÃ©, ce qui augmente le dÃ©bit de votre serveur.</p>
<!--
Weâ€™ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our serverâ€™s resources and grinding
the processing of requests to a halt.
-->
<p>Nous allons limiter le nombre de tÃ¢ches dans le groupe Ã  un petit nombre pour
nous protÃ©ger d'attaques par dÃ©ni de service (Denial of Service, DoS)Â ; si notre
programme crÃ©ait une nouvelle tÃ¢che Ã  chaque requÃªte qu'il reÃ§oit, quelqu'un qui
fait 10 millions de requÃªtes Ã  notre serveur pourrait faire des ravages en
utilisant toutes les ressources de notre serveur et paralyser le traitement des
demandes.</p>
<!--
Rather than spawning unlimited threads, weâ€™ll have a fixed number of threads
waiting in the pool. As requests come in, theyâ€™ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
`N` requests concurrently, where `N` is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but weâ€™ve increased the number of long-running requests we can
handle before reaching that point.
-->
<p>PlutÃ´t que de gÃ©nÃ©rer des tÃ¢ches en quantitÃ© illimitÃ©e, nous allons faire en
sorte qu'il y ait un nombre fixe de tÃ¢ches qui seront en attente dans le
groupe. Lorsqu'une requÃªte arrive, une tÃ¢che sera choisie dans le groupe pour
procÃ©der au traitement. Le groupe gÃ©rera une file d'attente pour les requÃªtes
entrantes. Chaque tÃ¢che dans le groupe va rÃ©cupÃ©rer une requÃªte dans cette
liste d'attente, traiter cette requÃªte, et ensuite demander une autre requÃªte
Ã  la file d'attente. Avec ce fonctionnement, nous pouvons traiter <code>N</code> requÃªtes
en concurrence, oÃ¹ <code>N</code> est le nombre de tÃ¢ches. Si toutes les tÃ¢ches rÃ©pondent
chacune Ã  une requÃªte longue Ã  traiter, les requÃªtes suivantes vont se stocker
dans la file d'attente, mais nous augmentons alors le nombre de requÃªtes
longues Ã  traiter que nous devons traiter avant d'arriver Ã  la fin.</p>
<!--
This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If youâ€™re interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.
-->
<p>Cette technique n'est qu'une des nombreuses maniÃ¨res d'amÃ©liorer le dÃ©bit d'un
serveur web. D'autres options que vous devriez envisager sont le modÃ¨le
fork/join et le modÃ¨le d'entrÃ©e-sortie asynchrone monotÃ¢che. Si vous Ãªtes
intÃ©ressÃ©s par ce sujet, vous pouvez aussi en apprendre plus sur d'autres
solutions et essayer de les implÃ©menter en RustÂ ; avec un langage bas niveau
comme Rust, toutes les options restent possibles.</p>
<!--
Before we begin implementing a thread pool, letâ€™s talk about what using the
pool should look like. When youâ€™re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so itâ€™s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.
-->
<p>Avant que nous commencions l'implÃ©mentation du groupe de tÃ¢ches, parlons de
l'utilisation du groupe. Lorsque vous essayez de concevoir du code, commencer
par Ã©crire l'interface client peut vous aider Ã  vous guider dans la conception.
Ecrivez l'API du code afin qu'il soit structurÃ© de la maniÃ¨re dont vous
souhaitez l'appelerÂ ; puis implÃ©mentez ensuite la fonctionnalitÃ© au sein de
cette structure, plutÃ´t que d'implÃ©menter la fonctionnalitÃ© puis de concevoir
l'API publique.</p>
<!--
Similar to how we used test-driven development in the project in Chapter 12,
weâ€™ll use compiler-driven development here. Weâ€™ll write the code that calls the
functions we want, and then weâ€™ll look at errors from the compiler to determine
what we should change next to get the code to work.
-->
<p>De la mÃªme maniÃ¨re que nous avons utilisÃ© le dÃ©veloppement pilotÃ© par les tests
dans le projet du chapitre 12, nous allons utiliser ici le dÃ©veloppement
orientÃ© par le compilateur. Nous allons Ã©crire le code qui appelle les
fonctions que nous souhaitons, et ensuite nous analyserons les erreurs du
compilateur pour dÃ©terminer ce qu'il faut ensuite corriger pour que le code
fonctionne.</p>
<!--
#### Code Structure If We Could Spawn a Thread for Each Request
-->
<h4><a class="header" href="#la-structure-du-code-si-nous-pouvions-crÃ©er-une-tÃ¢che-pour-chaque-requÃªte" id="la-structure-du-code-si-nous-pouvions-crÃ©er-une-tÃ¢che-pour-chaque-requÃªte">La structure du code si nous pouvions crÃ©er une tÃ¢che pour chaque requÃªte</a></h4>
<!--
First, letâ€™s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isnâ€™t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to `main` to spawn a
new thread to handle each stream within the `for` loop.
-->
<p>Pour commencer, voyons Ã  quoi ressemblerait notre code s'il crÃ©ait une nouvelle
tÃ¢che pour chaque connexion. Comme nous l'avons Ã©voquÃ© prÃ©cÃ©demment, cela ne
sera pas notre solution finale Ã  cause des problÃ¨mes liÃ©s Ã  la crÃ©ation
potentielle d'un nombre illimitÃ© de tÃ¢ches, mais c'est un dÃ©but. L'encart 20-11
montre les changements Ã  apporter au <code>main</code> pour crÃ©er une nouvelle tÃ¢che pour
gÃ©rer chaque flux avec une boucle <code>for</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        thread::spawn(|| {
            gestion_connexion(flux);
        });
    }
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-11: Spawning a new thread for each
stream</span>
-->
<p><span class="caption">Encart 20-11Â : crÃ©ation d'une nouvelle tÃ¢che pour chaque
flux</span></p>
<!--
As you learned in Chapter 16, `thread::spawn` will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
*/sleep* in your browser, then */* in two more browser tabs, youâ€™ll indeed see
that the requests to */* donâ€™t have to wait for */sleep* to finish. But as we
mentioned, this will eventually overwhelm the system because youâ€™d be making
new threads without any limit.
-->
<p>Comme vous l'avez appris au chapitre 16, <code>thread::spawn</code> va crÃ©er une nouvelle
tÃ¢che et ensuite exÃ©cuter dans cette nouvelle tÃ¢che le code prÃ©sent dans la
fermeture. Si vous exÃ©cutez ce code et chargez <em>/pause</em> dans votre navigateur,
et que vous ouvrez <em>/</em> dans deux nouveaux onglets, vous constaterez en effet
que les requÃªtes vers <em>/</em> n'aurons pas Ã  attendre que <em>/pause</em> se finisse. Mais
comme nous l'avons mentionnÃ©, cela peut potentiellement surcharger le systÃ¨me
si vous crÃ©ez des nouvelles tÃ¢ches sans limite.</p>
<!--
#### Creating a Similar Interface for a Finite Number of Threads
-->
<h4><a class="header" href="#crÃ©er-une-interface-similaire-pour-un-nombre-fini-de-tÃ¢ches" id="crÃ©er-une-interface-similaire-pour-un-nombre-fini-de-tÃ¢ches">CrÃ©er une interface similaire pour un nombre fini de tÃ¢ches</a></h4>
<!--
We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesnâ€™t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a `ThreadPool`
struct we want to use instead of `thread::spawn`.
-->
<p>Nous souhaitons faire en sorte que notre groupe de tÃ¢ches fonctionne de la mÃªme
maniÃ¨re, donc le remplacement des tÃ¢ches par le groupe de tÃ¢ches ne devrait pas
nÃ©cessiter de gros changements au code qui utilise notre API. L'encart 20-12
montre une interface Ã©ventuelle pour une structure <code>GroupeTaches</code> que nous
souhaitons utiliser Ã  la place de <code>thread::spawn</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-12: Our ideal `ThreadPool` interface</span>
-->
<p><span class="caption">Encart 20-12Â : Notre interface idÃ©ale <code>GroupeTaches</code>
</span></p>
<!--
We use `ThreadPool::new` to create a new thread pool with a configurable number
of threads, in this case four. Then, in the `for` loop, `pool.execute` has a
similar interface as `thread::spawn` in that it takes a closure the pool should
run for each stream. We need to implement `pool.execute` so it takes the
closure and gives it to a thread in the pool to run. This code wonâ€™t yet
compile, but weâ€™ll try so the compiler can guide us in how to fix it.
-->
<p>Nous avons utilisÃ© <code>GroupeTaches::new</code> pour crÃ©er un nouveau groupe de tÃ¢ches
avec un nombre configurable de tÃ¢ches, dans notre cas, quatre. Ensuite, dans
la boucle <code>for</code>, <code>groupe.executer</code> a une interface similaire Ã  <code>thread::spawn</code>
qui prend une fermeture que le groupe devra exÃ©cuter pour chaque flux. Nous
devons implÃ©menter <code>groupe.executer</code> pour qu'il prenne la fermeture et la donne
Ã  une tÃ¢che dans le groupe pour qu'elle l'exÃ©cute. Ce code ne se compile pas
encore, mais nous allons essayer de faire comme ceci pour que le compilateur
puisse nous guider dans la rÃ©solution des problÃ¨mes.</p>
<!--
#### Building the `ThreadPool` Struct Using Compiler Driven Development
-->
<h4><a class="header" href="#construire-la-structure-groupetaches-en-utilisant-le-dÃ©veloppement-orientÃ©-par-le-compilateur" id="construire-la-structure-groupetaches-en-utilisant-le-dÃ©veloppement-orientÃ©-par-le-compilateur">Construire la structure <code>GroupeTaches</code> en utilisant le dÃ©veloppement orientÃ© par le compilateur</a></h4>
<!--
Make the changes in Listing 20-12 to *src/main.rs*, and then letâ€™s use the
compiler errors from `cargo check` to drive our development. Here is the first
error we get:
-->
<p>Faites les changements de l'encart 20-12 dans votre <em>src/main.rs</em>, et utilisez
ensuite les erreurs du compilateur lors du <code>cargo check</code> pour orienter votre
dÃ©veloppement. Voici la premiÃ¨re erreur que nous obtenonsÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type or module `ThreadPool`
  -- > src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type or module `ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0433]: failed to resolve: use of undeclared type or module `GroupeTaches`
  --&gt; src/main.rs:10:16
   |
10 |     let groupe = GroupeTaches::new(4);
   |                  ^^^^^^^^^^^^ use of undeclared type or module `GroupeTaches`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0433`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Great! This error tells us we need a `ThreadPool` type or module, so weâ€™ll
build one now. Our `ThreadPool` implementation will be independent of the kind
of work our web server is doing. So, letâ€™s switch the `hello` crate from a
binary crate to a library crate to hold our `ThreadPool` implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.
-->
<p>BienÂ ! Cette erreur nous informe que nous avons besoin d'un type ou d'un module
qui s'appelle <code>GroupeTaches</code>, donc nous allons le crÃ©er. Notre implÃ©mentation
de <code>GroupeTaches</code> sera indÃ©pendante du type de travail qu'accomplira notre
serveur web. Donc, transformons la crate binaire <code>salutations</code> en crate de
bibliothÃ¨que pour y implÃ©menter notre <code>GroupeTaches</code>. AprÃ¨s l'avoir changÃ© en
crate de bibliothÃ¨que, nous pourrons utiliser ensuite cette bibliothÃ¨que de
groupe de tÃ¢ches dans n'importe quel projet oÃ¹ nous aurons besoin d'un groupe
de tÃ¢ches, et non pas seulement pour servir des requÃªtes web.</p>
<!--
Create a *src/lib.rs* that contains the following, which is the simplest
definition of a `ThreadPool` struct that we can have for now:
-->
<p>CrÃ©ez un <em>src/lib.rs</em> qui contient ceci, qui est la dÃ©finition la plus
simpliste d'une structure <code>GroupeTaches</code> que nous pouvons avoir pour le
momentÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct ThreadPool;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GroupeTaches;
<span class="boring">}
</span></code></pre></pre>
<!--
Then create a new directory, *src/bin*, and move the binary crate rooted in
*src/main.rs* into *src/bin/main.rs*. Doing so will make the library crate the
primary crate in the *hello* directory; we can still run the binary in
*src/bin/main.rs* using `cargo run`. After moving the *main.rs* file, edit it
to bring the library crate in and bring `ThreadPool` into scope by adding the
following code to the top of *src/bin/main.rs*:
-->
<p>CrÃ©ez ensuite un nouveau dossier, <em>src/bin</em>, et dÃ©placez-y la crate binaire qui
est le <em>src/main.rs</em> dans <em>src/bin/main.rs</em>. Faire ceci va faire en sorte que
la crate de bibliothÃ¨que soit la crate principale dans le dossier
<em>salutations</em>Â ; nous pouvons quand mÃªme continuer Ã  exÃ©cuter le binaire dans
<em>src/bin/main.rs</em> en utilisant <code>cargo run</code>. AprÃ¨s avoir dÃ©placÃ© le fichier
<em>main.rs</em>, modifiez-le pour importer la crate de bibliothÃ¨que et importer
<code>GroupeTaches</code> dans la portÃ©e en ajoutant le code suivant en haut de
<em>src/bin/main.rs</em>Â :</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/bin/main.rs</span></p>
<!--
```rust,ignore
use hello::ThreadPool;
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
#     let pool = ThreadPool::new(4);
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         pool.execute(|| {
#             handle_connection(stream);
#         });
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore">use salutations::GroupeTaches;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let groupe = GroupeTaches::new(4);
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        groupe.executer(|| {
</span><span class="boring">            gestion_connexion(flux);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
This code still wonâ€™t work, but letâ€™s check it again to get the next error that
we need to address:
-->
<p>Ce code ne fonctionne toujours pas, mais vÃ©rifions-le Ã  nouveau pour obtenir
l'erreur suivante que nous devons rÃ©soudreÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type `hello::ThreadPool` in the current scope
  -- > src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no function or associated item named `new` found for type `salutations::GroupeTaches` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let groupe = GroupeTaches::new(4);
   |                                ^^^ function or associated item not found in `salutations::GroupeTaches`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error indicates that next we need to create an associated function named
`new` for `ThreadPool`. We also know that `new` needs to have one parameter
that can accept `4` as an argument and should return a `ThreadPool` instance.
Letâ€™s implement the simplest `new` function that will have those
characteristics:
-->
<p>Cette erreur indique que nous devons ensuite crÃ©er une fonction associÃ©e <code>new</code>
pour <code>GroupeTaches</code>. Nous savons aussi que <code>new</code> nÃ©cessite d'avoir un paramÃ¨tre
qui peut accepter <code>4</code> comme argument et doit retourner une instance de
<code>GroupeTaches</code>. ImplÃ©mentons la fonction <code>new</code> la plus simple possible qui aura
ces caractÃ©ristiquesÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We chose `usize` as the type of the `size` parameter, because we know that a
negative number of threads doesnâ€™t make any sense. We also know weâ€™ll use this
4 as the number of elements in a collection of threads, which is what the
`usize` type is for, as discussed in the [â€œInteger Typesâ€][integer-types]<!--
ignore -- > section of Chapter 3.
-->
<p>Nous avons choisi <code>usize</code> comme type du paramÃ¨tre <code>taille</code>, car nous savons
qu'un nombre nÃ©gatif de tÃ¢ches n'as pas de sens. Nous savons Ã©galement que nous
allons utiliser ce 4 comme Ã©tant le nombre d'Ã©lÃ©ments dans une collection de
tÃ¢ches, ce Ã  quoi sert le type <code>usize</code>, comme nous l'avons vu dans la section
<a href="ch03-02-data-types.html">â€œTypes de nombres entiersâ€</a><!-- ignore --> du chapitre 3.</p>
<!--
Letâ€™s check the code again:
-->
<p>VÃ©rifions Ã  nouveau le codeÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  -- > src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no method named `executer` found for type `salutations::GroupeTaches` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         groupe.executer(|| {
   |                ^^^^^^^^ method not found in `salutations::GroupeTaches`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Now the error occurs because we donâ€™t have an `execute` method on `ThreadPool`.
Recall from the [â€œCreating a Similar Interface for a Finite Number of
Threadsâ€](#creating-a-similar-interface-for-a-finite-number-of-threads)<!--
ignore -- > section that we decided our thread pool should have an interface
similar to `thread::spawn`. In addition, weâ€™ll implement the `execute` function
so it takes the closure itâ€™s given and gives it to an idle thread in the pool
to run.
-->
<p>DÃ©sormais, nous obtenons une erreur car nous n'avons pas implÃ©mentÃ© la mÃ©thode
<code>executer</code> sur <code>GroupeTaches</code>. Souvenez-vous que nous avions dÃ©cidÃ© dans la
section <a href="ch20-02-multithreaded.html#cr%C3%A9er-une-interface-similaire-pour-un-nombre-fini-de-t%C3%A2ches">â€œCrÃ©er une interface similaire pour un nombre fini de
tÃ¢chesâ€</a><!--
ignore --> que notre groupe de tÃ¢ches devrait avoir une interface similaire Ã 
<code>thread::spawn</code>. C'est pourquoi nous allons implÃ©menter la fonction <code>executer</code>
pour qu'elle prenne en argument la fermeture qu'on lui donne et elle la passera
Ã  une tÃ¢che inactive du groupe pour qu'elle l'exÃ©cute.</p>
<!--
Weâ€™ll define the `execute` method on `ThreadPool` to take a closure as a
parameter. Recall from the [â€œStoring Closures Using Generic Parameters and the
`Fn` Traitsâ€][storing-closures-using-generic-parameters-and-the-fn-traits]<!--
ignore -- > section in Chapter 13 that we can take closures as parameters with
three different traits: `Fn`, `FnMut`, and `FnOnce`. We need to decide which
kind of closure to use here. We know weâ€™ll end up doing something similar to
the standard library `thread::spawn` implementation, so we can look at what
bounds the signature of `thread::spawn` has on its parameter. The documentation
shows us the following:
-->
<p>Nous allons dÃ©finir la mÃ©thode <code>executer</code> sur <code>GroupeTaches</code> pour prendre en
paramÃ¨tres une fermeture. Souvenez-vous que nous avions vu dans <a href="ch13-01-closures.html">une section du
chapitre 13</a><!--
ignore --> que nous pouvions prendre en paramÃ¨tre les fermetures avec trois
diffÃ©rents traitsÂ : <code>Fn</code>, <code>FnMut</code>, et <code>FnOnce</code>. Nous devons dÃ©cider quel genre
de fermeture nous allons utiliser ici. Nous savons que nous allons faire quelque
chose de sensiblement identique Ã  l'implÃ©mentation du <code>thread::spawn</code> de la
bibliothÃ¨que standard, donc nous pouvons nous inspirer de ce qui est attachÃ© Ã 
la signature de <code>thread::spawn</code>. La documentation nous donne ceciÂ :</p>
<!--
```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static
```
-->
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!--
The `F` type parameter is the one weâ€™re concerned with here; the `T` type
parameter is related to the return value, and weâ€™re not concerned with that. We
can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is probably
what we want as well, because weâ€™ll eventually pass the argument we get in
`execute` to `spawn`. We can be further confident that `FnOnce` is the trait we
want to use because the thread for running a request will only execute that
requestâ€™s closure one time, which matches the `Once` in `FnOnce`.
-->
<p>Le paramÃ¨tre de type <code>F</code> est celui qui nous intÃ©resse iciÂ ; le paramÃ¨tre de
type <code>T</code> est liÃ© Ã  la valeur de retour, et nous ne sommes pas intÃ©ressÃ©s par
ceci. Nous pouvons constater que <code>spawn</code> utilise le trait <code>FnOnce</code> liÃ© Ã  <code>F</code>.
Cela est probablement ce dont nous avons besoin, parce que nous allons sÃ»rement
passer cet argument dans le <code>execute</code> de <code>spawn</code>. Nous pouvons aussi Ãªtre sÃ»r
que <code>FnOnce</code> est le trait dont nous avons besoin car la tÃ¢che qui va exÃ©cuter la
requÃªte va exÃ©cuter le traitement la requÃªte uniquement une seule fois, ce qui
correspond Ã  la partie <code>Once</code> dans <code>FnOnce</code>.</p>
<!--
The `F` type parameter also has the trait bound `Send` and the lifetime bound
`'static`, which are useful in our situation: we need `Send` to transfer the
closure from one thread to another and `'static` because we donâ€™t know how long
the thread will take to execute. Letâ€™s create an `execute` method on
`ThreadPool` that will take a generic parameter of type `F` with these bounds:
-->
<p>Le paramÃ¨tre de type <code>F</code> a aussi le trait liÃ© <code>Send</code> et la durÃ©e de vie liÃ©e
<code>'static</code>, qui sont utiles dans notre situationÂ : nous avons besoin de <code>Send</code>
pour transfÃ©rer la fermeture d'une tÃ¢che vers une autre et de <code>'static</code> car nous
ne savons pas la durÃ©e d'exÃ©cution de la tÃ¢che. CrÃ©ons donc une mÃ©thode
<code>executer</code> sur <code>GroupeTaches</code> qui va utiliser un paramÃ¨tre gÃ©nÃ©rique de type <code>F</code>
avec les liens suivantsÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct ThreadPool;
# 
impl ThreadPool {
    // --snip--
#     pub fn new(size: usize) -> ThreadPool {
#         ThreadPool
#     }
# 
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct GroupeTaches;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquÃ©e ici--
<span class="boring">    pub fn new(size: usize) -&gt; GroupeTaches {
</span><span class="boring">        GroupeTaches
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct GroupeTaches;
</span>impl GroupeTaches {
    // -- partie masquÃ©e ici --

    pub fn executer&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We still use the `()` after `FnOnce` because this `FnOnce` represents a closure
that takes no parameters and returns the unit type `()`. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.
-->
<p>Nous utilisons toujours le <code>()</code> aprÃ¨s <code>FnOne</code> car ce <code>FnOnce</code> reprÃ©sente une
fermeture qui ne prend pas de paramÃ¨tres et retourne le type unitÃ© <code>()</code>.
Exactement comme les dÃ©finitions de fonctions, le type de retour peut Ãªtre omis
de la signature, mais mÃªme si elle n'a pas de paramÃ¨tre, nous avons tout de
mÃªme besoin des parenthÃ¨ses.</p>
<!--
Again, this is the simplest implementation of the `execute` method: it does
nothing, but weâ€™re trying only to make our code compile. Letâ€™s check it again:
-->
<p>A nouveau, c'est l'implÃ©mentation la plus simpliste de la mÃ©thode <code>executer</code>Â :
elle ne fait rien, mais nous essayons seulement de faire en sorte que notre code
se compile. VÃ©rifions-le Ã  nouveauÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<!--
It compiles! But note that if you try `cargo run` and make a request in the
browser, youâ€™ll see the errors in the browser that we saw at the beginning of
the chapter. Our library isnâ€™t actually calling the closure passed to `execute`
yet!
-->
<p>Cela se compileÂ ! Mais remarquez que si vous lancez <code>cargo run</code> et faites la
requÃªte dans votre navigateur web, vous verrez l'erreur dans le navigateur que
nous avions tout au dÃ©but du chapitre. Notre bibliothÃ¨que n'exÃ©cute pas encore
la fermeture envoyÃ©e Ã  <code>executer</code>Â !</p>
<!--
> Note: A saying you might hear about languages with strict compilers, such as
> Haskell and Rust, is â€œif the code compiles, it works.â€ But this saying is not
> universally true. Our project compiles, but it does absolutely nothing! If we
> were building a real, complete project, this would be a good time to start
> writing unit tests to check that the code compiles *and* has the behavior we
> want.
-->
<blockquote>
<p>RemarqueÂ : un dicton que vous avez probablement dÃ©jÃ  entendu Ã  propos des
compilateurs strictes, comme Haskell et Rust, est que â€œsi le code se compile,
il fonctionneâ€. Mais ce dicton n'est pas vrai universellement. Notre projet se
compile, mais il ne fait absolument rienÂ ! Si nous construisions un vrai
projet, complexe, il serait bon de commencer Ã  Ã©crire des tests unitaires pour
vÃ©rifier que ce code compile <em>et</em> qu'il suit le comportement que nous
souhaitons.</p>
</blockquote>
<!--
#### Validating the Number of Threads in `new`
-->
<h4><a class="header" href="#valider-le-nombre-de-tÃ¢ches-envoyÃ©-Ã -new" id="valider-le-nombre-de-tÃ¢ches-envoyÃ©-Ã -new">Valider le nombre de tÃ¢ches envoyÃ© Ã  <code>new</code></a></h4>
<!--
We arenâ€™t doing anything with the parameters to `new` and `execute`. Letâ€™s
implement the bodies of these functions with the behavior we want. To start,
letâ€™s think about `new`. Earlier we chose an unsigned type for the `size`
parameter, because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid `usize`. Weâ€™ll add code to check that `size` is greater than zero before
we return a `ThreadPool` instance and have the program panic if it receives a
zero by using the `assert!` macro, as shown in Listing 20-13.
-->
<p>Nous ne faisons rien avec les paramÃ¨tres <code>new</code> et <code>executer</code>. ImplÃ©mentons le
corps de ces fonctions avec le comportement que nous souhaitons. Pour commencer,
rÃ©flÃ©chissons Ã  <code>new</code>. PrÃ©cÃ©demment, nous avions choisi un type sans signe pour
le paramÃ¨tre <code>taille</code>, car un groupe avec un nombre nÃ©gatif de tÃ¢ches n'a pas de
sens. Cependant, un groupe avec aucune tÃ¢che n'a pas non plus de sens, alors que
zÃ©ro est une valeur parfaitement valide pour <code>usize</code>. Nous allons ajouter du
code pour vÃ©rifier que <code>taille</code> est plus grand que zÃ©ro avant de retourner une
instance de <code>GroupeTaille</code> et faire en sorte que le programme panique s'il
reÃ§oit un zÃ©ro, en utilisant la macro <code>assert!</code> comme dans l'encart 20-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FilenameÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct ThreadPool;
# 
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct GroupeTaches;
</span><span class="boring">
</span>impl GroupeTaches {
    /// CrÃ©e un nouveau GroupeTaches.
    ///
    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
    ///
    /// # Panics
    ///
    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        GroupeTaches
    }

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-13: Implementing `ThreadPool::new` to panic if
`size` is zero</span>
-->
<p><span class="caption">Encart 20-13Â : implÃ©mentation de <code>GroupeTaches::new</code> qui
devrait paniquer si <code>taille</code> vaut zÃ©ro</span></p>
<!--
Weâ€™ve added some documentation for our `ThreadPool` with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running `cargo doc --open` and clicking the `ThreadPool` struct to see what
the generated docs for `new` look like!
-->
<p>Nous avons ajoutÃ© un peu de documentation pour notre <code>GroupeTaches</code> avec des
commentaires de documentation. Remarquez que nous avons suivi les pratiques de
bonne documentation en ajoutant une section qui liste les situations pour
lesquelles notre fonction peut paniquer, comme nous l'avons vu dans le
chapitre 14. Essayez de lancer <code>cargo doc --open</code> et de cliquer sur la structure
<code>GroupeTaches</code> pour voir Ã  quoi ressemble la documentation gÃ©nÃ©rÃ©e pour <code>new</code>Â !</p>
<!--
Instead of adding the `assert!` macro as weâ€™ve done here, we could make `new`
return a `Result` like we did with `Config::new` in the I/O project in Listing
12-9. But weâ€™ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If youâ€™re feeling
ambitious, try to write a version of `new` with the following signature to
compare both versions:
-->
<p>Au lieu d'ajouter la macro <code>assert!</code> comme nous venons de faire, nous aurions pu
faire en sorte que <code>new</code> retourne un <code>Result</code> comme nous l'avions fait avec
<code>Config::new</code> dans le projet d'entrÃ©e/sortie dans l'encart 12-9. Mais nous avons
dÃ©cidÃ© que dans le cas d'une crÃ©ation d'un groupe de tÃ¢che sans aucune tÃ¢che
devrait Ãªtre une erreur irrÃ©cupÃ©rable. Si vous en sentez l'envie, essayez
d'Ã©crire une version de <code>new</code> avec la signature suivante, pour comparer les deux
versionsÂ :</p>
<!--
```rust,ignore
pub fn new(size: usize) -> Result<ThreadPool, PoolCreationError> {
```
-->
<pre><code class="language-rust ignore">pub fn new(taille: usize) -&gt; Result&lt;GroupeTaches, ErreurGroupeTaches&gt; {
</code></pre>
<!--
#### Creating Space to Store the Threads
-->
<h4><a class="header" href="#crÃ©er-lespace-de-rangement-des-tÃ¢ches" id="crÃ©er-lespace-de-rangement-des-tÃ¢ches">CrÃ©er l'espace de rangement des tÃ¢ches</a></h4>
<!--
Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the `ThreadPool` struct
before returning it. But how do we â€œstoreâ€ a thread? Letâ€™s take another look at
the `thread::spawn` signature:
-->
<p>Maintenant que nous avons une maniÃ¨re de savoir si nous avons un nombre valide
de tÃ¢ches Ã  stocker dans le groupe, nous pouvons crÃ©er ces tÃ¢ches et les stocker
dans la structure <code>GroupeTaches</code> avant de la retourner. Mais comment â€œstockerâ€
une tÃ¢cheÂ ? Regardons Ã  nouveau la signature de <code>thread::spawn</code>Â :</p>
<!--
```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static
```
-->
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!--
The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that the
closure returns. Letâ€™s try using `JoinHandle` too and see what happens. In our
case, the closures weâ€™re passing to the thread pool will handle the connection
and not return anything, so `T` will be the unit type `()`.
-->
<p>La fonction <code>spawn</code> retourne un <code>JoinHandle&lt;T&gt;</code>, oÃ¹ <code>T</code> est le type que retourne
notre fermeture. Essayons d'utiliser nous aussi <code>JoinHandle</code> pour voir ce qu'il
se passe. Dans notre cas, les fermetures que nous passons dans le groupe de
tÃ¢ches vont traiter les connexions mais ne vont rien retourner, donc <code>T</code> sera le
type unitÃ©, <code>()</code>.</p>
<!--
The code in Listing 20-14 will compile but doesnâ€™t create any threads yet.
Weâ€™ve changed the definition of `ThreadPool` to hold a vector of
`thread::JoinHandle<()>` instances, initialized the vector with a capacity of
`size`, set up a `for` loop that will run some code to create the threads, and
returned a `ThreadPool` instance containing them.
-->
<p>Le code de l'encart 20-14 va se compiler mais ne va pas encore crÃ©er de tÃ¢ches
pour le moment. Nous avons changÃ© la dÃ©finition du <code>GroupeTaches</code> pour qu'il
possÃ¨de un vecteur d'instances <code>thread::JoinHandle&lt;()&gt;</code>, nous avons initialisÃ©
le vecteur avec une capacitÃ© de la valeur de <code>taille</code>, mis en place une boucle
<code>for</code> qui va exÃ©cuter du code pour crÃ©er les tÃ¢ches, et nous avons retournÃ© une
instance de <code>GroupeTaches</code> qui les contient.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,not_desired_behavior
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
```
-->
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct GroupeTaches {
    taches: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl GroupeTaches {
    // -- partie masquÃ©e ici --
<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let mut taches = Vec::with_capacity(taille);

        for _ in 0..taille {
            // on crÃ©e quelques tÃ¢ches ici et on les stocke dans le vecteur
        }

        GroupeTaches { taches }
    }

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 20-14: Creating a vector for `ThreadPool` to hold
the threads</span>
-->
<p><span class="caption">Encart 20-14Â : crÃ©ation d'un vecteur pour <code>GroupeTaches</code>
pour stocker les tÃ¢ches</span></p>
<!--
Weâ€™ve brought `std::thread` into scope in the library crate, because weâ€™re
using `thread::JoinHandle` as the type of the items in the vector in
`ThreadPool`.
-->
<p>Nous avons importÃ© <code>std::thread</code> dans la portÃ©e de la crate de bibliothÃ¨que, car
nous utilisons <code>thread::JoinHandle</code> comme Ã©tant le type des Ã©lÃ©ments du vecteur
dans <code>GroupeTaches</code>.</p>
<!--
Once a valid size is received, our `ThreadPool` creates a new vector that can
hold `size` items. We havenâ€™t used the `with_capacity` function in this book
yet, which performs the same task as `Vec::new` but with an important
difference: it preallocates space in the vector. Because we know we need to
store `size` elements in the vector, doing this allocation up front is slightly
more efficient than using `Vec::new`, which resizes itself as elements are
inserted.
-->
<p>Une fois qu'une taille valide est reÃ§ue, notre <code>GroupeTaches</code> crÃ©e un nouveau
vecteur qui peut stocker <code>taille</code> Ã©lÃ©ments. Nous n'avons pas encore utilisÃ© la
fonction <code>with_capacity</code> dans ce livre, qui fait la mÃªme chose que <code>Vec::new</code>
mais avec une grosse diffÃ©renceÂ : elle prÃ©-alloue l'espace dans le vecteur.
Comme nous savons que nous avons besoin de stocker <code>taille</code> Ã©lÃ©ments dans le
vecteur, faire cette allocation en amont est bien plus efficace que d'utiliser
<code>Vec::new</code>, qui va se redimentionner lorsque des Ã©lÃ©ments lui seront rajoutÃ©s.</p>
<!--
When you run `cargo check` again, youâ€™ll get a few more warnings, but it should
succeed.
-->
<p>Lorsque vous lancez Ã  nouveau <code>cargo check</code>, vous devriez avoir quelques
avertissements en plus, mais cela devrait Ãªtre un succÃ¨s.</p>
<!-- markdownlint-disable -->
<!--
#### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a Thread
-->
<!-- markdownlint-enable -->
<h4><a class="header" href="#une-structure-operateur-chargÃ©-denvoyer-le-code-de-groupetaches-Ã -une-tÃ¢che" id="une-structure-operateur-chargÃ©-denvoyer-le-code-de-groupetaches-Ã -une-tÃ¢che">Une structure <code>Operateur</code> chargÃ© d'envoyer le code de <code>GroupeTaches</code> Ã  une tÃ¢che</a></h4>
<!--
We left a comment in the `for` loop in Listing 20-14 regarding the creation of
threads. Here, weâ€™ll look at how we actually create threads. The standard
library provides `thread::spawn` as a way to create threads, and
`thread::spawn` expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them *wait* for code that weâ€™ll send later. The standard libraryâ€™s
implementation of threads doesnâ€™t include any way to do that; we have to
implement it manually.
-->
<p>Nous avons laissÃ© un commentaire dans la boucle <code>for</code> dans l'encart 20-14 qui
concernait la crÃ©ation des tÃ¢ches. Ici, nous allons voir comment nous crÃ©er les
tÃ¢ches. La bibliothÃ¨que standard fournit une maniÃ¨re de crÃ©er les tÃ¢ches avec
<code>thread::spawn</code>, et <code>thread::spawn</code> doit recevoir du code que la tÃ¢che doit
exÃ©cuter dÃ¨s que la tÃ¢che est crÃ©Ã©e. Cependant, dans notre cas, nous souhaitons
crÃ©er les tÃ¢ches et qu'elles <em>attendent</em> du code que nous leur enverrons plus
tard. L'implÃ©mentation des tÃ¢ches de la bibliothÃ¨que standard n'offre pas les
moyens de faire ceciÂ ; nous devons implÃ©menter cela manuellement.</p>
<!--
Weâ€™ll implement this behavior by introducing a new data structure between the
`ThreadPool` and the threads that will manage this new behavior. Weâ€™ll call
this data structure `Worker`, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then theyâ€™re responsible
for taking those orders and filling them.
-->
<p>Nous allons implÃ©menter ce comportement en introduisant une nouvelle structure
de donnÃ©es entre le <code>GroupeTaches</code> et les tÃ¢ches qui va gÃ©rer ce nouveau
comportement. Nous allons appeler cette structure <code>Operateur</code>, qui est souvent
appelÃ© <code>Worker</code> dans les implÃ©mentations de groupe. C'est comme des personnes
qui travaillent dans la cuisine d'un restaurantÂ : les opÃ©rateurs attendent les
commandes des clients, et ils sont chargÃ©s de prendre en charge ces commandes et
d'y rÃ©pondre.</p>
<!--
Instead of storing a vector of `JoinHandle<()>` instances in the thread pool,
weâ€™ll store instances of the `Worker` struct. Each `Worker` will store a single
`JoinHandle<()>` instance. Then weâ€™ll implement a method on `Worker` that will
take a closure of code to run and send it to the already running thread for
execution. Weâ€™ll also give each worker an `id` so we can distinguish between
the different workers in the pool when logging or debugging.
-->
<p>Au lieu de stocker un vecteur d'instances <code>JoinHandle&lt;()&gt;</code> dans le groupe de
tÃ¢ches, nous allons stocker les instances de structure <code>Operateur</code>. Chaque
<code>Operateur</code> va stocker une seule instance de <code>JoinHandle&lt;()&gt;</code>. Ensuite nous
implÃ©menterons une mÃ©thode sur <code>Operateur</code> qui va prendre en argument une
fermeture de code Ã  exÃ©cuter et l'envoyer Ã  une tÃ¢che qui fonctionne dÃ©jÃ  pour
exÃ©cution. Nous allons aussi donner Ã  chacun des opÃ©rateurs un identifiant <code>id</code>
afin que nous puissions distinguer les diffÃ©rents opÃ©rateurs dans le groupe
dans les journaux ou lors de dÃ©boguages.</p>
<!--
Letâ€™s make the following changes to what happens when we create a `ThreadPool`.
Weâ€™ll implement the code that sends the closure to the thread after we have
`Worker` set up in this way:
-->
<p>Appliquons ces changements Ã  l'endroit oÃ¹ nous crÃ©ons un <code>GroupeTaches</code>. Nous
allons implÃ©menter le code de <code>Operateur</code> qui envoie la fermeture Ã  la tÃ¢che
selon ces instructionsÂ :</p>
<!--
1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`.
2. Change `ThreadPool` to hold a vector of `Worker` instances.
3. Define a `Worker::new` function that takes an `id` number and returns a
   `Worker` instance that holds the `id` and a thread spawned with an empty
   closure.
4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create
   a new `Worker` with that `id`, and store the worker in the vector.
-->
<ol>
<li>DÃ©finir une structure <code>Operateur</code> qui possÃ¨de un <code>id</code> et un <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Changer le <code>GroupeTaches</code> pour possÃ©der un vecteur d'instances de
<code>Operateur</code>.</li>
<li>DÃ©finir une fonction <code>Operateur::new</code> qui prend en argument un nombre <code>id</code>
et retourne une instance de <code>Operateur</code> qui contient le <code>id</code> et une tÃ¢che
crÃ©Ã©e avec une fermeture vide.</li>
<li>Dans <code>GroupeTaches::new</code>, utilisons le compteur de la boucle <code>for</code> pour
gÃ©nÃ©rer un <code>id</code>, crÃ©er un nouveau <code>Operateur</code> avec cet <code>id</code>, et stocker
l'opÃ©rateur dans le vecteur.</li>
</ol>
<!--
If youâ€™re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.
-->
<p>Si vous vous sentez prÃªt(e) Ã  relever le dÃ©fi, essayez de faire ces changements
de votre cÃ´tÃ© avant de regarder le code de l'encart 20-15.</p>
<!--
Ready? Here is Listing 20-15 with one way to make the preceding modifications.
-->
<p>Vous Ãªtes prÃªt(e)Â ? Voici l'encart 20-15 qui propose une solution pour procÃ©der
aux changements listÃ©s prÃ©cÃ©demment.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
}

impl GroupeTaches {
    // -- partie masquÃ©e ici --
<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id));
        }

        GroupeTaches { operateurs }
    }
    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Operateur {
    id: usize,
    tache: thread::JoinHandle&lt;()&gt;,
}

impl Operateur {
    fn new(id: usize) -&gt; Operateur {
        let tache = thread::spawn(|| {});

        Operateur { id, tache }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-15: Modifying `ThreadPool` to hold `Worker`
instances instead of holding threads directly</span>
-->
<p><span class="caption">Encart 20-15Â : modification de <code>GroupeTaches</code> pour
stocker des instances de <code>Operateur</code> plutÃ´t que de stocker directement des
tÃ¢ches</span></p>
<!--
Weâ€™ve changed the name of the field on `ThreadPool` from `threads` to `workers`
because itâ€™s now holding `Worker` instances instead of `JoinHandle<()>`
instances. We use the counter in the `for` loop as an argument to
`Worker::new`, and we store each new `Worker` in the vector named `workers`.
-->
<p>Nous avons changÃ© le nom du champ <code>taches</code> sur <code>GroupeTaches</code> par <code>operateurs</code>
car il stocke maintenant des instances de <code>Operateur</code> plutÃ´t que des instances
de <code>JoinHandle&lt;()&gt;</code>. Nous utilisons le compteur de la boucle <code>for</code> en argument
de <code>Operateur::new</code>, et nous stockons chacun des nouveaux <code>Operateur</code> dans le
vecteur <code>operateurs</code>.</p>
<!--
External code (like our server in *src/bin/main.rs*) doesnâ€™t need to know the
implementation details regarding using a `Worker` struct within `ThreadPool`,
so we make the `Worker` struct and its `new` function private. The
`Worker::new` function uses the `id` we give it and stores a `JoinHandle<()>`
instance that is created by spawning a new thread using an empty closure.
-->
<p>Le code externe (comme celui de notre serveur dans <em>src/bin/main.rs</em>) n'a pas
besoin de connaÃ®tre les dÃ©tails de l'implÃ©mentation qui utilise une structure
<code>Operateur</code> dans <code>GroupeTaches</code>, donc nous faisons en sorte que la structure
<code>Operateur</code> et sa fonction <code>new</code> restent privÃ©es. La fonction <code>Operateur::new</code>
utilise le <code>id</code> que nous lui donnons et stocke une instance de <code>JoinHandle&lt;()&gt;</code>
qui est crÃ©Ã©e en crÃ©ant une nouvelle tÃ¢che en utilisant une fermeture vide.</p>
<!--
This code will compile and will store the number of `Worker` instances we
specified as an argument to `ThreadPool::new`. But weâ€™re *still* not processing
the closure that we get in `execute`. Letâ€™s look at how to do that next.
-->
<p>Ce code va se compiler et stocker le nombre d'instances de <code>Operateur</code> que nous
avons renseignÃ© en argument de <code>GroupeTaches::new</code>. Mais nous n'exÃ©cutons
<em>toujours pas</em> la fermeture que nous obtenons de <code>executer</code>. Voyons dÃ©sormais
comment faire cela.</p>
<!--
#### Sending Requests to Threads via Channels
-->
<h4><a class="header" href="#envoyer-des-requÃªtes-Ã -des-tÃ¢ches-via-les-canaux" id="envoyer-des-requÃªtes-Ã -des-tÃ¢ches-via-les-canaux">Envoyer des requÃªtes Ã  des tÃ¢ches via les canaux</a></h4>
<!--
Now weâ€™ll tackle the problem that the closures given to `thread::spawn` do
absolutely nothing. Currently, we get the closure we want to execute in the
`execute` method. But we need to give `thread::spawn` a closure to run when we
create each `Worker` during the creation of the `ThreadPool`.
-->
<p>Maintenant nous allons nous pencher sur le problÃ¨me qui fait que les fermetures
passÃ©es Ã  <code>thread::spawn</code> ne font absolument rien. Actuellement, nous obtenons
la fermeture que nous souhaitons exÃ©cuter dans la mÃ©thode <code>executer</code>. Mais nous
avons besoin de donner une fermeture Ã  <code>thread::spawn</code> pour qu'elle l'exÃ©cute
lorsque nous crÃ©ons chaque <code>Operateur</code> pendant la crÃ©ation de <code>GroupeTaches</code>.</p>
<!--
We want the `Worker` structs that we just created to fetch code to run from a
queue held in the `ThreadPool` and send that code to its thread to run.
-->
<p>Nous souhaitons que les structures <code>Operateur</code> que nous venons de crÃ©er
rÃ©cupÃ¨rent du code Ã  exÃ©cuter dans une liste d'attente prÃ©sente dans le
<code>GroupeTaches</code> et renvoient ce code Ã  leur tÃ¢che pour l'exÃ©cuter.</p>
<!--
In Chapter 16, you learned about *channels*â€”a simple way to communicate between
two threadsâ€”that would be perfect for this use case. Weâ€™ll use a channel to
function as the queue of jobs, and `execute` will send a job from the
`ThreadPool` to the `Worker` instances, which will send the job to its thread.
Here is the plan:
-->
<p>Dans le chapitre 16, vous avez appris les <em>canaux</em> (une maniÃ¨re simple de
communiquer entre deux tÃ¢ches) qui seront parfaits pour ce cas d'emploi. Nous
allons utiliser un canal pour les fonctions pour crÃ©er la liste d'attente des
missions, et <code>executer</code> devrait envoyer une mission de <code>GroupeTaches</code> vers les
instances <code>Operateur</code>, qui vont passer la mission Ã  leurs tÃ¢ches. Voici le
planÂ :</p>
<!--
1. The `ThreadPool` will create a channel and hold on to the sending side of
   the channel.
2. Each `Worker` will hold on to the receiving side of the channel.
3. Weâ€™ll create a new `Job` struct that will hold the closures we want to send
   down the channel.
4. The `execute` method will send the job it wants to execute down the sending
   side of the channel.
5. In its thread, the `Worker` will loop over its receiving side of the channel
   and execute the closures of any jobs it receives.
-->
<ol>
<li>Le <code>GroupeTaches</code> va crÃ©er un canal et conserver la partie d'envoi du canal.</li>
<li>Chaque <code>Operateur</code> va conserver la partie de rÃ©ception du canal.</li>
<li>Nous allons crÃ©er une nouvelle structure <code>Mission</code> qui va stocker les
fermetures que nous souhaitons envoyer dans le canal.</li>
<li>La mÃ©thode <code>executer</code> va envoyer la mission qu'elle souhaite executer dans
la zone d'envoi du canal.</li>
<li>Dans sa propre tÃ¢che, le <code>Operateur</code> va vÃ©rifier en permanence la partie
rÃ©ception du canal et exÃ©cuter les fermetures des missions qu'il va
recevoir.</li>
</ol>
<!--
Letâ€™s start by creating a channel in `ThreadPool::new` and holding the sending
side in the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct
doesnâ€™t hold anything for now but will be the type of item weâ€™re sending down
the channel.
-->
<p>CommenÃ§ons par crÃ©er un canal dans <code>GroupeTaches::new</code> et stocker la partie
d'envoi dans l'instance de <code>GroupeTaches</code>, comme dans l'encart 20-16. La
structure <code>Mission</code> ne contient rien pour le moment, mais sera le type
d'Ã©lÃ©ments que nous enverrons dans le canal.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize) -> Worker {
#         let thread = thread::spawn(|| {});
# 
#         Worker { id, thread }
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span>// -- partie masquÃ©e ici --
use std::sync::mpsc;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Mission&gt;,
}

struct Mission;

impl GroupeTaches {
    // -- partie masquÃ©e ici --
<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id));
        }

        GroupeTaches { operateurs, envoi }
    }
    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-16: Modifying `ThreadPool` to store the
sending end of a channel that sends `Job` instances</span>
-->
<p><span class="caption">Encart 20-16Â : modification de <code>GroupeTaches</code> pour
stocker la partie d'envoi du canal qui envoie des instances de <code>Mission</code></span></p>
<!--
In `ThreadPool::new`, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.
-->
<p>Dans <code>GroupeTaches::new</code>, nous crÃ©ons notre nouveau canal et faisons en sorte
que le groupe stocke la partie d'envoi. Cela devrait pouvoir se compiler, mais
il subsiste des avertissements.</p>
<!--
Letâ€™s try passing a receiving end of the channel into each worker as the thread
pool creates the channel. We know we want to use the receiving end in the
thread that the workers spawn, so weâ€™ll reference the `receiver` parameter in
the closure. The code in Listing 20-17 wonâ€™t quite compile yet.
-->
<p>Essayons de donner la partie rÃ©ceptrice du canal Ã  chacun des opÃ©rateurs
lorsque le groupe de tÃ¢ches crÃ©e le canal. Nous savons que nous voulons
utiliser la partie rÃ©ceptrice dans la tÃ¢che que l'opÃ©rateur utilise, donc nous
allons crÃ©er une rÃ©fÃ©rence vers le paramÃ¨tre <code>reception</code> dans la fermeture. Le
code de l'encart 20-17 ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# struct Job;
# 
impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

// --snip--

# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Mission;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquÃ©e ici --
<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, reception));
        }

        GroupeTaches { operateurs, envoi }
    }
    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// -- partie masquÃ©e ici --

<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: mpsc::Receiver&lt;Mission&gt;) -&gt; Operateur {
        let tache = thread::spawn(|| {
            reception;
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span>
-->
<p><span class="caption">Encart 20-17Â : envoi de la partie rÃ©ceptrice du canal aux
opÃ©rateurs</span></p>
<!--
Weâ€™ve made some small and straightforward changes: we pass the receiving end of
the channel into `Worker::new`, and then we use it inside the closure.
-->
<p>Nous avons fait des petites et simples modificationsÂ : nous envoyons la partie
rÃ©ceptrice du canal dans <code>Operateur::new</code>, et ensuite nous l'utilisons dans la
fermeture.</p>
<!--
When we try to check this code, we get this error:
-->
<p>Lorsque nous essayons de vÃ©rifier ce code, nous obtenons cette erreurÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  -- > src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0382]: use of moved value: `reception`
  --&gt; src/lib.rs:27:42
   |
22 |         let (envoi, reception) = mpsc::channel();
   |                     --------- move occurs because `reception` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             operateurs.push(Worker::new(id, reception));
   |                                             ^^^^^^^^^ value moved here, in previous iteration of loop

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The code is trying to pass `receiver` to multiple `Worker` instances. This
wonâ€™t work, as youâ€™ll recall from Chapter 16: the channel implementation that
Rust provides is multiple *producer*, single *consumer*. This means we canâ€™t
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single `receiver` among all the workers.
-->
<p>Le code essaye d'envoyer <code>reception</code> dans plusieurs instances de <code>Operateur</code>.
Ceci ne fonctionne pas, comme vous l'avez appris au chapitre 16Â :
l'implÃ©mentation du canal que fournit Rust est du type plusieurs <em>producteurs</em>,
un seul <em>consommateur</em>. Cela signifie que nous ne pouvons pas simplement cloner
la partie rÃ©ceptrice du canal pour corriger ce code. MÃªme si nous aurions pu le
faire, ce n'est pas la solution que nous souhaitons utiliserÂ ; nous voulons
plutÃ´t distribuer les missions entre les tÃ¢ches en partageant la mÃªme rÃ©ception
entre tous les opÃ©rateurs.</p>
<!--
Additionally, taking a job off the channel queue involves mutating the
`receiver`, so the threads need a safe way to share and modify `receiver`;
otherwise, we might get race conditions (as covered in Chapter 16).
-->
<p>De plus, obtenir une mission de la file d'attente du canal implique de muter le
<code>reception</code>, donc les tÃ¢ches ont besoin d'une mÃ©thode sÃ©curisÃ©e pour partager
et modifier <code>reception</code>Â ; autrement, nous allons avoir des situations de
concurrence (comme nous l'avons vu dans le chapitre 16).</p>
<!--
Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own the
receiver, and `Mutex` will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.
-->
<p>Souvenez-vous des pointeurs intelligents conÃ§us pour les Ã©changes entre les
tÃ¢ches que nous avons vus au chapitre 16Â : pour partager la possession entre
plusieurs tÃ¢ches et permettre aux tÃ¢ches de muter la valeur, nous avons besoin
d'utiliser <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Le type <code>Arc</code> va permettre Ã  plusieurs opÃ©rateurs
de possÃ©der la rÃ©ception, et <code>Mutex</code> va s'assurer que seulement un seul
opÃ©rateur obtienne la mission dans la rÃ©ception au mÃªme moment. L'encart 20-18
montre les changements que nous devons apporter.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::thread;
use std::sync::Arc;
use std::sync::Mutex;
// --snip--

# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# struct Job;
# 
impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

// --snip--

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#             receiver;
#         });
# 
#         Worker { id, thread }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span>use std::sync::Arc;
use std::sync::Mutex;
// -- partie masquÃ©e ici --

<span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Mission;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquÃ©e ici --
<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let reception = Arc::new(Mutex::new(reception));

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
        }

        GroupeTaches { operateurs, envoi }
    }

    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// -- partie masquÃ©e ici --

<span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masquÃ©e ici --
<span class="boring">        let tache = thread::spawn(|| {
</span><span class="boring">            reception;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-18: Sharing the receiving end of the channel
among the workers using `Arc` and `Mutex`</span>
-->
<p><span class="caption">Encart 20-18Â : partage de la partie rÃ©ceptrice du canal
entre les opÃ©rateurs en utilisant <code>Arc</code> et <code>Mutex</code></span></p>
<!--
In `ThreadPool::new`, we put the receiving end of the channel in an `Arc` and a
`Mutex`. For each new worker, we clone the `Arc` to bump the reference count so
the workers can share ownership of the receiving end.
-->
<p>Dans <code>GroupeTaches::new</code>, nous installons la partie rÃ©ceptrice du canal dans un
<code>Arc</code> et un <code>Mutex</code>. Pour chaque nouvel opÃ©rateur, nous clonons le <code>Arc</code> pour
augmenter le compteur de rÃ©fÃ©rences afin que les opÃ©rateurs puissent se
partager la possession de la partie rÃ©ceptrice.</p>
<!--
With these changes, the code compiles! Weâ€™re getting there!
-->
<p>GrÃ¢ce Ã  ces changements, le code se compileÂ ! Nous touchons au butÂ !</p>
<!--
#### Implementing the `execute` Method
-->
<h4><a class="header" href="#implÃ©menter-la-mÃ©thode-executer" id="implÃ©menter-la-mÃ©thode-executer">ImplÃ©menter la mÃ©thode <code>executer</code></a></h4>
<!--
Letâ€™s finally implement the `execute` method on `ThreadPool`. Weâ€™ll also change
`Job` from a struct to a type alias for a trait object that holds the type of
closure that `execute` receives. As discussed in the [â€œCreating Type Synonyms
with Type Aliasesâ€][creating-type-synonyms-with-type-aliases]<!-- ignore -- >
section of Chapter 19, type aliases allow us to make long types shorter. Look
at Listing 20-19.
-->
<p>Finissons par implÃ©menter la mÃ©thode <code>executer</code> sur <code>GroupeTaches</code>. Nous allons
aussi modifier la structure <code>Mission</code> pour devenir un alias de type pour un
objet trait qui contiendra le type de la fermeture que <code>executer</code> recevra.
Comme nous l'avons vu dans <a href="ch19-04-advanced-types.html">une section du
chapitre 19</a><!-- ignore -->, les
alias de type nous permettent de raccourcir les types un peu trop longs.
Voyez cela dans l'encart 20-19.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(|| {
#             receiver;
#         });
# 
#         Worker { id, thread }
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --

type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl GroupeTaches {
    // -- partie masquÃ©e ici --
<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span>
    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(mission).unwrap();
    }
}

// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(|| {
</span><span class="boring">            reception;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-19: Creating a `Job` type alias for a `Box`
that holds each closure and then sending the job down the channel</span>
-->
<p><span class="caption">Encart 20-19Â : crÃ©ation d'un alias de type <code>Mission</code>
pour une <code>Box</code> qui contient chaque fermeture et qui transportera la mission
dans le canal</span></p>
<!--
After creating a new `Job` instance using the closure we get in `execute`, we
send that job down the sending end of the channel. Weâ€™re calling `unwrap` on
`send` for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we canâ€™t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use `unwrap` is that we know the failure case wonâ€™t happen, but the
compiler doesnâ€™t know that.
-->
<p>AprÃ¨s avoir crÃ©Ã© une nouvelle instance <code>Mission</code> en utilisant la fermeture que
nous obtenons dans <code>executer</code>, nous envoyons cette mission dans le canal via la
partie Ã©mettrice. Nous utilisons <code>unwrap</code> sur <code>send</code> pour les cas oÃ¹ l'envoi
Ã©choue. Cela peut arriver si, par exemple, nous stoppons l'exÃ©cution de toutes
les tÃ¢ches, ce qui signifiera que les parties rÃ©ceptrices auront finis de
recevoir des nouveaux messages. Pour le moment, nous ne pouvons pas stopper
l'exÃ©cution de nos tÃ¢chesÂ : nos tÃ¢ches continuerons Ã  s'exÃ©cuter aussi
longtemps que le groupe existe. La raison pour laquelle nous utilisons <code>unwrap</code>
est que nous savons que le cas d'Ã©chec ne va pas se produire, mais le
compilateur ne le sait pas.</p>
<!--
But weâ€™re not quite done yet! In the worker, our closure being passed to
`thread::spawn` still only *references* the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Letâ€™s make the change
shown in Listing 20-20 to `Worker::new`.
-->
<p>Mais nous n'avons pas encore finiÂ ! Dans l'opÃ©rateur, notre fermeture envoyÃ©e
Ã  <code>thread::spawn</code> ne fait que <em>rÃ©fÃ©rencer</em> la sortie du canal. Nous avons
plutÃ´t besoin d'une fermeture pour faire une boucle Ã  l'infini, qui demandera
une mission Ã  la sortie du canal et exÃ©cuter cette mission lorsqu'il en obtient
un. Appliquons les changements montrÃ©s dans l'encart 20-20 Ã  <code>Operateur::new</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {} got a job; executing.", id);

            job();
        });

        Worker { id, thread }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let mission = reception.lock().unwrap().recv().unwrap();

            println!(&quot;L'opÃ©rateur {} a obtenu une missionÂ ; il l'exÃ©cute.&quot;, id);

            mission();
        });

        Operateur { id, tache }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-20: Receiving and executing the jobs in the
workerâ€™s thread</span>
-->
<p><span class="caption">Encart 20-20Â : rÃ©ception et exÃ©cution des missions dans
la tÃ¢che de l'opÃ©rateur</span></p>
<!--
Here, we first call `lock` on the `receiver` to acquire the mutex, and then we
call `unwrap` to panic on any errors. Acquiring a lock might fail if the mutex
is in a *poisoned* state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
`unwrap` to have this thread panic is the correct action to take. Feel free to
change this `unwrap` to an `expect` with an error message that is meaningful to
you.
-->
<p>Ici, nous faisons d'abord appel Ã  <code>lock</code> sur <code>reception</code> pour obtenir le mutex,
et ensuite nous faisons appel Ã  <code>unwrap</code> pour paniquer dÃ¨s qu'il y a une
erreur. L'acquisition d'un verrou peut Ã©chouer si le mutex est dans un Ã©tat
<em>empoisonnÃ©</em>, ce qui peut arriver si d'autres tÃ¢ches ont paniquÃ© pendant
qu'elles avaient le verrou, au lieu de le rendre. Dans cette situation, l'appel
Ã  <code>unwrap</code> fera paniquer la tÃ¢che, ce qui est la bonne chose Ã  faire. Vous
pouvez aussi changer ce <code>unwrap</code> en un <code>expect</code> avec un message d'erreur qui
vous est plus explicite.</p>
<!--
If we get the lock on the mutex, we call `recv` to receive a `Job` from the
channel. A final `unwrap` moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the `send` method returns `Err` if the receiving side shuts down.
-->
<p>Si nous obtenons le verrou du mutex, nous faisons appel Ã  <code>recv</code> pour recevoir
une <code>Mission</code> provenant du canal. Un <code>unwrap</code> final s'occupe lui aussi des cas
d'erreurs, qui peuvent se produire si la tÃ¢che qui contient la partie Ã©mettrice
du canal se termine, de la mÃªme maniÃ¨re que la mÃ©thode <code>send</code> enverrait <code>Err</code>
si la partie rÃ©ceptrice se fermerait.</p>
<!--
The call to `recv` blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The `Mutex<T>` ensures that only one
`Worker` thread at a time is trying to request a job.
-->
<p>L'appel Ã  <code>recv</code> bloque l'exÃ©cution, donc s'il n'y a pas encore de mission, la
tÃ¢che courante va attendre jusqu'Ã  ce qu'une mission soit disponible. Le
<code>Mutex&lt;T&gt;</code> s'assure qu'une seule tÃ¢che d'<code>Operateur</code> obtienne une mÃªme mission
Ã  la fois.</p>
<!--
With the implementation of this trick, our thread pool is in a working state!
Give it a `cargo run` and make some requests:
-->
<p>Avec l'implÃ©mentation de cette astuce, notre groupe de tÃ¢ches est en Ã©tat de
fonctionnerÂ ! Faites un <code>cargo run</code> et faites quelques requÃªtesÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-- >
-->
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 -- > src/lib.rs:7:5
  |
7 |     workers: Vec<Worker>,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  -- > src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  -- > src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
warning: field is never read: `operateurs`
 -- &gt; src/lib.rs:7:5
  |
7 |     operateurs: Vec&lt;Operateur&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  -- &gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `tache`
  -- &gt; src/lib.rs:49:5
   |
49 |     tache: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
L'opÃ©rateur 0 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 2 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 1 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 3 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 0 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 2 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 1 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 3 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 0 a obtenu une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 2 a obtenu une missionÂ ; il l'exÃ©cute.
</code></pre>
<!--
Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system wonâ€™t get
overloaded if the server receives a lot of requests. If we make a request to
*/sleep*, the server will be able to serve other requests by having another
thread run them.
-->
<p>ParfaitÂ ! Nous avons maintenant un groupe de tÃ¢ches qui exÃ©cute des connexions
de maniÃ¨re asynchrone. Il n'y a pas plus que quatre tÃ¢ches qui sont crÃ©Ã©es,
donc notre systÃ¨me ne sera pas surchargÃ© si le serveur reÃ§oit beaucoup de
requÃªtes. Si nous faisons une requÃªte vers <em>/pause</em>, le serveur sera toujours
capable de servir les autres requÃªtes grÃ¢ce aux autres tÃ¢ches qui pourront les
exÃ©cuter.</p>
<!--
> Note: if you open */sleep* in multiple browser windows simultaneously, they
> might load one at a time in 5 second intervals. Some web browsers execute
> multiple instances of the same request sequentially for caching reasons. This
> limitation is not caused by our web server.
-->
<blockquote>
<p>RemarqueÂ : si vous ouvrez <em>/pause</em> dans plusieurs fenÃªtres de navigation en
simultanÃ©, elles peuvent parfois Ãªtre chargÃ©es une par une avec 5 secondes
d'intervalle. Certains navigateurs web exÃ©cutent plusieurs instances de la
mÃªme requÃªte de maniÃ¨re sÃ©quentielle pour des raisons de cache. Cette
limitation n'est pas la faute de notre serveur web.</p>
</blockquote>
<!--
After learning about the `while let` loop in Chapter 18, you might be wondering
why we didnâ€™t write the worker thread code as shown in Listing 20-21.
-->
<p>AprÃ¨s avoir appris la boucle <code>while let</code> dans le chapitre 18, vous pourriez
vous demander pourquoi nous n'avons pas Ã©crit le code des tÃ¢ches des opÃ©rateurs
comme dans l'encart 20-21.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,not_desired_behavior
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {} got a job; executing.", id);

                job();
            }
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// -- partie masquÃ©e ici --

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || {
            while let Ok(mission) = reception.lock().unwrap().recv() {
                println!(&quot;L'opÃ©rateur {} a obtenu une missionÂ ; il l'exÃ©cute.&quot;, id);

                mission();
            }
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-21: An alternative implementation of
`Worker::new` using `while let`</span>
-->
<p><span class="caption">Encart 20-21Â : une implÃ©mentation alternative de
<code>Operateur::new</code> qui utilise <code>while let</code></span></p>
<!--
This code compiles and runs but doesnâ€™t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the `Mutex` struct has no public
`unlock` method because the ownership of the lock is based on the lifetime of
the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock`
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a `Mutex` cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we donâ€™t think carefully about the lifetime of the
`MutexGuard<T>`. Because the values in the `while let` expression remain in
scope for the duration of the block, the lock remains held for the duration of
the call to `job()`, meaning other workers cannot receive jobs.
-->
<p>Ce code se compile et s'exÃ©cute mais ne se comporte pas comme nous
souhaiterions que les tÃ¢ches se comportentÂ : une requÃªte lente Ã  traiter va
continuer Ã  faire en sorte que les autres requÃªtes vont attendre d'Ãªtre
traitÃ©es. La raison Ã  cela est subtileÂ : la structure <code>Mutex</code> n'a pas de
mÃ©thode publique <code>unlock</code> car la propriÃ©tÃ© du verrou se base sur la durÃ©e de
vie du <code>MutexGuard&lt;T&gt;</code> au sein du <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> que retourne la
mÃ©thode <code>lock</code>. A la compilation, le vÃ©rificateur d'emprunt peut ensuite
vÃ©rifier la rÃ¨gle qui dit qu'une ressource gardÃ©e par un <code>Mutex</code> ne peut pas
Ãªtre accessible que si nous avons ce verrou. Mais cette implÃ©mentation peut
aussi faire en sorte que nous gardions le verrou plus longtemps que prÃ©vu si
nous ne rÃ©flÃ©chissons pas avec attention sur la durÃ©e de vie du
<code>MutexGuard&lt;T&gt;</code>. Comme les valeurs dans l'expression du <code>while let</code> restent dans
la portÃ©e pour la durÃ©e de ce bloc, le verrou reste verrouillÃ© pendant la durÃ©e
de l'appel Ã  <code>mission()</code>, ce qui signifie que les autres opÃ©rateurs ne peuvent
pas recevoir d'autres missions.</p>
<!--
By using `loop` instead and acquiring the lock without assigning to a variable,
the temporary `MutexGuard` returned from the `lock` method is dropped as soon
as the `let job` statement ends. This ensures that the lock is held during the
call to `recv`, but it is released before the call to `job()`, allowing
multiple requests to be serviced concurrently.
-->
<p>En utilisant <code>loop</code> Ã  la place et en obtenant le verrou sans l'assigner Ã  une
variable, le <code>MutexGuard</code> temporairement retournÃ© par la mÃ©thode <code>lock</code> est
libÃ©rÃ© dÃ¨s que l'instruction <code>let mission</code> se termine. Cela fait en sorte que le
verrou est gardÃ© pendant l'appel Ã  <code>recv</code>, mais il est libÃ©rÃ© avant l'appel Ã 
<code>mission()</code>, ce qui permet Ã  plusieurs requÃªtes qu'Ãªtre servies en concurrence.</p>
<!--
[creating-type-synonyms-with-type-aliases]:
ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases
[integer-types]: ch03-02-data-types.html#integer-types
[storing-closures-using-generic-parameters-and-the-fn-traits]:
ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--53" id="-attention-peinture-fraÃ®che--53">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/217">Pull Request</a>.</p>
</blockquote>
<!--
## Graceful Shutdown and Cleanup
-->
<h2><a class="header" href="#arrÃªt-propre-et-nettoyage" id="arrÃªt-propre-et-nettoyage">ArrÃªt propre et nettoyage</a></h2>
<!--
The code in Listing 20-20 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the `workers`,
`id`, and `thread` fields that weâ€™re not using in a direct way that reminds us
weâ€™re not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if theyâ€™re in the middle of
serving a request.
-->
<p>Le code de l'encart 20-20 rÃ©ponds aux requÃªtes de maniÃ¨re asynchrone grÃ¢ce Ã 
l'utilisation du groupe de tÃ¢ches, comme nous l'espÃ©rions. Nous avons quelques
avertissements sur les champs <code>operateurs</code>, <code>id</code> et <code>tÃ¢che</code> que nous
n'utilisons pas directement qui nous rappelle que nous ne nettoyons rien.
Lorsque nous utilisons la mÃ©thode <span class="keystroke">ctrl-c</span> pour
terminer la tÃ¢che principale, toutes les autres tÃ¢ches sont aussi stoppÃ©es
immÃ©diatement, mÃªme si nous sommes en train de servir une requÃªte.</p>
<!--
Now weâ€™ll implement the `Drop` trait to call `join` on each of the threads in
the pool so they can finish the requests theyâ€™re working on before closing.
Then weâ€™ll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, weâ€™ll modify our server to
accept only two requests before gracefully shutting down its thread pool.
-->
<p>Nous allons implÃ©menter le trait <code>Drop</code> pour faire appel Ã  <code>join</code> sur chacune
des tÃ¢ches dans le groupe afin qu'elles puissent finir les requÃªtes qu'elles
sont en train de traiter avant l'arrÃªt. Ensuite, nous allons implÃ©menter un
moyen de demander aux tÃ¢ches d'arrÃªter d'accepter des nouvelles requÃªtes et de
s'arrÃªter. Pour voir ce code Ã  l'action, nous allons modifier notre serveur
pour accepter seulement deux requÃªtes avant d'arrÃªter proprement son groupe de
tÃ¢ches.</p>
<!--
### Implementing the `Drop` Trait on `ThreadPool`
-->
<h3><a class="header" href="#implÃ©menter-le-trait-drop-sur-groupetaches" id="implÃ©menter-le-trait-drop-sur-groupetaches">ImplÃ©menter le trait <code>Drop</code> sur <code>GroupeTaches</code></a></h3>
<!--
Letâ€™s start with implementing `Drop` on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-22 shows a first attempt at a `Drop` implementation; this code wonâ€™t
quite work yet.
-->
<p>CommenÃ§ons par implÃ©menter <code>Drop</code> sur notre groupe de tÃ¢ches. Lorsque le groupe
est nettoyÃ©, nos tÃ¢ches doivent toutes faire appel Ã  <code>join</code> pour s'assurer
qu'elles finissent leur travail. L'encart 20-22 montre une premiÃ¨re tentative
d'implÃ©mentation de <code>Drop</code>Â ; ce code ne fonctionne pas encore tout Ã  fait.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        for operateur in &amp;mut self.operateurs {
            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);

            operateur.tache.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opÃ©rateur {} a reÃ§u une mission ; il l'exÃ©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-22: Joining each thread when the thread pool
goes out of scope</span>
-->
<p><span class="caption">Encart 20-22Â : utilisation de <code>join</code> sur chaque tÃ¢che
lorsque le groupe de tÃ¢ches sort de la portÃ©e</span></p>
<!--
First, we loop through each of the thread pool `workers`. We use `&mut` for
this because `self` is a mutable reference, and we also need to be able to
mutate `worker`. For each worker, we print a message saying that this
particular worker is shutting down, and then we call `join` on that workerâ€™s
thread. If the call to `join` fails, we use `unwrap` to make Rust panic and go
into an ungraceful shutdown.
-->
<p>D'abord, nous faisons une boucle sur les <code>operateurs</code>. Nous utilisons <code>&amp;mut</code>
pour cela car <code>self</code> est une rÃ©fÃ©rence mutable, et nous avons aussi besoin de
pouvoir muter <code>operateur</code>. Pour chaque opÃ©rateur, nous affichons un message qui
indique que cet opÃ©rateur s'arrÃªte, et ensuite nous faisons appel Ã  <code>join</code> sur
la tÃ¢che de cet opÃ©rateur. Si l'appel Ã  <code>join</code> Ã©choue, nous utilisons <code>unwrap</code>
pour faire paniquer Rust et ainsi procÃ©der Ã  un arrÃªt brutal.</p>
<!--
Here is the error we get when we compile this code:
-->
<p>Voici l'erreur que nous obtenons lorsque nous compilons ce codeÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  -- > src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ move occurs because `worker.thread` has type `std::thread::JoinHandle<()>`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0507]: cannot move out of `operateur.tache` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             operateur.tache.join().unwrap();
   |             ^^^^^^^^^^^^^^^ move occurs because `operateur.tache` has type `std::thread::JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0507`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error tells us we canâ€™t call `join` because we only have a mutable borrow
of each `worker` and `join` takes ownership of its argument. To solve this
issue, we need to move the thread out of the `Worker` instance that owns
`thread` so `join` can consume the thread. We did this in Listing 17-15: if
`Worker` holds an `Option<thread::JoinHandle<()>>` instead, we can call the
`take` method on the `Option` to move the value out of the `Some` variant and
leave a `None` variant in its place. In other words, a `Worker` that is running
will have a `Some` variant in `thread`, and when we want to clean up a
`Worker`, weâ€™ll replace `Some` with `None` so the `Worker` doesnâ€™t have a
thread to run.
-->
<p>L'erreur nous informe que nous ne pouvons pas faire appel Ã  <code>join</code> car nous
faisons seulement un emprunt mutable pour chacun des <code>operateur</code> et que <code>join</code>
prend possession de son argument. Pour rÃ©soudre ce problÃ¨me, nous devons
sortir la tÃ¢che de l'instance de <code>Operateur</code> qui possÃ¨de la <code>tache</code> afin que
<code>join</code> puisse consommer la tÃ¢che. Nous faisons ceci dans l'encart 17-15Â : si
<code>Operateur</code> contient un <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, nous pouvons utiliser
la mÃ©thode <code>take</code> sur <code>Option</code> pour sortir la valeur de la variante <code>Some</code> et
la remplacer par la variante <code>None</code> Ã  la place. Autrement dit, un <code>Operateur</code>
qui est en cours d'exÃ©cution aura une variante <code>Some</code> dans <code>tache</code>, et lorsque
nous souhaitons nettoyer <code>Operateur</code>, nous remplacerons <code>Some</code> par <code>None</code> afin
que <code>Operateur</code> n'ai pas de tÃ¢che Ã  exÃ©cuter.</p>
<!--
So we know we want to update the definition of `Worker` like this:
-->
<p>Donc nous savons que nous voulons modifier la dÃ©finition de <code>Operateur</code> comme
ceciÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             worker.thread.join().unwrap();
#         }
#     }
# }
# 
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            operateur.tache.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Operateur {
    id: usize,
    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opÃ©rateur {} a reÃ§u une mission ; il l'exÃ©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Now letâ€™s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:
-->
<p>Maintenant, aidons-nous du compilateur pour trouver les autres endroits qui ont
besoin de changer. En vÃ©rifiant ce code, nous obtenons deux erreursÂ :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for type `std::option::Option<std::thread::JoinHandle<()>>` in the current scope
  -- > src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `std::option::Option<std::thread::JoinHandle<()>>`

error[E0308]: mismatched types
  -- > src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^
   |                      |
   |                      expected enum `std::option::Option`, found struct `std::thread::JoinHandle`
   |                      help: try using a variant of the expected enum: `Some(thread)`
   |
   = note: expected enum `std::option::Option<std::thread::JoinHandle<()>>`
            found struct `std::thread::JoinHandle<_>`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no method named `join` found for type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             operateur.tache.join().unwrap();
   |                             ^^^^ method not found in `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, tache }
   |                      ^^^^^
   |                      |
   |                      expected enum `std::option::Option`, found struct `std::thread::JoinHandle`
   |                      help: try using a variant of the expected enum: `Some(tache)`
   |
   = note: expected enum `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
            found struct `std::thread::JoinHandle&lt;_&gt;`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Letâ€™s address the second error, which points to the code at the end of
`Worker::new`; we need to wrap the `thread` value in `Some` when we create a
new `Worker`. Make the following changes to fix this error:
-->
<p>Corrigeons la seconde erreur, qui se situe dans le code Ã  la fin de
<code>Operateur::new</code>Â ; nous devons intÃ©grer la valeur de <code>tache</code> dans un <code>Some</code>
lorsque nous crÃ©ons un nouvel <code>Operateur</code>. Faites les changements suivants pour
corriger cette erreurÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             worker.thread.join().unwrap();
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--

#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            operateur.tache.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masquÃ©e ici --

<span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opÃ©rateur {} a reÃ§u une mission ; il l'exÃ©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span>        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<pre><code class="language-rust ignore">impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masquÃ©e ici --

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
The first error is in our `Drop` implementation. We mentioned earlier that we
intended to call `take` on the `Option` value to move `thread` out of `worker`.
The following changes will do so:
-->
<p>La premiÃ¨re erreur se situe dans notre implÃ©mentation de <code>Drop</code>. Nous avions
mentionnÃ© plus tÃ´t que nous voulions faire appel Ã  <code>take</code> sur la valeur de
<code>Option</code> pour dÃ©placer <code>tache</code> en dehors de <code>operateur</code>. Voici les changements
Ã  apporter pour ceciÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        for operateur in &amp;mut self.operateurs {
            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opÃ©rateur {} a reÃ§u une mission ; il l'exÃ©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
As discussed in Chapter 17, the `take` method on `Option` takes the `Some`
variant out and leaves `None` in its place. Weâ€™re using `if let` to destructure
the `Some` and get the thread; then we call `join` on the thread. If a workerâ€™s
thread is already `None`, we know that worker has already had its thread
cleaned up, so nothing happens in that case.
-->
<p>Comme nous l'avons vu au chapitre 17, la mÃ©thode <code>take</code> sur <code>Option</code> sort la
variante <code>Some</code> et laisse un <code>None</code> Ã  la place. Nous utilisons <code>if let</code> pour
destructurer le <code>Some</code> et obtenir la tÃ¢cheÂ ; ensuite nous faisons appel Ã  <code>join</code>
sur cette tÃ¢che. Si la tÃ¢che d'un opÃ©rateur est dÃ©jÃ  un <code>None</code>, nous savons que
cet opÃ©rateur a dÃ©jÃ  nettoyÃ© sa tÃ¢che, donc nous ne faisons rien dans ce cas.</p>
<!--
### Signaling to the Threads to Stop Listening for Jobs
-->
<h3><a class="header" href="#demander-aux-tÃ¢ches-darrÃªter-dattendre-des-missions" id="demander-aux-tÃ¢ches-darrÃªter-dattendre-des-missions">Demander aux tÃ¢ches d'arrÃªter d'attendre des missions</a></h3>
<!--
With all the changes weâ€™ve made, our code compiles without any warnings. But
the bad news is this code doesnâ€™t function the way we want it to yet. The key
is the logic in the closures run by the threads of the `Worker` instances: at
the moment, we call `join`, but that wonâ€™t shut down the threads because they
`loop` forever looking for jobs. If we try to drop our `ThreadPool` with our
current implementation of `drop`, the main thread will block forever waiting
for the first thread to finish.
-->
<p>Avec tous ces changements, notre code se compile sans aucun avertissement. Mais
la mauvaise nouvelle est que ce code ne fonctionne pas de la faÃ§on dont nous
souhaitons, pour l'instant. La cause se situe dans la logique des fermetures
qui sont exÃ©cutÃ©es par les tÃ¢ches des instances de <code>Operateur</code>Â : pour le
moment, nous faisons faisons appel Ã  <code>join</code>, mais cela ne va pas arrÃªter les
tÃ¢ches car elles font une boucle infinie avec <code>loop</code> pour attendre des
missions. Si nous essayons de nettoyer notre <code>GroupeTaches</code> avec
l'implÃ©mentation actuelle de <code>drop</code>, la tÃ¢che principale va se bloquer Ã 
l'infini en attendant que la premiÃ¨re tÃ¢che se termine.</p>
<!--
To fix this problem, weâ€™ll modify the threads so they listen for either a `Job`
to run or a signal that they should stop listening and exit the infinite loop.
Instead of `Job` instances, our channel will send one of these two enum
variants.
-->
<p>Pour corriger ce problÃ¨me, nous allons modifier les tÃ¢ches pour qu'elles
attendent soit une <code>Mission</code> Ã  exÃ©cuter, ou le signal qui leur dit qu'elles
doivent arrÃªter d'attendre des missions et arrÃªter la boucle infinie. Notre
canal va envoyer une de ces deux variantes d'Ã©numÃ©ration au lieu d'uniquement
des instances de <code>Job</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
enum Message {
    NewJob(Job),
    Terminate,
}
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             if let Some(thread) = worker.thread.take() {
#                 thread.join().unwrap();
#             }
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>enum Message {
    NouvelleMission(Mission),
    Extinction,
}
<span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            if let Some(tache) = operateur.tache.take() {
</span><span class="boring">                tache.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opÃ©rateur {} a reÃ§u une mission ; il l'exÃ©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
This `Message` enum will either be a `NewJob` variant that holds the `Job` the
thread should run, or it will be a `Terminate` variant that will cause the
thread to exit its loop and stop.
-->
<p>Cette Ã©numÃ©ration <code>Message</code> aura pour valeurs une variante <code>NouvelleMission</code>
qui contiendra la <code>Mission</code> que la tÃ¢che devra exÃ©cuter, ou la variante
<code>Extinction</code> qui va faire en sorte que la tÃ¢che sorte de sa boucle et se
termine.</p>
<!--
We need to adjust the channel to use values of type `Message` rather than type
`Job`, as shown in Listing 20-23.
-->
<p>Nous devons corriger le canal pour utiliser les valeurs du type <code>Message</code>
plutÃ´t que le type <code>Mission</code>, comme dans l'encart 20-23.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

// --snip--

# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# enum Message {
#     NewJob(Job),
#     Terminate,
# }
# 
impl ThreadPool {
    // --snip--

#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             if let Some(thread) = worker.thread.take() {
#                 thread.join().unwrap();
#             }
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("Worker {} got a job; executing.", id);

                    job();
                }
                Message::Terminate => {
                    println!("Worker {} was told to terminate.", id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span>pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Message&gt;,
}

// -- partie masquÃ©e ici --

<span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NouvelleMission(Mission),
</span><span class="boring">    Extinction,
</span><span class="boring">}
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquÃ©e ici --

<span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
    }
}

// -- partie masquÃ©e ici --

<span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            if let Some(tache) = operateur.tache.take() {
</span><span class="boring">                tache.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let message = reception.lock().unwrap().recv().unwrap();

            match message {
                Message::NouvelleMission(mission) =&gt; {
                    println!(&quot;L'opÃ©rateur {} a reÃ§u une missionÂ ; il l'exÃ©cute.&quot;, id);

                    mission();
                }
                Message::Extinction =&gt; {
                    println!(&quot;L'opÃ©rateur {} a reÃ§u l'instruction d'arrÃªt.&quot;, id);

                    break;
                }
            }
        });

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-23: Sending and receiving `Message` values and
exiting the loop if a `Worker` receives `Message::Terminate`</span>
-->
<p><span class="caption">Encart 20-23Â : envoi et rÃ©ception de valeurs de <code>Message</code>
et sortie de la boucle si un <code>Operateur</code> reÃ§oit <code>Message:Extinction</code></span></p>
<!--
To incorporate the `Message` enum, we need to change `Job` to `Message` in two
places: the definition of `ThreadPool` and the signature of `Worker::new`. The
`execute` method of `ThreadPool` needs to send jobs wrapped in the
`Message::NewJob` variant. Then, in `Worker::new` where a `Message` is received
from the channel, the job will be processed if the `NewJob` variant is
received, and the thread will break out of the loop if the `Terminate` variant
is received.
-->
<p>Pour intÃ©grer l'Ã©numÃ©ration <code>Message</code>, nous devons changer <code>Mission</code> par
<code>Message</code> Ã  deux endroitsÂ : la dÃ©finition de <code>GroupeTaches</code> et la signature de
<code>Operateur::new</code>. La mÃ©thode <code>executer</code> de <code>GroupeTaches</code> doit envoyer des
missions intÃ©grÃ©es dans des variantes de <code>Message::NouvelleTache</code>. Ensuite,
dans <code>Operateur::new</code> oÃ¹ nous recevons des <code>Message</code> du canal, la mission sera
traitÃ©e si la variante <code>NouvelleTache</code> est reÃ§ue, et la tÃ¢che arrÃªtera la
boucle si la variante <code>Extinction</code> est reÃ§ue.</p>
<!--
With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-20. But weâ€™ll get a warning because we arenâ€™t
creating any messages of the `Terminate` variety. Letâ€™s fix this warning by
changing our `Drop` implementation to look like Listing 20-24.
-->
<p>GrÃ¢ce Ã  ces changements, le code va se compiler et continuer de fonctionner de
la mÃªme maniÃ¨re qu'il le faisait aprÃ¨s l'encart 20-20. Mais nous allons obtenir
un avertissement car nous ne crÃ©ons aucun message de la variante <code>Extinction</code>.
Corrigeons cet avertissement en corrigeant l'implÃ©mentation de notre <code>Drop</code>
pour qu'elle ressemble Ã  l'encart 20-24.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Message>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# enum Message {
#     NewJob(Job),
#     Terminate,
# }
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(Message::NewJob(job)).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        println!("Sending terminate message to all workers.");

        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!("Shutting down all workers.");

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let message = receiver.lock().unwrap().recv().unwrap();
# 
#             match message {
#                 Message::NewJob(job) => {
#                     println!("Worker {} got a job; executing.", id);
# 
#                     job();
#                 }
#                 Message::Terminate => {
#                     println!("Worker {} was told to terminate.", id);
# 
#                     break;
#                 }
#             }
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NouvelleMission(Mission),
</span><span class="boring">    Extinction,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// CrÃ©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        println!(&quot;Envoi du message d'extinction Ã  tous les opÃ©rateurs.&quot;);

        for _ in &amp;self.operateurs {
            self.envoi.send(Message::Extinction).unwrap();
        }

        println!(&quot;ArrÃªt de tous les opÃ©rateurs.&quot;);

        for operateur in &amp;mut self.operateurs {
            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let message = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            match message {
</span><span class="boring">                Message::NouvelleMission(mission) =&gt; {
</span><span class="boring">                    println!(&quot;L'opÃ©rateur {} a reÃ§u une missionÂ ; il l'exÃ©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    mission();
</span><span class="boring">                }
</span><span class="boring">                Message::Extinction =&gt; {
</span><span class="boring">                    println!(&quot;L'opÃ©rateur {} a reÃ§u l'instruction d'arrÃªt.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-24: Sending `Message::Terminate` to the
workers before calling `join` on each worker thread</span>
-->
<p><span class="caption">Encart 20-24Â : envoi de <code>Message::Extinction</code> aux
opÃ©rateurs avant de faire appel Ã  <code>join</code> sur toutes les tÃ¢ches des
opÃ©rateurs</span></p>
<!--
Weâ€™re now iterating over the workers twice: once to send one `Terminate`
message for each worker and once to call `join` on each workerâ€™s thread. If we
tried to send a message and `join` immediately in the same loop, we couldnâ€™t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.
-->
<p>Nous itÃ©rons deux fois sur les opÃ©rateursÂ : une fois pour envoyer un message
<code>Extinction</code> pour chaque opÃ©rateur, et une fois pour utiliser <code>join</code> sur la
tÃ¢che de chacun des opÃ©rateurs. Si nous essayons d'envoyer le message et
d'utiliser immÃ©diatement <code>join</code> dans la mÃªme boucle, nous ne pouvons pas
garantir que l'opÃ©rateur dans l'itÃ©ration en cours sera celui qui obtiendra le
message envoyÃ© dans le canal.</p>
<!--
To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and `join`
called on the first workerâ€™s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!
-->
<p>Pour mieux comprendre pourquoi nous avons besoin de sÃ©parer les boucles,
imaginez un scÃ©nario avec deux opÃ©rateurs. Si nous avions utilisÃ© une seule
boucle pour itÃ©rer sur chacun des opÃ©rateurs, dans la premiÃ¨re itÃ©ration un
message d'extinction sera envoyÃ© dans le canal et <code>join</code> sera utilisÃ© sur la
tÃ¢che du premier opÃ©rateur. Si ce premier opÃ©rateur Ã©tait occupÃ© Ã  traiter une
requÃªte Ã  ce moment-lÃ , le second opÃ©rateur devrait alors rÃ©cupÃ©rer le message
d'extinction dans le canal et s'arrÃªter. Nous resterons alors Ã  attendre que le
premier opÃ©rateur s'arrÃªte, mais cela ne sera jamais le cas car c'est la
seconde tÃ¢che qui aura obtenu le message d'extinction. Nous serions alors dans
une situation d'interblocageÂ !</p>
<!--
To prevent this scenario, we first put all of our `Terminate` messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before `join` is called on its thread.
-->
<p>Pour Ã©viter ce scÃ©nario, nous allons commencer par insÃ©rer tous nos messages
<code>Extinction</code> dans le canal dans une boucleÂ ; et ensuite nous utiliserons <code>join</code>
sur toutes les tÃ¢ches dans une autre boucle. Chaque opÃ©rateur va arrÃªter de
recevoir des nouvelles requÃªtes du canal dÃ¨s qu'ils recevront le message
d'extinction. Donc, nous pouvons nous assurer que si nous envoyons la mÃªme
quantitÃ© de messages d'extinction qu'il y a d'opÃ©rateurs, chaque opÃ©rateur
devrait recevoir un message d'extinction avant que <code>join</code> soit utilisÃ© sur leur
tÃ¢che.</p>
<!--
To see this code in action, letâ€™s modify `main` to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-25.
-->
<p>Pour observer ce code en action, modifions notre <code>main</code> pour accepter
uniquement deux requÃªtes avant d'arrÃªter proprement le serveur, comme dans
l'encart 20-25.</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/bin/main.rs</span></p>
<!--
```rust,ignore
# use hello::ThreadPool;
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use salutations::GroupeTaches;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming().take(2) {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }

    println!(&quot;ArrÃªt complet.&quot;);
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-25: Shut down the server after serving two
requests by exiting the loop</span>
-->
<p><span class="caption">Encart 20-25Â : arrÃªt du serveur aprÃ¨s avoir servi deux
requÃªtes en sortant de la boucle</span></p>
<!--
You wouldnâ€™t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.
-->
<p>Dans la rÃ©alitÃ© on ne voudrait pas qu'un serveur web s'arrÃªte aprÃ¨s avoir servi
seulement deux requÃªtes. Ce code sert uniquement Ã  montrer que l'arrÃªt et le
nettoyage s'effectuent bien proprement.</p>
<!--
The `take` method is defined in the `Iterator` trait and limits the iteration
to the first two items at most. The `ThreadPool` will go out of scope at the
end of `main`, and the `drop` implementation will run.
-->
<p>La mÃ©thode <code>take</code> est dÃ©finie dans le trait <code>Iterator</code> et limite l'itÃ©ration
aux deux premiers Ã©lÃ©ments au maximum. Le <code>GroupeTaches</code> va sortir de la portÃ©e
Ã  la fin du <code>main</code>, et l'implÃ©mentation de <code>drop</code> va s'exÃ©cuter.</p>
<!--
Start the server with `cargo run`, and make three requests. The third request
should error, and in your terminal you should see output similar to this:
-->
<p>DÃ©marrez le serveur avec <code>cargo run</code>, et faites trois requÃªtes. La troisiÃ¨me
requÃªte devrait faire une erreur, et dans votre terminal vous devriez avoir une
sortie similaire Ã  ceciÂ :</p>
<!--
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-- >
-->
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
L'opÃ©rateur 0 a reÃ§u une missionÂ ; il l'exÃ©cute.
L'opÃ©rateur 3 a reÃ§u une missionÂ ; il l'exÃ©cute.
ArrÃªt.
Envoi du message d'extinction Ã  tous les opÃ©rateurs.
ArrÃªt de tous les opÃ©rateurs.
ArrÃªt de l'opÃ©rateur 0
L'opÃ©rateur 1 a reÃ§u l'instruction d'arrÃªt.
L'opÃ©rateur 2 a reÃ§u l'instruction d'arrÃªt.
L'opÃ©rateur 0 a reÃ§u l'instruction d'arrÃªt.
L'opÃ©rateur 3 a reÃ§u l'instruction d'arrÃªt.
ArrÃªt de l'opÃ©rateur 1
ArrÃªt de l'opÃ©rateur 2
ArrÃªt de l'opÃ©rateur 3
</code></pre>
<!--
You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the `ThreadPool` goes out of scope at the end of `main`, its
`Drop` implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls `join` to shut down each worker thread.
-->
<p>Vous devriez voir un ordre diffÃ©rent entre les opÃ©rateurs et les messages
affichÃ©s. Nous pouvons constater comment ce code fonction avec les messagesÂ :
les opÃ©rateurs 0 et 3 obtiennent les deux premiÃ¨res requÃªtes, et ensuite lors
de la troisiÃ¨me requÃªte, le serveur arrÃªte d'accepter des connexions. Lorsque
le <code>GroupeTaches</code> sort de la portÃ©e Ã  la fin du <code>main</code>, son implÃ©mentation de
<code>Drop</code> rentre en action, et le groupe demande Ã  tous les opÃ©rateurs de
s'arrÃªter. Chaque opÃ©rateur va afficher un message lorsqu'il recevra le message
d'extinction, et ensuite le groupe de tÃ¢che utilisera <code>join</code> pour arrÃªter
chaque tÃ¢che de chaque opÃ©rateur.</p>
<!--
Notice one interesting aspect of this particular execution: the `ThreadPool`
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.
-->
<p>Remarquez un aspect intÃ©ressant spÃ©cifique Ã  cette exÃ©cutionÂ : le
<code>GroupeTaches</code> a envoyÃ© les messages d'extinction dans le canal, et avant que
tous les opÃ©rateurs aient reÃ§u les messages, nous avons essayÃ© d'utiliser
<code>join</code> sur l'opÃ©rateur 0. L'opÃ©rateur 0 n'avait pas encore reÃ§u le message
d'extinction, donc la tÃ¢che principale attendait que l'opÃ©rateur 0 finisse.
Pendant ce temps, tous les autres opÃ©rateurs ont reÃ§u les messages
d'extinction. Lorsque l'opÃ©rateur 0 a fini, la tÃ¢che principale a attendu que
les opÃ©rateurs restant se terminent. A partir de lÃ , ils ont tous reÃ§u le
message d'extinction et sont disposÃ©s Ã  s'arrÃªter.</p>
<!--
Congrats! Weâ€™ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. Weâ€™re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.
-->
<p>FÃ©licitationsÂ ! Nous avons maintenant terminÃ© notre projetÂ ; nous avons un
serveur web basique qui utilise un groupe de tÃ¢ches pour rÃ©pondre de maniÃ¨re
asynchrone. Nous pouvons demander un arrÃªt propre du serveur, qui va alors
nettoyer les tÃ¢ches dans le groupe.</p>
<!--
Hereâ€™s the full code for reference:
-->
<p>Voici le code complet pour pouvoir vous y rÃ©fÃ©rerÂ :</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/bin/main.rs</span></p>
<!--
```rust,ignore
use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!("{}{}", status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><code class="language-rust ignore">use salutations::GroupeTaches;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming().take(2) {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }

    println!(&quot;ArrÃªt complet.&quot;);
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;

    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if tampon.starts_with(pause) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

enum Message {
    NewJob(Job),
    Terminate,
}

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        println!("Sending terminate message to all workers.");

        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!("Shutting down all workers.");

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("Worker {} got a job; executing.", id);

                    job();
                }
                Message::Terminate => {
                    println!("Worker {} was told to terminate.", id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Message&gt;,
}

type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;

enum Message {
    NouvelleMission(Mission),
    Extinction,
}

impl GroupeTaches {
    /// CrÃ©e un nouveau GroupeTaches.
    ///
    /// La taille est le nom de tÃ¢ches prÃ©sentes dans le groupe.
    ///
    /// # Panics
    ///
    /// La fonction `new` devrait paniquer si la taille vaut zÃ©ro.
    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let reception = Arc::new(Mutex::new(reception));

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
        }

        GroupeTaches { operateurs, envoi }
    }

    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
    }
}

impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        println!(&quot;Envoi du message d'extinction Ã  tous les opÃ©rateurs.&quot;);

        for _ in &amp;self.operateurs {
            self.envoi.send(Message::Extinction).unwrap();
        }

        println!(&quot;ArrÃªt de tous les opÃ©rateurs.&quot;);

        for operateur in &amp;mut self.operateurs {
            println!(&quot;ArrÃªt de l'opÃ©rateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}

struct Operateur {
    id: usize,
    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let message = reception.lock().unwrap().recv().unwrap();

            match message {
                Message::NouvelleMission(mission) =&gt; {
                    println!(&quot;L'opÃ©rateur {} a reÃ§u une missionÂ ; il l'exÃ©cute.&quot;, id);

                    mission();
                }
                Message::Extinction =&gt; {
                    println!(&quot;L'opÃ©rateur {} a reÃ§u l'instruction d'arrÃªt.&quot;, id);

                    break;
                }
            }
        });

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We could do more here! If you want to continue enhancing this project, here are
some ideas:
-->
<p>Nous aurions pu faire bien plus lÃ -dedansÂ ! Si vous souhaitez continuer Ã 
amÃ©liorer ce projet, voici quelques idÃ©esÂ :</p>
<!--
* Add more documentation to `ThreadPool` and its public methods.
* Add tests of the libraryâ€™s functionality.
* Change calls to `unwrap` to more robust error handling.
* Use `ThreadPool` to perform some task other than serving web requests.
* Find a thread pool crate on [crates.io](https://crates.io/) and implement a
  similar web server using the crate instead. Then compare its API and
  robustness to the thread pool we implemented.
-->
<ul>
<li>Ajouter de la documentation sur <code>GroupeTaches</code> et les mÃ©thodes publiques.</li>
<li>Ajouter des tests sur les fonctionnalitÃ©s de la bibliothÃ¨que.</li>
<li>Corriger les appels Ã  <code>unwrap</code> pour une meilleure gestion des erreurs.</li>
<li>Utiliser <code>GroupeTaches</code> pour faire d'autres tÃ¢ches que de rÃ©pondre Ã  des
requÃªtes web.</li>
<li>Trouver une crate de groupe tÃ¢ches <em>(NdTÂ : thread pool)</em> sur
<a href="https://crates.io/">crates.io</a> et implÃ©menter un serveur web similaire en
utilisant plutÃ´t cette crate. Comparer ensuite son API et sa robustesse au
groupe de tÃ¢ches que nous avons implÃ©mentÃ©.</li>
</ul>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©-19" id="rÃ©sumÃ©-19">RÃ©sumÃ©</a></h2>
<!--
Well done! Youâ€™ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. Youâ€™re now ready to implement your own Rust
projects and help with other peoplesâ€™ projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.
-->
<p>BravoÂ ! Vous Ãªtes arrivÃ© Ã  la fin du livreÂ ! Nous tenons Ã  vous remercier
chaleureusement pour nous avoir accompagnÃ© pendant cette prÃ©sentation de Rust.
Vous Ãªtes maintenant fin prÃªt(e) Ã  crÃ©er vos propres projets Rust et aider les
projets des autres dÃ©veloppeurs. Rappelez-vous qu'il existe une communautÃ©
chaleureuse de RustacÃ©s qui est prÃªte Ã  vous aider dans tous les dÃ©fis que vous
rencontrerez dans votre aventure avec Rust.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--54" id="-attention-peinture-fraÃ®che--54">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/221">Pull Request</a>.</p>
</blockquote>
<!--
# Appendix
-->
<h1><a class="header" href="#annexes" id="annexes">Annexes</a></h1>
<!--
The following sections contain reference material you may find useful in your
Rust journey.
-->
<p>Les sections suivantes contiennent du contenu de rÃ©fÃ©rence que vous pourriez
trouver utile dans votre aventure avec Rust.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--55" id="-attention-peinture-fraÃ®che--55">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/222">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix A: Keywords
-->
<h2><a class="header" href="#annexe-a--les-mots-clÃ©s" id="annexe-a--les-mots-clÃ©s">Annexe AÂ : les mots-clÃ©s</a></h2>
<!--
The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as weâ€™ll discuss in the â€œ[Raw
Identifiers][raw-identifiers]<!-- ignore -- >â€ section), including names of
functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.
-->
<p>La liste suivante contient des mots-clÃ©s qui sont rÃ©servÃ©s pour Ãªtre utilisÃ©s
actuellement ou Ã  l'avenir dans le langage Rust. Ainsi, ils ne peuvent pas
Ãªtre utilisÃ©s comme identificateurs (sauf comme identificateurs bruts, ce que
nous allons voir dans la section
â€œ<a href="appendix-01-keywords.html#les-identificateurs-bruts">les identificateurs bruts</a><!-- ignore -->â€), y compris les
noms de fonctions, de variables, de paramÃ¨tres, de champs de structures, de
modules, de crates, de constantes, de macros, de valeurs statiques, d'attributs,
de types, de traits, ou de durÃ©es de vie.</p>
<!--
[raw-identifiers]: #raw-identifiers
-->
<!--
### Keywords Currently in Use
-->
<h3><a class="header" href="#les-mots-clÃ©s-actuellement-utilisÃ©s" id="les-mots-clÃ©s-actuellement-utilisÃ©s">Les mots-clÃ©s actuellement utilisÃ©s</a></h3>
<!--
The following keywords currently have the functionality described.
-->
<p>Les mots-clÃ©s suivants apportent actuellement les fonctionnalitÃ©s dÃ©crites.</p>
<!--
* `as` - perform primitive casting, disambiguate the specific trait containing
  an item, or rename items in `use` and `extern crate` statements
* `async` -  return a `Future` instead of blocking the current thread
* `await` - suspend execution until the result of a `Future` is ready
* `break` - exit a loop immediately
* `const` - define constant items or constant raw pointers
* `continue` - continue to the next loop iteration
* `crate` - link an external crate or a macro variable representing the crate in
  which the macro is defined
* `dyn` - dynamic dispatch to a trait object
* `else` - fallback for `if` and `if let` control flow constructs
* `enum` - define an enumeration
* `extern` - link an external crate, function, or variable
* `false` - Boolean false literal
* `fn` - define a function or the function pointer type
* `for` - loop over items from an iterator, implement a trait, or specify a
  higher-ranked lifetime
* `if` - branch based on the result of a conditional expression
* `impl` - implement inherent or trait functionality
* `in` - part of `for` loop syntax
* `let` - bind a variable
* `loop` - loop unconditionally
* `match` - match a value to patterns
* `mod` - define a module
* `move` - make a closure take ownership of all its captures
* `mut` - denote mutability in references, raw pointers, or pattern bindings
* `pub` - denote public visibility in struct fields, `impl` blocks, or modules
* `ref` - bind by reference
* `return` - return from function
* `Self` - a type alias for the type we are defining or implementing
* `self` - method subject or current module
* `static` - global variable or lifetime lasting the entire program execution
* `struct` - define a structure
* `super` - parent module of the current module
* `trait` - define a trait
* `true` - Boolean true literal
* `type` - define a type alias or associated type
* `union` - define a [union] and is only a keyword when used in a union declaration
* `unsafe` - denote unsafe code, functions, traits, or implementations
* `use` - bring symbols into scope
* `where` - denote clauses that constrain a type
* `while` - loop conditionally based on the result of an expression
-->
<ul>
<li><code>as</code> - effectue une transformation primitive, prÃ©cise le trait que contient un
Ã©lÃ©ment, ou renomme des Ã©lÃ©ments dans les instructions <code>use</code> et <code>extern crate</code></li>
<li><code>async</code> - retourne un <code>Future</code> plutÃ´t que de bloquer la tÃ¢che de cours</li>
<li><code>await</code> - mets en pause l'exÃ©cution jusqu'Ã  ce que le rÃ©sultat d'un <code>Future</code>
soit prÃªt</li>
<li><code>break</code> - sort immÃ©diatement d'une boucle</li>
<li><code>const</code> - dÃ©finit des Ã©lÃ©ments fixes ou des pointeurs bruts fixes</li>
<li><code>continue</code> - va directement Ã  la prochaine itÃ©ration de la boucle en cours</li>
<li><code>crate</code> - crÃ©e un lien vers une crate externe ou une variable de macro qui
reprÃ©sente la crate dans laquelle la macro est dÃ©finie</li>
<li><code>dyn</code> - utilisation dynamique d'un objet trait</li>
<li><code>else</code> - une branche de secours pour les structures de contrÃ´le de flux <code>if</code>
et <code>if let</code></li>
<li><code>enum</code> - dÃ©finit une Ã©numÃ©ration</li>
<li><code>extern</code> - crÃ©e un lien vers une crate, une fonction, ou une variable externe</li>
<li><code>false</code> - le litÃ©ral qui vaut &quot;faux&quot; pour un boolÃ©en</li>
<li><code>fn</code> - dÃ©finit une fonction ou le type de pointeur de fonction</li>
<li><code>for</code> - crÃ©e une boucle sur des Ã©lÃ©ments d'un itÃ©rateur, implÃ©mente un trait,
ou renseigne une durÃ©e de vie nÃ©cessaire pour un niveau supÃ©rieur</li>
<li><code>if</code> - une branche liÃ©e au rÃ©sultat d'une expression conditionnelle</li>
<li><code>impl</code> - implÃ©mente des fonctionnalitÃ©s propres Ã  l'Ã©lÃ©ment ou Ã  celles d'un
trait</li>
<li><code>in</code> - fait partie de la syntaxe de la boucle <code>for</code></li>
<li><code>let</code> - lie une valeur Ã  une variable</li>
<li><code>loop</code> - fait une boucle sans condition (thÃ©oriquement infinie)</li>
<li><code>match</code> - compare une valeur Ã  des motifs</li>
<li><code>mod</code> - dÃ©finit un module</li>
<li><code>move</code> - fait en sorte qu'une fermeture prenne possession de tout ce qu'elle
utilise</li>
<li><code>mut</code> - autorise la mutabilitÃ© sur des rÃ©fÃ©rences, des pointeurs bruts, ou des
Ã©lÃ©ments issus de motifs</li>
<li><code>pub</code> - autorise la visibilitÃ© publique sur des champs de structures, des
blocs <code>impl</code>, ou des modules</li>
<li><code>ref</code> - lie une valeur avec une rÃ©fÃ©rence</li>
<li><code>return</code> - retourne quelque chose, dans une fonction</li>
<li><code>Self</code> - un alias de type pour le type que nous dÃ©finissons ou implementons</li>
<li><code>self</code> - dÃ©signe le sujet d'une mÃ©thode, ou du module courant</li>
<li><code>static</code> - une variable globale ou une durÃ©e de vie qui dure tout le long de
l'exÃ©cution du programme</li>
<li><code>struct</code> - dÃ©finit une structure</li>
<li><code>super</code> - le module parent du module courant</li>
<li><code>trait</code> - dÃ©finit un trait</li>
<li><code>true</code> - le litÃ©ral qui vaut &quot;vrai&quot; pour un boolÃ©en</li>
<li><code>type</code> - dÃ©finit un alias de type ou un type associÃ©</li>
<li><code>union</code> - dÃ©finit un <a href="../reference/items/unions.html">union</a> et n'est qu'un mot-clÃ© lorsqu'il est utilisÃ© dans
la dÃ©calation d'un union</li>
<li><code>unsafe</code> - autorise du code, des fonctions, des traits ou des implÃ©mentations
non sÃ©curisÃ©es</li>
<li><code>use</code> - importe des Ã©lÃ©ments dans la portÃ©e</li>
<li><code>where</code> - indique des conditions pour contraindre un type</li>
<li><code>while</code> - crÃ©e une boucle en fonction des rÃ©sultats d'une expression</li>
</ul>
<!--
[union]: ../reference/items/unions.html
-->
<!--
### Keywords Reserved for Future Use
-->
<h3><a class="header" href="#les-mots-clÃ©s-rÃ©servÃ©s-pour-une-utilisation-future" id="les-mots-clÃ©s-rÃ©servÃ©s-pour-une-utilisation-future">Les mots-clÃ©s rÃ©servÃ©s pour une utilisation future</a></h3>
<!--
The following keywords do not have any functionality but are reserved by Rust
for potential future use.
-->
<p>Les mots-clÃ©s suivants n'offrent actuellement aucune fonctionnalitÃ©e mais sont
rÃ©servÃ©s par Rust pour une potentielle utilisation future.</p>
<!--
* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`
-->
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<!--
### Raw Identifiers
-->
<h3><a class="header" href="#les-identificateurs-bruts" id="les-identificateurs-bruts">Les identificateurs bruts</a></h3>
<!--
*Raw identifiers* are the syntax that lets you use keywords where they wouldnâ€™t
normally be allowed. You use a raw identifier by prefixing a keyword with `r#`.
-->
<p>Un <em>identificateur brut</em> est une syntaxe qui vous permet d'utiliser les
mots-clÃ©s lÃ  oÃ¹ ils ne devraient pas pouvoir l'Ãªtre. Vous pouvez utiliser un
identificateur brut en faisant prÃ©cÃ©der un mot-clÃ© par un <code>r#</code>.</p>
<!--
For example, `match` is a keyword. If you try to compile the following function
that uses `match` as its name:
-->
<p>Par exemple, <code>match</code> est un mot-clÃ©. Si vous essayez de compiler la fonction
suivante qui utilise <code>match</code> comme nomÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
    botte_de_foin.contains(aiguille)
}
</code></pre>
<!--
youâ€™ll get this error:
-->
<p>... vous allez obtenir l'erreur suivanteÂ :</p>
<!--
```text
error: expected identifier, found keyword `match`
 -- > src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```
-->
<pre><code class="language-text">error: expected identifier, found keyword `match`
 -- &gt; src/main.rs:4:4
  |
4 | fn match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<!--
The error shows that you canâ€™t use the keyword `match` as the function
identifier. To use `match` as a function name, you need to use the raw
identifier syntax, like this:
-->
<p>L'erreur montre que vous ne pouvez pas utiliser le mot-clÃ© <code>match</code> comme
identificateur de la fonction. Pour utiliser <code>match</code> comme nom de fonction, vous
allez avoir besoin d'utiliser la syntaxe d'identificateur brut, comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn r#match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
    botte_de_foin.contains(aiguille)
}

fn main() {
    assert!(r#match(&quot;lorem ipsum&quot;, &quot;rem&quot;));
}
</code></pre></pre>
<!--
This code will compile without any errors. Note the `r#` prefix on the function
name in its definition as well as where the function is called in `main`.
-->
<p>Ce code va se compiler sans erreur. Remarquez aussi le prÃ©fixe <code>r#</code> sur le nom
de la fonction dans sa dÃ©finition mais aussi lorsque cette fonction est appelÃ©e
dans <code>main</code>.</p>
<!--
Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018
edition. If you depend on a library thatâ€™s written using the 2015 edition and
has a `try` function, youâ€™ll need to use the raw identifier syntax, `r#try` in
this case, to call that function from your 2018 edition code. See [Appendix
E][appendix-e]<!-- ignore -- > for more information on editions.
-->
<p>Les identificateurs bruts vous permettent d'utiliser n'importe quel mot que vous
souhaitez comme identificateur, mÃªme si ce mot est un mot-clÃ© rÃ©servÃ©. De plus,
les identificateurs bruts vous permettent d'utiliser des bibliothÃ¨ques Ã©crites
dans des Ã©ditions de Rust diffÃ©rentes que celle qu'utilise votre crate. Par
exemple, <code>try</code> n'est pas un mot-clÃ© dans l'Ã©dition 2015 mais l'est dans
l'Ã©dition 2018. Si vous dÃ©pendez d'une bibliothÃ¨que qui Ã©tait Ã©crite avec
l'Ã©dition 2015 et qui avait une fonction <code>try</code>, vous allez avoir besoin
d'utiliser la syntaxe d'identificateur brut, <code>r#try</code> dans ce cas, pour faire
appel Ã  cette fonction Ã  partir de code Ã©crit avec l'Ã©dition 2018. Voir
<a href="appendix-05-editions.html">l'annexe E</a><!-- ignore --> pour en savoir plus les Ã©ditions.</p>
<!--
[appendix-e]: appendix-05-editions.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--56" id="-attention-peinture-fraÃ®che--56">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/223">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix B: Operators and Symbols
-->
<h2><a class="header" href="#annexe-b--les-opÃ©rateurs-et-les-symboles" id="annexe-b--les-opÃ©rateurs-et-les-symboles">Annexe BÂ : les opÃ©rateurs et les symboles</a></h2>
<!--
This appendix contains a glossary of Rustâ€™s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.
-->
<p>Cette annexe contient un glossaire de syntaxes Rust, comprenant les opÃ©rateurs
et les autres symboles qui s'utilisent tout seuls ou alors dans le cadre de
chemins, de gÃ©nÃ©riques, de traits liÃ©s, de macros, d'attributs, de commentaires,
de tuples, de crochets ou d'accolades.</p>
<!--
### Operators
-->
<h3><a class="header" href="#opÃ©rateurs" id="opÃ©rateurs">OpÃ©rateurs</a></h3>
<!--
Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.
-->
<p>Le tableau B-1 contient une liste d'opÃ©rateurs en Rust, un exemple de comment
l'opÃ©rateur devrait Ãªtre utilisÃ© dans ce contexte, une petite explication, et si
cet opÃ©rateur est surchargeable. Si un opÃ©rateur est surchargeable, le trait
concernÃ© Ã  utiliser pour la surcharge est indiquÃ©.</p>
<!--
<span class="caption">Table B-1: Operators</span>
-->
<p><span class="caption">Tableau B-1Â : les opÃ©rateurs</span></p>
<!--
| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!` | `!expr` | Bitwise or logical complement | `Not` |
| `!=` | `var != expr` | Nonequality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Borrow | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&` | `expr && expr` | Short-circuiting logical AND | |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*` | `*expr` | Dereference | |
| `*` | `*const type`, `*mut type` | Raw pointer | |
| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,` | `expr, expr` | Argument and element separator | |
| `-` | `- expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type | |
| `.` | `expr.ident` | Member access | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | |
| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | |
| `..` | `..expr` | Struct literal update syntax | |
| `..` | `variant(x, ..)`, `struct_type { x, .. }` | â€œAnd the restâ€ pattern binding | |
| `...` | `expr...expr` | In a pattern: inclusive range pattern | |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Constraints | |
| `:` | `ident: expr` | Struct field initializer | |
| `:` | `'a: loop {...}` | Loop label | |
| `;` | `expr;` | Statement and item terminator | |
| `;` | `[...; len]` | Part of fixed-size array syntax | |
| `<<` | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax | |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>` | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@` | `ident @ pat` | Pattern binding | |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| <code>&vert;</code> | <code>pat &vert; pat</code> | Pattern alternatives | |
| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` |
| <code>&vert;=</code> | <code>var &vert;= expr</code> | Bitwise OR and assignment | `BitOrAssign` |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-circuiting logical OR | |
| `?` | `expr?` | Error propagation | |
-->
<table><thead><tr><th>OpÃ©rateur</th><th>Exemple</th><th>Explication</th><th>Surchargeable ?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Identificateur de macro</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>NÃ©gation binaire ou logique</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Comparaison de non-Ã©galitÃ©</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Reste arithmÃ©tique</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Reste arithmÃ©tique et assignation</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Emprunt</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Type de pointeur empruntÃ©</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>ET binaire</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>ET binaire et assignation</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>ET logique</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Multiplication arithmÃ©tique</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Multiplication arithmÃ©tique et assignation</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>DÃ©rÃ©fÃ©rencement</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Pointeur brut</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Contrainte de type composÃ©</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Addition arithmÃ©tique</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Addition arithmÃ©tique et assignation</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>SÃ©parateur d'arguments et d'Ã©lÃ©ments</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>NÃ©gation arithmÃ©tique</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Soustraction arithmÃ©tique</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Soustraction arithmÃ©tique et assignation</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Type de retour de fonction et de fermeture</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>AccÃ¨s Ã  un membre</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>LittÃ©ral d'intervalle d'exclusion</td><td></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>LittÃ©ral d'intervalle d'inclusion</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Syntaxe de mise Ã  jour de litÃ©raux de structure</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Motif â€œainsi que la suiteâ€</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>Dans un motifÂ : motif d'intervalle inclusif</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Division arithmÃ©tique</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Division arithmÃ©tique et assignation</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Contrainte</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Initialisateur de champ de structure</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Une identification de boucle</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Fin d'Ã©lÃ©ment et d'instruction</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Syntaxe dÃ©signant une partie d'un tableau Ã  taille finie</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>DÃ©calage Ã  gauche</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>DÃ©calage Ã  gauche et assignation</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Comparaison &quot;infÃ©rieur Ã &quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Comparaison &quot;infÃ©rieur ou Ã©gal Ã &quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignation ou Ã©quivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Comparaison d'Ã©galitÃ©</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Syntaxe d'une partie d'une branche correspondante</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Comparaison &quot;supÃ©rieur Ã &quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Comparaison &quot;supÃ©rieur ou Ã©gal Ã &quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>DÃ©calage Ã  droite</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>DÃ©calage Ã  droite et assignation</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>CrÃ©ation d'un identificateur Ã  partir du motif</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>OU exclusif binaire</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>OU exclusif binaire et assignation</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Alternatives Ã  un motif</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>OU binaire</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>OU binaire et assignation</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>OU logique</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Propagation d'erreur</td><td></td></tr>
</tbody></table>
<!--
### Non-operator Symbols
-->
<h3><a class="header" href="#les-symboles-non-opÃ©rateurs" id="les-symboles-non-opÃ©rateurs">Les symboles non-opÃ©rateurs</a></h3>
<!--
The following list contains all non-letters that donâ€™t function as operators;
that is, they donâ€™t behave like a function or method call.
-->
<p>La liste suivante contient tout ce qui n'est pas une lettre et qui ne fonctionne
pas comme un opÃ©rateurÂ ; autrement dit tout ce qui ne se comporte pas comme un
appel de fonction ou de mÃ©thode.</p>
<!--
Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.
-->
<p>Le tableau B-2 montre des symboles qui s'utilisent tout seuls et qui sont
valables dans plusieurs situations.</p>
<!--
<span class="caption">Table B-2: Stand-Alone Syntax</span>
-->
<p><span class="caption">Tableau B-2Â : syntaxes autonomes</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| <code>&vert;...&vert; expr</code> | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | â€œIgnoredâ€ pattern binding; also used to make integer literals readable |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Nom d'une durÃ©e de vie ou nom boucle</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Nombre littÃ©ral d'un type spÃ©cifique</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>ChaÃ®ne de caractÃ¨re littÃ©rale</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>ChaÃ®ne de caractÃ¨res brute littÃ©rale, les caractÃ¨res d'Ã©chappement ne sont pas traitÃ©s</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>ChaÃ®ne d'octet littÃ©ralÂ ; construit un <code>[u8]</code> au lieu d'une chaÃ®ne de caractÃ¨res</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>ChaÃ®ne d'octets brute littÃ©rale, combinaison de la chaÃ®ne d'octets brute et de la chaÃ®ne d'octets littÃ©rale</td></tr>
<tr><td><code>'...'</code></td><td>CaractÃ¨re littÃ©ral</td></tr>
<tr><td><code>b'...'</code></td><td>Octet ASCII littÃ©ral</td></tr>
<tr><td><code>|...| expr</code></td><td>Une fermeture</td></tr>
<tr><td><code>!</code></td><td>Le type â€œjamais&quot;, toujours vide pour les fonctions divergentes</td></tr>
<tr><td><code>_</code></td><td>Le motif â€œignorÃ©&quot;Â ; aussi utilisÃ© pour rendre lisibles les nombres entiers littÃ©raux</td></tr>
</tbody></table>
<!--
Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.
-->
<p>Le tableau B-3 montre des symboles qui s'utilisent dans le contexte d'un chemin
dans une structure de modules pour obtenir un Ã©lÃ©ment.</p>
<!--
<span class="caption">Table B-3: Path-Related Syntax</span>
-->
<p><span class="caption">Tableau B-3Â : syntaxes utilisÃ©s pour les chemins</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which itâ€™s defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Chemin d'un espace de nom</td></tr>
<tr><td><code>::path</code></td><td>Chemin relatif Ã  la crate racine (c'est Ã  dire un chemin explicitement absolu)</td></tr>
<tr><td><code>self::path</code></td><td>Chemin relatif au module courant (c'est Ã  dire un chemin explicitement relatif)</td></tr>
<tr><td><code>super::path</code></td><td>Chemin relatif au parent du module courant</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Des constantes, fonctions et types associÃ©es</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Un Ã©lÃ©ment associÃ© pour un type qui ne peut pas Ãªtre directement nommÃ© (par exemple, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Clarifier l'appel d'une mÃ©thode en nommant le trait qui le dÃ©finit</td></tr>
<tr><td><code>type::method(...)</code></td><td>Clarifier l'appel d'une fonction en nommant le type pour laquelle elle est dÃ©finie</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Clarifier l'appel d'une mÃ©thode en nommant le trait et le type</td></tr>
</tbody></table>
<!--
Table B-4 shows symbols that appear in the context of using generic type
parameters.
-->
<p>Le tableau B-4 montre des symboles qui apparaissent dans le contexte
d'utilisation de paramÃ¨tres de type gÃ©nÃ©riques.</p>
<!--
<span class="caption">Table B-4: Generics</span>
-->
<p><span class="caption">Tableau B-4Â : gÃ©nÃ©riques</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>PrÃ©cise des paramÃ¨tres sur un type gÃ©nÃ©rique utilisÃ© dans un type (par exemple, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>PrÃ©cise des paramÃ¨tres sur un type gÃ©nÃ©rique, une fonction, ou une mÃ©thode dans une expressionÂ ; parfois appelÃ© turbofish (par exemple, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>DÃ©finit une fonction gÃ©nÃ©rique</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>DÃ©finit une structure gÃ©nÃ©rique</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>DÃ©finit une Ã©numÃ©ration gÃ©nÃ©rique</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>DÃ©finit une implÃ©mentation gÃ©nÃ©rique</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Augmente la durÃ©e de vie</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Un type gÃ©nÃ©rique sur lequel un ou plusieurs types associÃ©s ont des affectations spÃ©cifiques (par exemple, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<!--
Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.
-->
<p>Le tableau B-5 montre des symboles qui s'utilisent pour contraindre des
paramÃ¨tres de type gÃ©nÃ©riques avec des traits liÃ©s.</p>
<!--
<span class="caption">Table B-5: Trait Bound Constraints</span>
-->
<p><span class="caption">Tableau B-5Â : contraintes de trait liÃ©</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T : 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>ParamÃ¨tre gÃ©nÃ©rique <code>T</code> contraint aux types qui implÃ©mentent <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Type gÃ©nÃ©rique <code>T</code> doit vivre aussi longtemps que la durÃ©e de vie <code>'a</code> (ce qui signifie que le type ne peut pas contenir temporairement de rÃ©fÃ©rences avec une durÃ©e de vie plus petite que <code>'a</code>)</td></tr>
<tr><td><code>T : 'static</code></td><td>Type gÃ©nÃ©rique <code>T</code> qui ne contient pas d'autres rÃ©fÃ©rences empruntÃ©es autres que des <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>La durÃ©e de vie gÃ©nÃ©rique <code>'b</code> doit vivre aussi longtemps que <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Permet aux paramÃ¨tres de type gÃ©nÃ©riques d'Ãªtre de type Ã  taille dynamique</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Contrainte de type composÃ©</td></tr>
</tbody></table>
<!--
Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.
-->
<p>Le tableau B-6 montre des symboles qui s'utilisent lors de l'appel ou de la
dÃ©finition de macros et pour spÃ©cifier des attributs sur un Ã©lÃ©ment.</p>
<!--
<span class="caption">Table B-6: Macros and Attributes</span>
-->
<p><span class="caption">Tableau B-6Â : macros et attributs</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(â€¦)â€¦` | Macro repetition |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Attribut externe</td></tr>
<tr><td><code>#![meta]</code></td><td>Attribut interne</td></tr>
<tr><td><code>$ident</code></td><td>Substitution de macro</td></tr>
<tr><td><code>$ident:kind</code></td><td>Capture de macro</td></tr>
<tr><td><code>$(â€¦)â€¦</code></td><td>RÃ©pÃ©tition de macro</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Appel d'une macro</td></tr>
</tbody></table>
<!--
Table B-7 shows symbols that create comments.
-->
<p>Le tableau B-7 montre des symboles pour crÃ©er des commentaires.</p>
<!--
<span class="caption">Table B-7: Comments</span>
-->
<p><span class="caption">Tableau B-7Â : commentaires</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Ligne commentÃ©e</td></tr>
<tr><td><code>//!</code></td><td>Commentaire de documentation sur l'Ã©lÃ©ment contenant actuel</td></tr>
<tr><td><code>///</code></td><td>Commentaire de documentation sur l'Ã©lÃ©ment suivant ce commentaire</td></tr>
<tr><td><code>/*...*/</code></td><td>Bloc de commentaire</td></tr>
<tr><td><code>/*!...*/</code></td><td>Bloc de commentaire de documentation sur l'Ã©lÃ©ment contenant actuel</td></tr>
<tr><td><code>/**...*/</code></td><td>Bloc de commentaire de documentation sur l'Ã©lÃ©ment suivant ce commentaire</td></tr>
</tbody></table>
<!--
Table B-8 shows symbols that appear in the context of using tuples.
-->
<p>Le tableau B-8 montre des symboles utilisÃ©s avec les tuples.</p>
<!--
<span class="caption">Table B-8: Tuples</span>
-->
<p><span class="caption">Tableau B-8Â : les tuples</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Un tuple vide (aussi appelÃ© unitaire), Ã  la fois un type et un litÃ©ral</td></tr>
<tr><td><code>(expr)</code></td><td>Une expression entre parenthÃ¨ses</td></tr>
<tr><td><code>(expr,)</code></td><td>Un tuple d'un seul Ã©lement qui est une expression</td></tr>
<tr><td><code>(type,)</code></td><td>Un tuple d'un seul Ã©lement qui est un type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Une expression dans un tuple</td></tr>
<tr><td><code>(type, ...)</code></td><td>Un type dans un tuple</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Une expression d'appel Ã  une fonctionÂ ; aussi utilisÃ© pour initialiser une structure tuple ou une variante d'Ã©numÃ©ration tuple</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Utilisation d'indices sur un tuple</td></tr>
</tbody></table>
<!--
Table B-9 shows the contexts in which curly braces are used.
-->
<p>Le tableau B-9 montre les contextes d'utilisation des accolades.</p>
<!--
<span class="caption">Table B-9: Curly Brackets</span>
-->
<p><span class="caption">Tableau B-9Â : accolades</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Bloc d'expression</td></tr>
<tr><td><code>Type {...}</code></td><td>Un littÃ©ral de <code>struct</code></td></tr>
</tbody></table>
<!--
Table B-10 shows the contexts in which square brackets are used.
-->
<p>Le tableau B-10 montre les contextes d'utilisation des crochets.</p>
<!--
<span class="caption">Table B-10: Square Brackets</span>
-->
<p><span class="caption">Tableau B-10Â : crochets</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the â€œindexâ€ |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Un littÃ©ral de tableau</td></tr>
<tr><td><code>[expr; len]</code></td><td>Un littÃ©ral de tableau qui contient <code>len</code> copies de <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Un type de tableau qui contient <code>len</code> instances de <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Une collection indexÃ©e. C'est surchargeable (via <code>Index</code> et <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Une collection indexÃ©e qui se comporte comme une slice de collection, grÃ¢ce Ã  l'utilisation de <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, ou de <code>RangeFull</code> comme â€œindiceâ€</td></tr>
</tbody></table>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--57" id="-attention-peinture-fraÃ®che--57">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/224">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix C: Derivable Traits
-->
<h2><a class="header" href="#annexe-c--les-traits-dÃ©rivables" id="annexe-c--les-traits-dÃ©rivables">Annexe CÂ : les traits dÃ©rivables</a></h2>
<!--
In various places in the book, weâ€™ve discussed the `derive` attribute, which
you can apply to a struct or enum definition. The `derive` attribute generates
code that will implement a trait with its own default implementation on the
type youâ€™ve annotated with the `derive` syntax.
-->
<p>Dans de nombreux endroits du livre, nous avons vu l'attribut <code>derive</code>, que vous
pouvez appliquer Ã  une dÃ©finition de structure ou d'Ã©numÃ©ration. L'attribut
<code>derive</code> gÃ©nÃ¨re du code qui va implÃ©menter un trait avec sa propre
implÃ©mentation par dÃ©faut sur le type que vous avez annotÃ© avec la syntaxe
<code>derive</code>.</p>
<!--
In this appendix, we provide a reference of all the traits in the standard
library that you can use with `derive`. Each section covers:
-->
<p>Dans cette annexe, nous allons produire une rÃ©fÃ©rence de tous les traits de la
bibliothÃ¨que standard que vous pouvez utiliser avec <code>derive</code>. Chaque section
va donnerÂ :</p>
<!--
* What operators and methods deriving this trait will enable
* What the implementation of the trait provided by `derive` does
* What implementing the trait signifies about the type
* The conditions in which youâ€™re allowed or not allowed to implement the trait
* Examples of operations that require the trait
-->
<ul>
<li>Quels opÃ©rateurs et mÃ©thodes seront activÃ©s en dÃ©rivant de ce trait</li>
<li>Ce que fait l'implÃ©mentation du trait appliquÃ© par le <code>derive</code></li>
<li>Ce que l'implÃ©mentation du trait implique sur le type concernÃ©</li>
<li>Les conditions dans lesquelles vous pouvez ou non implÃ©menter le trait</li>
<li>Des exemples d'opÃ©rations qui nÃ©cessitent que le trait soit implÃ©mentÃ©</li>
</ul>
<!--
If you want different behavior from that provided by the `derive` attribute,
consult the [standard library documentation](../std/index.html)<!-- ignore -- >
for each trait for details of how to manually implement them.
-->
<p>Si vous souhaitez appliquer un comportement diffÃ©rent de celui fourni par
l'attribut <code>derive</code>, consultez <a href="https://doc.rust-lang.org/std/index.html">la documentation de la bibliothÃ¨que
standard</a><!-- ignore --> pour le trait
concernÃ© afin d'en savoir plus sur son implÃ©mentation manuelle.</p>
<!--
The rest of the traits defined in the standard library canâ€™t be implemented on
your types using `derive`. These traits donâ€™t have sensible default behavior,
so itâ€™s up to you to implement them in the way that makes sense for what youâ€™re
trying to accomplish.
-->
<p>Le reste des traits dÃ©finis dans la bibliothÃ¨que standard ne peuvent pas Ãªtre
implÃ©mentÃ©s sur des types en utilisant <code>derive</code>. Ces traits n'ont pas de
comportement logique par dÃ©faut, donc c'est Ã  vous de les implÃ©menter de la
faÃ§on la plus appropriÃ©e pour ce que vous souhaitez accomplir.</p>
<!--
An example of a trait that canâ€™t be derived is `Display`, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesnâ€™t have this insight, so
it canâ€™t provide appropriate default behavior for you.
-->
<p>Un exemple de trait qui ne peut pas Ãªtre dÃ©rivÃ© est <code>Display</code>, qui permet de
formater la donnÃ©e pour les utilisateurs finaux. Vous devez toujours rÃ©flÃ©chir
au formatage du type le plus appropriÃ© pour un utilisateur final. Quelles
parties d'un type un utilisateur final devrait pouvoir voirÂ ? Sous quelle forme
les donnÃ©es devraient Ãªtre les plus intÃ©ressantes pour euxÂ ? Le compilateur de
Rust n'a pas cette intuition, donc il ne peut pas fournir un comportement par
dÃ©faut Ã  votre place.</p>
<!--
The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement `derive` for their own traits, making the list of
traits you can use `derive` with truly open-ended. Implementing `derive`
involves using a procedural macro, which is covered in the
[â€œMacrosâ€][macros]<!-- ignore -- > section of Chapter 19.
-->
<p>La liste des traits dÃ©rivables fournis dans cette annexe n'est pas exhaustiveÂ :
les bibliothÃ¨ques peuvent implÃ©menter <code>derive</code> pour leurs propres traits,
Ã©tendant potentiellement Ã  l'infini la liste de traits que vous pouvez utiliser
avec <code>derive</code>. L'implÃ©mentation de <code>derive</code> implique l'utilisation d'une macro
procÃ©durale, que nous avons vu dans <a href="ch19-06-macros.html">une section</a><!-- ignore --> du
chapitre 19.</p>
<!--
### `Debug` for Programmer Output
-->
<h3><a class="header" href="#debug-pour-laffichage-au-dÃ©veloppeur" id="debug-pour-laffichage-au-dÃ©veloppeur"><code>Debug</code> pour l'affichage au dÃ©veloppeur</a></h3>
<!--
The `Debug` trait enables debug formatting in format strings, which you
indicate by adding `:?` within `{}` placeholders.
-->
<p>Le trait <code>Debug</code> permet le formatage de dÃ©boguage pour mettre en forme en tant
que chaÃ®nes de caractÃ¨res, que vous pouvez utiliser en ajoutant <code>:?</code> dans un
espace rÃ©servÃ© <code>{}</code>.</p>
<!--
The `Debug` trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a programâ€™s execution.
-->
<p>Le trait <code>Debug</code> vous permet d'afficher des instances d'un type pour des besoins
de dÃ©boguage, afin que vous et les autres dÃ©veloppeurs qui utilisent votre type
puissent inspecter une de ses instances Ã  un endroit prÃ©cis de l'exÃ©cution du
programme.</p>
<!--
The `Debug` trait is required, for example, in use of the `assert_eq!` macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances werenâ€™t equal.
-->
<p>Le trait <code>Debug</code> est nÃ©cessaire, par exemple, pour l'utilisation de la macro
<code>assert_eq!</code>. Cette macro affiche les valeurs des instances passÃ©es en argument
dans le cas oÃ¹ l'affirmation Ã©choue afin que le dÃ©veloppeur puisse voir pourquoi
les deux instances ne sont pas Ã©gales.</p>
<!--
### `PartialEq` and `Eq` for Equality Comparisons
-->
<h3><a class="header" href="#partialeq-et-eq-pour-comparer-lÃ©galitÃ©" id="partialeq-et-eq-pour-comparer-lÃ©galitÃ©"><code>PartialEq</code> et <code>Eq</code> pour comparer l'Ã©galitÃ©</a></h3>
<!--
The `PartialEq` trait allows you to compare instances of a type to check for
equality and enables use of the `==` and `!=` operators.
-->
<p>Le trait <code>PartialEq</code> vous permet de comparer des instances d'un type pour
vÃ©rifier leur Ã©galitÃ© et permet l'utilisation des opÃ©rateurs <code>==</code> et <code>!=</code>.</p>
<!--
Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived on
structs, two instances are equal only if *all* fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.
-->
<p>L'application de <code>derive</code> avec <code>PartialEq</code> implÃ©mente la mÃ©thode <code>eq</code>. Lorsque
<code>PartialEq</code> est dÃ©rivÃ© sur une structure, deux instances ne peuvent Ãªtre Ã©gales
seulement si <em>tous</em> leurs champs sont Ã©gaux, et les instances ne sont pas Ã©gales
si un des champs n'est pas Ã©gal. Lorsque ce trait est dÃ©rivÃ© sur une
Ã©numÃ©ration, chaque variante est Ã©gale Ã  elle-mÃªme et n'est pas Ã©gale aux autres
variantes.</p>
<!--
The `PartialEq` trait is required, for example, with the use of the
`assert_eq!` macro, which needs to be able to compare two instances of a type
for equality.
-->
<p>Le trait <code>Eq</code> est nÃ©cessaire, par exemple, pour utiliser la macro <code>assert_eq!</code>,
qui nÃ©cessite de pouvoir comparer l'Ã©galitÃ© de deux instances d'un type.</p>
<!--
The `Eq` trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The `Eq` trait can only be
applied to types that also implement `PartialEq`, although not all types that
implement `PartialEq` can implement `Eq`. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (`NaN`) value are not equal to each other.
-->
<p>Le trait <code>Eq</code> n'a pas de mÃ©thode. Son rÃ´le est de signaler que pour chaque
valeur du type annotÃ©, la valeur est Ã©gale Ã  elle-mÃªme. Le trait <code>Eq</code> peut
seulement Ãªtre appliquÃ© sur des types qui implÃ©mentent <code>PartialEq</code>, bien que
tous les types qui implÃ©mentent <code>PartialEq</code> ne puissent pas implÃ©menter <code>Eq</code>. Un
exemple de ceci sont les types de nombres Ã  virgule flottanteÂ : l'implÃ©mentation
des nombres Ã  virgule flottante stipule que deux instances ayant la valeur
â€œnot-a-numberâ€ (<code>NaN</code>, c'est-Ã -dire â€œceci n'est pas un nombreâ€) ne sont pas
Ã©gales entre elles.</p>
<!--
An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the
`HashMap<K, V>` can tell whether two keys are the same.
-->
<p>Par exemple, <code>Eq</code> est nÃ©cessaire est pour les clÃ©s dans un <code>HashMap&lt;K, V&gt;</code> afin
que le <code>HashMap&lt;K, V&gt;</code> puisse dÃ©terminer si deux clÃ©s sont identiques.</p>
<!--
### `PartialOrd` and `Ord` for Ordering Comparisons
-->
<h3><a class="header" href="#partialord-et-ord-pour-comparer-les-ordres-de-grandeur" id="partialord-et-ord-pour-comparer-les-ordres-de-grandeur"><code>PartialOrd</code> et <code>Ord</code> pour comparer les ordres de grandeur</a></h3>
<!--
The `PartialOrd` trait allows you to compare instances of a type for sorting
purposes. A type that implements `PartialOrd` can be used with the `<`, `>`,
`<=`, and `>=` operators. You can only apply the `PartialOrd` trait to types
that also implement `PartialEq`.
-->
<p>Le trait <code>PartialOrd</code> vous permet de comparer des instances d'un type pour
pouvoir les trier. Un type qui implÃ©mente <code>PartialOrd</code> peut Ãªtre utilisÃ© avec
les opÃ©rateurs <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, et <code>&gt;=</code>. Vous pouvez appliquer uniquement le
trait <code>PartialOrd</code> aux types qui implÃ©mentent aussi <code>PartialEq</code>.</p>
<!--
Deriving `PartialOrd` implements the `partial_cmp` method, which returns an
`Option<Ordering>` that will be `None` when the values given donâ€™t produce an
ordering. An example of a value that doesnâ€™t produce an ordering, even though
most values of that type can be compared, is the not-a-number (`NaN`) floating
point value. Calling `partial_cmp` with any floating point number and the `NaN`
floating point value will return `None`.
-->
<p>L'application de <code>derive</code> avec <code>PartialOrd</code> implÃ©mente la mÃ©thode <code>partial_cmp</code>,
qui retourne un <code>Option&lt;Ordering&gt;</code> qui vaudra <code>None</code> lorsque les valeurs
fournies ne fournissent pas un ordre. Un exemple de valeur qui ne produit pas
d'ordre, mÃªme si la plupart des valeurs de ce type peuvent Ãªtre comparÃ©es, est
la valeur â€œnot-a-numberâ€ (<code>NaN</code>) des virgules flottantes. L'appel Ã 
<code>partial_cmp</code> entre n'importe quel nombre Ã  virgule flottante et la valeur <code>NaN</code>
de virgule flottante va retourner <code>None</code>.</p>
<!--
When derived on structs, `PartialOrd` compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.
-->
<p>Lorsqu'il est dÃ©rivÃ© sur une structure, <code>PartialOrd</code> compare deux instances en
comparant les valeurs de chaque champ dans l'ordre dans lequel les champs
apparaissent dans la dÃ©finition de la structure. Lorsqu'il est dÃ©rivÃ© sur des
Ã©numÃ©rations, les variantes de l'Ã©numÃ©ration dÃ©clarÃ©es plus tÃ´t dans la
dÃ©finition de l'Ã©numÃ©ration sont considÃ©rÃ©es infÃ©rieures aux variantes dÃ©clarÃ©es
ensuite.</p>
<!--
The `PartialOrd` trait is required, for example, for the `gen_range` method
from the `rand` crate that generates a random value in the range specified by a
low value and a high value.
-->
<p>Le trait <code>PartialOrd</code> est nÃ©cessaire, par exemple, pour la mÃ©thode <code>gen_range</code>
de la crate <code>rand</code> qui gÃ©nÃ¨re une valeur alÃ©atoire dans l'intervalle contrainte
par une valeur minimale et une valeur maximale.</p>
<!--
The `Ord` trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The `Ord` trait implements the `cmp` method,
which returns an `Ordering` rather than an `Option<Ordering>` because a valid
ordering will always be possible. You can only apply the `Ord` trait to types
that also implement `PartialOrd` and `Eq` (and `Eq` requires `PartialEq`). When
derived on structs and enums, `cmp` behaves the same way as the derived
implementation for `partial_cmp` does with `PartialOrd`.
-->
<p>Le trait <code>Ord</code> vous permet de savoir si un ordre valide existe toujours entre
deux valeurs du type annotÃ©. Le trait <code>Ord</code> implÃ©mente la mÃ©thode <code>cmp</code>, qui
retourne un <code>Ordering</code> plutÃ´t qu'une <code>Option&lt;Ordering&gt;</code> car un ordre valide sera
toujours possible. Vous pouvez appliquer le trait <code>Ord</code> uniquement sur les types
qui implÃ©mentent aussi <code>PartialOrd</code> et <code>Eq</code> (et <code>Eq</code> nÃ©cessite <code>PartialEq</code>).
Lorsqu'il est dÃ©rivÃ© sur des structures et des Ã©numÃ©rations, <code>cmp</code> se comporte
de la mÃªme maniÃ¨re que l'implÃ©mentation de <code>partial_cmp</code> dÃ©rivÃ©e de
<code>PartialOrd</code>.</p>
<!--
An example of when `Ord` is required is when storing values in a `BTreeSet<T>`,
a data structure that stores data based on the sort order of the values.
-->
<p>Par exemple, <code>Ord</code> doit Ãªtre implÃ©mentÃ© sur le type de valeurs que nous stockons
dans un <code>BTreeSet&lt;T&gt;</code>, qui est une structure de donnÃ©e qui stocke des donnÃ©es en
fonction de l'ordre de tri de ces valeurs.</p>
<!--
### `Clone` and `Copy` for Duplicating Values
-->
<h3><a class="header" href="#clone-et-copy-pour-dupliquer-des-valeurs" id="clone-et-copy-pour-dupliquer-des-valeurs"><code>Clone</code> et <code>Copy</code> pour dupliquer des valeurs</a></h3>
<!--
The `Clone` trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the [â€œWays Variables and Data Interact:
Cloneâ€][ways-variables-and-data-interact-clone]<!-- ignore -- > section in
Chapter 4 for more information on `Clone`.
-->
<p>Le trait <code>Clone</code> vous permet de crÃ©er explicitement une copie profonde d'une
valeur, et le processus de duplication peut impliquer l'exÃ©cution d'un code
arbitraire pour copier les donnÃ©es stockÃ©es dans le tas. Rendez-vous Ã  la
section <a href="ch04-01-what-is-ownership.html#les-interactions-entre-les-variables-et-les-donn%C3%A9es--le-d%C3%A9placement">â€œLes interactions entre les variables et les donnÃ©es : le
dÃ©placementâ€</a><!-- ignore --> du
chapitre 4 pour plus d'informations sur <code>Clone</code>.</p>
<!--
Deriving `Clone` implements the `clone` method, which when implemented for the
whole type, calls `clone` on each of the parts of the type. This means all the
fields or values in the type must also implement `Clone` to derive `Clone`.
-->
<p>Utiliser <code>derive</code> avec <code>Clone</code> implÃ©mente la mÃ©thode <code>clone</code>, qui, lorsqu'elle
est implÃ©mentÃ©e sur tout le type, fait appel Ã  <code>clone</code> sur chaque constituant du
type. Cela signifie que tous les champs ou les valeurs dans le type doivent
aussi implÃ©menter <code>Clone</code> pour dÃ©river de <code>Clone</code>.</p>
<!--
An example of when `Clone` is required is when calling the `to_vec` method on a
slice. The slice doesnâ€™t own the type instances it contains, but the vector
returned from `to_vec` will need to own its instances, so `to_vec` calls
`clone` on each item. Thus, the type stored in the slice must implement `Clone`.
-->
<p><code>Clone</code> est par exemple nÃ©cessaire lorsque nous appelons la mÃ©thode <code>to_vec</code> sur
une slice. La slice ne prend pas possession des instances du type qu'il
contient, mais le vecteur retournÃ© par <code>to_vec</code> va avoir besoin de prendre
possession de ses instances, donc <code>to_vec</code> fait appel Ã  <code>clone</code> sur chaque
Ã©lÃ©ment. C'est pourquoi le type stockÃ© dans la slice doit implÃ©menter <code>Clone</code>.</p>
<!--
The `Copy` trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the [â€œStack-Only Data:
Copyâ€][stack-only-data-copy]<!-- ignore -- > section in Chapter 4 for more
information on `Copy`.
-->
<p>Le trait <code>Copy</code> vous permet de dupliquer une valeur en copiant uniquement les
Ã©lÃ©ments stockÃ©s sur la pileÂ ; il n'est pas nÃ©cessaire d'avoir de code
arbitraire. Rendez-vous Ã  la section <a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">â€œDonnÃ©es uniquement sur la pile : la
copieâ€</a><!-- ignore --> du chapitre 4 pour plus
d'informations sur <code>Copy</code>.</p>
<!--
The `Copy` trait doesnâ€™t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.
-->
<p>Le trait <code>Copy</code> ne dÃ©finit pas de mÃ©thode, volontairement pour empÃªcher les
dÃ©veloppeurs de surcharger ces mÃ©thodes et ainsi violer l'affirmation qu'aucun
code arbitraire est exÃ©cutÃ© Ã  la copie. Ainsi, tous les dÃ©veloppeurs peuvent
compter sur le fait qu'une copie de valeur est trÃ¨s rapide.</p>
<!--
You can derive `Copy` on any type whose parts all implement `Copy`. You can
only apply the `Copy` trait to types that also implement `Clone`, because a
type that implements `Copy` has a trivial implementation of `Clone` that
performs the same task as `Copy`.
-->
<p>Vous pouvez utiliser <code>derive</code> avec <code>Copy</code> sur n'importe quel type constituÃ©
d'Ã©lÃ©ments qui implÃ©mentent aussi <code>Copy</code>. Vous ne pouvez appliquer le trait
<code>Copy</code> que sur des types qui implÃ©mentent aussi <code>Clone</code>, car un type qui
implÃ©mente <code>Copy</code> a aussi une implÃ©mentation triviale de <code>Clone</code> qui procÃ¨de
aux mÃªmes actions que <code>Copy</code>.</p>
<!--
The `Copy` trait is rarely required; types that implement `Copy` have
optimizations available, meaning you donâ€™t have to call `clone`, which makes
the code more concise.
-->
<p>Le trait <code>Copy</code> est rarement nÃ©cessaireÂ ; les types qui implÃ©mentent <code>Copy</code>
peuvent Ãªtre optimisÃ©s, ce qui veut dire que vous n'avez pas Ã  appeler <code>clone</code>,
ce qui rend le code plus concis.</p>
<!--
Everything possible with `Copy` you can also accomplish with `Clone`, but the
code might be slower or have to use `clone` in places.
-->
<p>Tout ce que vous pouvez accomplir avec <code>Copy</code>, vous pouvez le faire avec
<code>Clone</code>, mais le code risque d'Ãªtre plus lent ou doit parfois utiliser <code>clone</code>.</p>
<!--
### `Hash` for Mapping a Value to a Value of Fixed Size
-->
<h3><a class="header" href="#hash-pour-faire-correspondre-une-valeur-avec-une-valeur-de-taille-fixe" id="hash-pour-faire-correspondre-une-valeur-avec-une-valeur-de-taille-fixe"><code>Hash</code> pour faire correspondre une valeur avec une valeur de taille fixe</a></h3>
<!--
The `Hash` trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
`Hash` implements the `hash` method. The derived implementation of the `hash`
method combines the result of calling `hash` on each of the parts of the type,
meaning all fields or values must also implement `Hash` to derive `Hash`.
-->
<p>Le trait <code>Hash</code> vous permet d'obtenir une valeur Ã  taille fixe en utilisant une
fonction de hachage sur une instance d'un type d'une taille quelconque. Utiliser
<code>derive</code> avec <code>Hash</code> implÃ©mente la mÃ©thode <code>hash</code>. L'implÃ©mentation dÃ©rive de la
mÃ©thode <code>hash</code> combine le rÃ©sultat de l'appel de <code>hash</code> sur chaque Ã©lÃ©ment du
type, ce qui signifie que tous ses champs ou valeurs doivent aussi implÃ©menter
<code>Hash</code> pour pouvoir lui appliquer le trait <code>Hash</code>.</p>
<!--
An example of when `Hash` is required is in storing keys in a `HashMap<K, V>`
to store data efficiently.
-->
<p>Pour stocker des clÃ©s efficacement dans un <code>HashMap&lt;K, V&gt;</code>, les clÃ©s doivent
nÃ©cessairement implÃ©menter <code>Hash</code>.</p>
<!--
### `Default` for Default Values
-->
<h3><a class="header" href="#default-pour-des-valeurs-par-dÃ©faut" id="default-pour-des-valeurs-par-dÃ©faut"><code>Default</code> pour des valeurs par dÃ©faut</a></h3>
<!--
The `Default` trait allows you to create a default value for a type. Deriving
`Default` implements the `default` function. The derived implementation of the
`default` function calls the `default` function on each part of the type,
meaning all fields or values in the type must also implement `Default` to
derive `Default`.
-->
<p>Le trait <code>Default</code> vous permet de crÃ©er une valeur par dÃ©faut pour un type.
ImplÃ©menter <code>Default</code> avec <code>derive</code> ajoute la fonction <code>default</code>. Cette fonction
<code>default</code> fait elle-mÃªme appel Ã  la fonction <code>default</code> sur chaque Ã©lÃ©ment du
type, ce qui signifie que tous les champs ou les valeurs dans le type doit aussi
implÃ©menter <code>Default</code> pour que ce type puisse dÃ©river de <code>Default</code>.</p>
<!-- markdownlint-disable -->
<!--
The `Default::default` function is commonly used in combination with the struct
update syntax discussed in the [â€œCreating Instances From Other Instances With
Struct Update
Syntaxâ€][creating-instances-from-other-instances-with-struct-update-syntax]<!-- ignore -- >
section in Chapter 5. You can customize a few fields of a struct and then
set and use a default value for the rest of the fields by using
`..Default::default()`.
-->
<p>La fonction <code>Default::default</code> est couramment utilisÃ© en association avec la
syntaxe de modification de structures que nous avons vu dans la section <a href="ch05-01-defining-structs.html#cr%C3%A9er-des-instances-%C3%A0-partir-dautres-instances-avec-la-syntaxe-de-mise-%C3%A0-jour-de-structure">â€œCrÃ©er
des instances Ã  partir d'autres instances avec la syntaxe de mise Ã  jour de
structureâ€</a><!-- ignore -->
du chapitre 5. Vous pouvez personnaliser quelques champs d'une structure et
ensuite dÃ©finir et utiliser une valeur par dÃ©faut pour le reste des champs en
utilisant <code>..Default::default()</code>.</p>
<!--
The `Default` trait is required when you use the method `unwrap_or_default` on
`Option<T>` instances, for example. If the `Option<T>` is `None`, the method
`unwrap_or_default` will return the result of `Default::default` for the type
`T` stored in the `Option<T>`.
-->
<p>Le trait <code>Default</code> est nÃ©cessaire lorsque vous utilisez la mÃ©thode
<code>unwrap_or_default</code> sur les instances de <code>Option&lt;T&gt;</code>, par exemple. Si le
<code>Option&lt;T&gt;</code> vaut <code>None</code>, la mÃ©thode <code>unwrap_or_default</code> va retourner le rÃ©sultat
de <code>Default::default</code> sur le type <code>T</code> provenant du <code>Option&lt;T&gt;</code>.</p>
<!--
[creating-instances-from-other-instances-with-struct-update-syntax]:
ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[ways-variables-and-data-interact-clone]:
ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--58" id="-attention-peinture-fraÃ®che--58">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/225">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix D - Useful Development Tools
-->
<h2><a class="header" href="#annexe-d---des-outils-de-dÃ©veloppement-utiles" id="annexe-d---des-outils-de-dÃ©veloppement-utiles">Annexe D - Des outils de dÃ©veloppement utiles</a></h2>
<!--
In this appendix, we talk about some useful development tools that the Rust
project provides. Weâ€™ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.
-->
<p>Dans cette annexe, nous allons dÃ©couvrir quelques outils de dÃ©veloppement utiles
que propose le projet Rust. Nous allons voir le formatage automatique, des
moyens rapides pour corriger des avertissements, un analyseur statique, et
l'intÃ©gration avec un IDE.</p>
<!--
### Automatic Formatting with `rustfmt`
-->
<h3><a class="header" href="#le-formatage-automatique-avec-rustfmt" id="le-formatage-automatique-avec-rustfmt">Le formatage automatique avec <code>rustfmt</code></a></h3>
<!--
The `rustfmt` toolÂ reformats your code according to the community code style.
Many collaborative projects use `rustfmt` to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.
-->
<p>L'outil <code>rustfmt</code> reformate votre code suivant le style de code de la
communautÃ©. De nombreux projets collaboratifs utilisent <code>rustfmt</code> pour Ã©viter
des dÃ©saccords sur le style Ã  utiliser lorsqu'ils Ã©crivent du code RustÂ : tout le
monde formate leur code en utilisant l'outil.</p>
<!--
To install `rustfmt`, enter the following:
-->
<p>Pour installer <code>rustfmt</code>, saisissez ceciÂ :</p>
<!--
```console
$ rustup component add rustfmt
```
-->
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<!--
This command gives you `rustfmt` and `cargo-fmt`, similar to how Rust gives you
both `rustc` and `cargo`. To format any Cargo project, enter the following:
-->
<p>Cette commande vous offre <code>rustfmt</code> et <code>cargo-fmt</code>, de la mÃªme maniÃ¨re que Rust
vous installe <code>rustc</code> et <code>cargo</code>. Pour formater un projet Cargo, saisissez
ceciÂ :</p>
<!--
```console
$ cargo fmt
```
-->
<pre><code class="language-console">$ cargo fmt
</code></pre>
<!--
Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on `rustfmt`, see [its documentation][rustfmt].
-->
<p>L'exÃ©cution de cette commande reformate tout le code Rust dans la crate
courante. Cela va uniquement changer le style de code, pas sa sÃ©mantique. Pour
plus d'informations sur <code>rustfmt</code>, voyez <a href="https://github.com/rust-lang/rustfmt">sa documentation</a>.</p>
<!--
[rustfmt]: https://github.com/rust-lang/rustfmt
-->
<!--
### Fix Your Code with `rustfix`
-->
<h3><a class="header" href="#corriger-votre-code-avec-rustfix" id="corriger-votre-code-avec-rustfix">Corriger votre code avec <code>rustfix</code></a></h3>
<!--
The rustfix tool is included with Rust installations and can automatically fix
some compiler warnings. If youâ€™ve written code in Rust, youâ€™ve probably seen
compiler warnings. For example, consider this code:
-->
<p>L'outil rustfix est inclus lors de l'installation de Rust et peut
automatiquement corriger certains avertissements de compilateur. Si vous avez
dÃ©jÃ  Ã©crit du code en Rust, vous avez probablement vu des avertissements du
compilateur. Par exemple, avec le code suivantÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fait_quelquechose() {}

fn main() {
    for i in 0..100 {
        fait_quelquechose();
    }
}
</code></pre></pre>
<!--
Here, weâ€™re calling the `do_something` function 100 times, but we never use the
variable `i` in the body of the `for` loop. Rust warns us about that:
-->
<p>Ici, nous appelons la fonction <code>fait_quelquechose</code> 100 fois, mais nous
n'utilisons jamais la variable <code>i</code> dans le corps de la boucle <code>for</code>. Rust nous
avertit de celaÂ :</p>
<!--
```console
$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 -- > src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling mon_programme v0.1.0 (file:///projects/mon_programme)
warning: unused variable: `i`
 -- &gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<!--
The warning suggests that we use `_i` as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the `rustfix` tool by running the command `cargo
fix`:
-->
<p>L'avertissement indique que nous devrions utiliser <code>_i</code> comme nom Ã  sa placeÂ :
le tiret bas indique que nous avons l'intention de ne pas utiliser cette
variable. Nous pouvons appliquer automatiquement cette suggestion en utilisant
l'outil <code>rustfix</code> en lanÃ§ant la commande <code>cargo fix</code>Â :</p>
<!--
```console
$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```
-->
<pre><code class="language-console">$ cargo fix
    Checking mon_programme v0.1.0 (file:///projects/mon_programme)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
When we look at *src/main.rs* again, weâ€™ll see that `cargo fix` has changed the
code:
-->
<p>Lorsque nous regardons Ã  nouveau <em>src/main.rs</em>, nous pouvons constater que
<code>cargo fix</code> a changÃ© le codeÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fait_quelquechose() {}

fn main() {
    for _i in 0..100 {
        fait_quelquechose();
    }
}
</code></pre></pre>
<!--
The `for` loop variable is now named `_i`, and the warning no longer appears.
-->
<p>La variable de la boucle <code>for</code> s'appelle maintenant <code>_i</code>, et l'avertissement ne
s'affiche plus.</p>
<!--
You can also use the `cargo fix` command to transition your code between
different Rust editions. Editions are covered in Appendix E.
-->
<p>Vous pouvez aussi utiliser la commande <code>cargo fix</code> pour corriger votre code
entre diffÃ©rentes Ã©ditions de Rust. Les Ã©ditions sont abordÃ©es Ã  l'annexe E.</p>
<!--
### More Lints with Clippy
-->
<h3><a class="header" href="#une-analyse-statique-plus-complÃ¨te-avec-clippy" id="une-analyse-statique-plus-complÃ¨te-avec-clippy">Une analyse statique plus complÃ¨te avec Clippy</a></h3>
<!--
The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.
-->
<p>L'outil Clippy est une collection d'analyses statiques pour analyser votre code
afin que vous puissiez dÃ©busquer certaines erreurs courantes et ainsi amÃ©liorer
votre code.</p>
<!--
To install Clippy, enter the following:
-->
<p>Pour installer Clippy, saisissez ceciÂ :</p>
<!--
```console
$ rustup component add clippy
```
-->
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<!--
To run Clippyâ€™s lints on any Cargo project, enter the following:
-->
<p>Pour lancer l'analyse statique de Clippy sur un projet Cargo, saisissez ceciÂ :</p>
<!--
```console
$ cargo clippy
```
-->
<pre><code class="language-console">$ cargo clippy
</code></pre>
<!--
For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:
-->
<p>Par exemple, imaginons que vous Ã©crivez un programme qui utilise une
approximation d'une constante mathÃ©matique, comme pi, comme le fait ce
programmeÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;l'aire du cercle vaut {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
Running `cargo clippy` on this project results in this error:
-->
<p>L'exÃ©cution de <code>cargo clippy</code> sur ce projet va afficher cette erreurÂ :</p>
<!--
```text
error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 -- > src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
```
-->
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 -- &gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<!--
This error lets you know that Rust has this constant defined more precisely and
that your program would be more correct if you used the constant instead. You
would then change your code to use the `PI` constant. The following code
doesnâ€™t result in any errors or warnings from Clippy:
-->
<p>Cette erreur vous fais savoir que Rust a cette constante qui est dÃ©finie plus
prÃ©cisÃ©ment et que votre programme serait plus pertinent si vous utilisiez Ã  la
place la constante. Vous changeriez alors votre code pour utiliser la constante
<code>PI</code>. Le code suivant ne donne pas d'erreur ou d'avertissement avec ClippyÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;l'aire du cercle vaut {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
For more information on Clippy, see [its documentation][clippy].
-->
<p>Pour en savoir plus Clippy, voyez <a href="https://github.com/rust-lang/rust-clippy">sa documentation</a>.</p>
<!--
[clippy]: https://github.com/rust-lang/rust-clippy
-->
<!--
### IDE Integration Using the Rust Language Server
-->
<h3><a class="header" href="#lintÃ©gration-aux-ide-en-utilisant-le-rust-language-server" id="lintÃ©gration-aux-ide-en-utilisant-le-rust-language-server">L'intÃ©gration aux IDE en utilisant le Rust Language Server</a></h3>
<!--
To help IDE integration, the Rust project distributes the *Rust Language
Server* (`rls`). This tool speaks the [Language Server
Protocol][lsp], which is a specification for IDEs and programming
languages to communicate with each other. Different clients can use the `rls`,
such as [the Rust plug-in for Visual Studio Code][vscode].
-->
<p>Pour aider l'intÃ©gration aux IDE, le projet Rust distribue le
<em>Rust Language Server</em> (<code>rls</code>). Cet outil suit le
<a href="http://langserver.org/">Language Server Protocol</a>, qui est une spÃ©cification entre les IDE et les
langages pour communiquer entre eux. DiffÃ©rents clients peuvent utiliser le
<code>rls</code>, comme <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">le plug-in Rust pour Visual Studio Code</a>.</p>
<!--
[lsp]: http://langserver.org/
[vscode]: https://marketplace.visualstudio.com/items?itemName=rust-lang.rust
-->
<!--
To install the `rls`, enter the following:
-->
<p>Pour installer le <code>rls</code>, saisissez ceciÂ :</p>
<!--
```console
$ rustup component add rls
```
-->
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<!--
Then install the language server support in your particular IDE; youâ€™ll gain
abilities such as autocompletion, jump to definition, and inline errors.
-->
<p>Installez ensuite le systÃ¨me du <em>language server</em> dans votre IDEÂ ; vous devriez
obtenir des capacitÃ©s supplÃ©mentaires comme l'auto-complÃ©tion, pouvoir se rendre
Ã  la dÃ©finition de l'Ã©lÃ©ment, et la mise en valeur d'erreurs sur la ligne
concernÃ©e.</p>
<!--
For more information on the `rls`, see [its documentation][rls].
-->
<p>Pour plus d'information sur <code>rls</code>, rendez-vous <a href="https://github.com/rust-lang/rls">Ã  sa documentation</a>.</p>
<!--
[rls]: https://github.com/rust-lang/rls
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--59" id="-attention-peinture-fraÃ®che--59">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/226">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix E - Editions
-->
<h2><a class="header" href="#annexe-e---les-Ã©ditions" id="annexe-e---les-Ã©ditions">Annexe E - Les Ã©ditions</a></h2>
<!--
In Chapter 1, you saw that `cargo new` adds a bit of metadata to your
*Cargo.toml* file about an edition. This appendix talks about what that means!
-->
<p>Au chapitre 1, vous avez constatÃ© que <code>cargo new</code> ajoutait une petite mÃ©tadonnÃ©e
Ã  propos d'une Ã©dition dans votre fichier <em>Cargo.toml</em>. Cette annexe vous
explique ce que cela signifieÂ !</p>
<!--
The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, â€œWow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!â€
-->
<p>Le langage Rust et son compilateur suivent un cycle de publication de six
semaines, ce qui signifie que leurs utilisateurs suivent un flux constant de
nouvelles fonctionnalitÃ©s. Les autres langages de programmation publient moins
souvent des changements mais qui sont plus grosÂ ; Rust a fait le choix de
publier des petits changements plus frÃ©quemment. Au bout d'un certain moment,
tous ces petits changements s'accumulent. Mais de mise Ã  jour en mise Ã  jour, il
devient difficile de regarder en arriÃ¨re et de direÂ : â€œOuah, Rust a beaucoup
changÃ© entre Rust 1.10 et Rust 1.31â€.</p>
<!--
Every two or three years, the Rust team produces a new Rust *edition*. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.
-->
<p>Tous les deux ou trois ans, l'Ã©quipe Rust produit une nouvelle <em>Ã©dition</em> de
Rust. Chaque Ã©dition rassemble des fonctionnalitÃ©s qui ont convergÃ© en un
ensemble clair, avec une documentation et des outils complÃ¨tement Ã  jour. Les
nouvelles Ã©ditions sont livrÃ©es comme faisant partie du cycle habituel de
publication toutes les six semaines.</p>
<!--
Editions serve different purposes for different people:
-->
<p>Les Ã©ditions apportent diffÃ©rentes choses pour diffÃ©rentes personnesÂ :</p>
<!--
* For active Rust users, a new edition brings together incremental changes into
  an easy-to-understand package.
* For non-users, a new edition signals that some major advancements have
  landed, which might make Rust worth another look.
* For those developing Rust, a new edition provides a rallying point for the
  project as a whole.
-->
<ul>
<li>Pour les utilisateurs actifs de Rust, une nouvelle Ã©dition regroupe les
diffÃ©rents changements progressifs dans un ensemble clair.</li>
<li>Pour ceux qui n'utilisent pas Rust, une nouvelle Ã©dition signale la livraison
d'avancÃ©es majeures, qui pourrait Ãªtre le signal que Rust mÃ©riterait un
nouveau coup d'Å“il.</li>
<li>Pour ceux qui dÃ©veloppent Rust, une nouvelle Ã©dition est un point de
ralliement pour l'ensemble du projet.</li>
</ul>
<!--
At the time of this writing, two Rust editions are available: Rust 2015 and
Rust 2018. This book is written using Rust 2018 edition idioms.
-->
<p>Au moment de cette Ã©criture, deux Ã©ditions de Rust sont disponiblesÂ : Rust 2015
et Rust 2018. Ce livre est Ã©crit selon les termes de l'Ã©dition Rust 2018.</p>
<!--
The `edition` key in *Cargo.toml* indicates which edition the compiler should
use for your code. If the key doesnâ€™t exist, Rust uses `2015` as the edition
value for backward compatibility reasons.
-->
<p>La clÃ© <code>edition</code> dans <em>Cargo.toml</em> indique quelle Ã©dition le compilateur doit
utiliser dans votre code. Si la clÃ© n'existe pas, Rust utilise <code>2015</code> comme
valeur de l'Ã©dition, pour des raisons de rÃ©tro-compatibilitÃ©.</p>
<!--
Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.
-->
<p>Chaque projet peut opter pour une autre Ã©dition que l'Ã©dition 2015 par dÃ©faut.
Les Ã©ditions peuvent impliquer des changements incompatibles, comme
l'introduction d'un nouveau mot-clÃ© qui rentre en conflit avec des
identificateurs (noms de variables, de fonctions, ...) utilisÃ©s dans le code.
Cependant, Ã  moins que vous ne dÃ©cidiez d'opter pour ces changements, votre code
va continuer Ã  se compiler mÃªme si vous augmentez la version du compilateur Rust
que vous utilisez.</p>
<!--
All Rust compiler versions support any edition that existed prior to that
compilerâ€™s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if youâ€™re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.
-->
<p>Toutes les versions du compilateur Rust supporte toutes les Ã©ditions qui ont
existÃ© avant la publication courante du compilateur, et ils peuvent lier
ensemble les crates de n'importe quelle Ã©dition supportÃ©e. Les changements de
chaque Ã©dition changent uniquement la faÃ§on dont le compilateur interprÃ¨te
initialement le code. Par consÃ©quent, si vous utilisez Rust 2015 et qu'une de
vos dÃ©pendances utilise Rust 2018, votre programme va se compiler et Ãªtre
capable d'utiliser cette dÃ©pendance. La situation inverse, dans laquelle votre
projet utilise Rust 2018 et qu'une dÃ©pendance utilise Rust 2015, va aussi
fonctionner.</p>
<!--
To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.
-->
<p>En clairÂ : la plupart des fonctionnalitÃ©s seront disponibles sur toutes les
versions. Les dÃ©veloppeurs qui utilisent n'importe quelle Ã©dition de Rust vont
continuer Ã  constater des amÃ©liorations au fur et Ã  mesure que des nouvelles
Ã©ditions stables sont publiÃ©es. Cependant, dans certains cas, principalement
lorsque des nouveaux mot-clÃ©s serons rajoutÃ©s, certaines nouvelles
fonctionnalitÃ©s ne seront disponibles que dans les nouvelles Ã©ditions. Vous
aurez alors besoin de changer d'Ã©dition si vous souhaitez profiter des avantages
de ces fonctionnalitÃ©s.</p>
<!--
For more details, the [*Edition
Guide*](https://doc.rust-lang.org/stable/edition-guide/) is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via `cargo fix`.
-->
<p>Pour en savoir plus, le
<a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> est un livre
complet sur les Ã©ditions, qui Ã©numÃ¨re les diffÃ©rences entre les Ã©ditions et qui
explique comment mettre Ã  jour automatiquement votre code vers une nouvelle
Ã©dition via <code>cargo fix</code>.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--60" id="-attention-peinture-fraÃ®che--60">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/227">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix F: Translations of the Book
-->
<h2><a class="header" href="#annexe-f--les-traductions-de-ce-livre" id="annexe-f--les-traductions-de-ce-livre">Annexe FÂ : les traductions de ce livre</a></h2>
<!--
For resources in languages other than English. Most are still in progress; see
[the Translations label][label] to help or let us know about a new translation!
-->
<p>Voici des ressources dans d'autres langages qu'en FranÃ§ais. Certaines sont
toujours en cours de constructionÂ ; consultez <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">le drapeau Translation</a>
pour les aider, ou nous informer de la crÃ©ation d'une nouvelle traductionÂ !</p>
<!--
[label]: https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations
-->
<!--
- [PortuguÃªs](https://github.com/rust-br/rust-book-pt-br) (BR)
- [PortuguÃªs](https://github.com/nunojesus/rust-book-pt-pt) (PT)
- [ç®€ä½“ä¸­æ–‡](https://github.com/KaiserY/trpl-zh-cn)
- [Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°](https://github.com/pavloslav/rust-book-uk-ua)
- [EspaÃ±ol](https://github.com/thecodix/book), [alternate](https://github.com/ManRR/rust-book-es)
- [Italiano](https://github.com/AgeOfWar/rust-book-it)
- [Ğ ÑƒÑÑĞºĞ¸Ğ¹](https://github.com/ruRust/rust_book_2ed)
- [í•œêµ­ì–´](https://github.com/rinthel/rust-lang-book-ko)
- [æ—¥æœ¬èª](https://github.com/rust-lang-ja/book-ja)
- [FranÃ§ais](https://github.com/Jimskapt/rust-book-fr)
- [Polski](https://github.com/paytchoo/book-pl)
- [×¢×‘×¨×™×ª](https://github.com/idanmel/rust-book-heb)
- [Cebuano](https://github.com/agentzero1/book)
- [Tagalog](https://github.com/josephace135/book)
- [Esperanto](https://github.com/psychoslave/Rust-libro)
- [ÎµÎ»Î»Î·Î½Î¹ÎºÎ®](https://github.com/TChatzigiannakis/rust-book-greek)
- [Svenska](https://github.com/sebras/book)
- [Farsi](https://github.com/pomokhtari/rust-book-fa)
- [Deutsch](https://github.com/rust-lang-de/rustbook-de)
-->
<ul>
<li><a href="https://github.com/rust-lang/book">English</a></li>
<li><a href="https://github.com/rust-br/rust-book-pt-br">PortuguÃªs</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">PortuguÃªs</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">ç®€ä½“ä¸­æ–‡</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°</a></li>
<li><a href="https://github.com/thecodix/book">EspaÃ±ol</a>, <a href="https://github.com/ManRR/rust-book-es">alternative</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/ruRust/rust_book_2ed">Ğ ÑƒÑÑĞºĞ¸Ğ¹</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">í•œêµ­ì–´</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">æ—¥æœ¬èª</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">×¢×‘×¨×™×ª</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ÎµÎ»Î»Î·Î½Î¹ÎºÎ®</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
</ul>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--61" id="-attention-peinture-fraÃ®che--61">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/228">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix G - How Rust is Made and â€œNightly Rustâ€
-->
<h2><a class="header" href="#annexe-g---comment-rust-est-construit-et-nightly-rust" id="annexe-g---comment-rust-est-construit-et-nightly-rust">Annexe G - Comment Rust est construit, et â€œNightly Rustâ€</a></h2>
<!--
This appendix is about how Rust is made and how that affects you as a Rust
developer.
-->
<p>Cette annexe va expliquer comment Rust est construit et comment cela vous
impacte en tant que dÃ©veloppeur Rust.</p>
<!--
### Stability Without Stagnation
-->
<h3><a class="header" href="#la-stabilitÃ©-sans-stagnation" id="la-stabilitÃ©-sans-stagnation">La stabilitÃ© sans stagnation</a></h3>
<!--
As a language, Rust cares a *lot* about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we canâ€™t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.
-->
<p>En tant que langage, Rust se soucie <em>beaucoup</em> de la stabilitÃ© de votre code.
Nous voulons que Rust soit une solide fondation sur laquelle vous pouvez
construire, et si les choses changent constamment, cela serait impossible. En
mÃªme temps, si nous ne pouvions pas expÃ©rimenter de nouvelles fonctionnalitÃ©s,
nous ne pourrions pas dÃ©couvrir les dÃ©fauts importants avant leur publication,
ce qui serait trop tard pour changer les choses.</p>
<!--
Our solution to this problem is what we call â€œstability without stagnationâ€,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.
-->
<p>Notre solution Ã  ce problÃ¨me est ce que nous appelons la â€œstabilitÃ© sans
stagnationâ€, et notre ligne directrice est la suivanteÂ : vous ne devriez jamais
craindre de passer Ã  nouvelle version de Rust stable. Chaque mise Ã  jour devrait
Ãªtre facile, et devrait aussi vous apporter de nouvelles fonctionnalitÃ©s, moins
de bogues et un temps de compilation plus rapide.</p>
<!--
### Choo, Choo! Release Channels and Riding the Trains
-->
<h3><a class="header" href="#les-canaux-de-diffusion-et-sauter-dans-le-train" id="les-canaux-de-diffusion-et-sauter-dans-le-train">Les canaux de diffusion et sauter dans le train</a></h3>
<!--
Rust development operates on a *train schedule*. That is, all development is
done on the `master` branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three *release channels* for Rust:
-->
<p>Le dÃ©veloppement de Rust suit un <em>planning ferroviaire</em>. Ce que cela veut dire,
c'est que tout le dÃ©veloppement est fait sur la branche <code>master</code> du dÃ©pÃ´t de
Rust. Les publications suivent le modÃ¨le de trains de publication de programmes,
qui a Ã©tÃ© popularisÃ© par Cisco IOS et d'autres projets logiciels. Il y a trois
<em>canaux de diffusion</em> pour RustÂ :</p>
<!--
* Nightly
* Beta
* Stable
-->
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<!--
Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.
-->
<p>La plupart des dÃ©veloppeurs Rust utilisent principalement le canal stable, mais
ceux qui souhaitent essayer les nouvelles fonctionnalitÃ©s expÃ©rimentales
utilisent nightly ou beta.</p>
<!--
Hereâ€™s an example of how the development and release process works: letâ€™s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the `master`
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:
-->
<p>Voici un exemple du fonctionnement du processus de dÃ©veloppement et de
publicationÂ : supposons que l'Ã©quipe de Rust travaille sur la publication de
Rust 1.5. Cette publication a Ã©tÃ© faite en dÃ©cembre 2015, et nous permet de nous
appuyer sur des numÃ©ros de version rÃ©alistes. Une nouvelle fonctionnalitÃ© a Ã©tÃ©
ajoutÃ©e Ã  RustÂ : un nouveau commit est arrivÃ© sur la branche <code>master</code>. Chaque
nuit, une nouvelle version nightly de Rust est produite. Chaque jour voit une
nouvelle publication, et ces publications sont crÃ©Ã©es automatiquement par
l'infrastructure de publication. Ainsi, les publications ressemblent Ã  ceci, une
fois par nuitÂ :</p>
<!--
```text
nightly: * - - * - - *
```
-->
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<!--
Every six weeks, itâ€™s time to prepare a new release! The `beta` branch of the
Rust repository branches off from the `master` branch used by nightly. Now,
there are two releases:
-->
<p>Tous les six semaines, c'est le moment de prÃ©parer une nouvelle publicationÂ ! La
branche <code>beta</code> du dÃ©pÃ´t Rust est alors dÃ©rivÃ©e de la branche <code>master</code> utilisÃ©e
par nightly. Ainsi, il y a deux canaux de publicationsÂ :</p>
<!--
```text
nightly: * - - * - - *
                     |
beta:                *
```
-->
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
thereâ€™s still a nightly release every night:
-->
<p>La plupart des utilisateurs Rust n'utilisent pas activement les publications en
beta, mais les tests en beta sur leur systÃ¨me d'IntÃ©gration Continue aident Ã 
dÃ©couvrir des potentielles rÃ©gressions. Pendant ce temps, il continue Ã  avoir
une publication nightly chaque nuitÂ :</p>
<!--
```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Letâ€™s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to `master`, so that nightly is fixed, and then the fix is backported to the
`beta` branch, and a new release of beta is produced:
-->
<p>Imaginons qu'une rÃ©gression soit trouvÃ©e. C'est alors une bonne chose que nous
ayons du temps pour tester la publication beta avant que la rÃ©gression se
retrouve dans une publication stableÂ ! La correction est alors appliquÃ©e sur
<code>master</code>, ainsi nightly est corrigÃ©, et ensuite la correction est reportÃ©e sur
la branche <code>beta</code>, et une nouvelle publication de beta est produiteÂ :</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<!--
Six weeks after the first beta was created, itâ€™s time for a stable release! The
`stable` branch is produced from the `beta` branch:
-->
<p>Six semaines aprÃ¨s que la premiÃ¨re beta soit crÃ©Ã©e, c'est le moment de publier
une version stableÂ ! La branche <code>stable</code> est produite Ã  partir de la branche
<code>beta</code>Â :</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<!--
Hooray! Rust 1.5 is done! However, weâ€™ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the *next* version of Rust, 1.6.
So after `stable` branches off of `beta`, the next version of `beta` branches
off of `nightly` again:
-->
<p>YoupiÂ ! Rust 1.5 est sortiÂ ! Cependant, nous avons oubliÃ© quelque choseÂ : comme
les six semaines sont passÃ©es, nous devons aussi publier une nouvelle beta de la
version <em>suivante</em> de Rust, la 1.6. Donc aprÃ¨s que la branche <code>stable</code> soit
dÃ©rivÃ©e de la <code>beta</code>, la prochaine version de la branche <code>beta</code> doit Ã  nouveau
Ãªtre dÃ©rivÃ©e de nightlyÂ :</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<!--
This is called the â€œtrain modelâ€ because every six weeks, a release â€œleaves the
stationâ€, but still has to take a journey through the beta channel before it
arrives as a stable release.
-->
<p>C'est appelÃ© le â€œmodÃ¨le ferroviaireâ€ car toutes les six semaines, une nouvelle
publication â€œquitte la gareâ€, mais doit encore voyager dans la voie de la
beta avant d'arriver en gare de la publication stable.</p>
<!--
Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: itâ€™s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, thereâ€™s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.
-->
<p>Rust publie rÃ©guliÃ¨rement toutes les six semaines, rÃ©glÃ©e comme une montre. Si
vous savez la date d'une publication Rust, vous savez la date de la suivanteÂ :
elle aura toujours lieu six semaines plus tard. Un des avantages d'avoir des
publications planifiÃ©es toutes les six semaines est que le train suivant arrive
rapidement aprÃ¨s. Si une fonctionnalitÃ© n'est pas intÃ©grÃ©e Ã  une publication, il
n'y a pas Ã  s'inquiÃ©terÂ : une autre arrive bientÃ´tÂ ! Cela aide Ã  rÃ©duire la
pression pour faire passer en toute discrÃ©tion des fonctionnalitÃ©s
Ã©ventuellement inachevÃ©es Ã  l'approche de la date limite de diffusion.</p>
<!--
Thanks to this process, you can always check out the next build of Rust and
verify for yourself that itâ€™s easy to upgrade to: if a beta release doesnâ€™t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
`rustc` is still a piece of software, and bugs do exist.
-->
<p>GrÃ¢ce Ã  ce processus, vous pouvez toujours dÃ©couvrir la prochaine compilation de
Rust et constater par vous-mÃªme qu'il est facile de mettre Ã  jourÂ : si une
publication en beta ne fonctionne pas comme prÃ©vu, vous pouvez signaler cela Ã 
l'Ã©quipe et cela sera corrigÃ© avant que la prochaine publication stable soit
produiteÂ ! La dÃ©gradation d'une version bÃªta est plutÃ´t rare, mais <code>rustc</code> reste
un logiciel, et les bogues peuvent exister malgrÃ© tout.</p>
<!--
### Unstable Features
-->
<h3><a class="header" href="#les-fonctionnalitÃ©s-instables" id="les-fonctionnalitÃ©s-instables">Les fonctionnalitÃ©s instables</a></h3>
<!--
Thereâ€™s one more catch with this release model: unstable features. Rust uses a
technique called â€œfeature flagsâ€ to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
`master`, and therefore, in nightly, but behind a *feature flag*. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.
-->
<p>Il reste une surprise avec ce modÃ¨le de publicationÂ : les fonctionnalitÃ©s
instables. Rust utilise une technique qui s'appelle les â€œdrapeaux de
fonctionnalitÃ©sâ€ pour dÃ©terminer quelles fonctionnalitÃ©s sont activÃ©es dans une
publication donnÃ©e. Si une nouvelle fonctionnalitÃ© est en dÃ©veloppement actif,
elle va atterrir sur <code>master</code>, et ainsi, dans nightly, mais derriÃ¨re un <em>drapeau
de fonctionnalitÃ©s</em>. Si vous, en tant qu'utilisateur, souhaitez essayer la
fonctionnalitÃ© en cours de dÃ©veloppement, vous pouvez, mais vous devez utiliser
une publication nightly de Rust et annoter votre code source avec le drapeau
appropriÃ© pour l'activer.</p>
<!--
If youâ€™re using a beta or stable release of Rust, you canâ€™t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code wonâ€™t break. Stability without stagnation.
-->
<p>Si vous utilisez une publication beta ou stable de Rust, vous ne pouvez pas
utiliser de drapeaux de fonctionnalitÃ©s. C'est la clÃ© qui permet d'obtenir une
utilisation pratique avec les nouvelles fonctionnalitÃ©s avant que nous les
dÃ©clarions stables pour toujours. Ceux qui souhaitent activer ces
fonctionnalitÃ©s expÃ©rimentales peuvent le faire, et ceux qui souhaitent avoir
une expÃ©rience plus solide peuvent s'en tenir au canal stable et leur code ne
sera pas cassÃ©. C'est la stabilitÃ© sans stagnation.</p>
<!--
This book only contains information about stable features, as in-progress
features are still changing, and surely theyâ€™ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.
-->
<p>Ce livre contient uniquement des informations sur des fonctionnalitÃ©s stables,
car les fonctionnalitÃ©s en cours de dÃ©veloppement sont toujours en train de
changer, et elles seront sÃ»rement diffÃ©rentes entre le moment oÃ¹ ce livre sera
Ã©crit et lorsqu'elles seront activÃ©es dans les compilations stables. Vous pouvez
trouver la documentation pour les fonctionnalitÃ©s uniquement pour nightly en
ligne.</p>
<!--
### Rustup and the Role of Rust Nightly
-->
<h3><a class="header" href="#rustup-et-le-role-de-rust-nightly" id="rustup-et-le-role-de-rust-nightly">Rustup et le role de Rust nightly</a></h3>
<!--
Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, youâ€™ll have stable Rust installed. To
install nightly, for example:
-->
<p>Rustup facilite les changements entre les diffÃ©rents canaux de publication de
Rust, de maniÃ¨re globale ou par projet. Par dÃ©faut, vous avez Rust stable
d'installÃ©. Pour installer nightly, vous pouvez saisir, par exempleÂ :</p>
<!--
```console
$ rustup toolchain install nightly
```
-->
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<!--
You can see all of the *toolchains* (releases of Rust and associated
components) you have installed with `rustup` as well. Hereâ€™s an example on one
of your authorsâ€™ Windows computer:
-->
<p>Vous pouvez aussi voir avec <code>rustup</code> toutes les <em>toolchains</em> (les publications
de Rust et leurs composants associÃ©s) que vous avez d'installÃ©es. Voici un
exemple d'un ordinateur sous Windows d'un des auteurs du livreÂ :</p>
<!--
```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```
-->
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<!--
As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use `rustup override` in that projectâ€™s directory to set the
nightly toolchain as the one `rustup` should use when youâ€™re in that directory:
-->
<p>Comme vous pouvez le constater, la toolchain stable est celle par dÃ©faut. La
plupart des utilisateurs Rust utilisent celle qui est stable la plupart du
temps. Il est possible que vous souhaitiez utiliser celle qui est stable la
plupart du temps, mais que vous souhaitiez utiliser nightly sur un projet
particulier, car parce que vous vous intÃ©ressez Ã  une fonctionnalitÃ©
expÃ©rimentale. Pour pouvoir faire cela, vous pouvez utiliser <code>rustup override</code>
dans le dossier de ce projet pour rÃ©gler <code>rustup</code> pour qu'il utilise la
toolchain nightly lorsque vous vous trouvez dans ce dossierÂ :</p>
<!--
```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```
-->
<pre><code class="language-console">$ cd ~/projets/necessite-nightly
$ rustup override set nightly
</code></pre>
<!--
Now, every time you call `rustc` or `cargo` inside of
*~/projects/needs-nightly*, `rustup` will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!
-->
<p>Maintenant, Ã  chaque fois que vous faites appel Ã  <code>rustc</code> ou <code>cargo</code> Ã 
l'intÃ©rieur de <em>~/projets/necessite-nightly</em>, <code>rustup</code> va s'assurer que vous
utilisez Rust nightly, plutÃ´t que votre Rust stable par dÃ©faut. C'est trÃ¨s utile
lorsque vous avez beaucoup de projets RustÂ !</p>
<!--
### The RFC Process and Teams
-->
<h3><a class="header" href="#le-processus-de-rfc-et-les-Ã©quipes" id="le-processus-de-rfc-et-les-Ã©quipes">Le processus de RFC et les Ã©quipes</a></h3>
<!--
So how do you learn about these new features? Rustâ€™s development model follows
a *Request For Comments (RFC) process*. If youâ€™d like an improvement in Rust,
you can write up a proposal, called an RFC.
-->
<p>Donc, comment en apprendre plus ces nouvelles fonctionnalitÃ©sÂ ? Le modÃ¨le de
dÃ©veloppement de Rust suit le <em>processus de Request For Comments (RFC)</em>. Si vous
souhaitez avoir une amÃ©lioration de Rust, vous pouvez rÃ©diger une proposition,
qu'on appelle une RFC.</p>
<!--
Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. Thereâ€™s
a full list of the teams [on Rustâ€™s
website](https://www.rust-lang.org/governance), which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
thereâ€™s consensus to accept or reject the feature.
-->
<p>N'importe qui peut Ã©crire de RFC pour amÃ©liorer Rust, et les propositions sont
examinÃ©es et dÃ©battues par l'Ã©quipe de Rust, qui est composÃ©e de nombreuses
sous-Ã©quipes spÃ©cialisÃ©es dans diffÃ©rents domaines. Voici une liste complÃ¨te des
Ã©quipes <a href="https://www.rust-lang.org/governance">sur le site web de Rust</a>, qui
comprend des Ã©quipes pour chaque aspect du projetÂ : la conception du langage,
l'implÃ©mentation du compilateur, de l'infrastructure, de la documentation, et
plus encore. L'Ã©quipe appropriÃ©e lit la proposition et les commentaires, Ã©crit
quelques commentaires la concernant, et finalement, un consensus se crÃ©e pour
accepter ou rejeter la fonctionnalitÃ©.</p>
<!--
If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the `master` branch behind a feature gate, as we discussed
in the [â€œUnstable Featuresâ€](#unstable-features)<!-- ignore -- > section.
-->
<p>Si la fonctionnalitÃ© est acceptÃ©e, un ticket est ouvert sur le dÃ©pÃ´t de Rust, et
quelqu'un peut l'implÃ©menter. La personne qui l'implÃ©mente ne peut pas Ãªtre
celle qui a proposÃ© la fonctionnalitÃ©Â ! Lorsque l'implÃ©mentation est prÃªte, elle
atterrit sur la branche <code>master</code> derriÃ¨re un drapeau de fonctionnalitÃ©, comme
nous l'avons vu dans la section <a href="appendix-07-nightly-rust.html#les-fonctionnalit%C3%A9s-instables">â€œLes fonctionnalitÃ©s
instablesâ€</a><!-- ignore -->.</p>
<!--
After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how itâ€™s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.
-->
<p>Au bout d'un moment, une fois que les dÃ©veloppeurs Rust qui utilisent les
publications nightly ont pu tester la nouvelle fonctionnalitÃ©, les membres de
l'Ã©quipe vont discuter de la fonctionnalitÃ©, de voir comment elle a
fonctionnÃ© sur nightly, et vont dÃ©cider si elle doit Ãªtre publiÃ©e sur Rust
stable ou non. Si la dÃ©cision est d'avancer, le drapeau de fonctionnalitÃ© est
enlevÃ©, et la fonctionnalitÃ© est maintenant considÃ©rÃ©e comme stableÂ ! Elle saute
alors dans le train en direction d'une nouvelle publication stable de Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
