<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stocker du texte encodÃ© en UTF-8 avec les Strings - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html" class="active"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Storing UTF-8 Encoded Text with Strings
-->
<h2><a class="header" href="#stocker-du-texte-encodÃ©-en-utf-8-avec-les-strings" id="stocker-du-texte-encodÃ©-en-utf-8-avec-les-strings">Stocker du texte encodÃ© en UTF-8 avec les Strings</a></h2>
<!--
We talked about strings in Chapter 4, but weâ€™ll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rustâ€™s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when youâ€™re
coming from other programming languages.
-->
<p>Nous avons dÃ©jÃ  parlÃ© des chaÃ®nes de caractÃ¨res dans le chapitre 4, mais nous
allons Ã  prÃ©sent les analyser plus en dÃ©tail. Les nouveaux RustacÃ©s bloquent
souvent avec les chaÃ®nes de caractÃ¨res pour trois raisonsÂ : la tendance de Rust
Ã  prÃ©venir les erreurs, le fait que les chaÃ®nes de caractÃ¨res sont des structures de
donnÃ©es plus compliquÃ©es que ne le pensent la plupart des dÃ©veloppeurs, et
l'UTF-8. Ces raisons cumulÃ©es rendent les choses compliquÃ©es lorsque vous
venez d'un autre langage de programmation.</p>
<!--
Itâ€™s useful to discuss strings in the context of collections because strings
are implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, weâ€™ll
talk about the operations on `String` that every collection type has, such as
creating, updating, and reading. Weâ€™ll also discuss the ways in which `String`
is different from the other collections, namely how indexing into a `String` is
complicated by the differences between how people and computers interpret
`String` data.
-->
<p>Il est pertinent de prÃ©senter les chaÃ®nes de caractÃ¨res comme des collections
car les chaÃ®nes de caractÃ¨res sont en rÃ©alitÃ© des ensembles d'octets, avec
quelques mÃ©thodes supplÃ©mentaires qui sont utiles lorsque ces octets sont
considÃ©rÃ©s comme du texte. Dans cette section, nous allons voir les points
communs entre le fonctionnement des <code>String</code> et celui des autres collections,
comme la crÃ©ation, la modification, et la lecture. Nous verrons les raisons pour
lesquelles les <code>String</code> sont diffÃ©rents des autres collections, en particulier
pourquoi l'indexation d'un <code>String</code> est compliquÃ©e Ã  cause de la faÃ§on dont les
gens et les ordinateurs interprÃ¨tent les donnÃ©es d'une <code>String</code>.</p>
<!--
### What Is a String?
-->
<h3><a class="header" href="#quest-ce-quune-chaÃ®ne-de-caractÃ¨res-" id="quest-ce-quune-chaÃ®ne-de-caractÃ¨res-">Qu'est-ce qu'une chaÃ®ne de caractÃ¨resÂ ?</a></h3>
<!--
Weâ€™ll first define what we mean by the term *string*. Rust has only one string
type in the core language, which is the string slice `str` that is usually seen
in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the programâ€™s binary and are therefore
string slices.
-->
<p>Nous allons d'abord dÃ©finir ce que nous entendons par le terme <em>chaÃ®ne de
caractÃ¨res</em>. Rust a un seul type de chaÃ®nes de caractÃ¨res dans le noyau du
langage, qui est la slice de chaÃ®ne de caractÃ¨res <code>str</code> qui est habituellement
utilisÃ©e sous sa forme empruntÃ©e, <code>&amp;str</code>. Dans le chapitre 4, nous avons abordÃ©
les <em>slices de chaÃ®ne de caractÃ¨res</em>, qui sont des rÃ©fÃ©rences Ã  une partie des
donnÃ©es d'une chaÃ®ne de caractÃ¨res encodÃ©e en UTF-8 qui sont stockÃ©s autre part.
Les chaÃ®nes de caractÃ¨res pures, par exemple, sont stockÃ©es dans le binaire du
programme et sont des slices de chaÃ®nes de caractÃ¨res.</p>
<!--
The `String` type, which is provided by Rustâ€™s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to â€œstringsâ€ in Rust, they usually mean the
`String` and the string slice `&str` types, not just one of those types.
Although this section is largely about `String`, both types are used heavily in
Rustâ€™s standard library, and both `String` and string slices are UTF-8 encoded.
-->
<p>Le type <code>String</code>, qui est fourni par la bibliothÃ¨que standard de Rust plutÃ´t que
d'Ãªtre intÃ©grÃ© au noyau du langage, est un type de chaÃ®ne de caractÃ¨res encodÃ©
en UTF-8 qui peut s'agrandir, Ãªtre mutable, et Ãªtre possÃ©dÃ©. Lorsque les
RustacÃ©s parlent de â€œchaÃ®nes de caractÃ¨resâ€ en Rust, cela dÃ©signe le type
<code>String</code> mais aussi le type de slice de chaÃ®nes de caractÃ¨res <code>&amp;str</code>, et non pas
un seul de ces types. Bien que cette section traite essentiellement de <code>String</code>,
ces deux types sont utilisÃ©s massivement dans la bibliothÃ¨que standard de Rust,
et tous les deux sont encodÃ©s en UTF-8.</p>
<!--
Rustâ€™s standard library also includes a number of other string types, such as
`OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even
more options for storing string data. See how those names all end in `String`
or `Str`? They refer to owned and borrowed variants, just like the `String` and
`str` types youâ€™ve seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We wonâ€™t discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.
-->
<p>La bibliothÃ¨que standard de Rust apporte aussi un certain nombre d'autres types
de chaÃ®nes de caractÃ¨res, comme <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, et <code>CStr</code>. Les
crates de bibliothÃ¨que peuvent fournir encore plus de solutions pour stocker des
chaÃ®nes de caractÃ¨res. Avez vous remarquÃ© que ces noms finissent tous par <code>String</code>
ou <code>Str</code>Â ? Cela fait rÃ©fÃ©rence aux variantes possÃ©dÃ©es et empruntÃ©es, comme les
types <code>String</code> et <code>str</code> que nous avons vu prÃ©cÃ©demment. Ces types de chaÃ®nes de
caractÃ¨res peuvent stocker leur texte dans de diffÃ©rents encodages, ou le
stocker en mÃ©moire de maniÃ¨re diffÃ©rente, par exemple. Nous n'allons pas traiter
ces autres types de chaÃ®nes de caractÃ¨res dans ce chapitreÂ ; rÃ©fÃ©rez-vous Ã 
la documentation de leur API pour en savoir plus sur leur utilisation et leur utilitÃ©.</p>
<!--
### Creating a New String
-->
<h3><a class="header" href="#crÃ©er-une-nouvelle-string" id="crÃ©er-une-nouvelle-string">CrÃ©er une nouvelle String</a></h3>
<!--
Many of the same operations available with `Vec<T>` are available with `String`
as well, starting with the `new` function to create a string, shown in Listing
8-11.
-->
<p>De nombreuses opÃ©rations disponibles avec <code>Vec&lt;T&gt;</code> sont aussi disponibles avec
<code>String</code>, en commenÃ§ant par la fonction <code>new</code> pour crÃ©er une <code>String</code>, utilisÃ©e
dans l'encart 8-11.</p>
<!--
```rust
# fn main() {
    let mut s = String::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-11: Creating a new, empty `String`</span>
-->
<p><span class="caption">Encart 8-11Â : CrÃ©ation d'une nouvelle <code>String</code> vide</span></p>
<!--
This line creates a new empty string called `s`, which we can then load data
into. Often, weâ€™ll have some initial data that we want to start the string
with. For that, we use the `to_string` method, which is available on any type
that implements the `Display` trait, as string literals do. Listing 8-12 shows
two examples.
-->
<p>Cette ligne crÃ©Ã©e une nouvelle <code>String</code> vide qui s'appelle <code>s</code>, dans laquelle
nous pouvons ensuite y charger des donnÃ©es. Parfois, nous aurons quelques
donnÃ©es initiales que nous voudrions ajouter dans la <code>String</code>. Pour cela, nous
utilisons la mÃ©thode <code>to_string</code>, qui est disponible sur tous les types qui
implÃ©mentent le trait <code>Display</code>, comme le font les chaÃ®nes de caractÃ¨res pures.
L'encart 8-12 nous montre deux exemples.</p>
<!--
```rust
# fn main() {
    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let donnee = &quot;contenu initial&quot;;

    let s = donnee.to_string();

    // cette mÃ©thode fonctionne aussi directement sur une
    // chaÃ®ne de caractÃ¨res pureÂ :
    let s = &quot;contenu initial&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-12: Using the `to_string` method to create a
`String` from a string literal</span>
-->
<p><span class="caption">Encart 8-12Â : Utilisation de la mÃ©thode <code>to_string</code> pour
crÃ©er un <code>String</code> Ã  partir d'une chaÃ®ne de caractÃ¨res pure</span></p>
<!--
This code creates a string containing `initial contents`.
-->
<p>Ce code crÃ©e une <code>String</code> qui contient <code>contenu initial</code>.</p>
<!--
We can also use the function `String::from` to create a `String` from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses `to_string`.
-->
<p>Nous pouvons aussi utiliser la fonction <code>String::from</code> pour crÃ©er une <code>String</code>
Ã  partir d'une chaÃ®ne de caractÃ¨res pure. Le code dans l'encart 8-13 est
Ã©quivalent au code dans l'encart 8-12 qui utilisait <code>to_string</code>.</p>
<!--
```rust
# fn main() {
    let s = String::from("initial contents");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;contenu initial&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-13: Using the `String::from` function to create
a `String` from a string literal</span>
-->
<p><span class="caption">Encart 8-13Â : Utilisation de la fonction <code>String::from</code>
afin de crÃ©er une <code>String</code> Ã  partir d'une chaÃ®ne de caractÃ¨res pure</span></p>
<!--
Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, `String::from` and
`to_string` do the same thing, so which you choose is a matter of style.
-->
<p>Comme les chaÃ®nes de caractÃ¨res sont utilisÃ©es pour de nombreuses choses, nous
pouvons utiliser beaucoup d'APIs gÃ©nÃ©riques pour les chaÃ®nes de caractÃ¨res.
Certaines d'entre elles peuvent paraÃ®tre redondantes, mais elles ont toutes
leur placeÂ ! Dans notre cas, <code>String::from</code> et <code>to_string</code> font la mÃªme
chose, donc votre choix est une question de goÃ»t.</p>
<!--
Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.
-->
<p>Souvenez-vous que les chaÃ®nes de caractÃ¨res sont encodÃ©es en UTF-8, donc nous
pouvons y intÃ©grer n'importe quelle donnÃ©e valide, comme nous
le voyons dans l'encart 8-14.</p>
<!--
```rust
# fn main() {
    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
    let hello = String::from("DobrÃ½ den");
    let hello = String::from("Hello");
    let hello = String::from("×©Ö¸××œ×•Ö¹×");
    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
    let hello = String::from("ä½ å¥½");
    let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;);
    let hello = String::from(&quot;DobrÃ½ den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;×©Ö¸××œ×•Ö¹×&quot;);
    let hello = String::from(&quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;);
    let hello = String::from(&quot;ã“ã‚“ã«ã¡ã¯&quot;);
    let hello = String::from(&quot;ì•ˆë…•í•˜ì„¸ìš”&quot;);
    let hello = String::from(&quot;ä½ å¥½&quot;);
    let hello = String::from(&quot;OlÃ¡&quot;);
    let hello = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span>
-->
<p><span class="caption">Encart 8-14Â : Stockage de texte dans diffÃ©rents langages
dans des chaÃ®nes de caractÃ¨res</span></p>
<!--
All of these are valid `String` values.
-->
<p>Toutes ces chaÃ®nes sont des valeurs <code>String</code> valides.</p>
<!--
### Updating a String
-->
<h3><a class="header" href="#modifier-une-string" id="modifier-une-string">Modifier une <code>String</code></a></h3>
<!--
A `String` can grow in size and its contents can change, just like the contents
of a `Vec<T>`, if you push more data into it. In addition, you can conveniently
use the `+` operator or the `format!` macro to concatenate `String` values.
-->
<p>Une <code>String</code> peut s'agrandir et son contenu peut changer, exactement comme le
contenu d'un <code>Vec&lt;T&gt;</code>, si vous utilisez <code>push</code> pour y rajouter des donnÃ©es Ã 
l'intÃ©rieur. De plus, vous pouvez correctement utiliser l'opÃ©rateur <code>+</code> ou la
macro <code>format!</code> pour concatener des valeurs <code>String</code>.</p>
<!--
#### Appending to a String with `push_str` and `push`
-->
<h4><a class="header" href="#ajouter-du-texte-Ã -une-chaÃ®ne-avec-push_str-et-push" id="ajouter-du-texte-Ã -une-chaÃ®ne-avec-push_str-et-push">Ajouter du texte Ã  une chaÃ®ne avec <code>push_str</code> et <code>push</code></a></h4>
<!--
We can grow a `String` by using the `push_str` method to append a string slice,
as shown in Listing 8-15.
-->
<p>Nous pouvons agrandir un <code>String</code> en utilisant la mÃ©thode <code>push_str</code> pour
ajouter une slice de chaÃ®ne de caractÃ¨res, comme dans l'encart 8-15.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-15: Appending a string slice to a `String`
using the `push_str` method</span>
-->
<p><span class="caption">Encart 8-15Â : Ajout d'une slice de chaÃ®ne de caractÃ¨res
dans un <code>String</code> en utilisant la mÃ©thode <code>push_str</code></span></p>
<!--
After these two lines, `s` will contain `foobar`. The `push_str` method takes a
string slice because we donâ€™t necessarily want to take ownership of the
parameter. For example, the code in Listing 8-16 shows that it would be
unfortunate if we werenâ€™t able to use `s2` after appending its contents to `s1`.
-->
<p>A l'issue de ces deux lignes, <code>s</code> va contenir <code>foobar</code>. La mÃ©thode <code>push_str</code>
prend une slice de chaÃ®ne de caractÃ¨res car nous ne souhaitons pas forcÃ©ment
prendre possession du paramÃ¨tre. Par exemple, le code de l'encart 8-16 nous
montre une situation oÃ¹ il serait regrettable si nous ne pouvions plus utiliser
<code>s2</code> aprÃ¨s avoir ajoutÃ© son contenu dans <code>s1</code>.</p>
<!--
```rust
# fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 est {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-16: Using a string slice after appending its
contents to a `String`</span>
-->
<p><span class="caption">Encart 8-16Â : Utilisation d'une slice de chaÃ®ne de
caractÃ¨res aprÃ¨s avoir ajoutÃ© son contenu dans une <code>String</code></span></p>
<!--
If the `push_str` method took ownership of `s2`, we wouldnâ€™t be able to print
its value on the last line. However, this code works as weâ€™d expect!
-->
<p>Si la mÃ©thode <code>push_str</code> prenait possession de <code>s2</code>, Ã  la derniÃ¨re ligne, nous
ne pourrions pas afficher sa valeur. Cependant, ce code fonctionne comme nous
l'espÃ©rionsÂ !</p>
<!--
The `push` method takes a single character as a parameter and adds it to the
`String`. Listing 8-17 shows code that adds the letter *l* to a `String` using
the `push` method.
-->
<p>La mÃ©thode <code>push</code> prend un seul caractÃ¨re en paramÃ¨tre et l'ajoute au <code>String</code>.
L'encart 8-17 nous montre du code qui ajoute la lettre <em>l</em> au <code>String</code> en
utilisant la mÃ©thode <code>push</code>.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("lo");
    s.push('l');
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-17: Adding one character to a `String` value
using `push`</span>
-->
<p><span class="caption">Encart 8-17Â : Ajout d'un unique caractÃ¨re Ã  la valeur d'une
<code>String</code> en utilisant <code>push</code></span></p>
<!--
As a result of this code, `s` will contain `lol`.
-->
<p>AprÃ¨s exÃ©cution de ce code, <code>s</code> contiendra <code>lol</code>.</p>
<!--
#### Concatenation with the `+` Operator or the `format!` Macro
-->
<h4><a class="header" href="#concatÃ©nation-avec-lopÃ©rateur--ou-la-macro-format" id="concatÃ©nation-avec-lopÃ©rateur--ou-la-macro-format">ConcatÃ©nation avec l'opÃ©rateur <code>+</code> ou la macro <code>format!</code></a></h4>
<!--
Often, youâ€™ll want to combine two existing strings. One way is to use the `+`
operator, as shown in Listing 8-18.
-->
<p>Parfois, vous aurez besoin de combiner deux chaÃ®nes de caractÃ¨res existantes.
Une faÃ§on de faire cela est d'utiliser l'opÃ©rateur <code>+</code>, comme dans l'encart
8-18.</p>
<!--
```rust
# fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // notez que s1 a Ã©tÃ© dÃ©placÃ© ici
                       // et ne pourra plus Ãªtre utilisÃ©
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-18: Using the `+` operator to combine two
`String` values into a new `String` value</span>
-->
<p><span class="caption">Encart 8-18Â : Utilisation de l'opÃ©rateur <code>+</code> pour
combiner deux valeurs de <code>String</code></span></p>
<!--
The string `s3` will contain `Hello, world!` as a result of this code. The
reason `s1` is no longer valid after the addition and the reason we used a
reference to `s2` has to do with the signature of the method that gets called
when we use the `+` operator. The `+` operator uses the `add` method, whose
signature looks something like this:
-->
<p>La chaÃ®ne de caractÃ¨res <code>s3</code> va contenir <code>Hello, world!</code> Ã  l'issue de
l'exÃ©cution de ce code. La raison pour laquelle <code>s1</code> n'est plus utilisable aprÃ¨s
avoir Ã©tÃ© ajoutÃ© et la raison pour laquelle nous utilisons une rÃ©fÃ©rence vers
<code>s2</code> s'expliquent par la signature de la mÃ©thode qui est appelÃ©e lorsque nous
utilisons l'opÃ©rateur <code>+</code>. L'opÃ©rateur <code>+</code> utilise la mÃ©thode <code>add</code>, dont la
signature ressemble Ã  ceciÂ :</p>
<!--
```rust,ignore
fn add(self, s: &str) -> String {
```
-->
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!--
This isnâ€™t the exact signature thatâ€™s in the standard library: in the standard
library, `add` is defined using generics. Here, weâ€™re looking at the signature
of `add` with concrete types substituted for the generic ones, which is what
happens when we call this method with `String` values. Weâ€™ll discuss generics
in Chapter 10. This signature gives us the clues we need to understand the
tricky bits of the `+` operator.
-->
<p>Ce n'est pas exactement la mÃªme signature que celle de la bibliothÃ¨que
standardÂ : dans la bibliothÃ¨que standard, <code>add</code> est dÃ©fini avec des types
gÃ©nÃ©riques. Ici, nous voyons la signature de <code>add</code> avec des types concrets Ã  la
place des gÃ©nÃ©riques, ce qui se passe lorsque nous utilisons cette mÃ©thode avec
des valeurs de type <code>String</code>. Nous verrons les gÃ©nÃ©riques au chapitre 10. Cette
signature nous donne les Ã©lÃ©ments dont nous avons besoin pour comprendre les
subtilitÃ©s de l'opÃ©rateur <code>+</code>.</p>
<!--
First, `s2` has an `&`, meaning that weâ€™re adding a *reference* of the second
string to the first string because of the `s` parameter in the `add` function:
we can only add a `&str` to a `String`; we canâ€™t add two `String` values
together. But waitâ€”the type of `&s2` is `&String`, not `&str`, as specified in
the second parameter to `add`. So why does Listing 8-18 compile?
-->
<p>PremiÃ¨rement, <code>s2</code> a un <code>&amp;</code>, ce qui veut dire que nous ajoutons une <em>rÃ©fÃ©rence</em>
vers la seconde chaÃ®ne de caractÃ¨res en raison du paramÃ¨tre <code>s</code> dans la fonction
<code>add</code>Â : nous pouvons seulement ajouter une <code>&amp;str</code> Ã  une <code>String</code>Â ; nous ne
pouvons pas ajouter deux valeurs de type <code>String</code> ensemble. Mais attendez â€” le
type de <code>&amp;s2</code> est <code>&amp;String</code>, et non pas <code>&amp;str</code>, comme c'est Ã©crit dans le second
paramÃ¨tre de <code>add</code>. Donc pourquoi est-ce que le code l'encart 8-18 se compileÂ ?</p>
<!--
The reason weâ€™re able to use `&s2` in the call to `add` is that the compiler
can *coerce* the `&String` argument into a `&str`. When we call the `add`
method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`.
Weâ€™ll discuss deref coercion in more depth in Chapter 15. Because `add` does
not take ownership of the `s` parameter, `s2` will still be a valid `String`
after this operation.
-->
<p>La raison pour laquelle nous pouvons utiliser <code>&amp;s2</code> dans l'appel Ã  <code>add</code> est que
le compilateur peut <em>extrapoler</em> l'argument <code>&amp;String</code> en un <code>&amp;str</code>. Lorsque
nous appelons la mÃ©thode <code>add</code>, Rust va utiliser une <em>extrapolation de
dÃ©rÃ©fÃ©rencement</em>, qui transforme ici <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Nous verrons plus en
dÃ©tails l'extrapolation de dÃ©rÃ©fÃ©rencement au chapitre 15. Comme <code>add</code> ne prend
pas possession du paramÃ¨tre <code>s</code>, <code>s2</code> sera toujours une <code>String</code> valide aprÃ¨s
cette opÃ©ration.</p>
<!--
Second, we can see in the signature that `add` takes ownership of `self`,
because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be
moved into the `add` call and no longer be valid after that. So although `let
s3 = s1 + &s2;` looks like it will copy both strings and create a new one, this
statement actually takes ownership of `s1`, appends a copy of the contents of
`s2`, and then returns ownership of the result. In other words, it looks like
itâ€™s making a lot of copies but isnâ€™t; the implementation is more efficient
than copying.
-->
<p>Ensuite, nous pouvons constater que la signature de <code>add</code> prend possession de
<code>self</code>, car <code>self</code> n'a <em>pas</em> de <code>&amp;</code>. Cela signifie que <code>s1</code> dans l'encart 8-18
va Ãªtre dÃ©placÃ© dans l'appel Ã  <code>add</code> et ne sera plus en vigueur aprÃ¨s cela. Donc
bien que <code>let s3 = s1 + &amp;s2</code> semble copier les deux chaÃ®nes de caractÃ¨res pour
en crÃ©er une nouvelle, cette instruction va en rÃ©alitÃ© prendre possession du
rÃ©sultat. Autrement dit, cela semble faire beaucoup de copies mais en rÃ©alitÃ©
nonÂ ; son implÃ©mentation est plus efficace que la copie.</p>
<!--
If we need to concatenate multiple strings, the behavior of the `+` operator
gets unwieldy:
-->
<p>Si nous avons besoin de concatÃ©ner plusieurs chaÃ®nes de caractÃ¨res, le
comportement de l'opÃ©rateur <code>+</code> devient difficile Ã  utiliserÂ :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<!--
At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"`
characters, itâ€™s difficult to see whatâ€™s going on. For more complicated string
combining, we can use the `format!` macro:
-->
<p>Au final, <code>s</code> vaudra <code>tic-tac-toe</code>. Avec tous les caractÃ¨res <code>+</code>et <code>&quot;</code>, il est
difficile de visualiser ce qu'il se passe. Pour une combinaison de chaÃ®nes de
caractÃ¨res plus complexes, nous pouvons utiliser la macro <code>format!</code>Â :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<!--
This code also sets `s` to `tic-tac-toe`. The `format!` macro works in the same
way as `println!`, but instead of printing the output to the screen, it returns
a `String` with the contents. The version of the code using `format!` is much
easier to read and doesnâ€™t take ownership of any of its parameters.
-->
<p>Ce code assigne lui aussi Ã  <code>s</code> la valeur <code>tic-tac-toe</code>. La macro <code>format!</code>
fonctionne de la mÃªme maniÃ¨re que <code>println!</code>, mais au lieu d'afficher son
rÃ©sultat Ã  l'Ã©cran, elle retourne un <code>String</code> avec son contenu. La version du
code qui utilise <code>format!</code> est plus facile Ã  lire et ne prends pas possession de
ses paramÃ¨tres.</p>
<!--
### Indexing into Strings
-->
<h3><a class="header" href="#lindexation-des-string" id="lindexation-des-string">L'indexation des <code>String</code></a></h3>
<!--
In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a `String` using indexing syntax in Rust, youâ€™ll
get an error. Consider the invalid code in Listing 8-19.
-->
<p>Dans de nombreux autres langages de programmation, l'accÃ¨s individuel aux
caractÃ¨res d'une chaÃ®ne de caractÃ¨res en utilisant leur indice est une
opÃ©ration valide et courante. Cependant, si vous essayez d'accÃ©der Ã  des
Ã©lÃ©ments d'une <code>String</code> en utilisant la syntaxe des indices avec Rust, vous
allez avoir une erreur. Nous tentons cela dans le code invalide de l'encart
8-19.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span>
-->
<p><span class="caption">Encart 8-19Â : Essai d'utilisation de la syntaxe
d'indexation avec une <code>String</code></span></p>
<!--
This code will result in the following error:
-->
<p>Ce code va produire l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 -- > src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error and the note tell the story: Rust strings donâ€™t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.
-->
<p>L'erreur et la remarque nous expliquent le problÃ¨meÂ : les <code>String</code> de Rust
n'acceptent pas l'utilisation des indices. Mais pourquoiÂ ? Pour rÃ©pondre Ã 
cette question, nous avons besoin de savoir comment Rust enregistre les chaÃ®nes
de caractÃ¨res dans la mÃ©moire.</p>
<!--
#### Internal Representation
-->
<h4><a class="header" href="#reprÃ©sentation-du-fonctionnement-interne" id="reprÃ©sentation-du-fonctionnement-interne">ReprÃ©sentation du fonctionnement interne</a></h4>
<!--
A `String` is a wrapper over a `Vec<u8>`. Letâ€™s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:
-->
<p>Une <code>String</code> est une surcouche de <code>Vec&lt;u8&gt;</code>. Revenons sur certains exemples de
chaÃ®nes de caractÃ¨res correctement encodÃ©es en UTF-8 que nous avions dans
l'encart 8-14. PremiÃ¨rement, celle-ciÂ :</p>
<!--
```rust
# fn main() {
#     let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
#     let hello = String::from("DobrÃ½ den");
#     let hello = String::from("Hello");
#     let hello = String::from("×©Ö¸××œ×•Ö¹×");
#     let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
#     let hello = String::from("ã“ã‚“ã«ã¡ã¯");
#     let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
#     let hello = String::from("ä½ å¥½");
#     let hello = String::from("OlÃ¡");
#     let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;);
</span><span class="boring">    let hello = String::from(&quot;DobrÃ½ den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;×©Ö¸××œ×•Ö¹×&quot;);
</span><span class="boring">    let hello = String::from(&quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;);
</span><span class="boring">    let hello = String::from(&quot;ã“ã‚“ã«ã¡ã¯&quot;);
</span><span class="boring">    let hello = String::from(&quot;ì•ˆë…•í•˜ì„¸ìš”&quot;);
</span><span class="boring">    let hello = String::from(&quot;ä½ å¥½&quot;);
</span><span class="boring">    let hello = String::from(&quot;OlÃ¡&quot;);
</span><span class="boring">    let hello = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
In this case, `len` will be 4, which means the vector storing the string â€œHolaâ€
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But
what about the following line? (Note that this string begins with the capital
Cyrillic letter Ze, not the Arabic number 3.)
-->
<p>Dans ce cas-ci, <code>len</code> vaudra 4, ce qui veut dire que le vecteur qui stocke la
chaÃ®ne â€œHolaâ€ a une taille de 4 octets. Chacune des lettres prends 1 octet
lorsqu'elles sont encodÃ©es en UTF-8. Mais que se passe-t-il Ã  la ligne
suivanteÂ ? (Notez que cette chaÃ®ne de caractÃ¨res commence avec la lettre
majuscule cyrillique Ze, et non pas le nombre arabe 3.)</p>
<!--
```rust
# fn main() {
#     let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
#     let hello = String::from("DobrÃ½ den");
#     let hello = String::from("Hello");
#     let hello = String::from("×©Ö¸××œ×•Ö¹×");
#     let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
#     let hello = String::from("ã“ã‚“ã«ã¡ã¯");
#     let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
#     let hello = String::from("ä½ å¥½");
#     let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
#     let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;);
</span><span class="boring">    let hello = String::from(&quot;DobrÃ½ den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;×©Ö¸××œ×•Ö¹×&quot;);
</span><span class="boring">    let hello = String::from(&quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;);
</span><span class="boring">    let hello = String::from(&quot;ã“ã‚“ã«ã¡ã¯&quot;);
</span><span class="boring">    let hello = String::from(&quot;ì•ˆë…•í•˜ì„¸ìš”&quot;);
</span><span class="boring">    let hello = String::from(&quot;ä½ å¥½&quot;);
</span><span class="boring">    let hello = String::from(&quot;OlÃ¡&quot;);
</span>    let hello = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Asked how long the string is, you might say 12. However, Rustâ€™s answer is 24:
thatâ€™s the number of bytes it takes to encode â€œĞ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€ in UTF-8, because
each Unicode scalar value in that string takes 2 bytes of storage. Therefore,
an index into the stringâ€™s bytes will not always correlate to a valid Unicode
scalar value. To demonstrate, consider this invalid Rust code:
-->
<p>Si vous vous demandez la longueur de la chaÃ®ne de caractÃ¨res, vous vous direz
probablement 12. Cependant, la rÃ©ponse de Rust sera 24Â : c'est le nombre
d'octets nÃ©cessaires pour encoder â€œĞ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€ en UTF-8, car chaque valeur
scalaire Unicode dans cette chaÃ®ne de caractÃ¨res prend 2 octets en mÃ©moire.
Par consÃ©quent, un indice dans les octets de la chaÃ®ne de caractÃ¨res ne
correspondra pas forcÃ©ment Ã  une valeur unicode valide. Pour dÃ©montrer cela,
utilisons ce code Rust invalideÂ :</p>
<!--
```rust,ignore,does_not_compile
let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
let answer = &hello[0];
```
-->
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
let answer = &amp;hello[0];
</code></pre>
<!--
What should the value of `answer` be? Should it be `Ğ—`, the first letter? When
encoded in UTF-8, the first byte of `Ğ—` is `208` and the second is `151`, so
`answer` should in fact be `208`, but `208` is not a valid character on its
own. Returning `208` is likely not what a user would want if they asked for the
first letter of this string; however, thatâ€™s the only data that Rust has at
byte index 0. Users generally donâ€™t want the byte value returned, even if the
string contains only Latin letters: if `&"hello"[0]` were valid code that
returned the byte value, it would return `104`, not `h`. To avoid returning an
unexpected value and causing bugs that might not be discovered immediately,
Rust doesnâ€™t compile this code at all and prevents misunderstandings early in
the development process.
-->
<p>Quelle sera la valeur de <code>answer</code>Â ? Est-ce que ce sera <code>Ğ—</code>, la premiÃ¨re
lettreÂ ?  Lorsqu'il est encodÃ© en UTF-8, le premier octet de <code>Ğ—</code> est <code>208</code> et
le second est <code>151</code>, donc en vÃ©ritÃ© <code>answer</code> vaudra <code>208</code>, mais <code>208</code> n'est pas
un caractÃ¨re valide Ã  lui seul. Renvoyer <code>208</code> n'est pas ce qu'un utilisateur
attend s'il demande la premiÃ¨re lettre de cette chaÃ®ne de caractÃ¨resÂ ;
cependant, c'est la seule valeur que Rust a Ã  l'indice 0 des octets. Les
utilisateurs ne souhaitent gÃ©nÃ©ralement pas obtenir la valeur en octets, mÃªme si
la chaÃ®ne de caractÃ¨res contient uniquement des lettres latinesÂ : si
<code>&amp;&quot;hello&quot;[0]</code> Ã©tait un code valide qui retournerait la valeur de l'octet, il
retournerait <code>104</code> et non pas <code>h</code>. Pour Ã©viter de retourner une valeur
inattendue et gÃ©nÃ©rer des bogues qui ne seraient pas dÃ©couverts immÃ©diatement,
Rust ne va pas compiler ce code et ainsi Ã©viter des erreurs dÃ¨s le dÃ©but du
processus de dÃ©veloppement.</p>
<!--
#### Bytes and Scalar Values and Grapheme Clusters! Oh My!
-->
<h4><a class="header" href="#les-valeurs-des-octets-et-des-scalaires-et-les-groupes-de-graphÃ¨mes-" id="les-valeurs-des-octets-et-des-scalaires-et-les-groupes-de-graphÃ¨mes-">Les valeurs des octets et des scalaires et les groupes de graphÃ¨mes !</a></h4>
<!--
Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rustâ€™s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call *letters*).
-->
<p>Un autre problÃ¨me avec l'UTF-8 est qu'il a en fait trois maniÃ¨res pertinentes
pour considÃ©rer les chaÃ®nes de caractÃ¨res avec RustÂ : comme des octets, comme
des valeurs scalaires et comme des groupes de graphÃ¨mes (la chose qui se
rapproche le plus de ce que nous pourrions appeler des <em>lettres</em>).</p>
<!--
If we look at the Hindi word â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:
-->
<p>Si l'on considÃ¨re le mot en Hindi â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ Ã©crit dans le style Devanagari, il est
stockÃ© comme un vecteur de valeurs <code>u8</code> qui sont les suivantsÂ :</p>
<!--
```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```
-->
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!--
Thatâ€™s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rustâ€™s `char` type is, those
bytes look like this:
-->
<p>Cela fait 18 octets et c'est ainsi que les ordinateurs stockeront cette donnÃ©e.
Si nous les voyons comme des valeurs scalaires Unicode, ce qu'est le type <code>char</code>
de Rust, ces octets seront les suivantsÂ :</p>
<!--
```text
['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
```
-->
<pre><code class="language-text">['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
</code></pre>
<!--
There are six `char` values here, but the fourth and sixth are not letters:
theyâ€™re diacritics that donâ€™t make sense on their own. Finally, if we look at
them as grapheme clusters, weâ€™d get what a person would call the four letters
that make up the Hindi word:
-->
<p>Nous avons six valeurs <code>char</code> ici, mais la quatriÃ¨me et sixiÃ¨me valeur ne sont
pas des lettresÂ : ce sont des signes diacritiques qui n'ont pas de sens employÃ©s seuls.
Enfin, si nous les voyons comme des groupes de graphÃ¨mes, on obtient ce qu'une
personne pourrait appeler les quatre lettres qui constituent le mot HindiÂ :</p>
<!--
```text
["à¤¨", "à¤®", "à¤¸à¥", "à¤¤à¥‡"]
```
-->
<pre><code class="language-text">[&quot;à¤¨&quot;, &quot;à¤®&quot;, &quot;à¤¸à¥&quot;, &quot;à¤¤à¥‡&quot;]
</code></pre>
<!--
Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.
-->
<p>Rust fournit diffÃ©rentes maniÃ¨res d'interprÃ©ter les donnÃ©es brutes des chaÃ®nes
de caractÃ¨res que les ordinateurs stockent afin que chaque programme puisse
choisir l'interprÃ©tation dont il a besoin, peu importe dans quel langage humain
sont les donnÃ©es.</p>
<!--
A final reason Rust doesnâ€™t allow us to index into a `String` to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isnâ€™t possible to guarantee that performance with a `String`,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.
-->
<p>Une derniÃ¨re raison pour laquelle Rust ne nous autorise pas Ã  indexer une
<code>String</code> comme caractÃ¨re est que les opÃ©rations d'indexation sont censÃ©s prendre
un temps constant (O(1)). Mais il n'est pas possible de garantir cette
performance avec une <code>String</code>, car Rust devrait parcourir le contenu depuis le
dÃ©but jusqu'Ã  l'indice pour dÃ©terminer combien il y a de caractÃ¨res valides.</p>
<!--
### Slicing Strings
-->
<h3><a class="header" href="#les-slices-de-chaÃ®nes-de-caractÃ¨res" id="les-slices-de-chaÃ®nes-de-caractÃ¨res">Les slices de chaÃ®nes de caractÃ¨res</a></h3>
<!--
Indexing into a string is often a bad idea because itâ€™s not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. Therefore, Rust asks you to
be more specific if you really need to use indices to create string slices. To
be more specific in your indexing and indicate that you want a string slice,
rather than indexing using `[]` with a single number, you can use `[]` with a
range to create a string slice containing particular bytes:
-->
<p>L'utilisation des indices sur une chaÃ®ne de caractÃ¨res est souvent une mauvaise
idÃ©e car le type de retour de l'opÃ©ration n'est pas toujours Ã©videntÂ : une
valeur en octets, en caractÃ¨res, un groupe de graphÃ¨mes, ou une slice de chaÃ®ne
de caractÃ¨res. C'est pourquoi Rust vous demande d'Ãªtre plus prÃ©cis si vous avez
vraiment besoin d'utiliser des indices pour crÃ©er un dÃ©oupage de chaÃ®ne de
caractÃ¨res. Afin d'Ãªtre plus prÃ©cis sur l'utilisation des indices et que vous
souhaitez obtenir une slice de chaine de caractÃ¨res, vous pouvez utiliser <code>[]</code>
avec une intervalle d'indices pour crÃ©er une slice de chaÃ®ne de caractÃ¨res
contenant des octets bien prÃ©cis, plutÃ´t que d'utiliser <code>[]</code> avec un seul
nombreÂ :</p>
<!--
```rust
let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";

let s = &hello[0..4];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `s` will be a `&str` that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
`s` will be `Ğ—Ğ´`.
-->
<p>Ici, <code>s</code> sera un <code>&amp;str</code> qui contiendra les 4 premiers octets de la chaine de
caractÃ¨res. PrÃ©cÃ©demment, nous avions mentionnÃ© que chacun de ces caractÃ¨res
Ã©taient encodÃ©s sur 2 octets, ce qui veut dire que <code>s</code> vaudra <code>Ğ—Ğ´</code>.</p>
<!--
What would happen if we used `&hello[0..1]`? The answer: Rust would panic at
runtime in the same way as if an invalid index were accessed in a vector:
-->
<p>Que se serait-il passÃ© si nous avions utilisÃ© <code>&amp;hello[0..1]</code>Â ? RÃ©ponseÂ : Rust
aurait paniquÃ© au moment de l'exÃ©cution de la mÃªme faÃ§on que si nous
utiliserions un indice invalide pour accÃ©der Ã  un Ã©lÃ©ment d'un vecteurÂ :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'Ğ—' (bytes 0..2) of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'Ğ—' (bytes 0..2) of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<!--
You should use ranges to create string slices with caution, because doing so
can crash your program.
-->
<p>Vous devriez utiliser les intervalles pour crÃ©er des slices avec prudence, car
cela peut provoquer un plantage de votre programme.</p>
<!--
### Methods for Iterating Over Strings
-->
<h3><a class="header" href="#les-mÃ©thodes-pour-parcourir-les-chaÃ®nes-de-caractÃ¨res" id="les-mÃ©thodes-pour-parcourir-les-chaÃ®nes-de-caractÃ¨res">Les mÃ©thodes pour parcourir les chaÃ®nes de caractÃ¨res</a></h3>
<!--
Fortunately, you can access elements in a string in other ways.
-->
<p>Heureusement, il existe d'autres maniÃ¨res d'accÃ©der aux Ã©lÃ©ments d'une chaine
de caractÃ¨res.</p>
<!--
If you need to perform operations on individual Unicode scalar values, the best
way to do so is to use the `chars` method. Calling `chars` on â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ separates
out and returns six values of type `char`, and you can iterate over the result
to access each element:
-->
<p>Si vous avez besoin de faire des opÃ©rations sur les valeurs scalaires Unicodes
une par une, la meilleure faÃ§on de procÃ©der est d'utiliser la mÃ©thode <code>chars</code>.
Utiliser <code>chars</code> sur â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ sÃ©pare et retourne six valeurs de type <code>char</code>, et
vous pouvez itÃ©rer sur le rÃ©sultat pour accÃ©der sur chaque Ã©lÃ©mentÂ :</p>
<!--
```rust
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the following:
-->
<p>Ce code va afficher ceciÂ :</p>
<!--
```text
à¤¨
à¤®
à¤¸
à¥
à¤¤
à¥‡
```
-->
<pre><code class="language-text">à¤¨
à¤®
à¤¸
à¥
à¤¤
à¥‡
</code></pre>
<!--
The `bytes` method returns each raw byte, which might be appropriate for your
domain:
-->
<p>La mÃ©thode <code>bytes</code> va retourner chaque octet brut, ce qui sera peut-Ãªtre plus
utile selon ce que vous voulez faireÂ :</p>
<!--
```rust
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
    println!("{}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the 18 bytes that make up this `String`:
-->
<p>Ce code va imprimer les 18 octets qui constituent cette <code>String</code>Â :</p>
<!--
```text
224
164
// --snip--
165
135
```
-->
<pre><code class="language-text">224
164
// -- Ã©lÃ©ments masquÃ©s ici --
165
135
</code></pre>
<!--
But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.
-->
<p>Rappelez-vous bien que des valeurs scalaires Unicode peuvent Ãªtre constituÃ©es de
plus d'un octet.</p>
<!--
Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
[crates.io](https://crates.io/) if this is the functionality you need.
-->
<p>L'obtention des groupes de graphÃ¨mes Ã  partir des chaines de caractÃ¨res est
complexe, donc cette fonctionnalitÃ© n'est pas fournie par la bibliothÃ¨que
standard. Des crates sont disponibles sur <a href="https://crates.io/">crates.io</a> si
c'est la fonctionnalitÃ© dont vous avez besoin.</p>
<!--
### Strings Are Not So Simple
-->
<h3><a class="header" href="#les-chaÃ®nes-de-caractÃ¨res-ne-sont-pas-si-simples" id="les-chaÃ®nes-de-caractÃ¨res-ne-sont-pas-si-simples">Les chaÃ®nes de caractÃ¨res ne sont pas si simples</a></h3>
<!--
To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of `String` data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.
-->
<p>Pour rÃ©sumer, les chaÃ®nes de caractÃ¨res sont complexes. De nombreux langages
de programmation ont fait diffÃ©rents choix sur la faÃ§on de prÃ©senter cette
complexitÃ© aux dÃ©veloppeurs. Rust a choisi d'appliquer par dÃ©faut la gestion
rigoureuse des donnÃ©es de <code>String</code> pour tous les programmes Rust, ce qui veut
dire que les dÃ©veloppeurs doivent rÃ©flÃ©chir davantage Ã  la gestion des donnÃ©es
UTF-8. Ce compromis rÃ©vÃ¨le davantage la complexitÃ© des chaÃ®nes de caractÃ¨res par
rapport Ã  ce que les autres langages de programmation laissent paraÃ®tre, mais vous
Ã©vite d'avoir Ã  gÃ©rer plus tard dans votre cycle de dÃ©veloppement des erreurs Ã 
cause de caractÃ¨res non ASCII.</p>
<!--
Letâ€™s switch to something a bit less complex: hash maps!
-->
<p>Changeons maintenant pour quelque chose de moins complexe : les tables de
hachageÂ !</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
