<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html" class="active"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/192">Pull Request</a>.</p>
</blockquote>
<!--
## `Rc<T>`, the Reference Counted Smart Pointer
-->
<h2 id="rct-le-pointeur-intelligent-qui-compte-les-rÃ©fÃ©rences"><a class="header" href="#rct-le-pointeur-intelligent-qui-compte-les-rÃ©fÃ©rences"><code>Rc&lt;T&gt;</code>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></h2>
<!--
In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldnâ€™t be cleaned up unless it doesnâ€™t have any
edges pointing to it.
-->
<p>Dans la majoritÃ© des cas, la possession est claireÂ : vous savez exactement
quelle variable possÃ¨de une valeur donnÃ©e. Cependant, il existe des cas oÃ¹ une
valeur puisse Ãªtre possÃ©dÃ©e par plusieurs propriÃ©taires. Par exemple, dans une
structure de donnÃ©es de courbes, plusieurs extrÃ©mitÃ©s peuvent pointer vers le
mÃªme noeud, et ce noeud est thÃ©oriquement possÃ©dÃ© par toutes les extrÃ©mitÃ©s qui
y pointent. Un noeud ne devrait pas Ãªtre nettoyÃ©, Ã  moins qu'il n'ait plus
d'extrÃ©mitÃ©s qui pointent sur lui.</p>
<!--
To enable multiple ownership, Rust has a type called `Rc<T>`, which is an
abbreviation for *reference counting*. The `Rc<T>` type keeps track of the
number of references to a value which determines whether or not a value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.
-->
<p>Pour permettre la possession multiple, Rust a le type <code>Rc&lt;T&gt;</code>, qui est une
abrÃ©viation pour <code>Reference Counting</code> <em>(compteur de rÃ©fÃ©rences)</em>. Le type
<code>Rc&lt;T&gt;</code> assure le suivi du nombre de rÃ©fÃ©rences vers une valeur, ce qui
dÃ©termine si la valeur est toujours utilisÃ©e ou non. S'il y a zÃ©ro rÃ©fÃ©rences
vers une valeur, la valeur peut Ãªtre nettoyÃ©e sans qu'aucune rÃ©fÃ©rence devienne
invalide.</p>
<!--
Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because itâ€™s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!
-->
<p>Imaginez que <code>Rc&lt;T&gt;</code> est comme une tÃ©lÃ©vision dans une salle commune. Lorsqu'une
personne entre pour regarder la tÃ©lÃ©vision, elle l'allume. Une autre rentre dans
la salle et regarde la tÃ©lÃ©vision. Lorsque la derniÃ¨re personne quitte la salle,
elle Ã©teint la tÃ©lÃ©vision car elle n'est plus utilisÃ©e. Si quelqu'un Ã©teint la
tÃ©lÃ©vision alors que d'autres continuent Ã  la regarder, il va y avoir du tapage
par les autres tÃ©lÃ©spectateursÂ !</p>
<!--
We use the `Rc<T>` type when we want to allocate some data on the heap for
multiple parts of our program to read and we canâ€™t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the dataâ€™s owner, and the normal ownership
rules enforced at compile time would take effect.
-->
<p>Nous utilisons le type <code>Rc&lt;T&gt;</code> lorsque nous souhaitons allouer une donnÃ©e sur le
tas pour que plusieurs Ã©lÃ©ments de notre programme puissent la lire et que nous
ne pouvons pas dÃ©terminer au moment de la compilation quel Ã©lÃ©ment va finir de
l'utiliser en dernier. Si nous savons quel Ã©lÃ©ment va finir en dernier, nous
pouvons juste faire en sorte que cet Ã©lÃ©ment prenne possession de la donnÃ©e, et
les rÃ¨gles de possession classiques qui s'appliquent au moment de la compilation
prendront effet.</p>
<!--
Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, weâ€™ll cover how to do reference counting in
multithreaded programs.
-->
<p>Notez que <code>Rc&lt;T&gt;</code> fonctionne uniquement dans des scÃ©narios Ã  un seul processus.
Lorsque nous verrons la concurrence au chapitre 16, nous verrons comment
procÃ©der au comptage de rÃ©fÃ©rences dans des programmes multi-processus.</p>
<!--
### Using `Rc<T>` to Share Data
-->
<h3 id="utiliser-rct-pour-partager-une-donnÃ©e"><a class="header" href="#utiliser-rct-pour-partager-une-donnÃ©e">Utiliser <code>Rc&lt;T&gt;</code> pour partager une donnÃ©e</a></h3>
<!--
Letâ€™s return to our cons list example in Listing 15-5. Recall that we defined
it using `Box<T>`. This time, weâ€™ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:
-->
<p>Retournons Ã  notre exemple de liste de construction de l'encart 15-5.
Souvenez-vous que nous l'avons dÃ©fini en utilisant <code>Box&lt;T&gt;</code>. Cette fois-ci, nous
allons crÃ©er deux listes qui partagent tous les deux la propriÃ©tÃ© d'une
troisiÃ¨me liste. ThÃ©oriquement, cela ressemblera Ã  l'illustration 15-3Â :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Deux listes qui se partagent la propriÃ©tÃ© d'une troisiÃ¨me liste"
    src="img/trpl15-03.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of
a third list, `a`</span>
-->
<p><span class="caption">Illustration 15-3Â : deux listes, <code>b</code> et <code>c</code>, qui se
partagent la possession d'une troisiÃ¨me liste, <code>a</code></span></p>
<!--
Weâ€™ll create list `a` that contains 5 and then 10. Then weâ€™ll make two more
lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`
lists will then continue on to the first `a` list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.
-->
<p>Nous allons crÃ©er une liste <code>a</code> qui contient <code>5</code> et ensuite <code>10</code>. Ensuite, nous
allons crÃ©er deux autres listesÂ : <code>b</code> qui dÃ©marre avec <code>3</code> et <code>c</code> qui dÃ©marre
avec <code>4</code>. Les deux listes <code>b</code> et <code>c</code> vont ensuite continuer sur la premiÃ¨re
liste <code>a</code> qui contient dÃ©jÃ  <code>5</code> et <code>10</code>. Autrement dit, les deux listes vont se
partager la premiÃ¨re liste contenant <code>5</code> et <code>10</code>.</p>
<!--
Trying to implement this scenario using our definition of `List` with `Box<T>`
wonâ€™t work, as shown in Listing 15-17:
-->
<p>Si nous essayons d'implÃ©menter ce scÃ©nario en utilisant les dÃ©finitions de
<code>List</code> avec <code>Box&lt;T&gt;</code>, comme dans l'encart 15-17, cela ne va pas fonctionnerÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<!--
<span class="caption">Listing 15-17: Demonstrating weâ€™re not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>
-->
<p><span class="caption">Encart 15-17Â : dÃ©monstration que nous ne sommes pas
autorisÃ©s Ã  avoir deux listes qui utilisent <code>Box&lt;T&gt;</code> pour partager la propriÃ©tÃ©
d'une troisiÃ¨me liste</span></p>
<!--
When we compile this code, we get this error:
-->
<p>Lorsque nous compilons ce code, nous obtenons cette erreurÂ :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  -- > src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The `Cons` variants own the data they hold, so when we create the `b` list, `a`
is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when
creating `c`, weâ€™re not allowed to because `a` has been moved.
-->
<p>Les variantes <code>Cons</code> prennent possession des donnÃ©es qu'elles obteniennent, donc
lorsque nous avons crÃ©Ã© la liste <code>b</code>, <code>a</code> a Ã©tÃ© dÃ©placÃ©e dans <code>b</code> et <code>b</code> possÃ¨de
dÃ©sormais <code>a</code>. Ensuite, lorsque nous essayons d'utiliser <code>a</code> Ã  nouveau lorsque
nous crÃ©ons <code>c</code>, nous ne sommes pas autorisÃ©s Ã  le faire car <code>a</code> a Ã©tÃ© dÃ©placÃ©.</p>
<!--
We could change the definition of `Cons` to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldnâ€™t let us compile
`let a = Cons(10, &Nil);` for example, because the temporary `Nil` value would
be dropped before `a` could take a reference to it.
-->
<p>Nous pourrions changer la dÃ©finition de <code>Cons</code> pour stocker des rÃ©fÃ©rences Ã  la
place, mais ensuite nous aurions besoin de renseigner des paramÃ¨tres de durÃ©e de
vie. En renseignant les paramÃ¨tres de durÃ©e de vie, nous devrons dire que chaque
Ã©lÃ©ment dans la liste devrait vivre aussi longtemps que la liste entiÃ¨re. Le
vÃ©rificateur d'emprunt ne nous laisserait pas compiler <code>let a = Cons(10, &amp;Nil);</code>
par exemple, car la valeur temporaire <code>Nil</code> serait libÃ©rÃ©e avant que <code>a</code> puisse
obtenir une rÃ©fÃ©rence vers elle.</p>
<!--
Instead, weâ€™ll change our definition of `List` to use `Rc<T>` in place of
`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value
and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking
ownership of `a`, weâ€™ll clone the `Rc<List>` that `a` is holding, thereby
increasing the number of references from one to two and letting `a` and `b`
share ownership of the data in that `Rc<List>`. Weâ€™ll also clone `a` when
creating `c`, increasing the number of references from two to three. Every time
we call `Rc::clone`, the reference count to the data within the `Rc<List>` will
increase, and the data wonâ€™t be cleaned up unless there are zero references to
it.
-->
<p>A la place, nous allons changer la dÃ©finition de <code>List</code> pour utiliser <code>Rc&lt;T&gt;</code> Ã 
la place de <code>Box&lt;T&gt;</code>, comme dans l'encart 15-18. Chaque variante <code>Cons</code> va
maintenant possÃ©der une valeur et un <code>Rc&lt;T&gt;</code> pointant sur une <code>List</code>. Lorsque
nous crÃ©ons <code>b</code>, au lieu de prendre possession de <code>a</code>, nous allons cloner le
<code>Rc&lt;List&gt;</code> que <code>a</code> possÃ¨de, augmentant ainsi le nombre de rÃ©fÃ©rences de un Ã 
deux et permettant Ã  <code>a</code> et <code>b</code> de partager la propriÃ©tÃ© des donnÃ©es dans
<code>Rc&lt;List&gt;</code>. Nous allons aussi cloner <code>a</code> lorsque nous crÃ©ons <code>c</code>, augmentant le
nombre de rÃ©fÃ©rences de deux Ã  trois. Chaque fois que nous appelons <code>Rc::clone</code>,
le compteur de rÃ©fÃ©rences des donnÃ©es prÃ©sentes dans le <code>Rc&lt;List&gt;</code> va augmenter,
et les donnÃ©es ne seront pas nettoyÃ©es tant qu'il n'y aura pas zÃ©ro rÃ©fÃ©rences
vers elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FilenameÂ : src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>
-->
<p><span class="caption">Encart 15-18Â : une dÃ©finition de <code>List</code> qui utilise
<code>Rc&lt;T&gt;</code></span></p>
<!--
We need to add a `use` statement to bring `Rc<T>` into scope because itâ€™s not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.
-->
<p>Nous devons ajouter une instruction <code>use</code> pour importer <code>Rc&lt;T&gt;</code> dans la portÃ©e
car il n'est pas prÃ©sent dans l'Ã©tape prÃ©liminaire. Dans le <code>main</code>, nous crÃ©ons
la liste qui stocke <code>5</code> et <code>10</code> et la stocke dans une nouvelle <code>Rc&lt;List&gt;</code> dans
<code>a</code>. Ensuite lorsque nous crÃ©ons <code>b</code> et <code>c</code>, nous appelons la fonction
<code>Rc::clone</code> et passer une rÃ©fÃ©rence vers le <code>Rc&lt;List&gt;</code> de <code>a</code> en argument.</p>
<!--
We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rustâ€™s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesnâ€™t make a deep copy of all the data like most typesâ€™
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesnâ€™t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
`Rc::clone`.
-->
<p>Nous aurions pu appeler <code>a.clone()</code> plutÃ´t que <code>Rc::clone(&amp;a)</code>, mais la
convention en Rust est d'utiliser <code>Rc::clone</code> dans cette situation.
L'implÃ©mentation de <code>Rc::clone</code> ne fait pas une copie profonde de toutes les
donnÃ©es comme le fait la plupart des implÃ©mentations de <code>clone</code>. L'appel Ã 
<code>Rc:clone</code> augmente uniquement le compteur de rÃ©fÃ©rences, ce qui ne prend pas
beaucoup de temps. Les copies profondes des donnÃ©es peut prendre beaucoup de
temps. En utilisant <code>Rc::clone</code> pour les compteurs de rÃ©fÃ©rences, nous pouvons
distinguer visuellement un clonage qui fait une copie profonde d'un clonage qui
augmente uniquement le compteur de rÃ©fÃ©rences. Lorsque vous enquÃªtez sur des
problÃ¨mes de performances dans le code, vous pouvez ainsi Ã©carter les appels Ã 
<code>Rc::clone</code> des clonages Ã  copie profonde, que vous recherchez probablement.</p>
<!--
### Cloning an `Rc<T>` Increases the Reference Count
-->
<h3 id="cloner-une-rct-augmente-le-compteur-de-rÃ©fÃ©rence"><a class="header" href="#cloner-une-rct-augmente-le-compteur-de-rÃ©fÃ©rence">Cloner une <code>Rc&lt;T&gt;</code> augmente le compteur de rÃ©fÃ©rence</a></h3>
<!--
Letâ€™s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.
-->
<p>Changeons notre exemple de l'encart 15-18 pour que nous puissions voir le
compteur de rÃ©fÃ©rences changer au fur et Ã  mesure que nous crÃ©ons et libÃ©rons
des rÃ©fÃ©rences vers le <code>Rc&lt;List&gt;</code> prÃ©sent dans <code>a</code>.</p>
<!--
In Listing 15-19, weâ€™ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope.
-->
<p>Dans l'encart 15-19, nous allons changer le <code>main</code> afin qu'il ait une portÃ©e
en son sein autour de <code>c</code>Â ; ainsi nous pourrons voir comment le compteur de
rÃ©fÃ©rences change lorsque <code>c</code> sort de la portÃ©e.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
# 
# use crate::List::{Cons, Nil};
# use std::rc::Rc;
# 
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;compteur aprÃ¨s la crÃ©ation de a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;compteur aprÃ¨s la crÃ©ation de b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;compteur aprÃ¨s la crÃ©ation de c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;compteur aprÃ¨s que c soit sortie de la portÃ©e = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-19: Printing the reference count</span>
-->
<p><span class="caption">Encart 15-19Â : affichage du compteur de rÃ©fÃ©rences</span></p>
<!--
At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; weâ€™ll see what `weak_count` is used for in the
[â€œPreventing Reference Cycles: Turning an `Rc<T>` into a
`Weak<T>`â€][preventing-ref-cycles]<!-- ignore -- > section.
-->
<p>A chaque Ã©tape du programme oÃ¹ le compteur de rÃ©fÃ©rences change, nous affichons
le compteur de rÃ©fÃ©rences, que nous pouvons obtenir en faisant appel Ã  la
fonction <code>Rc::strong_count</code>. Cette fonction s'appelle <code>strong_count</code> plutÃ´t que
<code>count</code> car le type <code>Rc&lt;T&gt;</code> a aussi un <code>weak_count</code>Â ; nous verrons Ã  quoi sert
ce <code>weak_count</code> dans
<a href="ch15-06-reference-cycles.html">la derniÃ¨re section de ce chapitre</a><!-- ignore -->.</p>
<!--
This code prints the following:
-->
<p>Ce code affiche ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
compteur aprÃ¨s la crÃ©ation de a = 1
compteur aprÃ¨s la crÃ©ation de b = 2
compteur aprÃ¨s la crÃ©ation de c = 3
compteur aprÃ¨s que c soit sortie de la portÃ©e = 2
</code></pre>
<!--
We can see that the `Rc<List>` in `a` has an initial reference count of 1; then
each time we call `clone`, the count goes up by 1. When `c` goes out of scope,
the count goes down by 1. We donâ€™t have to call a function to decrease the
reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.
-->
<p>Nous pouvons voir clairement que le <code>Rc&lt;List&gt;</code> dans <code>a</code> a un compteur de
rÃ©fÃ©rences initial Ã  <code>1</code>Â ; puis Ã  chaque fois que nous appelons <code>clone</code>, le
compteur augmente de 1. Nous n'avons pas Ã  appeler une fonction pour rÃ©duire le
compteur de rÃ©fÃ©rences, comme nous avons dÃ» le faire avec <code>Rc::clone</code> pour
augmenter compteurÂ : l'implÃ©mentation du trait <code>Drop</code> rÃ©duit le compteur de
rÃ©fÃ©rences automatiquement lorsqu'une valeur de <code>Rc&lt;T&gt;</code> sort de la portÃ©e.</p>
<!--
What we canâ€™t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.
-->
<p>Ce que nous ne voyons pas dans cet exemple est lorsque <code>b</code> et <code>a</code> sortent de la
portÃ©e Ã  la fin du <code>main</code>, le compteur vaut alors 0, et le <code>Rc&lt;List&gt;</code> est
nettoyÃ© complÃ¨tement Ã  ce moment. L'utilisation de <code>Rc&lt;T&gt;</code> permet Ã  une valeur
d'avoir plusieurs propriÃ©taires, et le compteur garantit que la valeur reste
en vigueur tant qu'au moins un propriÃ©taire existe encore.</p>
<!--
Via immutable references, `Rc<T>` allows you to share data between multiple
parts of your program for reading only. If `Rc<T>` allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, weâ€™ll discuss the interior mutability pattern and the `RefCell<T>`
type that you can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
-->
<p>GrÃ¢ce aux rÃ©fÃ©rences immuables, <code>Rc&lt;T&gt;</code> vous permet de partager des donnÃ©es
entre plusieurs Ã©lÃ©ments de votre programme pour uniquement les lire. Si <code>Rc&lt;T&gt;</code>
vous aurait aussi permis d'avoir des rÃ©fÃ©rences mutables, vous aurez alors
violÃ© une des rÃ¨gles d'emprunt vues au chapitre 4Â : les emprunts mutables
multiples Ã  une mÃªme donnÃ©e peuvent causer des accÃ¨s concurrents et des
incohÃ©rences. Cependant, pouvoir modifier des donnÃ©es reste trÃ¨s utileÂ ! Dans la
section suivante, nous allons voir le motif de mutabilitÃ© interne et le type
<code>RefCell&lt;T&gt;</code> que vous pouvez utiliser conjointement avec un <code>Rc&lt;T&gt;</code> pour pouvoir
travailler avec cette contrainte d'immuabilitÃ©.</p>
<!-- markdownlint-disable -->
<!--
[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
-->
<!-- markdownlint-restore -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-03-drop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-03-drop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch15-05-interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
