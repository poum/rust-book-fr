<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la protection</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸš§ Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸš§ La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box<T> pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc<T>, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell<T> et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html" class="active"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
## Implementing an Object-Oriented Design Pattern
-->
<h2><a class="header" href="#implÃ©menter-un-patron-de-conception-orientÃ©-objet" id="implÃ©menter-un-patron-de-conception-orientÃ©-objet">ImplÃ©menter un patron de conception orientÃ©-objet</a></h2>
<!--
The *state pattern* is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of *state objects*, and the valueâ€™s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.
-->
<p>Le <em>patron Ã©tat</em> est un patron de conception issu de l'orientÃ© objet. Le point
essentiel du modÃ¨le est qu'une valeur a un Ã©tat interne, qui est reprÃ©sentÃ© par
un ensemble <em>d'Ã©tats</em>, et le comportement de la valeur change en fonction de son
Ã©tat interne. Les objets Ã©tat partagent des fonctionnalitÃ©sÂ : en Rust, bien sÃ»r,
nous utilisons des structures et des traits plutÃ´t que des objets et de
l'hÃ©ritage. Chaque objet Ã©tat est responsable de son propre comportement et
dÃ©cide lorsqu'il doit changer pour un autre Ã©tat. La valeur contenue dans un
objet Ã©tat ne sait rien sur les diffÃ©rents comportements des Ã©tats et ne sait
pas quand il va changer d'Ã©tat.</p>
<!--
Using the state pattern means when the business requirements of the program
change, we wonâ€™t need to change the code of the value holding the state or the
code that uses the value. Weâ€™ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Letâ€™s look
at an example of the state design pattern and how to use it in Rust.
-->
<p>L'utilisation du patron Ã©tat signifie que lorsque les prÃ©-requis du mÃ©tier du
programme ont changÃ©, nous n'avons pas besoin de changer le code Ã  l'intÃ©rieur
de l'objet Ã©tat ou le code qui utilise l'objet. Nous avons juste besoin de
modifier le code dans un des objets Ã©tat pour changer son fonctionnement ou pour
ajouter d'autres objets Ã©tat. Voyons un exemple du patron Ã©tat et comment
l'utiliser en Rust.</p>
<!--
Weâ€™ll implement a blog post workflow in an incremental way. The blogâ€™s final
functionality will look like this:
-->
<p>Nous allons implÃ©menter un processus de publication de billets de blogs de
maniÃ¨re incrÃ©mentale. Les fonctionnalitÃ©s finales du blog seront les suivantesÂ :</p>
<!--
1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts canâ€™t
   accidentally be published.
-->
<ol>
<li>Un billet de blog commence par un brouillon vide.</li>
<li>Lorsque le brouillon est terminÃ©, une relecture du billet est demandÃ©e.</li>
<li>Lorsqu'un billet est approuvÃ©, il est publiÃ©.</li>
<li>Seuls les billets de blog publiÃ©s retournent du contenu Ã  afficher, donc les
billets non approuvÃ©s ne peuvent pas Ãªtre publiÃ©s accidentellement.</li>
</ol>
<!--
Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before weâ€™ve requested a review, the post
should remain an unpublished draft.
-->
<p>Tous les autres changements effectuÃ©s sur un billet n'auront pas d'effet. Par
exemple, si nous essayons d'approuver un brouillon de billet de blog avant
d'avoir demandÃ© une relecture, le billet devrait rester Ã  l'Ã©tat de brouillon
non publiÃ©.</p>
<!--
Listing 17-11 shows this workflow in code form: this is an example usage of the
API weâ€™ll implement in a library crate named `blog`. This wonâ€™t compile yet
because we havenâ€™t implemented the `blog` crate yet.
-->
<p>L'encart 17-11 prÃ©sente ce processus de publication sous forme de codeÂ : c'est
un exemple d'utilisation de l'API que nous allons implÃ©menter dans une crate de
bibliothÃ¨que <code>blog</code>. Elle ne va pas encore se compiler car nous n'avons pas
encore implÃ©mentÃ© la crate <code>blog</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.demander_relecture();
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.approuver();
    assert_eq!(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our `blog` crate to have</span>
-->
<p><span class="caption">Encart 17-11Â : du code qui montre le comportement attendu
de notre crate <code>blog</code></span></p>
<!--
We want to allow the user to create a new draft blog post with `Post::new`.
Then we want to allow text to be added to the blog post while itâ€™s in the draft
state. If we try to get the postâ€™s content immediately, before approval,
nothing should happen because the post is still a draft. Weâ€™ve added
`assert_eq!` in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
`content` method, but weâ€™re not going to write tests for this example.
-->
<p>Nous voulons permettre Ã  l'utilisateur de crÃ©er un nouveau brouillon de billet
de blog avec <code>Billet::new</code>. Ensuite nous voulons qu'il puisse ajouter du texte
au billet de blog tant qu'il est Ã  l'Ã©tat de brouillon. Si nous essayons
d'obtenir immÃ©diatement le contenu du billet, avant qu'il soit relu, rien ne va
se passer car le billet est toujours un brouillon. Nous avons ajoutÃ© des
<code>assert_eq!</code> dans le code pour les besoins de la dÃ©monstration. Un excellent
test unitaire pour cela serait de vÃ©rifier qu'un brouillon de billet de blog
retourne bien une chaÃ®ne de caractÃ¨res vide Ã  partir de la mÃ©thode <code>contenu</code>,
mais nous n'allons pas Ã©crire de tests pour cet exemple.</p>
<!--
Next, we want to enable a request for a review of the post, and we want
`content` to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when `content` is called.
-->
<p>Ensuite, nous voulons permettre de demander une relecture du billet, et nous
souhaitons que <code>contenu</code> retourne toujours une chaÃ®ne de caractÃ¨res vide pendant
que nous attendons la relecture. Lorsque la relecture du billet est approuvÃ©e,
il doit Ãªtre publiÃ©, ce qui signifie que le texte du billet doit Ãªtre retournÃ©
lors de l'appel Ã  <code>contenu</code>.</p>
<!--
Notice that the only type weâ€™re interacting with from the crate is the `Post`
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
inâ€”draft, waiting for review, or published. Changing from one state to another
will be managed internally within the `Post` type. The states change in
response to the methods called by our libraryâ€™s users on the `Post` instance,
but they donâ€™t have to manage the state changes directly. Also, users canâ€™t
make a mistake with the states, like publishing a post before itâ€™s reviewed.
-->
<p>Remarquez que le seul type avec lequel nous interagissons avec la crate est le
type <code>Billet</code>. Ce type va utiliser le patron Ã©tat et va hÃ©berger une valeur qui
sera un des trois objets Ã©tat reprÃ©sentant les diffÃ©rents Ã©tats dans lesquels
passent un billetÂ : brouillon, en attente de relecture, ou publiÃ©. Le changement
d'un Ã©tat Ã  un autre sera gÃ©rÃ© en interne du type <code>Billet</code>. Les Ã©tats vont
changer suite aux mÃ©thodes appelÃ©es par les utilisateurs de notre bibliothÃ¨que
sur l'instance de <code>Billet</code>, mais ils n'ont pas Ã  gÃ©rer directement les
changements d'Ã©tat. De plus, les utilisateurs ne peuvent pas faire d'erreur avec
les Ã©tats, comme par exemple publier un billet avant qu'il soit relu.</p>
<!--
### Defining `Post` and Creating a New Instance in the Draft State
-->
<h3><a class="header" href="#dÃ©finir-billet-et-crÃ©er-une-nouvelle-instance-Ã -lÃ©tat-de-brouillon" id="dÃ©finir-billet-et-crÃ©er-une-nouvelle-instance-Ã -lÃ©tat-de-brouillon">DÃ©finir <code>Billet</code> et crÃ©er une nouvelle instance Ã  l'Ã©tat de brouillon</a></h3>
<!--
Letâ€™s get started on the implementation of the library! We know we need a
public `Post` struct that holds some content, so weâ€™ll start with the
definition of the struct and an associated public `new` function to create an
instance of `Post`, as shown in Listing 17-12. Weâ€™ll also make a private
`State` trait. Then `Post` will hold a trait object of `Box<dyn State>`
inside an `Option<T>` in a private field named `state`. Youâ€™ll see why the
`Option<T>` is necessary in a bit.
-->
<p>CommenÃ§ons l'implÃ©mentation de la bibliothÃ¨queÂ ! Nous savons que nous aurons
besoin d'une structure publique <code>Billet</code> qui hÃ©berge du contenu, donc nous
allons commencer par dÃ©finir cette structure et une fonction publique <code>new</code> qui
lui est associÃ©e pour crÃ©er une instance de <code>Billet</code>, comme dans l'encart 17-12.
Nous allons aussi crÃ©er un trait privÃ© <code>Etat</code>. Ensuite <code>Billet</code> devra avoir un
champ privÃ© <code>etat</code> pour y loger une <code>Option&lt;T&gt;</code> contenant un objet trait de
<code>Box&lt;dyn Etat&gt;</code>. Nous verrons plus tard l'intÃ©rÃªt du <code>Option&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Billet {
    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; Billet {
        Billet {
            etat: Some(Box::new(Brouillon {})),
            contenu: String::new(),
        }
    }
}

trait Etat {}

struct Brouillon {}

impl Etat for Brouillon {}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-12: Definition of a `Post` struct and a `new`
function that creates a new `Post` instance, a `State` trait, and a `Draft`
struct</span>
-->
<p><span class="caption">Encart 17-12Â : dÃ©finition d'une structure <code>Billet</code> et
d'une fonction <code>new</code> qui crÃ©e une nouvelle instance de <code>Billet</code>, un trait
<code>Etat</code>, et une structure <code>Brouillon</code></span></p>
<!--
The `State` trait defines the behavior shared by different post states, and the
`Draft`, `PendingReview`, and `Published` states will all implement the `State`
trait. For now, the trait doesnâ€™t have any methods, and weâ€™ll start by defining
just the `Draft` state because that is the state we want a post to start in.
-->
<p>Le trait <code>Etat</code> dÃ©finit le comportement partagÃ© par plusieurs Ã©tats de billet,
et les Ã©tats <code>Brouillon</code>, <code>EnRelecture</code>, et <code>Publier</code> vont tous implÃ©menter le
trait <code>Etat</code>. Pour l'instant, le trait n'a pas de mÃ©thode, et nous allons
commencer par dÃ©finir uniquement l'Ã©tat <code>Brouillon</code> car c'est l'Ã©tat dans lequel
nous voulons crÃ©er un nouveau billet.</p>
<!--
When we create a new `Post`, we set its `state` field to a `Some` value that
holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This
ensures whenever we create a new instance of `Post`, it will start out as a
draft. Because the `state` field of `Post` is private, there is no way to
create a `Post` in any other state! In the `Post::new` function, we set the
`content` field to a new, empty `String`.
-->
<p>Lorsque nous crÃ©ons un nouveau <code>Billet</code>, nous assignons Ã  son champ <code>etat</code> une
valeur <code>Some</code> qui contient une <code>Box</code>. Cette <code>Box</code> pointe sur une nouvelle
instance de la structure <code>Brouillon</code>. Cela garantira qu'Ã  chaque fois que nous
crÃ©ons une nouvelle instance de <code>Billet</code>, elle commencera Ã  l'Ã©tat de brouillon.
Comme le champ <code>etat</code> de <code>Billet</code> est privÃ©, il n'y a pas d'autre maniÃ¨re de
crÃ©er un <code>Billet</code> dans un autre Ã©tatÂ ! Dans la fonction <code>Billet::new</code>, nous
assignons une nouvelle <code>String</code> vide au champ <code>contenu</code>.</p>
<!--
### Storing the Text of the Post Content
-->
<h3><a class="header" href="#stocker-le-texte-du-contenu-du-billet" id="stocker-le-texte-du-contenu-du-billet">Stocker le texte du contenu du billet</a></h3>
<!--
Listing 17-11 showed that we want to be able to call a method named
`add_text` and pass it a `&str` that is then added to the text content of the
blog post. We implement this as a method rather than exposing the `content`
field as `pub`. This means we can implement a method later that will control
how the `content` fieldâ€™s data is read. The `add_text` method is pretty
straightforward, so letâ€™s add the implementation in Listing 17-13 to the `impl
Post` block:
-->
<p>L'encart 17-11 a montrÃ© que nous souhaitons appeler une mÃ©thode <code>ajouter_texte</code>
et lui passer un <code>&amp;str</code> qui est ensuite ajoutÃ© au contenu textuel du billet de
blog. Nous implÃ©mentons ceci avec une mÃ©thode plutÃ´t que d'exposer publiquement
le champ <code>contenu</code> avec <code>pub</code>. Cela signifie que nous pouvons implÃ©menter une
mÃ©thode plus tard qui va contrÃ´ler comment le champ <code>contenu</code> sera lu. La
mÃ©thode <code>ajouter_texte</code> est assez simple, donc ajoutons son implÃ©mentation dans
le bloc <code>Billet</code> de l'encart 17-13Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-13: Implementing the `add_text` method to add
text to a postâ€™s `content`</span>
-->
<p><span class="caption">Encart 17-13Â : implÃ©mentation de la mÃ©thode
<code>ajouter_texte</code> pour ajouter du texte au <code>contenu</code> d'un billet</span></p>
<!--
The `add_text` method takes a mutable reference to `self`, because weâ€™re
changing the `Post` instance that weâ€™re calling `add_text` on. We then call
`push_str` on the `String` in `content` and pass the `text` argument to add to
the saved `content`. This behavior doesnâ€™t depend on the state the post is in,
so itâ€™s not part of the state pattern. The `add_text` method doesnâ€™t interact
with the `state` field at all, but it is part of the behavior we want to
support.
-->
<p>La mÃ©thode <code>ajouter_texte</code> prend en argument une rÃ©fÃ©rence mutable vers <code>self</code>,
car nous changeons l'instance <code>Billet</code> sur laquelle nous appelons
<code>ajouter_texte</code>. Nous faisons ensuite appel Ã  <code>push_str</code> sur le <code>String</code> dans
<code>contenu</code> et nous y envoyons l'argument <code>texte</code> pour l'ajouter au <code>contenu</code> dÃ©jÃ 
stockÃ©. Ce comportement ne dÃ©pend pas de l'Ã©tat dans lequel est le billet, donc
cela ne fait pas partie du patron Ã©tat. La mÃ©thode <code>ajouter_texte</code> n'interagit
pas du tout avec le champ <code>etat</code>, mais c'est volontaire.</p>
<!--
### Ensuring the Content of a Draft Post Is Empty
-->
<h3><a class="header" href="#sassurer-que-le-contenu-dun-brouillon-est-vide" id="sassurer-que-le-contenu-dun-brouillon-est-vide">S'assurer que le contenu d'un brouillon est vide</a></h3>
<!--
Even after weâ€™ve called `add_text` and added some content to our post, we still
want the `content` method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 17-11. For now, letâ€™s
implement the `content` method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. Weâ€™ll change this later
once we implement the ability to change a postâ€™s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:
-->
<p>MÃªme si nous avons appelÃ© <code>ajouter_texte</code> et ajoutÃ© du contenu dans notre
billet, nous voulons que la mÃ©thode <code>contenu</code> retourne toujours une slice de
chaÃ®ne de caractÃ¨res vide car le billet est toujours Ã  l'Ã©tat de brouillon,
comme le montre la ligne 7 de l'encart 17-11. ImplÃ©mentons maintenant la mÃ©thode
<code>contenu</code> de la maniÃ¨re la plus simple qui rÃ©pond Ã  cette consigneÂ : toujours
retourner un slice de chaÃ®ne de caractÃ¨res vide. Nous la changerons plus tard
lorsque nous implÃ©menterons la capacitÃ© de changer l'Ã©tat d'un billet afin qu'il
puisse Ãªtre publiÃ©. Pour l'instant, les billets ne peuvent qu'Ãªtre Ã  l'Ã©tat de
brouillon, donc le contenu du billet devrait toujours Ãªtre vide. L'encart 17-14
montre l'implÃ©mentation de ceciÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        ""
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-14: Adding a placeholder implementation for
the `content` method on `Post` that always returns an empty string slice</span>
-->
<p><span class="caption">Encart 17-14Â : ajout d'une implÃ©mentation de la mÃ©thode
<code>contenu</code> sur <code>Billet</code> qui va toujours retourner une slice de chaÃ®ne de
caractÃ¨res vide</span></p>
<!--
With this added `content` method, everything in Listing 17-11 up to line 7
works as intended.
-->
<p>Avec cette mÃ©thode <code>contenu</code> ajoutÃ©e, tout ce qu'il y a dans l'encart 17-11
fonctionne comme prÃ©vu jusqu'Ã  la ligne 7.</p>
<!--
### Requesting a Review of the Post Changes Its State
-->
<h3><a class="header" href="#demander-une-relecture-du-billet-va-changer-son-Ã©tat" id="demander-une-relecture-du-billet-va-changer-son-Ã©tat">Demander une relecture du billet va changer son Ã©tat</a></h3>
<!--
Next, we need to add functionality to request a review of a post, which should
change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:
-->
<p>Ensuite, nous avons besoin d'ajouter une fonctionnalitÃ© pour demander la
relecture d'un billet, qui devrait changer son Ã©tat de <code>Brouillon</code> Ã 
<code>EnRelecture</code>. L'encart 17-15 montre ce codeÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.demander_relecture())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(EnRelecture {})
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-15: Implementing `request_review` methods on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-15Â : implÃ©mentation des mÃ©thodes
<code>demander_relecture</code> sur <code>Billet</code> et le trait <code>Etat</code></span></p>
<!--
We give `Post` a public method named `request_review` that will take a mutable
reference to `self`. Then we call an internal `request_review` method on the
current state of `Post`, and this second `request_review` method consumes the
current state and returns a new state.
-->
<p>Nous installons la mÃ©thode publique <code>demander_relecture</code> sur <code>Billet</code> qui va
prendre en argument une rÃ©fÃ©rence mutable Ã  <code>self</code>. Ensuite nous appelons la
mÃ©thode interne <code>demander_relecture</code> sur l'Ã©tat interne de <code>Billet</code>, et cette
seconde mÃ©thode <code>demander_relecture</code> consomme l'Ã©tat en cours et applique un
nouvel Ã©tat.</p>
<!--
Weâ€™ve added the `request_review` method to the `State` trait; all types that
implement the trait will now need to implement the `request_review` method.
Note that rather than having `self`, `&self`, or `&mut self` as the first
parameter of the method, we have `self: Box<Self>`. This syntax means the
method is only valid when called on a `Box` holding the type. This syntax takes
ownership of `Box<Self>`, invalidating the old state so the state value of the
`Post` can transform into a new state.
-->
<p>Nous avons ajoutÃ© la mÃ©thode <code>demander_relecture</code> sur le trait <code>Etat</code>Â ; tous les
types qui implÃ©mentent le trait vont maintenant devoir implÃ©menter la mÃ©thode
<code>demander_relecture</code>. Remarquez qu'au lieu d'avoir <code>self</code>, <code>&amp;self</code>, ou
<code>&amp;mut self</code> en premier paramÃ¨tre de la mÃ©thode, nous avons <code>self: Box&lt;Self&gt;</code>.
Cette syntaxe signifie que la mÃ©thode est valide uniquement lorsqu'on l'appelle
sur une <code>Box</code> qui contient ce type. Cette syntaxe prend possession de
<code>Box&lt;Self&gt;</code>, ce qui annule l'ancien Ã©tat du <code>Billet</code> qui peut changer pour un
nouvel Ã©tat.</p>
<!--
To consume the old state, the `request_review` method needs to take ownership
of the state value. This is where the `Option` in the `state` field of `Post`
comes in: we call the `take` method to take the `Some` value out of the `state`
field and leave a `None` in its place, because Rust doesnâ€™t let us have
unpopulated fields in structs. This lets us move the `state` value out of
`Post` rather than borrowing it. Then weâ€™ll set the postâ€™s `state` value to the
result of this operation.
-->
<p>Pour consommer l'ancien Ã©tat, la mÃ©thode <code>demander_relecture</code> a besoin de
prendre possession de la valeur d'Ã©tat. C'est ce Ã  quoi sert le <code>Option</code> dans le
champ <code>etat</code> de <code>Billet</code>Â : nous faisons appel Ã  la mÃ©thode <code>take</code> pour obtenir
la valeur dans le <code>Some</code> du champ <code>etat</code> et le remplacer par <code>None</code>, car Rust ne
nous permet pas d'avoir des champs non renseignÃ©s dans des structures. Cela nous
permet d'extraire la valeur de <code>etat</code> d'un <code>Billet</code>, plutÃ´t que de l'emprunter.
Ensuite, nous allons rÃ©affecter le rÃ©sultat de cette opÃ©ration Ã  <code>etat</code> du
<code>Billet</code> concernÃ©.</p>
<!--
We need to set `state` to `None` temporarily rather than setting it directly
with code like `self.state = self.state.request_review();` to get ownership of
the `state` value. This ensures `Post` canâ€™t use the old `state` value after
weâ€™ve transformed it into a new state.
-->
<p>Nous devons assigner temporairement <code>None</code> Ã  <code>etat</code> plutÃ´t que de lui donner
directement avec code comme <code>self.etat = self.etat.demander_relecture();</code> car
nous voulons prendre possession de la valeur <code>etat</code>. Cela garantit que <code>Billet</code>
ne peut pas utiliser l'ancienne valeur de <code>etat</code> aprÃ¨s qu'on ai changÃ© cet Ã©tat.</p>
<!--
The `request_review` method on `Draft` needs to return a new, boxed instance of
a new `PendingReview` struct, which represents the state when a post is waiting
for a review. The `PendingReview` struct also implements the `request_review`
method but doesnâ€™t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the `PendingReview` state, it
should stay in the `PendingReview` state.
-->
<p>La mÃ©thode <code>demander_relecture</code> sur <code>Brouillon</code> doit retourner une nouvelle
instance d'une structure <code>EnRelecture</code> dans une <code>Box</code>, qui reprÃ©sente l'Ã©tat
lorsqu'un billet est en attente de relecture. La structure <code>EnRelecture</code>
implÃ©mente elle aussi la mÃ©thode <code>demander_relecture</code> mais ne fait aucune
modification. A la place, il se retourne lui-mÃªme, car lorsque nous demandons
une relecture sur un billet dÃ©jÃ  Ã  l'Ã©tat <code>EnRelecture</code>, il doit rester Ã  l'Ã©tat
<code>EnRelecture</code>.</p>
<!--
Now we can start seeing the advantages of the state pattern: the
`request_review` method on `Post` is the same no matter its `state` value. Each
state is responsible for its own rules.
-->
<p>DÃ©sormais nous commenÃ§ons Ã  voir les avantages du patron Ã©tatÂ : la mÃ©thode
<code>demander_relecture</code> sur <code>Billet</code> est la mÃªme peu importe la valeur de son
<code>etat</code>. Chaque Ã©tat est maÃ®tre de son fonctionnement.</p>
<!--
Weâ€™ll leave the `content` method on `Post` as is, returning an empty string
slice. We can now have a `Post` in the `PendingReview` state as well as in the
`Draft` state, but we want the same behavior in the `PendingReview` state.
Listing 17-11 now works up to line 10!
-->
<p>Nous allons conserver la mÃ©thode <code>contenu</code> sur <code>Billet</code> comme elle l'est, elle
va continuer Ã  retourner une slice de chaÃ®ne de caractÃ¨res vide. Nous pouvons
maintenant avoir un <code>Billet</code> Ã  l'Ã©tat <code>Brouillon</code> ou <code>EnRelecture</code>, mais nous
voulons qu'il suive le mÃªme comportement lorsqu'il est dans l'Ã©tat
<code>EnRelecture</code>. L'encart 17-11 fonctionne maintenant jusqu'Ã  la ligne 10Â !</p>
<!--
### Adding the `approve` Method that Changes the Behavior of `content`
-->
<h3><a class="header" href="#ajouter-une-mÃ©thode-approuver-qui-change-le-comportement-de-contenu" id="ajouter-une-mÃ©thode-approuver-qui-change-le-comportement-de-contenu">Ajouter une mÃ©thode <code>approuver</code> qui change le comportement de <code>contenu</code></a></h3>
<!--
The `approve` method will be similar to the `request_review` method: it will
set `state` to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:
-->
<p>La mÃ©thode <code>approuver</code> ressemble Ã  la mÃ©thode <code>demander_relecture</code>Â : elle va
changer <code>etat</code> pour la valeur que l'Ã©tat actuel retournera lorsque cet Ã©tat est
approuvÃ©, comme le montre l'encart 17-16Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approuver(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.approuver())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(Publier {})
    }
}

struct Publier {}

impl Etat for Publier {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }

    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-16: Implementing the `approve` method on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-16Â : implÃ©mentation de la mÃ©thode <code>approuver</code>
sur <code>Billet</code> et sur le trait <code>Etat</code></span></p>
<!--
We add the `approve` method to the `State` trait and add a new struct that
implements `State`, the `Published` state.
-->
<p>Nous avons ajoutÃ© la mÃ©thode <code>approuver</code> au trait <code>Etat</code> et ajoutÃ© une nouvelle
structure <code>Publier</code>, qui implÃ©mente <code>Etat</code>.</p>
<!--
Similar to `request_review`, if we call the `approve` method on a `Draft`, it
will have no effect because it will return `self`. When we call `approve` on
`PendingReview`, it returns a new, boxed instance of the `Published` struct.
The `Published` struct implements the `State` trait, and for both the
`request_review` method and the `approve` method, it returns itself, because
the post should stay in the `Published` state in those cases.
-->
<p>Comme pour <code>demander_relecture</code>, si nous faisons appel Ã  la mÃ©thode <code>approuver</code>
sur un <code>Brouillon</code>, cela n'aura pas d'effet car elle va retourner <code>self</code>.
Lorsque nous appellerons <code>approuver</code> sur <code>EnRelecture</code>, elle va retourner une
nouvelle instance de la structure <code>Publier</code> dans une instance de <code>Box</code>. La
structure <code>Publier</code> implÃ©mente le trait <code>Etat</code>, et pour chacune des mÃ©thodes
<code>demander_relecture</code> et <code>approuver</code>, elle va retourner elle-mÃªme, car le billet
doit rester Ã  l'Ã©tat <code>Publier</code> dans ce cas-lÃ .</p>
<!--
Now we need to update the `content` method on `Post`: if the state is
`Published`, we want to return the value in the postâ€™s `content` field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:
-->
<p>Nous devons maintenant modifier la mÃ©thode <code>contenu</code> sur <code>Billet</code>Â : si l'Ã©tat
est <code>Publier</code>, nous voulons retourner la valeur du champ <code>contenu</code> du billetÂ ;
sinon nous retournons une slice de chaÃ®ne de caractÃ¨res vide, comme dans
l'encart 17-17Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
}
# 
# trait State {
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# }
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
# struct Published {}
# 
# impl State for Published {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        self.etat.as_ref().unwrap().contenu(self)
    }
    // -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait Etat {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Publier {}
</span><span class="boring">
</span><span class="boring">impl Etat for Publier {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 17-17: Updating the `content` method on `Post` to
delegate to a `content` method on `State`</span>
-->
<p><span class="caption">Encart 17-17Â : correction de la mÃ©thode <code>contenu</code> de
<code>Billet</code> pour dÃ©lÃ©guer Ã  la mÃ©thode <code>contenu</code> de <code>Etat</code></span></p>
<!--
Because the goal is to keep all these rules inside the structs that implement
`State`, we call a `content` method on the value in `state` and pass the post
instance (that is, `self`) as an argument. Then we return the value that is
returned from using the `content` method on the `state` value.
-->
<p>Comme notre but est de conserver toutes ces rÃ¨gles dans les structures qui
implÃ©mentent <code>Etat</code>, nous appelons une mÃ©thode <code>contenu</code> sur la valeur de
<code>etat</code> et nous lui passons en argument l'instance du billet (avec le <code>self</code>).
Nous retournons ensuite la valeur retournÃ©e par la mÃ©thode <code>contenu</code> sur la
valeur de <code>etat</code>.</p>
<!-- markdownlint-disable -->
<!--
We call the `as_ref` method on the `Option` because we want a reference to the
value inside the `Option` rather than ownership of the value. Because `state`
is an `Option<Box<dyn State>>`, when we call `as_ref`, an `Option<&Box<dyn State>>` is
returned. If we didnâ€™t call `as_ref`, we would get an error because we canâ€™t
move `state` out of the borrowed `&self` of the function parameter.
-->
<!-- markdownlint-enable -->
<p>Nous faisons appel Ã  la mÃ©thode <code>as_ref</code> sur <code>Option</code> car nous voulons une
rÃ©fÃ©rence vers la valeur dans <code>Option</code> plutÃ´t que d'en prendre possession. Comme
<code>etat</code> est un <code>Option&lt;Box&lt;dyn Etat&gt;&gt;</code>, lorsque nous faisons appel Ã  <code>as_ref</code>,
une <code>Option&lt;&amp;Box&lt;dyn Etat&gt;&gt;</code> est retournÃ©e. Si nous n'avions pas fait appel Ã 
<code>as_ref</code>, nous aurions obtenu une erreur car nous ne pouvons pas dÃ©placer
<code>etat</code> du <code>&amp;self</code>, qui est empruntÃ©, qui provient des paramÃ¨tres de la fonction.</p>
<!--
We then call the `unwrap` method, which we know will never panic, because we
know the methods on `Post` ensure that `state` will always contain a `Some`
value when those methods are done. This is one of the cases we talked about in
the [â€œCases In Which You Have More Information Than the
Compilerâ€][more-info-than-rustc]<!-- ignore -- > section of Chapter 9 when we
know that a `None` value is never possible, even though the compiler isnâ€™t able
to understand that.
-->
<p>Nous faisons ensuite appel Ã  la mÃ©thode <code>unwrap</code>, mais nous savons qu'elle ne
va jamais paniquer, car nous savons que les mÃ©thodes sur <code>Billet</code> vont toujours
garantir que <code>etat</code> contiendra toujours une valeur <code>Some</code> lorsqu'elles seront
utilisÃ©es. C'est un des cas dont nous avons parlÃ© dans
<a href="ch09-03-to-panic-or-not-to-panic.html">une section</a><!-- ignore --> du chapitre 9 lorsque nous
savions qu'une valeur <code>None</code> ne serait jamais possible, mÃªme si le compilateur
n'est pas capable de le comprendre.</p>
<!-- markdownlint-disable -->
<!--
At this point, when we call `content` on the `&Box<dyn State>`, deref coercion will
take effect on the `&` and the `Box` so the `content` method will ultimately be
called on the type that implements the `State` trait. That means we need to add
`content` to the `State` trait definition, and that is where weâ€™ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:
-->
<!-- markdownlint-enable -->
<p>A partir de lÃ , lorsque nous faisons appel Ã  <code>contenu</code> sur <code>&amp;Box&lt;dyn Etat&gt;</code>,
l'extrapolation de dÃ©rÃ©fÃ©rencement va s'appliquer sur le <code>&amp;</code> et le <code>Box</code> pour
que la mÃ©thode <code>contenu</code> puisse finalement Ãªtre appelÃ©e sur le type qui
implÃ©mente le trait <code>Etat</code>. Cela signifie que nous devons ajouter <code>contenu</code> Ã  la
dÃ©finition du trait <code>Etat</code>, et que c'est ici que nous allons placer la logique
pour le contenu Ã  retourner en fonction de quel Ã©tat nous avons, comme le montre
l'encart 17-18Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         self.state.as_ref().unwrap().content(self)
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
# }
# 
trait State {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

// --snip--
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
struct Published {}

impl State for Published {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.etat.as_ref().unwrap().contenu(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait Etat {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Publier {}

impl Etat for Publier {
    // -- partie masquÃ©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &amp;billet.contenu
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-18: Adding the `content` method to the `State`
trait</span>
-->
<p><span class="caption">Encart 17-18Â : ajout de la mÃ©thode <code>contenu</code> sur le trait
<code>Etat</code></span></p>
<!--
We add a default implementation for the `content` method that returns an empty
string slice. That means we donâ€™t need to implement `content` on the `Draft`
and `PendingReview` structs. The `Published` struct will override the `content`
method and return the value in `post.content`.
-->
<p>Nous avons ajoutÃ© une implÃ©mentation par dÃ©faut pour la mÃ©thode <code>contenu</code> qui
retourne une slice de chaÃ®ne de caractÃ¨res vide. Cela nous permet de ne pas
avoir Ã  implÃ©menter <code>contenu</code> sur les structures <code>Brouillon</code> et <code>EnRelecture</code>.
La structure <code>Publier</code> va remplacer la mÃ©thode <code>contenu</code> et retourner la valeur
prÃ©sente dans <code>billet.contenu</code>.</p>
<!--
Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. Weâ€™re taking a reference to a `post` as an argument and returning a
reference to part of that `post`, so the lifetime of the returned reference is
related to the lifetime of the `post` argument.
-->
<p>Remarquez aussi que nous devons annoter des durÃ©es de vie sur cette mÃ©thode,
comme nous l'avons vu au chapitre 10. Nous allons prendre en argument une
rÃ©fÃ©rence au <code>billet</code> et retourner une rÃ©fÃ©rence Ã  une partie de ce <code>billet</code>,
donc la durÃ©e de vie retournÃ©e par la rÃ©fÃ©rence est liÃ©e Ã  la durÃ©e de vie de
l'argument <code>billet</code>.</p>
<!--
And weâ€™re doneâ€”all of Listing 17-11 now works! Weâ€™ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout `Post`.
-->
<p>Et nous avons maintenant terminÃ©, tout le code de l'encart 17-11 fonctionne,
dÃ©sormaisÂ ! Nous avons implÃ©mentÃ© le patron Ã©tat avec les rÃ¨gles de notre
processus de publication dÃ©finies pour notre blog. La logique des rÃ¨gles sont
intÃ©grÃ©es dans les objets Ã©tat plutÃ´t que d'Ãªtre dispersÃ©e un peu partout dans
<code>Billet</code>.</p>
<!--
### Trade-offs of the State Pattern
-->
<h3><a class="header" href="#les-dÃ©savantages-du-patron-Ã©tat" id="les-dÃ©savantages-du-patron-Ã©tat">Les dÃ©savantages du patron Ã©tat</a></h3>
<!--
Weâ€™ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on `Post` know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the `State`
trait on the `Published` struct.
-->
<p>Nous avons dÃ©montrÃ© que Rust est capable d'implÃ©menter le patron Ã©tat qui est
orientÃ© objet pour regrouper les diffÃ©rents types de comportement qu'un billet
doit avoir Ã  chaque Ã©tat. Les mÃ©thodes sur <code>Billet</code> ne savent rien des
diffÃ©rents comportements. De la maniÃ¨re dont nous avons organisÃ© le code, nous
n'avons qu'Ã  regarder Ã  un seul endroit pour connaÃ®tre les diffÃ©rents
comportements qu'un billet publiÃ© va suivreÂ : l'implÃ©mentation du trait <code>Etat</code>
sur la structure <code>Publier</code>.</p>
<!--
If we were to create an alternative implementation that didnâ€™t use the state
pattern, we might instead use `match` expressions in the methods on `Post` or
even in the `main` code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those `match` expressions
would need another arm.
-->
<p>Si nous aurions utilitÃ© une autre faÃ§on d'implÃ©menter ces rÃ¨gles sans utiliser
le patron Ã©tat, nous aurions dÃ» utiliser des expressions <code>match</code> dans les
mÃ©thodes de <code>Billet</code> ou mÃªme dans le code du <code>main</code> qui vÃ©rifie que l'Ã©tat du
billet et les comportements associÃ©s aux changements d'Ã©tats. Cela aurait eu
pour consÃ©quence d'avoir Ã  regarder Ã  diffÃ©rents endroits pour comprendre toutes
les consÃ©quences de la publication d'un billetÂ ! Et ce code grossira au fur et
Ã  mesure que nous ajouterons des Ã©tatsÂ : chaque expression <code>match</code> devra avoir
des nouvelles branches pour ces nouveaux Ã©tats.</p>
<!--
With the state pattern, the `Post` methods and the places we use `Post` donâ€™t
need `match` expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.
-->
<p>Avec le patron Ã©tat, les mÃ©thodes de <code>Billet</code> et les endroits oÃ¹ nous utilisons
<code>Billet</code> n'ont pas besoin d'expressions <code>match</code>, et pour ajouter un nouvel Ã©tat,
nous avons seulement besoin d'ajouter une nouvelle structure et d'implÃ©menter
les mÃ©thodes du trait sur cette structure.</p>
<div id="suggestions-implementations">
<!--
The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:
-->
<p>L'implÃ©mentation qui utilise le patron Ã©tat est facile Ã  amÃ©liorer pour ajouter
plus de fonctionnalitÃ©s. Pour dÃ©couvrir la simplicitÃ© de maintenance du code qui
utilise le patron Ã©tat, essayez d'accomplir certaines de ces suggestionsÂ :</p>
<!--
* Add a `reject` method that changes the postâ€™s state from `PendingReview` back
  to `Draft`.
* Require two calls to `approve` before the state can be changed to `Published`.
* Allow users to add text content only when a post is in the `Draft` state.
  Hint: have the state object responsible for what might change about the
  content but not responsible for modifying the `Post`.
-->
<ul>
<li>Ajouter une mÃ©thode <code>rejeter</code> qui fait retourner l'Ã©tat d'un billet de
<code>EnRelecture</code> en <code>Brouillon</code>.</li>
<li>Attendre deux appels Ã  <code>approuver</code> avant que l'Ã©tat puisse Ãªtre changÃ© en
<code>Publier</code>.</li>
<li>Permettre aux utilisateurs pour ajouter du contenu textuel uniquement
lorsqu'un billet est Ã  l'Ã©tat <code>Brouillon</code>. AstuceÂ : l'objet Ã©tat est
responsable de ce qui peut changer dans le contenu mais pas responsable de la
modification de <code>Billet</code>.</li>
</ul>
</div>
<!--
One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between `PendingReview` and `Published`, such as `Scheduled`,
we would have to change the code in `PendingReview` to transition to
`Scheduled` instead. It would be less work if `PendingReview` didnâ€™t need to
change with the addition of a new state, but that would mean switching to
another design pattern.
-->
<p>Un dÃ©savantage du patron Ã©tat est que comme les Ã©tats implÃ©mentent les
transitions en les Ã©tats, certains des Ã©tats sont reliÃ©s entre eux. Si nous
ajoutons un nouvel Ã©tat entre <code>EnRelecture</code> et <code>Publier</code>, comme <code>Planifier</code>,
nous devrions alors changer le code dans <code>EnRelecture</code> pour qu'il passe ensuite
Ã  l'Ã©tat <code>Planifier</code> Ã  la place de <code>Publier</code>. Cela reprÃ©sentera moins de travail
si <code>EnRelecture</code> n'a pas besoin de changer lorsqu'on ajoute un nouvel Ã©tat, mais
cela signifiera alors qu'il faut changer de patron.</p>
<!--
Another downside is that weâ€™ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
`request_review` and `approve` methods on the `State` trait that return `self`;
however, this would violate object safety, because the trait doesnâ€™t know what
the concrete `self` will be exactly. We want to be able to use `State` as a
trait object, so we need its methods to be object safe.
-->
<p>Un autre dÃ©savantage et que nous avons de la logique en double. Pour Ã©viter ces
doublons, nous devrions essayer de faire en sorte que les mÃ©thodes
<code>demander_relecture</code> et <code>approuver</code> qui retournent <code>self</code> deviennent les
implÃ©mentations par dÃ©faut sur le trait <code>Etat</code>Â ; cependant, cela violera la
sÃ©curitÃ© des objets, car le trait ne sait pas ce qu'est exactement <code>self</code>. Nous
voulons pouvoir utiliser <code>Etat</code> en tant qu'objet trait, donc nous avons besoin
que ses mÃ©thodes soient sÃ»res pour les objets.</p>
<!--
Other duplication includes the similar implementations of the `request_review`
and `approve` methods on `Post`. Both methods delegate to the implementation of
the same method on the value in the `state` field of `Option` and set the new
value of the `state` field to the result. If we had a lot of methods on `Post`
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the [â€œMacrosâ€][macros]<!-- ignore -- > section in Chapter 19).
-->
<p>Nous avons aussi des doublons dans le code des mÃ©thodes <code>demander_relecture</code>
et <code>approuver</code> sur <code>Billet</code>. Ces deux mÃ©thodes dÃ©lÃ¨guent leur travail aux mÃªmes
mÃ©thodes respectives sur la valeur du champ <code>etat</code> de type <code>Option</code> et assignent
la valeur au mÃªme champ <code>etat</code> Ã  la fin. Si nous avions beaucoup de mÃ©thodes sur
<code>Billet</code> qui suivent cette logique, nous devrions considÃ©rer la crÃ©ation et
l'utilisation d'une macro pour Ã©viter cette rÃ©pÃ©tition (voir la
<a href="ch19-06-macros.html#macros">section dÃ©diÃ©e</a><!-- ignore --> dans le chapitre 19).</p>
<!--
By implementing the state pattern exactly as itâ€™s defined for object-oriented
languages, weâ€™re not taking as full advantage of Rustâ€™s strengths as we could.
Letâ€™s look at some changes we can make to the `blog` crate that can make
invalid states and transitions into compile time errors.
-->
<p>En implÃ©mentant le patron Ã©tat exactement comme il l'est dÃ©fini pour les
langages orientÃ©s-objet, nous ne profitons pas pleinement des avantages de
Rust. Voyons voir si nous pouvons faire quelques changements pour que la crate
<code>blog</code> puisse lever des erreurs Ã  la compilation lorsqu'elle aura dÃ©tectÃ© des
Ã©tats ou des transitions invalides.</p>
<!--
#### Encoding States and Behavior as Types
-->
<h4><a class="header" href="#implÃ©menter-les-Ã©tats-et-les-comportements-avec-des-types" id="implÃ©menter-les-Ã©tats-et-les-comportements-avec-des-types">ImplÃ©menter les Ã©tats et les comportements avec des types</a></h4>
<!--
Weâ€™ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, weâ€™ll encode the states into different
types. Consequently, Rustâ€™s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.
-->
<p>Nous allons vous montrer comment repenser le patron Ã©tat pour qu'il offre des
compromis diffÃ©rents. PlutÃ´t que d'intÃ©grer les Ã©tats et les transitions
complÃ¨tement de maniÃ¨re Ã  ce que le code externe ne puissent pas les connaÃ®tre,
nous allons transformer les Ã©tats dans diffÃ©rents types. En consÃ©quence, le
systÃ¨me de vÃ©rification de type de Rust va Ã©viter d'utiliser des brouillons de
billets en provoquant une erreur du compilateur dans les endroits oÃ¹ ils seront
utilisÃ©s alors que seuls les billets publiÃ©s seront autorisÃ©s.</p>
<!--
Letâ€™s consider the first part of `main` in Listing 17-11:
-->
<p>ConsidÃ©rons la premiÃ¨re partie du <code>main</code> de l'encart 17-11Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use blog::Post;
# 
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
# 
#     post.request_review();
#     assert_eq!("", post.content());
# 
#     post.approve();
#     assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use blog::Billet;
</span><span class="boring">
</span>fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());
<span class="boring">
</span><span class="boring">    billet.demander_relecture();
</span><span class="boring">    assert_eq!(&quot;&quot;, billet.contenu());
</span><span class="boring">
</span><span class="boring">    billet.approuver();
</span><span class="boring">    assert_eq!(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;, billet.contenu());
</span>}
</code></pre>
<!--
We still enable the creation of new posts in the draft state using `Post::new`
and the ability to add text to the postâ€™s content. But instead of having a
`content` method on a draft post that returns an empty string, weâ€™ll make it so
draft posts donâ€™t have the `content` method at all. That way, if we try to get
a draft postâ€™s content, weâ€™ll get a compiler error telling us the method
doesnâ€™t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code wonâ€™t even compile.
Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,
as well as methods on each:
-->
<p>Nous pouvons toujours crÃ©er de nouveaux billets Ã  l'Ã©tat de brouillon en
utilisant <code>Billet::new</code> et ajouter du texte au contenu du billet. Mais au lieu
d'avoir une mÃ©thode <code>contenu</code> sur un brouillon de billet qui retourne une chaÃ®ne
de caractÃ¨res vide, nous faisons en sorte que les brouillons de billets n'aient
mÃªme pas de mÃ©thode <code>contenu</code>. Ainsi, si nous essayons de rÃ©cupÃ©rer le contenu
d'un brouillon de billet, nous obtenons une erreur de compilation qui nous
informera que la mÃ©thode n'existe pas. Finalement, il nous sera impossible de
publier le contenu d'un brouillon de billet en production, car ce code ne se
compilera mÃªme pas. L'encart 17-19 nous propose les dÃ©finitions d'une structure
<code>Billet</code> et d'une structure <code>BrouillonDeBillet</code> ainsi que leurs mÃ©thodesÂ :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Billet {
    contenu: String,
}

pub struct BrouillonDeBillet {
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; BrouillonDeBillet {
        BrouillonDeBillet {
            contenu: String::new(),
        }
    }

    pub fn contenu(&amp;self) -&gt; &amp;str {
        &amp;self.contenu
    }
}

impl BrouillonDeBillet {
    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-19: A `Post` with a `content` method and a
`DraftPost` without a `content` method</span>
-->
<p><span class="caption">Encart 17-19Â : un <code>Billet</code> avec une mÃ©thode <code>contenu</code> et
un <code>BrouillonDeBillet</code> sans mÃ©thode <code>contenu</code></span></p>
<!--
Both the `Post` and `DraftPost` structs have a private `content` field that
stores the blog post text. The structs no longer have the `state` field because
weâ€™re moving the encoding of the state to the types of the structs. The `Post`
struct will represent a published post, and it has a `content` method that
returns the `content`.
-->
<p>Les deux structures <code>Billet</code> et <code>BrouillonDeBillet</code> ont un champ privÃ© <code>contenu</code>
qui stocke le texte du billet de blog. Les structures n'ont plus le champ <code>etat</code>
car nous avons dÃ©placÃ© la signification de l'Ã©tat directement dans le nom de ces
types de structures. La structure <code>Billet</code> reprÃ©sente un billet publiÃ©, et a une
mÃ©thode <code>contenu</code> qui retourne le <code>contenu</code>.</p>
<!--
We still have a `Post::new` function, but instead of returning an instance of
`Post`, it returns an instance of `DraftPost`. Because `content` is private
and there arenâ€™t any functions that return `Post`, itâ€™s not possible to create
an instance of `Post` right now.
-->
<p>Nous avons toujours la fonction <code>Billet::new</code>, mais au lieu de retourner une
instance de <code>Billet</code>, elle va retourner une instance de <code>BrouillonDeBillet</code>.
Comme <code>contenu</code> est privÃ© et qu'il n'y a pas de fonction qui retourne <code>Billet</code>,
il ne sera pas possible pour le moment de crÃ©er une instance de <code>Billet</code>.</p>
<!--
The `DraftPost` struct has an `add_text` method, so we can add text to
`content` as before, but note that `DraftPost` does not have a `content` method
defined! So now the program ensures all posts start as draft posts, and draft
posts donâ€™t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.
-->
<p>La structure <code>BrouillonDeBillet</code> a une mÃ©thode <code>ajouter_texte</code>, donc nous
pouvons ajouter du texte Ã  <code>contenu</code> comme nous le faisions avant, mais
remarquez toutefois que <code>BrouillonDeBillet</code> n'a pas de mÃ©thode <code>contenu</code> de
dÃ©finiÂ ! Donc pour l'instant le programme s'assure que tous les billets
dÃ©marrent Ã  l'Ã©tat de brouillon, et que les brouillons ne proposent pas de
contenu Ã  publier. Toute tentative d'outre-passer ces contraintes vont
dÃ©clencher des erreurs de compilation.</p>
<!--
#### Implementing Transitions as Transformations into Different Types
-->
<h4><a class="header" href="#implÃ©menter-les-changements-dÃ©tat-en-tant-que-changement-de-type" id="implÃ©menter-les-changements-dÃ©tat-en-tant-que-changement-de-type">ImplÃ©menter les changements d'Ã©tat en tant que changement de type</a></h4>
<!--
So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Letâ€™s implement
these constraints by adding another struct, `PendingReviewPost`, defining the
`request_review` method on `DraftPost` to return a `PendingReviewPost`, and
defining an `approve` method on `PendingReviewPost` to return a `Post`, as
shown in Listing 17-20:
-->
<p>Donc, comment publier un billetÂ ? Nous voulons renforcer la rÃ¨gle qui dit qu'un
brouillon de billet doit Ãªtre relu et approuvÃ© avant de pouvoir Ãªtre publiÃ©. Un
billet Ã  l'Ã©tat de relecture doit continuer Ã  ne pas montrer son contenu.
ImplÃ©mentons ces contraintes en introduisant une nouvelle structure,
<code>BilletEnRelecture</code>, en dÃ©finissant la mÃ©thode <code>demander_relecture</code> sur
<code>BrouillonDeBillet</code> pour retourner un <code>BilletEnRelecture</code>, et en dÃ©finissant une
mÃ©thode <code>approuver</code> sur <code>BilletEnRelecture</code> pour qu'elle retourne un <code>Billet</code>,
comme le propose l'encart 17-20Â :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     content: String,
# }
# 
# pub struct DraftPost {
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> DraftPost {
#         DraftPost {
#             content: String::new(),
#         }
#     }
# 
#     pub fn content(&self) -> &str {
#         &self.content
#     }
# }
# 
impl DraftPost {
    // --snip--
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct BrouillonDeBillet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; BrouillonDeBillet {
</span><span class="boring">        BrouillonDeBillet {
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.contenu
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl BrouillonDeBillet {
    // -- partie masquÃ©e ici --
<span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(self) -&gt; BilletEnRelecture {
        BilletEnRelecture {
            contenu: self.contenu,
        }
    }
}

pub struct BilletEnRelecture {
    contenu: String,
}

impl BilletEnRelecture {
    pub fn approuver(self) -&gt; Billet {
        Billet {
            contenu: self.contenu,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by
calling `request_review` on `DraftPost` and an `approve` method that turns a
`PendingReviewPost` into a published `Post`</span>
-->
<p><span class="caption">Encart 17-20Â : ajout d'un <code>BilletEnRelecture</code> qui est crÃ©Ã©
par l'appel Ã  <code>demander_relecture</code> sur <code>BrouillonDeBillet</code>, ainsi qu'une mÃ©thode
<code>approuver</code> qui transforme un <code>BilletEnRelecture</code> en <code>Billet</code> publiÃ©</span></p>
<!--
The `request_review` and `approve` methods take ownership of `self`, thus
consuming the `DraftPost` and `PendingReviewPost` instances and transforming
them into a `PendingReviewPost` and a published `Post`, respectively. This way,
we wonâ€™t have any lingering `DraftPost` instances after weâ€™ve called
`request_review` on them, and so forth. The `PendingReviewPost` struct doesnâ€™t
have a `content` method defined on it, so attempting to read its content
results in a compiler error, as with `DraftPost`. Because the only way to get a
published `Post` instance that does have a `content` method defined is to call
the `approve` method on a `PendingReviewPost`, and the only way to get a
`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,
weâ€™ve now encoded the blog post workflow into the type system.
-->
<p>Les mÃ©thodes <code>demander_relecture</code> et <code>approuver</code> prennent possession de <code>self</code>,
ce qui consomme les instances de <code>BrouillonDeBillet</code> et de <code>BilletEnRelecture</code>
pour les transformer respectivement en <code>BilletEnRelecture</code> et en <code>Billet</code>.
Ainsi, il ne restera plus d'instances de <code>BrouillonDeBillet</code> aprÃ¨s avoir appelÃ©
<code>approuver</code> sur elles, et ainsi de suite. La structure <code>BilletEnRelecture</code> n'a
pas de mÃ©thode <code>contenu</code> qui lui est dÃ©finie, donc si on essaye de lire son
contenu, on obtient une erreur de compilation, comme avec <code>BrouillonDeBillet</code>.
Comme la seule maniÃ¨re d'obtenir une instance de <code>Billet</code> qui a une mÃ©thode
<code>contenu</code> de dÃ©finie est d'appeler la mÃ©thode<code>approuver</code> sur un
<code>BilletEnRelecture</code>, et que la seule maniÃ¨re d'obtenir un <code>BilletEnRelecture</code>
est d'appeler la mÃ©thode <code>demander_relecture</code> sur un <code>BrouillonDeBillet</code>, nous
avons dÃ©sormais intÃ©grÃ© le processus de publication des billets de blog avec le
systÃ¨me de type.</p>
<!--
But we also have to make some small changes to `main`. The `request_review` and
`approve` methods return new instances rather than modifying the struct theyâ€™re
called on, so we need to add more `let post =` shadowing assignments to save
the returned instances. We also canâ€™t have the assertions about the draft and
pending review postâ€™s contents be empty strings, nor do we need them: we canâ€™t
compile code that tries to use the content of posts in those states any longer.
The updated code in `main` is shown in Listing 17-21:
-->
<p>Mais nous devons aussi faire quelques petits changements dans le <code>main</code>. Les
mÃ©thodes <code>demander_relecture</code> et <code>approuver</code> retournent des nouvelles instances
au lieu de modifier la structure sur laquelle elles ont Ã©tÃ© appelÃ©es, donc nous
devons ajouter des assignations de masquage <code>let billet =</code> pour stocker les
nouvelles instances retournÃ©es. Nous ne pouvons pas non plus vÃ©rifier que le
contenu des brouillons de billets et ceux en cours de relecture soient bien
vides, donc nous n'en avons plus besoinÂ : nous ne pouvons plus compiler du code
qui essaye d'utiliser le contenu d'un billet dans cet Ã©tat. Le code du <code>main</code>
mis Ã  jour est prÃ©sentÃ© dans l'encart 17-21Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;);

    let billet = billet.demander_relecture();

    let billet = billet.approuver();

    assert_eq!(&quot;J'ai mangÃ© une salade au dÃ©jeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-21: Modifications to `main` to use the new
implementation of the blog post workflow</span>
-->
<p><span class="caption">Encart 17-21Â : modification de <code>main</code> pour utiliser la
nouvelle implÃ©mentation du processus de publication de billet de blog</span></p>
<!--
The changes we needed to make to `main` to reassign `post` mean that this
implementation doesnâ€™t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the `Post` implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.
-->
<p>Les modifications dont nous avons besoin de faire au <code>main</code> pour rÃ©assigner
<code>billet</code> impliquent que cette implÃ©mentation ne suit plus exactement le patron
Ã©tat orientÃ©-objetÂ : les changements d'Ã©tats ne sont plus totalement intÃ©grÃ©s
dans l'implÃ©mentation de <code>Billet</code>. Cependant, nous faisons en sorte que les
Ã©tats invalides soient impossibles grÃ¢ce au systÃ¨me de types et que la
vÃ©rification de type s'effectue Ã  la compilationÂ ! Cela garantit que certains
bogues, comme l'affichage du contenu d'un billet non publiÃ©, sera dÃ©tectÃ© avant
avant d'arriver en production.</p>
<!--
Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the `blog` crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.
-->
<p>Essayez d'accomplir <a href="#suggestions-implementations">les suggestions proposÃ©es pour les conditions
supplÃ©mentaires que nous avons listÃ©s au dÃ©but de cette
section</a>, sur la crate <code>blog</code> telle qu'elle est
aprÃ¨s l'encart 17-20, pour vous faire une idÃ©e sur cette conception du code.
Notez aussi que certaines suggestions sont dÃ©jÃ  accomplies implicitement grÃ¢ce Ã 
cette conception.</p>
<!--
Weâ€™ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rustâ€™s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns wonâ€™t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages donâ€™t have.
-->
<p>Nous avons vu que mÃªme si Rust est capable d'implÃ©menter des patrons de
conception orientÃ©s-objet, les autres patrons, comme intÃ©grer l'Ã©tat dans le
systÃ¨me de type, est aussi possible en Rust. Ces patrons ont diffÃ©rents
avantages et dÃ©savantages. Bien que vous soyez familier avec les patrons
orientÃ©s-objet, vous gagnerez Ã  repenser les choses pour tirer avantage des
fonctionnalitÃ©s de Rust, comme la dÃ©tection de certains bogues Ã  la compilation.
Les patrons orientÃ©s-objet ne sont pas toujours la meilleure solution en Rust Ã 
cause de certaines de ses fonctionnalitÃ©s, comme la possession, que les langages
orientÃ©s-objet n'ont pas.</p>
<!--
## Summary
-->
<h2><a class="header" href="#rÃ©sumÃ©" id="rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your codeâ€™s
maintainability. Rust also has other features, like ownership, that
object-oriented languages donâ€™t have. An object-oriented pattern wonâ€™t always
be the best way to take advantage of Rustâ€™s strengths, but is an available
option.
-->
<p>Que vous pensiez ou non que Rust est un langage orientÃ©-objet aprÃ¨s avoir lu ce
chapitre, vous savez maintenant que vous pouvez utiliser les objets trait pour
pouvoir obtenir certaines fonctionnalitÃ©s orientÃ©-objet en Rust. La rÃ©partition
dynamique peut offrir de la flexibilitÃ© Ã  votre code en Ã©change d'une perte de
performances Ã  l'exÃ©cution. Vous pouvez utiliser cette flexibilitÃ© pour
implÃ©menter des patrons orientÃ©s-objet qui puissent aider la maintenance de
votre code. Rust offre d'autres fonctionnalitÃ©s, comme la possession, que les
langages orientÃ©s-objet n'ont pas. L'utilisation d'un patron orientÃ©-objet n'est
pas toujours la meilleure maniÃ¨re de tirer parti des avantages de Rust, mais
cela reste une option disponible.</p>
<!--
Next, weâ€™ll look at patterns, which are another of Rustâ€™s features that enable
lots of flexibility. Weâ€™ve looked at them briefly throughout the book but
havenâ€™t seen their full capability yet. Letâ€™s go!
-->
<p>Dans le chapitre suivant, nous allons Ã©tudier les motifs, qui est une autre des
fonctionnalitÃ©s de Rust qui offre beaucoup de flexibilitÃ©. Nous les avons
rencontrÃ©s briÃ¨vement dans le livre, mais nous n'avons pas encore vu tout leur
potentiel. C'est partiÂ !</p>
<!-- markdownlint-disable -->
<!--
[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch17-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch18-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch17-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch18-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
