<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Importer des chemins dans la portÃ©e via le mot-clÃ© use - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="active"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸš§ Les types gÃ©nÃ©riques, les traits et les durÃ©es de vies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Bringing Paths into Scope with the `use` Keyword
-->
<h2 id="importer-des-chemins-dans-la-portÃ©e-via-le-mot-clÃ©-use"><a class="header" href="#importer-des-chemins-dans-la-portÃ©e-via-le-mot-clÃ©-use">Importer des chemins dans la portÃ©e via le mot-clÃ© <code>use</code></a></h2>
<!--
It might seem like the paths weâ€™ve written to call functions so far are
inconveniently long and repetitive. For example, in Listing 7-7, whether we
chose the absolute or relative path to the `add_to_waitlist` function, every
time we wanted to call `add_to_waitlist` we had to specify `front_of_house` and
`hosting` too. Fortunately, thereâ€™s a way to simplify this process. We can
bring a path into a scope once and then call the items in that path as if
theyâ€™re local items with the `use` keyword.
-->
<p>Les chemins que nous avons Ã©crits jusqu'ici peuvent paraÃ®tre pÃ©nibles car trop
longs et rÃ©pÃ©titifs. Par exemple, dans l'encart 7-7, que nous ayons choisi
d'utiliser le chemin absolu ou relatif pour la fonction
<code>ajouter_a_la_liste_attente</code>, nous aurions dÃ» aussi Ã©crire <code>salle_a_manger</code> et
<code>accueil</code> Ã  chaque fois que nous voulions appeler <code>ajouter_a_la_liste_attente</code>.
Heureusement, il existe une solution pour simplifier ce cheminement.
Nous pouvons importer un chemin dans la portÃ©e et appeler ensuite les Ã©lÃ©ments
de ce chemin comme s'ils Ã©taient locaux grÃ¢ce au mot-clÃ© <code>use</code>.</p>
<!--
In Listing 7-11, we bring the `crate::front_of_house::hosting` module into the
scope of the `eat_at_restaurant` function so we only have to specify
`hosting::add_to_waitlist` to call the `add_to_waitlist` function in
`eat_at_restaurant`.
-->
<p>Dans l'encart 7-11, nous importons le module <code>crate::salle_a_manger::accueil</code>
dans la portÃ©e de la fonction <code>manger_au_restaurant</code> afin que nous n'ayons plus
qu'Ã  utiliser <code>accueil::ajouter_a_la_liste_attente</code> pour appeler la fonction
<code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-11: Bringing a module into scope with
`use`</span>
-->
<p><span class="caption">Encart 7-11Â : importer un module dans la portÃ©e via <code>use</code>
</span></p>
<!--
Adding `use` and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding `use crate::front_of_house::hosting` in the crate
root, `hosting` is now a valid name in that scope, just as though the `hosting`
module had been defined in the crate root. Paths brought into scope with `use`
also check privacy, like any other paths.
-->
<p>Dans une portÃ©e, utiliser un <code>use</code> et un chemin s'apparente Ã  crÃ©er un lien
symbolique dans le systÃ¨me de fichier. GrÃ¢ce Ã  l'ajout de
<code>use crate::salle_a_manger::accueil</code> Ã  la racine de la crate, <code>accueil</code> est
maintenant un nom valide dans cette portÃ©e, comme si le module <code>accueil</code> avait
Ã©tÃ© dÃ©fini Ã  la racine de la crate. Les chemins importÃ©s dans la portÃ©e via
<code>use</code> doivent respecter les rÃ¨gles de visibilitÃ©, tout comme les autres chemins.</p>
<!--
You can also bring an item into scope with `use` and a relative path. Listing
7-12 shows how to specify a relative path to get the same behavior as in
Listing 7-11.
-->
<p>Vous pouvez aussi importer un Ã©lÃ©ment dans la portÃ©e avec <code>use</code> et un chemin
relatif. L'encart 7-12 nous montre comment utiliser un chemin relatif pour
obtenir le mÃªme rÃ©sultat que l'encart 7-11.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-12: Bringing a module into scope with `use` and
a relative path</span>
-->
<p><span class="caption">Encart 7-12Â : importer un module dans la portÃ©e avec <code>use</code>
et un chemin relatif</span></p>
<!--
### Creating Idiomatic `use` Paths
-->
<h3 id="crÃ©er-des-chemins-idÃ©aux-pour-use"><a class="header" href="#crÃ©er-des-chemins-idÃ©aux-pour-use">CrÃ©er des chemins idÃ©aux pour <code>use</code></a></h3>
<!--
In Listing 7-11, you might have wondered why we specified `use
crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` in
`eat_at_restaurant` rather than specifying the `use` path all the way out to
the `add_to_waitlist` function to achieve the same result, as in Listing 7-13.
-->
<p>Dans l'encart 7-11, vous vous Ãªtes peut-Ãªtre demandÃ© pourquoi nous avions
utilisÃ© <code>use crate::salle_a_manger::accueil</code> et appelÃ© ensuite
<code>accueil::ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code> plutÃ´t que
d'Ã©crire le chemin du <code>use</code> jusqu'Ã  la fonction <code>ajouter_a_la_liste_attente</code>
pour avoir le mÃªme rÃ©sultat, comme dans l'encart 7-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil::ajouter_a_la_liste_attente;

pub fn manger_au_restaurant() {
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-13: Bringing the `add_to_waitlist` function
into scope with `use`, which is unidiomatic</span>
-->
<p><span class="caption">Encart 7-13Â : importer la fonction
<code>ajouter_a_la_liste_attente</code> dans la portÃ©e avec <code>use</code>, ce qui n'est pas idÃ©al
</span></p>
<!--
Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with `use`. Bringing the
functionâ€™s parent module into scope with `use` so we have to specify the parent
module when calling the function makes it clear that the function isnâ€™t locally
defined while still minimizing repetition of the full path. The code in Listing
7-13 is unclear as to where `add_to_waitlist` is defined.
-->
<p>Bien que l'encart 7-11 et 7-13 accomplissent la mÃªme tÃ¢che, l'encart 7-11 est la
faÃ§on idÃ©ale d'importer une fonction dans la portÃ©e via <code>use</code>. Le fait
d'importer le module parent de la fonction dans notre portÃ©e avec <code>use</code>, de
sorte que nous ayons Ã  prÃ©ciser le module parent quand nous appelons la
fonction, prÃ©cise clairement que la fonction n'est pas dÃ©finie localement, tout
en minimisant la rÃ©pÃ©tition du chemin complet. Nous ne pouvons pas repÃ©rer
facilement lÃ  oÃ¹ est dÃ©fini <code>ajouter_a_la_liste_attente</code> dans l'encart 7-13.</p>
<!--
On the other hand, when bringing in structs, enums, and other items with `use`,
itâ€™s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard libraryâ€™s `HashMap` struct into the scope of a binary
crate.
-->
<p>Cela dit, lorsque nous importons des structures, des Ã©numÃ©rations, et d'autres
Ã©lÃ©ments avec <code>use</code>, il est idÃ©al de prÃ©ciser le chemin complet. L'encart 7-14
montre la maniÃ¨re idÃ©ale d'importer la structure <code>HashMap</code> de la bibliothÃ¨que
standard dans la portÃ©e d'une crate binaire.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<!--
<span class="caption">Listing 7-14: Bringing `HashMap` into scope in an
idiomatic way</span>
-->
<p><span class="caption">Encart 7-14Â : import de <code>HashMap</code> dans la portÃ©e de
maniÃ¨re idÃ©ale</span></p>
<!--
Thereâ€™s no strong reason behind this idiom: itâ€™s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.
-->
<p>Il n'y a pas de forte justification Ã  cette pratiqueÂ : c'est simplement une
convention qui a germÃ©, et les gens se sont habituÃ©s Ã  lire et Ã©crire du code
Rust de cette faÃ§on.</p>
<!--
The exception to this idiom is if weâ€™re bringing two items with the same name
into scope with `use` statements, because Rust doesnâ€™t allow that. Listing 7-15
shows how to bring two `Result` types into scope that have the same name but
different parent modules and how to refer to them.
-->
<p>Il y a une exception Ã  cette pratiqueÂ : nous ne pouvons pas utiliser
l'instruction <code>use</code> pour importer deux Ã©lÃ©ments avec le mÃªme nom dans la portÃ©e,
car Rust ne l'autorise pas. L'encart 7-15 nous montre comment importer puis
utiliser deux types <code>Result</code> ayant le mÃªme nom mais dont les modules parents
sont distincts.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
#     Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn fonction1() -&gt; fmt::Result {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; io::Result&lt;()&gt; {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span>
-->
<p><span class="caption">Encart 7-15Â : l'import de deux types ayant le mÃªme nom
dans la mÃªme portÃ©e nÃ©cessite d'utiliser leurs modules parents.</span></p>
<!--
As you can see, using the parent modules distinguishes the two `Result` types.
If instead we specified `use std::fmt::Result` and `use std::io::Result`, weâ€™d
have two `Result` types in the same scope and Rust wouldnâ€™t know which one we
meant when we used `Result`.
-->
<p>Comme vous pouvez le constater, l'utilisation des modules parents permet de
distinguer les deux types <code>Result</code>. Si nous avions utilisÃ©
<code>use std::fmt::Result</code> et <code>use std::io::Result</code>, nous aurions deux types nommÃ©s
<code>Result</code> dans la mÃªme portÃ©e et donc Rust ne pourrait pas comprendre lequel nous
voudrions utiliser en demandant <code>Result</code>.</p>
<!--
### Providing New Names with the `as` Keyword
-->
<h3 id="renommer-des-Ã©lÃ©ments-avec-le-mot-clÃ©-as"><a class="header" href="#renommer-des-Ã©lÃ©ments-avec-le-mot-clÃ©-as">Renommer des Ã©lÃ©ments avec le mot-clÃ© <code>as</code></a></h3>
<!--
Thereâ€™s another solution to the problem of bringing two types of the same name
into the same scope with `use`: after the path, we can specify `as` and a new
local name, or alias, for the type. Listing 7-16 shows another way to write the
code in Listing 7-15 by renaming one of the two `Result` types using `as`.
-->
<p>Il y a une autre solution au fait d'avoir deux types du mÃªme nom dans la mÃªme
portÃ©e Ã  cause de <code>use</code>Â : aprÃ¨s le chemin, nous pouvons rajouter <code>as</code> suivi d'un
nouveau nom local, ou alias, sur le type. L'encart 7-16 nous montre une autre
faÃ§on d'Ã©crire le code de l'encart 7-15 en utilisant <code>as</code> pour renommer un des
deux types <code>Result</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
#     Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn fonction1() -&gt; Result {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; IoResult&lt;()&gt; {
    // -- partie masquÃ©e ici --
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-16: Renaming a type when itâ€™s brought into
scope with the `as` keyword</span>
-->
<p><span class="caption">Encart 7-16Â : renommer un type lorsqu'il est importÃ© dans
la portÃ©e, avec le mot-clÃ© <code>as</code></span></p>
<!--
In the second `use` statement, we chose the new name `IoResult` for the
`std::io::Result` type, which wonâ€™t conflict with the `Result` from `std::fmt`
that weâ€™ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!
-->
<p>Dans la seconde instruction <code>use</code>, nous avons choisi <code>IoResult</code> comme nouveau
nom du type <code>std::io::Result</code>, qui n'est plus en conflit avec le <code>Result</code> de
<code>std::fmt</code> que nous avons aussi importÃ© dans la portÃ©e. Les encarts 7-15 et 7-16
sont idÃ©aux, donc le choix vous revientÂ !</p>
<!--
### Re-exporting Names with `pub use`
-->
<h3 id="rÃ©exporter-des-Ã©lÃ©ments-avec-pub-use"><a class="header" href="#rÃ©exporter-des-Ã©lÃ©ments-avec-pub-use">RÃ©exporter des Ã©lÃ©ments avec <code>pub use</code></a></h3>
<!--
When we bring a name into scope with the `use` keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that codeâ€™s scope, we can combine `pub`
and `use`. This technique is called *re-exporting* because weâ€™re bringing
an item into scope but also making that item available for others to bring into
their scope.
-->
<p>Lorsque nous importons un Ã©lÃ©ment dans la portÃ©e avec le mot-clÃ© <code>use</code>, son nom
dans la nouvelle portÃ©e est privÃ©. Pour permettre au code appelant d'utiliser ce
nom comme s'il Ã©tait dÃ©fini dans cette portÃ©e, nous pouvons associer <code>pub</code> et
<code>use</code>. Cette technique est appelÃ©e <em>rÃ©exporter</em> car nous importons un Ã©lÃ©ment
dans la portÃ©e, mais nous rendons aussi cet Ã©lÃ©ment disponible aux portÃ©es des
autres.</p>
<!--
Listing 7-17 shows the code in Listing 7-11 with `use` in the root module
changed to `pub use`.
-->
<p>L'encart 7-17 nous montre le code de l'encart 7-11 oÃ¹ le <code>use</code> du module racine
a Ã©tÃ© remplacÃ© par <code>pub use</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with `pub use`</span>
-->
<p><span class="caption">Encart 7-17Â : rendre un Ã©lÃ©ment disponible pour n'importe
quel code qui l'importera dans sa portÃ©e, avec <code>pub use</code></span></p>
<!--
By using `pub use`, external code can now call the `add_to_waitlist` function
using `hosting::add_to_waitlist`. If we hadnâ€™t specified `pub use`, the
`eat_at_restaurant` function could call `hosting::add_to_waitlist` in its
scope, but external code couldnâ€™t take advantage of this new path.
-->
<p>GrÃ¢ce Ã  <code>pub use</code>, le code externe peut maintenant appeler la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant <code>accueil::ajouter_a_la_liste_attente</code>.
Si nous n'avions pas utilisÃ© <code>pub use</code>, la fonction <code>manger_au_restaurant</code>
aurait pu appeler <code>accueil::ajouter_a_la_liste_attente</code> dans sa portÃ©e, mais le
code externe n'aurait pas pu profiter de ce nouveau chemin.</p>
<!--
Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about â€œfront of houseâ€ and â€œback of house.â€ But customers visiting a restaurant
probably wonâ€™t think about the parts of the restaurant in those terms. With
`pub use`, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.
-->
<p>RÃ©exporter est utile quand la structure interne de votre code est diffÃ©rente de
la faÃ§on dont les dÃ©veloppeurs qui utilisent votre code se la reprÃ©sentent. Par
exemple, dans cette mÃ©taphore du restaurant, les personnes qui font fonctionner
le restaurant se structurent en fonction de la â€œsalle Ã  mangerâ€ et des
â€œcuisinesâ€. Mais les clients qui utilisent le restaurant ne vont probablement
pas voir les choses ainsi. Avec <code>pub use</code>, nous pouvons Ã©crire notre code selon
une certaine organisation, mais l'exposer avec une organisation diffÃ©rente. En
faisant ainsi, la bibliothÃ¨que est bien organisÃ©e autant pour les dÃ©veloppeurs
qui travaillent sur la bibliothÃ¨que que pour les dÃ©veloppeurs qui utilisent la
bibliothÃ¨que.</p>
<!--
### Using External Packages
-->
<h3 id="utiliser-des-paquets-externes"><a class="header" href="#utiliser-des-paquets-externes">Utiliser des paquets externes</a></h3>
<!--
In Chapter 2, we programmed a guessing game project that used an external
package called `rand` to get random numbers. To use `rand` in our project, we
added this line to *Cargo.toml*:
-->
<p>Dans le chapitre 2, nous avions dÃ©veloppÃ© un projet de jeu du plus ou du moins
qui utilisait le paquet externe <code>rand</code> afin d'obtenir des nombres alÃ©atoires.
Pour pouvoir utiliser <code>rand</code> dans notre projet, nous avions ajoutÃ© cette ligne
dans <em>Cargo.toml</em>Â :</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">FichierÂ : Cargo.toml</span></p>
<!--
```toml
[dependencies]
rand = "0.5.5"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<!--
Adding `rand` as a dependency in *Cargo.toml* tells Cargo to download the
`rand` package and any dependencies from [crates.io](https://crates.io/) and
make `rand` available to our project.
-->
<p>L'ajout de <code>rand</code> comme dÃ©pendance dans <em>Cargo.toml</em> demande Ã  Cargo de
tÃ©lÃ©charger le paquet <code>rand</code> et toutes ses dÃ©pendances Ã  partir de
<a href="https://crates.io/">crates.io</a> et rend disponible <code>rand</code> pour notre projet.</p>
<!--
Then, to bring `rand` definitions into the scope of our package, we added a
`use` line starting with the name of the crate, `rand`, and listed the items
we wanted to bring into scope. Recall that in the [â€œGenerating a Random
Numberâ€][rand]<!-- ignore -- > section in Chapter 2, we brought the `Rng` trait
into scope and called the `rand::thread_rng` function:
-->
<p>Ensuite, pour importer les dÃ©finitions de <code>rand</code> dans la portÃ©e de notre paquet,
nous avions ajoutÃ© une ligne <code>use</code> qui commence avec le nom de la crate, <code>rand</code>,
et nous avions listÃ© les Ã©lÃ©ments que nous voulions importer dans notre portÃ©e.
Dans la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">â€œGÃ©nÃ©rer le nombre secretâ€</a><!-- ignore --> du chapitre 2,
nous avions importÃ© le trait <code>Rng</code> dans la portÃ©e, puis nous avions appelÃ© la
fonction <code>rand::thread_rng</code>Â :</p>
<!--
```rust,ignore
# use std::io;
use rand::Rng;

fn main() {
#     println!("Guess the number!");
# 
    let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span>    let nombre_secret = rand::thread_rng().gen_range(1, 101);
<span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span>}
</code></pre>
<!--
Members of the Rust community have made many packages available at
[crates.io](https://crates.io/), and pulling any of them into your package
involves these same steps: listing them in your packageâ€™s *Cargo.toml* file and
using `use` to bring items from their crates into scope.
-->
<p>Les membres de la communautÃ© Rust ont mis Ã  disposition de nombreux paquets sur
<a href="https://crates.io/">crates.io</a>, et utiliser l'un d'entre eux dans votre paquet
implique toujours ces mÃªmes Ã©tapesÂ : les lister dans le fichier <em>Cargo.toml</em> de
votre paquet et utiliser <code>use</code> pour importer certains Ã©lÃ©ments de ces crates
dans la portÃ©e.</p>
<!--
Note that the standard library (`std`) is also a crate thatâ€™s external to our
package. Because the standard library is shipped with the Rust language, we
donâ€™t need to change *Cargo.toml* to include `std`. But we do need to refer to
it with `use` to bring items from there into our packageâ€™s scope. For example,
with `HashMap` we would use this line:
-->
<p>Notez que la bibliothÃ¨que standard (<code>std</code>) est aussi une crate qui est externe Ã 
notre paquet. Comme la bibliothÃ¨que standard est livrÃ©e avec le langage Rust,
nous n'avons pas Ã  modifier le <em>Cargo.toml</em> pour y inclure <code>std</code>. Mais nous
devons utiliser <code>use</code> pour importer les Ã©lÃ©ments qui se trouvent dans la portÃ©e
de notre paquet. Par exemple, pour <code>HashMap</code>, nous pourrions utiliser cette
ligneÂ :</p>
<!--
```rust
use std::collections::HashMap;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<!--
This is an absolute path starting with `std`, the name of the standard library
crate.
-->
<p>C'est un chemin absolu qui commence par <code>std</code>, le nom de la crate de la
bibliothÃ¨que standard.</p>
<!--
### Using Nested Paths to Clean Up Large `use` Lists
-->
<h3 id="utiliser-des-chemins-imbriquÃ©s-pour-simplifier-les-grandes-listes-de-use"><a class="header" href="#utiliser-des-chemins-imbriquÃ©s-pour-simplifier-les-grandes-listes-de-use">Utiliser des chemins imbriquÃ©s pour simplifier les grandes listes de <code>use</code></a></h3>
<!--
If weâ€™re using multiple items defined in the same crate or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two `use` statements we had in the Guessing Game in
Listing 2-4 bring items from `std` into scope:
-->
<p>Si vous utilisez de nombreux Ã©lÃ©ments dÃ©finis dans une mÃªme crate ou dans un
mÃªme module, lister chaque Ã©lÃ©ment sur sa propre ligne prendra beaucoup d'espace
vertical dans vos fichiers. Par exemple, ces deux instructions <code>use</code>, que nous
avions dans le jeu du plus ou du moins dans l'encart 2-4, importaient des
Ã©lÃ©ments de <code>std</code> dans la portÃ©eÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masquÃ©e ici --
use std::cmp::Ordering;
use std::io;
// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.
-->
<p>Ã€ la place, nous pouvons utiliser des chemins imbriquÃ©s afin d'importer ces
mÃªmes Ã©lÃ©ments dans la portÃ©e en une seule ligne. Nous pouvons faire cela en
indiquant la partie commune du chemin, suivi d'un double deux-points, puis
d'accolades autour d'une liste des Ã©lÃ©ments qui diffÃ¨rent entre les chemins,
comme dans l'encart 7-18Â :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1, 101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masquÃ©e ici --
use std::{cmp::Ordering, io};
// -- partie masquÃ©e ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret estÂ : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Ã‰chec de la lecture de l'entrÃ©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez saisir un nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombreÂ : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagnÃ©Â !&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span>
-->
<p><span class="caption">Encart 7-18Â : utiliser un chemin imbriquÃ© pour importer
plusieurs Ã©lÃ©ments avec le mÃªme prÃ©fixe dans la portÃ©e</span></p>
<!--
In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate `use` statements
needed by a lot!
-->
<p>Pour des programmes plus gros, importer plusieurs Ã©lÃ©ments dans la portÃ©e depuis
la mÃªme crate ou module en utilisant des chemins imbriquÃ©s peut rÃ©duire
considÃ©rablement le nombre de <code>use</code> utilisÃ©sÂ !</p>
<!--
We can use a nested path at any level in a path, which is useful when combining
two `use` statements that share a subpath. For example, Listing 7-19 shows two
`use` statements: one that brings `std::io` into scope and one that brings
`std::io::Write` into scope.
-->
<p>Nous pouvons utiliser un chemin imbriquÃ© Ã  tous les niveaux d'un chemin, ce qui
peut Ãªtre utile lorsqu'on utilise deux instructions <code>use</code> qui partagent un
sous-chemin. Par exemple, l'encart 7-19 nous montre deux instructions <code>use</code>Â :
une qui importe <code>std::io</code> dans la portÃ©e et une autre qui importe
<code>std::io::Write</code> dans la portÃ©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::io;
use std::io::Write;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-19: Two `use` statements where one is a subpath
of the other</span>
-->
<p><span class="caption">Encart 7-19Â : deux instructions <code>use</code> oÃ¹ l'une est un
sous-chemin de l'autre</span></p>
<!--
The common part of these two paths is `std::io`, and thatâ€™s the complete first
path. To merge these two paths into one `use` statement, we can use `self` in
the nested path, as shown in Listing 7-20.
-->
<p>La partie commune entre ces deux chemins est <code>std::io</code>, et c'est le premier
chemin complet. Pour imbriquer ces deux chemins en une seule instruction <code>use</code>,
nous pouvons utiliser <code>self</code> dans le chemin imbriquÃ©, comme dans l'encart 7-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">FichierÂ : src/lib.rs</span></p>
<!--
```rust
use std::io::{self, Write};
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one `use` statement</span>
-->
<p><span class="caption">Encart 7-20Â : imbrication des chemins de l'encart 7-19
dans une seule instruction <code>use</code></span></p>
<!--
This line brings `std::io` and `std::io::Write` into scope.
-->
<p>Cette ligne importe <code>std::io</code> et <code>std::io::Write</code> dans la portÃ©e.</p>
<!--
### The Glob Operator
-->
<h3 id="lopÃ©rateur-global"><a class="header" href="#lopÃ©rateur-global">L'opÃ©rateur global</a></h3>
<!--
If we want to bring *all* public items defined in a path into scope, we can
specify that path followed by `*`, the glob operator:
-->
<p>Si nous voulons importer, dans la portÃ©e, <em>tous</em> les Ã©lÃ©ments publics dÃ©finis
dans un chemin, nous pouvons indiquer ce chemin suivi par <code>*</code>, l'opÃ©rateur
globalÂ :</p>
<!--
```rust
use std::collections::*;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This `use` statement brings all public items defined in `std::collections` into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.
-->
<p>Cette instruction <code>use</code> va importer tous les Ã©lÃ©ments publics dÃ©finis dans
<code>std::collections</code> dans la portÃ©e courante. Mais soyez prudent quand vous
utilisez l'opÃ©rateur globalÂ ! L'opÃ©rateur global rend difficile Ã  dire quels
Ã©lÃ©ments sont dans la portÃ©e et lÃ  oÃ¹ un Ã©lÃ©ment utilisÃ© dans notre programme a
Ã©tÃ© dÃ©fini.</p>
<!--
The glob operator is often used when testing to bring everything under test
into the `tests` module; weâ€™ll talk about that in the [â€œHow to Write
Testsâ€][writing-tests]<!-- ignore -- > section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see [the standard
library documentation](../std/prelude/index.html#other-preludes)<!-- ignore -- >
for more information on that pattern.
-->
<p>L'opÃ©rateur global est souvent utilisÃ© lorsque nous Ã©crivons des tests, pour
importer tout ce qu'il y a Ã  tester dans le module <code>tests</code>Â ; nous verrons cela
dans une section du <a href="ch11-01-writing-tests.html">chapitre 11</a>. L'opÃ©rateur global est parfois
aussi utilisÃ© pour l'Ã©tape prÃ©liminaireÂ : rendez-vous dans <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">la documentation de
la bibliothÃ¨que
standard</a><!--
ignore --> pour plus d'informations sur cela.</p>
<!--
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
[writing-tests]: ch11-01-writing-tests.html#how-to-write-tests
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch07-05-separating-modules-into-different-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch07-05-separating-modules-into-different-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
