<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paniquer ou ne pas paniquer, telle est la question - Le langage de programmation Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html" class="active"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸš§ Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸš§ DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸš§ La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> ğŸš§ Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> ğŸš§ Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> ğŸš§ GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> ğŸš§ L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸš§ Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸš§ RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸš§ Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸš§ Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸš§ DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸš§ Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸš§ Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> ğŸš§ En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> ğŸš§ Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> ğŸš§ Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> ğŸš§ Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> ğŸš§ Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> ğŸš§ Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸš§ Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸš§ Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸš§ ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸš§ ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸš§ Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸš§ RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸš§ Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> ğŸš§ La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> ğŸš§ Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> ğŸš§ Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> ğŸš§ Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> ğŸš§ Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸš§ Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸš§ Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸš§ ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> ğŸš§ Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> ğŸš§ Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> ğŸš§ La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> ğŸš§ La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> ğŸš§ Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> ğŸš§ Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> ğŸš§ Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> ğŸš§ Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> ğŸš§ Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> ğŸš§ Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> ğŸš§ Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> ğŸš§ DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> ğŸš§ Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ğŸš§ ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> ğŸš§ Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> ğŸš§ A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## To `panic!` or Not to `panic!`
-->
<h2 id="paniquer-ou-ne-pas-paniquer-telle-est-la-question"><a class="header" href="#paniquer-ou-ne-pas-paniquer-telle-est-la-question">Paniquer ou ne pas paniquer, telle est la question</a></h2>
<!--
So how do you decide when you should call `panic!` and when you should return
`Result`? When code panics, thereâ€™s no way to recover. You could call `panic!`
for any error situation, whether thereâ€™s a possible way to recover or not, but
then youâ€™re making the decision on behalf of the code calling your code that a
situation is unrecoverable. When you choose to return a `Result` value, you
give the calling code options rather than making the decision for it. The
calling code could choose to attempt to recover in a way thatâ€™s appropriate for
its situation, or it could decide that an `Err` value in this case is
unrecoverable, so it can call `panic!` and turn your recoverable error into an
unrecoverable one. Therefore, returning `Result` is a good default choice when
youâ€™re defining a function that might fail.
-->
<p>Comment dÃ©cider si vous devez utiliser <code>panic!</code> ou si vous devez retourner un
<code>Result</code>Â ? Quand un code panique, il n'y a pas de moyen de rÃ©cupÃ©rer la
situation. Vous pourriez utiliser <code>panic!</code> pour n'importe quelle situation
d'erreur, peu importe s'il est possible de rÃ©cupÃ©rer la situation ou non, mais
vous prenez alors la dÃ©cision de tout arrÃªter Ã  la place du code qui appelle
votre code. Lorsque vous choisissez de retourner une valeur <code>Result</code>, vous
donnez plus de choix au code appelant plutÃ´t que de prendre des dÃ©cisions Ã  sa
place. Le code appelant peut choisir d'essayer de rÃ©cupÃ©rer l'erreur de maniÃ¨re
appropriÃ©e Ã  la situation, ou il peut dÃ©cider que dans ce cas une valeur <code>Err</code>
est irrÃ©cupÃ©rable, et va donc utiliser <code>panic!</code> et transformer votre erreur
rÃ©cupÃ©rable en erreur irrÃ©cupÃ©rable. Ainsi, retourner <code>Result</code> est un bon choix
par dÃ©faut lorsque vous dÃ©finissez une fonction qui peut Ã©chouer.</p>
<!--
In rare situations, itâ€™s more appropriate to write code that panics instead of
returning a `Result`. Letâ€™s explore why itâ€™s appropriate to panic in examples,
prototype code, and tests. Then weâ€™ll discuss situations in which the compiler
canâ€™t tell that failure is impossible, but you as a human can. The chapter will
conclude with some general guidelines on how to decide whether to panic in
library code.
-->
<p>Dans certaines situations, il est plus appropriÃ© d'Ã©crire du code qui panique
plutÃ´t que de retourner un <code>Result</code>. Nous allons voir pourquoi il est appropriÃ©
de paniquer dans les exemples, les prototypes et les tests. Ensuite, nous
verrons des situations dans lesquelles vous savez en tant qu'humain qu'un
code ne peut pas Ã©chouer, mais que le compilateur ne peut pas le dÃ©duire par
lui-mÃªme. Puis nous allons conclure le chapitre par quelques lignes directrices
gÃ©nÃ©rales pour dÃ©cider s'il faut paniquer dans le code d'une bibliothÃ¨que.</p>
<!--
### Examples, Prototype Code, and Tests
-->
<h3 id="les-exemples-les-prototypes-et-les-tests"><a class="header" href="#les-exemples-les-prototypes-et-les-tests">Les exemples, les prototypes et les tests</a></h3>
<!--
When youâ€™re writing an example to illustrate some concept, having robust
error-handling code in the example as well can make the example less clear. In
examples, itâ€™s understood that a call to a method like `unwrap` that could
panic is meant as a placeholder for the way youâ€™d want your application to
handle errors, which can differ based on what the rest of your code is doing.
-->
<p>Lorsque vous Ã©crivez un exemple pour illustrer un concept, avoir un code de
gestion des erreurs trÃ¨s rÃ©silient peut nuire Ã  la clartÃ© de l'exemple. Dans
les exemples, il est courant d'utiliser une mÃ©thode comme <code>unwrap</code> (qui peut
faire un panic) pour remplacer le code de gestion de l'erreur que vous
utiliseriez en temps normal dans votre application, et qui peut changer en
fonction de ce que le reste de votre code va faire.</p>
<!--
Similarly, the `unwrap` and `expect` methods are very handy when prototyping,
before youâ€™re ready to decide how to handle errors. They leave clear markers in
your code for when youâ€™re ready to make your program more robust.
-->
<p>De la mÃªme maniÃ¨re, les mÃ©thodes <code>unwrap</code> et <code>expect</code> sont trÃ¨s pratiques pour
coder des prototypes, avant mÃªme de dÃ©cider comment gÃ©rer les erreurs. Ce sont
des indicateurs clairs dans votre code pour plus tard quand vous serez prÃªt Ã 
rendre votre code plus rÃ©silient aux Ã©checs.</p>
<!--
If a method call fails in a test, youâ€™d want the whole test to fail, even if
that method isnâ€™t the functionality under test. Because `panic!` is how a test
is marked as a failure, calling `unwrap` or `expect` is exactly what should
happen.
-->
<p>Si l'appel Ã  une mÃ©thode Ã©choue dans un test, nous voulons que tout le test
Ã©choue, mÃªme si cette mÃ©thode n'est pas la fonctionnalitÃ© que nous testons.
Puisque c'est <code>panic!</code> qui indique qu'un test a Ã©chouÃ©, utiliser <code>unwrap</code> ou
<code>expect</code> est exactement ce qu'il faut faire.</p>
<!--
### Cases in Which You Have More Information Than the Compiler
-->
<h3 id="les-cas-oÃ¹-vous-avez-plus-dinformations-que-le-compilateur"><a class="header" href="#les-cas-oÃ¹-vous-avez-plus-dinformations-que-le-compilateur">Les cas oÃ¹ vous avez plus d'informations que le compilateur</a></h3>
<!--
It would also be appropriate to call `unwrap` when you have some other logic
that ensures the `Result` will have an `Ok` value, but the logic isnâ€™t
something the compiler understands. Youâ€™ll still have a `Result` value that you
need to handle: whatever operation youâ€™re calling still has the possibility of
failing in general, even though itâ€™s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that youâ€™ll never
have an `Err` variant, itâ€™s perfectly acceptable to call `unwrap`. Hereâ€™s an
example:
-->
<p>Vous pouvez utiliser <code>unwrap</code> lorsque vous avez une certaine logique qui
garantit que le <code>Result</code> sera toujours une valeur <code>Ok</code>, mais que ce n'est pas le
genre de logique que le compilateur arrive Ã  comprendre. Vous aurez quand mÃªme
une valeur <code>Result</code> Ã  gÃ©rerÂ : l'opÃ©ration que vous utilisez peut Ã©chouer de
maniÃ¨re gÃ©nÃ©rale, mÃªme si dans votre cas c'est logiquement impossible. Si en
inspectant manuellement le code vous vous rendez compte que vous n'aurez jamais
une variante <code>Err</code>, vous pouvez tout Ã  fait utiliser <code>unwrap</code>. Voici un
exempleÂ :</p>
<!--
```rust
# fn main() {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1".parse().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<!--
Weâ€™re creating an `IpAddr` instance by parsing a hardcoded string. We can see
that `127.0.0.1` is a valid IP address, so itâ€™s acceptable to use `unwrap`
here. However, having a hardcoded, valid string doesnâ€™t change the return type
of the `parse` method: we still get a `Result` value, and the compiler will
still make us handle the `Result` as if the `Err` variant is a possibility
because the compiler isnâ€™t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore *did* have a possibility of failure,
weâ€™d definitely want to handle the `Result` in a more robust way instead.
-->
<p>Nous crÃ©ons une instance de <code>IpAddr</code> en interprÃ©tant une chaÃ®ne de caractÃ¨res
codÃ©e en dur dans le code. Nous savons que <code>127.0.0.1</code> est une adresse IP
valide, donc il est acceptable d'utiliser <code>unwrap</code> ici. Toutefois, avoir une
chaÃ®ne de caractÃ¨res valide et codÃ©e en dur ne change pas le type de retour de
la mÃ©thode <code>parse</code>Â : nous obtenons toujours une valeur de type <code>Result</code> et le
compilateur va nous demander de gÃ©rer le <code>Result</code> comme si on pouvait obtenir la
variante <code>Err</code>, car le compilateur n'est pas suffisamment intelligent pour
comprendre que cette chaÃ®ne de caractÃ¨res est toujours une adresse IP valide. Si
le texte de l'adresse IP provient de l'utilisateur au lieu d'Ãªtre codÃ© en dur
dans le programme et donc qu'il y a dÃ©sormais une possibilitÃ© d'erreur, alors
nous devrions vouloir gÃ©rer le <code>Result</code> d'une maniÃ¨re plus rÃ©siliente.</p>
<!--
### Guidelines for Error Handling
-->
<h3 id="recommandations-pour-gÃ©rer-les-erreurs"><a class="header" href="#recommandations-pour-gÃ©rer-les-erreurs">Recommandations pour gÃ©rer les erreurs</a></h3>
<!--
Itâ€™s advisable to have your code panic when itâ€™s possible that your code
could end up in a bad state. In this context, a *bad state* is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
codeâ€”plus one or more of the following:
-->
<p>Il est recommandÃ© de faire paniquer votre code dÃ¨s qu'il risque d'aboutir Ã  un
Ã©tat invalide. Dans ce contexte, un <em>Ã©tat invalide</em> est lorsqu'un postulat, une
garantie, un contrat ou un invariant a Ã©tÃ© rompu, comme des valeurs invalides,
contradictoires ou manquantes qui sont fournies Ã  votre code, ainsi qu'un ou
plusieurs des Ã©lÃ©ments suivantsÂ :</p>
<!--
* The bad state is not something thatâ€™s *expected* to happen occasionally.
* Your code after this point needs to rely on not being in this bad state.
* Thereâ€™s not a good way to encode this information in the types you use.
-->
<ul>
<li>L'Ã©tat invalide n'est pas <em>censÃ©</em> se produire occasionnellement.</li>
<li>AprÃ¨s cette instruction, votre code a besoin de ne pas Ãªtre dans cet Ã©tat
invalide.</li>
<li>Il n'y a pas de bonne faÃ§on d'encoder cette information dans les types que
vous utilisez.</li>
</ul>
<!--
If someone calls your code and passes in values that donâ€™t make sense, the best
choice might be to call `panic!` and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, `panic!` is
often appropriate if youâ€™re calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.
-->
<p>Si une personne utilise votre bibliothÃ¨que et lui fournit des valeurs qui n'ont
pas de sens, la meilleure des choses Ã  faire est d'utiliser <code>panic!</code> et
d'avertir cette personne du bogue dans son code afin qu'elle le rÃ¨gle pendant la
phase de dÃ©veloppement. De la mÃªme maniÃ¨re, <code>panic!</code> est parfois appropriÃ© si
vous appelez du code externe sur lequel vous n'avez pas la main, et qu'il
retourne un Ã©tat invalide que vous ne pouvez pas corriger.</p>
<!--
However, when failure is expected, itâ€™s more appropriate to return a `Result`
than to make a `panic!` call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a `Result` indicates that failure is an
expected possibility that the calling code must decide how to handle.
-->
<p>Cependant, si l'on s'attend Ã  rencontrer des Ã©checs, il est plus appropriÃ© de
retourner un <code>Result</code> plutÃ´t que de faire appel Ã  <code>panic!</code>. Il peut s'agir par
exemple d'un interprÃ©teur qui reÃ§oit des donnÃ©es erronÃ©es, ou une requÃªte HTTP
qui retourne un statut qui indique que vous avez atteint une limite de dÃ©bit.
Dans ces cas-lÃ , vous devriez indiquer qu'il est possible que cela puisse
Ã©chouer en retournant un <code>Result</code> afin que le code appelant puisse dÃ©cider quoi
faire pour gÃ©rer le problÃ¨me.</p>
<!--
When your code performs operations on values, your code should verify the
values are valid first and panic if the values arenâ€™t valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
`panic!` if you attempt an out-of-bounds memory access: trying to access memory
that doesnâ€™t belong to the current data structure is a common security problem.
Functions often have *contracts*: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug and
itâ€™s not a kind of error you want the calling code to have to explicitly
handle. In fact, thereâ€™s no reasonable way for calling code to recover; the
calling *programmers* need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.
-->
<p>Lorsque votre code effectue des opÃ©rations sur des valeurs, votre code devrait
d'abord vÃ©rifier que ces valeurs sont valides, et faire un panic si les valeurs
ne sont pas correctes. C'est essentiellement pour des raisons de sÃ©curitÃ©Â :
tenter de travailler avec des donnÃ©es invalides peut exposer votre code Ã  des
vulnÃ©rabilitÃ©s. C'est la principale raison pour laquelle la bibliothÃ¨que
standard va appeler <code>panic!</code> si vous essayez d'accÃ©der Ã  la mÃ©moire hors
limiteÂ : essayer d'accÃ©der Ã  de la mÃ©moire qui n'appartient pas Ã  la structure
de donnÃ©es actuelle est un problÃ¨me de sÃ©curitÃ© frÃ©quent. Les fonctions ont
souvent des <em>contrats</em>Â : leur comportement est garanti uniquement si les donnÃ©es
d'entrÃ©e remplissent des conditions particuliÃ¨res. Paniquer lorsque le contrat
est violÃ© est justifiÃ©, car une violation de contrat signifie toujours un bogue
du cÃ´tÃ© de l'appelant, et ce n'est pas le genre d'erreur que vous voulez que le
code appelant gÃ¨re explicitement. En fait, il n'y a aucun moyen rationnel pour
que le code appelant se corrigeÂ : le <em>dÃ©veloppeur</em> du code appelant doit
corriger le code. Les contrats d'une fonction, en particulier lorsqu'une
violation va causer un panic, doivent Ãªtre expliquÃ©s dans la documentation de
l'API de ladite fonction.</p>
<!--
However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rustâ€™s type system (and thus the type
checking the compiler does) to do many of the checks for you. If your function
has a particular type as a parameter, you can proceed with your codeâ€™s logic
knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an `Option`, your program expects to
have *something* rather than *nothing*. Your code then doesnâ€™t have to handle
two cases for the `Some` and `None` variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function wonâ€™t
even compile, so your function doesnâ€™t have to check for that case at runtime.
Another example is using an unsigned integer type such as `u32`, which ensures
the parameter is never negative.
-->
<p>Cependant, avoir beaucoup de vÃ©rifications d'erreurs dans toutes vos fonctions
serait verbeux et pÃ©nible. Heureusement, vous pouvez utiliser le systÃ¨me de
types de Rust (et donc la vÃ©rification de type que fait le compilateur) pour
assurer une partie des vÃ©rifications Ã  votre place. Si votre fonction a un
paramÃ¨tre d'un type prÃ©cis, vous pouvez continuer Ã  Ã©crire votre code en sachant
que le compilateur s'est dÃ©jÃ  assurÃ© que vous avez une valeur valide. Par
exemple, si vous obtenez un type de valeur plutÃ´t qu'une <code>Option</code>, votre
programme s'attend Ã  obtenir <em>quelque chose</em> plutÃ´t que <em>rien</em>. Votre code n'a
donc pas Ã  gÃ©rer les deux cas de variantes <code>Some</code> et <code>None</code>Â : la seule
possibilitÃ© est qu'il y a une valeur. Du code qui essaye de ne rien fournir Ã 
votre fonction ne compilera mÃªme pas, donc votre fonction n'a pas besoin de
vÃ©rifier ce cas-lÃ  lors de l'exÃ©cution. Un autre exemple est d'utiliser un type
d'entier non signÃ© comme <code>u32</code>, qui garantit que le paramÃ¨tre n'est jamais
strictement nÃ©gatif.</p>
<!--
### Creating Custom Types for Validation
-->
<h3 id="crÃ©er-des-types-personnalisÃ©s-pour-la-vÃ©rification"><a class="header" href="#crÃ©er-des-types-personnalisÃ©s-pour-la-vÃ©rification">CrÃ©er des types personnalisÃ©s pour la vÃ©rification</a></h3>
<!--
Letâ€™s take the idea of using Rustâ€™s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the userâ€™s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of â€œToo highâ€ or â€œToo lowâ€ would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number thatâ€™s out of range versus when a user
types, for example, letters instead.
-->
<p>Allons plus loin dans l'idÃ©e d'utiliser le systÃ¨me de types de Rust pour
s'assurer d'avoir une valeur valide en crÃ©ant un type personnalisÃ© pour la
vÃ©rification. Souvenez-vous du jeu du plus ou du moins du chapitre 2 dans lequel
notre code demandait Ã  l'utilisateur de deviner un nombre entre 1 et 100. Nous
n'avons jamais validÃ© que le nombre saisi par l'utilisateur Ã©tait entre ces
nombres avant de le comparer Ã  notre nombre secretÂ ; nous avons seulement
vÃ©rifiÃ© que le nombre Ã©tait positif. Dans ce cas, les consÃ©quences ne sont pas
trÃ¨s gravesÂ : notre rÃ©sultat â€œC'est plusÂ !â€ ou â€œC'est moinsÂ !â€ sera toujours
correct. Mais ce serait une amÃ©lioration utile pour aider l'utilisateur Ã  faire
des suppositions valides et pour avoir un comportement diffÃ©rent selon qu'un
utilisateur propose un nombre en dehors des limites ou qu'il saisit, par
exemple, des lettres Ã  la place.</p>
<!--
One way to do this would be to parse the guess as an `i32` instead of only a
`u32` to allow potentially negative numbers, and then add a check for the
number being in range, like so:
-->
<p>Une faÃ§on de faire cela serait de stocker le nombre saisi dans un <code>i32</code> plutÃ´t
que dans un <code>u32</code> afin de permettre d'obtenir potentiellement des nombres
nÃ©gatifs, et ensuite vÃ©rifier que le nombre est dans la plage autorisÃ©e, comme
ceciÂ :</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Devinez le nombreÂ !");
# 
#     let nombre_secret = rand::thread_rng().gen_range(1..101);
# 
    loop {
        // -- partie masquÃ©e ici --

#         println!("Veuillez saisir un nombre.");
# 
#         let mut supposition = String::new();
# 
#         io::stdin()
#             .read_line(&mut supposition)
#             .expect("Ã‰chec de la lecture de la saisie");
# 
        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) => nombre,
            Err(_) => continue,
        };

        if supposition < 1 || supposition > 100 {
            println!("Le nombre secret est entre 1 et 100.");
            continue;
        }

        match supposition.cmp(&nombre_secret) {
            // -- partie masquÃ©e ici --
#             Ordering::Less => println!("C'est plusÂ !"),
#             Ordering::Greater => println!("C'est moinsÂ !"),
#             Ordering::Equal => {
#                 println!("GagnÃ©Â !");
#                 break;
#             }
#         }
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombreÂ !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    loop {
        // -- partie masquÃ©e ici --

<span class="boring">        println!(&quot;Veuillez saisir un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Ã‰chec de la lecture de la saisie&quot;);
</span><span class="boring">
</span>        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        if supposition &lt; 1 || supposition &gt; 100 {
            println!(&quot;Le nombre secret est entre 1 et 100.&quot;);
            continue;
        }

        match supposition.cmp(&amp;nombre_secret) {
            // -- partie masquÃ©e ici --
<span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plusÂ !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moinsÂ !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;GagnÃ©Â !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<!--
The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.
-->
<p>L'expression <code>if</code> vÃ©rifie si la valeur est en dehors des limites et informe
l'utilisateur du problÃ¨me le cas Ã©chÃ©ant, puis utilise <code>continue</code> pour passer Ã 
la prochaine itÃ©ration de la boucle et ainsi demander de saisir une nouvelle
supposition. AprÃ¨s l'expression <code>if</code>, nous pouvons continuer avec la comparaison
entre <code>supposition</code> et le nombre secret tout en sachant que <code>supposition</code> est
entre 1 et 100.</p>
<!--
However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).
-->
<p>Cependant, ce n'est pas une solution idÃ©aleÂ : si c'Ã©tait absolument critique
que le programme ne travaille qu'avec des valeurs entre 1 et 100 et qu'il aurait
de nombreuses fonctions qui reposent sur cette condition, cela pourrait Ãªtre
fastidieux (et cela impacterait potentiellement la performance) de faire une
vÃ©rification comme celle-ci dans chacune de ces fonctions.</p>
<!--
Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, itâ€™s safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-10 shows one way to define a
`Guess` type that will only create an instance of `Guess` if the `new` function
receives a value between 1 and 100.
-->
<p>Ã€ la place, nous pourrions construire un nouveau type et intÃ©grer les
vÃ©rifications dans la fonction de crÃ©ation d'une instance de ce type plutÃ´t que
de rÃ©pÃ©ter partout les vÃ©rifications. Il est ainsi plus sÃ»r pour les fonctions
d'utiliser ce nouveau type dans leurs signatures et d'utiliser avec confiance
les valeurs qu'elles reÃ§oivent. L'encart 9-10 montre une faÃ§on de dÃ©finir un
type <code>Supposition</code> qui ne crÃ©era une instance de <code>Supposition</code> que si la
fonction <code>new</code> reÃ§oit une valeur entre 1 et 100Â :</p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -- >
-->
<!--
```rust
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&self) -> i32 {
        self.valeur
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&amp;self) -&gt; i32 {
        self.valeur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-10: A `Guess` type that will only continue with
values between 1 and 100</span>
-->
<p><span class="caption">Encart 9-10Â : un type <code>Supposition</code> qui ne va continuer
que si la valeur est entre 1 et 100</span></p>
<!--
First, we define a struct named `Guess` that has a field named `value` that
holds an `i32`. This is where the number will be stored.
-->
<p>D'abord, nous dÃ©finissons une structure qui s'appelle <code>Supposition</code> qui a un
champ <code>valeur</code> qui stocke un <code>i32</code>. C'est dans ce dernier que le nombre sera
stockÃ©.</p>
<!--
Then we implement an associated function named `new` on `Guess` that creates
instances of `Guess` values. The `new` function is defined to have one
parameter named `value` of type `i32` and to return a `Guess`. The code in the
body of the `new` function tests `value` to make sure itâ€™s between 1 and 100.
If `value` doesnâ€™t pass this test, we make a `panic!` call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a `Guess` with a `value` outside this range would
violate the contract that `Guess::new` is relying on. The conditions in which
`Guess::new` might panic should be discussed in its public-facing API
documentation; weâ€™ll cover documentation conventions indicating the possibility
of a `panic!` in the API documentation that you create in Chapter 14. If
`value` does pass the test, we create a new `Guess` with its `value` field set
to the `value` parameter and return the `Guess`.
-->
<p>Ensuite, nous implÃ©mentons une fonction associÃ©e <code>new</code> sur <code>Supposition</code> qui
crÃ©e des instances de <code>Supposition</code>. La fonction <code>new</code> est conÃ§ue pour recevoir
un paramÃ¨tre <code>valeur</code> de type <code>i32</code> et retourner une <code>Supposition</code>. Le code dans
le corps de la fonction <code>new</code> teste <code>valeur</code> pour s'assurer qu'elle est bien
entre 1 et 100. Si <code>valeur</code> Ã©choue Ã  ce test, nous faisons appel Ã  <code>panic!</code>, qui
alertera le dÃ©veloppeur qui Ã©crit le code appelant qu'il a un bogue qu'il doit
rÃ©gler, car crÃ©er une <code>Supposition</code> avec <code>valeur</code> en dehors de cette plage va
violer le contrat sur lequel s'appuie <code>Supposition::new</code>. Les conditions dans
lesquelles <code>Supposition::new</code> va paniquer devraient Ãªtre expliquÃ©es dans la
documentation publique de l'APIÂ ; nous verrons les conventions pour indiquer
l'Ã©ventualitÃ© d'un <code>panic!</code> dans la documentation de l'API que vous crÃ©erez
au chapitre 14. Si <code>valeur</code> passe le test, nous crÃ©ons une nouvelle
<code>Supposition</code> avec son champ <code>valeur</code> qui prend la valeur du paramÃ¨tre <code>valeur</code>
et retourne cette <code>Supposition</code>.</p>
<!--
Next, we implement a method named `value` that borrows `self`, doesnâ€™t have any
other parameters, and returns an `i32`. This kind of method is sometimes called
a *getter*, because its purpose is to get some data from its fields and return
it. This public method is necessary because the `value` field of the `Guess`
struct is private. Itâ€™s important that the `value` field be private so code
using the `Guess` struct is not allowed to set `value` directly: code outside
the module *must* use the `Guess::new` function to create an instance of
`Guess`, thereby ensuring thereâ€™s no way for a `Guess` to have a `value` that
hasnâ€™t been checked by the conditions in the `Guess::new` function.
-->
<p>Enfin, nous implÃ©mentons une mÃ©thode <code>valeur</code> qui emprunte <code>self</code>, n'a aucun
autre paramÃ¨tre, et retourne un <code>i32</code>. Ce genre de mÃ©thode est parfois appelÃ© un
<em>accesseur</em>, car son rÃ´le est d'accÃ©der aux donnÃ©es des champs et de les
retourner. Cette mÃ©thode publique est nÃ©cessaire car le champ <code>valeur</code> de la
structure <code>Supposition</code> est privÃ©. Il est important que le champ <code>valeur</code> soit
privÃ© pour que le code qui utilise la structure <code>Supposition</code> ne puisse pas
directement assigner une valeur Ã  <code>valeur</code>Â : le code en dehors du module <em>doit</em>
utiliser la fonction <code>Supposition::new</code> pour crÃ©er une instance de
<code>Supposition</code>, ce qui permet d'empÃªcher la crÃ©ation d'une <code>Supposition</code> avec un
champ <code>valeur</code> qui n'a pas Ã©tÃ© vÃ©rifiÃ© par les conditions dans la fonction
<code>Supposition:new</code>.</p>
<!--
A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a `Guess` rather than an
`i32` and wouldnâ€™t need to do any additional checks in its body.
-->
<p>Une fonction qui prend en paramÃ¨tre ou qui retourne des nombres uniquement entre
1 et 100 peut ensuite dÃ©clarer dans sa signature qu'elle prend en paramÃ¨tre ou
qu'elle retourne une <code>Supposition</code> plutÃ´t qu'un <code>i32</code> et n'aura pas besoin de
faire de vÃ©rifications supplÃ©mentaires dans son corps.</p>
<!--
## Summary
-->
<h2 id="rÃ©sumÃ©"><a class="header" href="#rÃ©sumÃ©">RÃ©sumÃ©</a></h2>
<!--
Rustâ€™s error handling features are designed to help you write more robust code.
The `panic!` macro signals that your program is in a state it canâ€™t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The `Result` enum uses Rustâ€™s type system to indicate that
operations might fail in a way that your code could recover from. You can use
`Result` to tell code that calls your code that it needs to handle potential
success or failure as well. Using `panic!` and `Result` in the appropriate
situations will make your code more reliable in the face of inevitable problems.
-->
<p>Les fonctionnalitÃ©s de gestion d'erreurs de Rust sont conÃ§ues pour vous aider Ã 
Ã©crire du code plus rÃ©silient. La macro <code>panic!</code> signale que votre programme
est dans un Ã©tat qu'il ne peut pas gÃ©rer et vous permet de dire au processus de
s'arrÃªter au lieu d'essayer de continuer avec des valeurs invalides ou
incorrectes. L'Ã©numÃ©ration <code>Result</code> utilise le systÃ¨me de types de Rust pour
signaler que des opÃ©rations peuvent Ã©chouer de telle faÃ§on que votre code puisse
rattraper l'erreur. Vous pouvez utiliser <code>Result</code> pour dire au code qui appelle
votre code qu'il a besoin de gÃ©rer le rÃ©sultat et aussi les potentielles
erreurs. Utiliser <code>panic!</code> et <code>Result</code> de maniÃ¨re appropriÃ©e rendra votre code
plus fiable face Ã  des problÃ¨mes inÃ©vitables.</p>
<!--
Now that youâ€™ve seen useful ways that the standard library uses generics with
the `Option` and `Result` enums, weâ€™ll talk about how generics work and how you
can use them in your code.
-->
<p>Maintenant que vous avez vu la faÃ§on dont la bibliothÃ¨que standard tire parti de
la gÃ©nÃ©ricitÃ© avec les Ã©numÃ©rations <code>Option</code> et <code>Result</code>, nous allons voir
comment la gÃ©nÃ©ricitÃ© fonctionne et comment vous pouvez l'utiliser dans votre code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
